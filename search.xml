<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vue项目结构设计]]></title>
    <url>%2F2020%2F09%2F20%2Fvue%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[书接上回，这次我们来聊一下，我之前项目中关于 vue 的架构实践，也欢迎大佬们指出不足。 我们先看一下整体的目录结构： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384.├── dev-tools // 开发工具，比如自定义的 stylelint 规则之类的│ └── ... ├── dist│ └── ... ├── public│ └── index.html├── src│ ├── api // 抽取出API请求，所有 API │ │ └── ...│ ├── assets // 静态文件目录（图片、字体）│ │ └── ...│ ├── components // 公共组件│ │ └── ...│ ├── constants // 项目中的常量│ │ └── ...│ ├── lang // 多语言文件│ │ ├── en-US.json│ │ └── zh-CN.json│ ├── lib // 第三方 js 代码│ │ └── ...│ ├── layouts // 布局层相关的 vue 组件│ │ ├── BasicLayout.vue // 基础 layout vue 组件│ │ ├── BlankLayout.vue // 空白 layout vue 组件│ │ └── index.js│ ├── router│ │ └── index.js│ ├── store│ │ ├── actions.js // 根级别的 action│ │ ├── getters.js // 根级别的 getter│ │ ├── index.js // 组装模块并导出 store 的地方│ │ ├── mutations.js // 根级别的 mutation│ │ ├── state.js // 根级别的 state│ │ └── modules│ │ └── A // 模块级别的 store│ │ │ ├── actions.js│ │ │ ├── getters.js│ │ │ ├── index.js│ │ │ ├── mutations.js│ │ │ └── state.js│ │ └── ...│ ├── styles│ │ ├── app.less // 通用的less│ │ ├── mixin.less // 通用的mixin│ │ ├── variables.less // 通用的变量│ │ └── ...│ ├── utils│ │ ├── http // 封装 axios│ │ │ ├── axios.js│ │ │ └── http.js│ │ └── ...│ ├── views // 页面组件│ │ └── ...│ ├── App.vue│ ├── i18n.js │ ├── initData.js│ └── main.js├── tests // 测试│ ├── e2e // e2e 测试│ │ └── ... │ └── unit // 单元测试│ └── ... ├── .browserslistrc├── .commitlintrc.js // commit 规范校验├── .editorconfig // 编辑器配置文件├── .env.development // 开发环境的环境变量├── .env.production // 生产环境的环境变量├── .eslintignore // eslint 的忽略规则├── .eslintrc.js // eslint 的配置├── .gitignore // git 的忽略规则├── .prettierrc // prettier 的配置├── .stylelintrc.json // stylelint 的配置├── babel.config.js // 开发环境的环境变量├── Dockerfile // 构建 Docker 镜像的文本文件├── docker-compose.yml // Docker compose 配置├── README.md├── build.sh // Docker 镜像中执行的构件脚本├── default.conf // ngnix 配置├── jest.config.js // jest 配置├── jsconfig.json // VSCode js 配置├── package-lock.json├── package.json├── start-nginx.sh // docker 镜像中运行 nginx 的脚本└── vue.config.js // vue 配置文件 首先对于视图层分成了三块：components、 layouts 和 views： components 为公共组件，主要包括原子组件（比如 Button、Modal等）和业务公用组件，从深度上，此处的目录层级结构应该尽量扁平，不应该有很深的层级； layouts 主要用来负责基本的布局，每个页面都会是 layout 组件的子集，BasicLayout是页面基本布局，会是用得最多的布局，BlankLayout是空白页面，方便处理一些特殊页面； views 主要是路由页面组件，。 router中是页面路由，最上层的路由的 Component 会是layout 中的 Component，其 children 则是 views 中的 Component : 1234567891011121314151617181920212223242526272829[ &#123; path: '/', component: BasicLayout, redirect: '/homepage', children: [ &#123; path: 'homepage', name: 'homepage', component: () =&gt; import('../views/homepage/Homepage') &#125;, ] &#125;, &#123; path: '/404', name: '404', component: () =&gt; import('../views/exception/404') &#125;, &#123; path: '/500', name: '500', component: () =&gt; import('../views/exception/500') &#125;, &#123; path: '*', redirect: '/404', hidden: true &#125;] styles 下会是所有全局的样式，比如全局的变量、mixin 以及修改的ant-design的样式等。 所有的接口都会放在Api目录下，做统一管理。utils下面的http 目录是对 axios 的二次封装，集成了拦截器、统一错误处理、 token 处理等功能。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899const handleError = (message) =&gt; &#123; Vue.prototype.$warning(&#123; title: 'Warning', content: message &#125;) store.commit('setGlobalLoading', &#123; loading: false &#125;)&#125;const makeRequest = axios.create(&#123; baseURL: host.BACK_END_URL, timeout: 60000&#125;)const requestRetryInfo = &#123;&#125;const MaxRetry = 5const handleRefreshToken = config =&gt; &#123; const url = config.url if (!requestRetryInfo[url]) &#123; requestRetryInfo[url] = 0 &#125; if (requestRetryInfo[url] &gt; MaxRetry) &#123; requestRetryInfo[url] = 0 return &#125; requestRetryInfo[url]++ return getNewToken() .then(res =&gt; &#123; const &#123; token &#125; = res setToken(res.token) config.headers.Authorization = `Bearer $&#123;token&#125;` config.baseURL = host.BACK_END_URL return makeRequest(config) &#125;) .catch(() =&gt; &#123; clearToken() &#125;)&#125;const error = error =&gt; &#123; let parsedError = &#123; ...error &#125; const response = _.get(parsedError, 'response') const url = _.get(parsedError, 'response.config.url') || _.get(parsedError, 'config.url') if (_.isEmpty(response)) &#123; parsedError = &#123; ...error, response: &#123; data: &#123; message: i18n.t('timeout') &#125;, status: 500 &#125; &#125; &#125; const errorCode = _.get(parsedError, 'response.status') const message = _.get(parsedError, 'response.data.message') const config = error.config if (errorCode === 401) &#123; return handleRefreshToken(config) &#125; if (!NOT_SHOW_ERROR_URL.some(value =&gt; url.includes(value))) &#123; switch (errorCode) &#123; case 403: ... handleError(message) break case 406: handleError(message) clearToken() break default: handleError(message) &#125; &#125; return Promise.reject(parsedError)&#125;// request interceptormakeRequest.interceptors.request.use( config =&gt; &#123; const token = getToken() if (token &amp;&amp; !config.url.includes('token')) &#123; config.headers.Authorization = `Bearer $&#123;localStorage.getItem('TOKEN')&#125;` &#125; return config &#125;, error =&gt; Promise.reject(error))// response interceptormakeRequest.interceptors.response.use(response =&gt; &#123; const token = _.get(response, 'headers.authorization') if (token) &#123; setToken(token) &#125; return response.data&#125;, error) store的管理按照modules进行拆分，根级别的只放类似globalLoading这种状态管理，其他的状态管理按照业务拆分成 modules。 12345678910111213141516171819// root storeexport default new Vuex.Store(&#123; state, getters, mutations, actions, modules: &#123; homepage &#125;&#125;)// homepageexport default &#123; namespaced: true, state, getters, actions, mutations&#125; constants主要存放常量，用于 store 的常量放在单独文件内，其他常量的管理也按业务进行拆分。 assets主要存放代码以外的静态资源，比如图片、视频等，资源需要按业务进行分类，方便管理这些静态资源。]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>前端</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建你自己的 vue cli preset]]></title>
    <url>%2F2020%2F09%2F07%2F%E5%88%9B%E5%BB%BA%E4%BD%A0%E8%87%AA%E5%B7%B1%E7%9A%84%20vue%20cli%20preset%2F</url>
    <content type="text"><![CDATA[前一阵子从0到1做了一个 vue的项目，为了下次使用方便，写了一个preset，也顺便聊聊这个项目中的一些东西。 根据官网的文档： 你可以通过发布 git repo 将一个 preset 分享给其他开发者。这个 repo 应该包含以下文件： preset.json: 包含 preset 数据的主要文件（必需）。 generator.js: 一个可以注入或是修改项目中文件的 Generator。 prompts.js 一个可以通过命令行对话为 generator 收集选项的 prompts 文件。 发布 repo 后，你就可以在创建项目的时候通过 --preset 选项使用这个远程的 preset 了 我们先在 GitHub 新建一个 repo，在这个 repo 中增加三个文件：preset.json、generator.js、prompts.js。 prompt.js 是允许用户通过命令行对话的方式进行项目的配置，这次没有涉及到，所以直接 export空数组就行： 1module.exports = [] generator.js这个文件负责的就是注入或是修改项目中文件。这里主要用到的两个 API 是: api.extendPackage：用来会扩展项目中的package.json中的参数，包括依赖、scripts以及其他在package.json中用到的配置 api.render：用来将模板项目中的文件拷贝到初始化的项目中（当你需要创建一个以 . 开头的文件时，模板项目中需要用 _ 替代 .） 需要注意的是aoi.render在拷贝文件的时候是用EJS去实现，所以在处理比如index.html中的&lt;%= BASE_URL %&gt;时，需要转义成&lt;%%= BASE_URL %%&gt;。当然，你也可以使用EJS对文件中的代码进行更细粒度的控制。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152module.exports = (api, options, rootOptions) =&gt; &#123; api.extendPackage(&#123; 'dependencies': &#123; 'axios': '^0.19.0', 'lodash': '^4.17.15', 'normalize.css': '^8.0.1', &#125;, 'devDependencies': &#123; '@babel/plugin-proposal-optional-chaining': '^7.9.0', '@commitlint/cli': '^8.3.5', '@commitlint/config-conventional': '^8.3.4', '@leo-tools/eslint-config-vue': '^0.0.9', '@vue/eslint-config-standard': '^5.1.2', 'babel-plugin-lodash': '^3.3.4', 'commitizen': '^4.0.4', 'compression-webpack-plugin': '^3.1.0', 'cross-env': '^7.0.2', 'cz-conventional-changelog': '^3.1.0', 'lodash-webpack-plugin': '^0.11.5', 'vue-cli-plugin-webpack-bundle-analyzer': '~2.0.0', 'vue-svg-loader': '^0.16.0', &#125;, 'scripts': &#123; 'build:dev': 'vue-cli-service build --mode development', 'build:prod': 'vue-cli-service build --mode production', 'test:unit': 'cross-env NODE_ENV=test vue-cli-service test:unit', 'test:e2e': 'cross-env NODE_ENV=test vue-cli-service test:e2e', 'lint': 'vue-cli-service lint src/**/*.&#123;js,vue&#125; tests/**/*.js --fix' &#125;, 'config': &#123; 'commitizen': &#123; 'path': 'node_modules/cz-conventional-changelog' &#125; &#125;, 'gitHooks': &#123; 'pre-commit': 'lint-staged', 'commit-msg': 'commitlint -e $GIT_PARAMS' &#125;, 'lint-staged': &#123; 'src/**/*.&#123;js,jsx,vue&#125;': [ 'vue-cli-service lint --fix', 'git add' ], 'tests/**/*.js': [ 'vue-cli-service lint --fix', 'git add' ] &#125; &#125;) api.render('./template')&#125; preset.json主要是 vue 的配置，这个配置内容可以在用 vue create xxx 初始化项目并保存为本地模板后，~/.vuerc 文件中找到对应的配置内容，比如： 123456789101112131415161718192021222324&#123; "useTaobaoRegistry": false, "packageManager": "yarn", "useConfigFiles": true, "router": true, "vuex": true, "cssPreprocessor": "node-sass", "plugins": &#123; "@vue/cli-plugin-babel": &#123;&#125;, "@vue/cli-plugin-pwa": &#123;&#125;, "@vue/cli-plugin-router": &#123; "historyMode": true &#125;, "@vue/cli-plugin-vuex": &#123;&#125;, "@vue/cli-plugin-eslint": &#123; "config": "prettier", "lintOn": [ "save" ] &#125;, "@vue/cli-plugin-e2e-cypress": &#123;&#125;, "@vue/cli-plugin-unit-jest": &#123;&#125; &#125;&#125; 这些都弄好后，就可以直接用vue create --preset leo-tools/vue-cli-preset &lt;YOUR PROJECT NAME&gt;生成新的项目了。上面 --preset 后跟的参数就是 GitHub 的 username/repo ，比如这个项目就是leo-tools/vue-cli-preset。 今天先写这么多吧，下一期来聊一聊这个项目中的架构以及一些优化。 参考文章 preset 如何使用 vue-cli 3 的 preset 打造基于 git repo 的前端项目模板]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端大容量缓存方案-IndexedDB]]></title>
    <url>%2F2020%2F01%2F30%2F%E5%89%8D%E7%AB%AF%E5%A4%A7%E5%AE%B9%E9%87%8F%E7%BC%93%E5%AD%98%E6%96%B9%E6%A1%88-IndexedDB%2F</url>
    <content type="text"><![CDATA[对于做3D WebGL 的开发者来说，加载大量的 hdr、glb、gltf 等文件往往是很令人头疼的，因为这些文件体积不小，在网络侧加载会消耗大量时间，从而影响用户体验。对于这些大文件，localstorage 和 sessionstorage 的缓存容量肯定是不够塞牙缝的。所以这时候我们要请出 IndexedDB。 IndexedDB 是一种可以让你在用户的浏览器内持久化存储数据的方法， 允许储存大量数据，提供查找接口，还能建立索引。 IndexedDB 的兼容性也还不错，基本上不兼容太老的浏览器，都还是可用的。 IndexedDB 不属于关系型数据库（不支持 SQL 查询语句），更接近 NoSQL 数据库，可以简单认为是一个基于事务操作的 key-value 型前端数据库。它的 API 大部分都是异步。IndexedDB 语法比较底层，所以可以使用一些基于 IndexedDB 封装的库来简化操作： localForage: 一个提供 name:value 的简单语法的客户端数据存储垫片（Polyfill），它基于 IndexedDB 实现，并在不持支 IndexedDB 的浏览器中自动回退只 WebSQL 和 localStorage。 dexie.js: 对 IndexedDB 的封装，通过提供更友好和简单语法以进行快速的编码开发。 ZangoDB: 一个类 MongoDB 的 IndexedDB 接口实现，提供了诸如过滤、投影、排序、更新和聚合等大多数 MongoDB 常见的特性。 JsStore: 一个具备类 SQL 语法的简单和先进的 IndexedDB 封装实现。 关于 IndexedDB 的其他介绍和基本使用可以查看MDN、浏览器数据库 IndexedDB 入门教程、HTML5 indexedDB前端本地存储数据库实例教程，这里就不多介绍了。 IndexedDB 的容量那么IndexedDB 的容量有多大呢，拿 chrome 来说，Chrome67 之前的版本是50%的硬盘空间，而从Chrome 67开始， 在 Chrome 正常模式下 如果命中了should remain available的值（这个值可以理解为浏览器需要留出来的空间，硬盘容量除去这个值以后的空间就是浏览器临时存储可用空间），则一个来源（“站点”）的配额将为零。 should remain available值与在大容量存储上保持空闲的空间有关。从Chrome 67开始，它是2 GB和大容量存储总容量的10％中的较低值。一旦达到此限制，对临时存储的其他写操作将失败，但是临时存储中的现有数据将不会被删除。 如果尚未达到should remain available值，则配额将为共享池的20％。这表示 （Chrome已保存的临时存储中所有数据的大小，加上Chrome可以将所有数据保存到本地存储而不会达到should remain available值）的20％。 比如我有一块 256GB 的硬盘，should remain available的值就是2GB，也就是浏览器临时存储空间是 254GB。如果这时候临时存储空间已经用了 4GB 了，这时候 IndexedDB 可用大小就是 50GB。 我们可以从 chromium 的源码以及chrome developer 文档看到相应的描述： 1234567891011121314151617181920212223242526272829// The amount of the device's storage the browser attempts to // keep free. If there is less than this amount of storage free // on the device, Chrome will grant 0 quota to origins. // // Prior to M66, this was 10% of total storage instead of a fixed value on // all devices. Now the minimum of a fixed value (2GB) and 10% is used to // limit the reserve on devices with plenty of storage, but scale down for // devices with extremely limited storage. // * 1TB storage -- min(100GB,2GB) = 2GB // * 500GB storage -- min(50GB,2GB) = 2GB // * 64GB storage -- min(6GB,2GB) = 2GB // * 16GB storage -- min(1.6GB,2GB) = 1.6GB // * 8GB storage -- min(800MB,2GB) = 800MB const int64_t kShouldRemainAvailableFixed = 2048 * kMBytes; // 2GB const double kShouldRemainAvailableRatio = 0.1; // 10% // The amount of the device's storage the browser attempts to // keep free at all costs. Data will be aggressively evicted. // // Prior to M66, this was 1% of total storage instead of a fixed value on // all devices. Now the minimum of a fixed value (1GB) and 1% is used to // limit the reserve on devices with plenty of storage, but scale down for // devices with extremely limited storage. // * 1TB storage -- min(10GB,1GB) = 1GB // * 500GB storage -- min(5GB,1GB) = 1GB // * 64GB storage -- min(640MB,1GB) = 640MB // * 16GB storage -- min(160MB,1GB) = 160MB // * 8GB storage -- min(80MB,1GB) = 80MB const int64_t kMustRemainAvailableFixed = 1024 * kMBytes; // 1GB const double kMustRemainAvailableRatio = 0.01; // 1% 在 Chrome 隐身模式下 固定 100MB 的大小 IndexedDB 中的大文件存储IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象），所以我们可以把图片或者 3D 模型文件转化成 Blob 格式的文件，存在 IndexedDB 中，就可以解决免去二次加载时网络请求的时间。 例如，我有一张 20M 的图片在静态服务器上，在浏览器上请求到这张图片后，将它以不同 key 存入 IndexedDB 500 次，也就是相当于在 IndexedDB 中塞入近 10G 大小的 Blob 对象，这里使用 localForage 简化 IndexedDB 的操作，请注意这里的responseType 要记得设置为Blob，这样请求到的图片就是 Blob 对象： 1234567891011121314151617181920212223242526272829303132333435axios(&#123; url: 'DSC06753-HDR-2.jpg', method: 'get', responseType: 'blob'&#125;).then(result =&gt; &#123; this.start = new Date().getTime() console.log(this.start, 'start save') console.log('is Blob', result instanceof Blob, 'result') const number = 500 // 循环次数 const setItemArray = [] const getItemArray = [] for (let i = 0; i &lt; number; i++) &#123; setItemArray.push(localforage.setItem(`img$&#123;i&#125;`, result)) &#125; // 存储 500 次 Promise.all(setItemArray).then(result =&gt; &#123; this.save = new Date().getTime() console.log(this.save - this.start, 'total save time(save time - start time)') for (let j = 0; j &lt; number; j++) &#123; getItemArray.push(localforage.getItem(`img$&#123;j&#125;`)) &#125; // 读取 500 张图片 Promise.all(getItemArray).then(value =&gt; &#123; console.log(new Date().getTime() - this.start, 'read time(read time - start time)') console.log(new Date().getTime() - this.save, 'read time(read time - save time)') console.log(value[value.length - 1] instanceof Blob, 'get') // 把 Blob 对象转成 ObjectURL，以便在页面显示图片 const URL = window.URL || window.webkitURL const imgURL = URL.createObjectURL(value[value.length - 1]) this.src = imgURL &#125;) &#125;)&#125;) 在 chrome 开发者工具中，我们可以清楚地看到，所有的图片以 Blob 对象的形式存储在 IndexedDB 中： 再看一下读取和存储速度的数据： 存储 10GB 的数据一共用了 59.345 s，读取更快，用了 152ms（这个是在I7、 16GB内存、 256GB SSD 的 MacBook Pro 上测出来的数据）。 综上所述，IndexedDB 完全可以满足存储大体积文件的需求，并且 IndexedDB 可以 worker 中使用，包括 Web Worker 和 Service Worker，当 3D 需要进行复杂计算时，就可以利用 Service Worker 把一些数据存储在 IndexedDB 中或者通过 Web Worker 读取 IndexedDB 中的数据进行多线程计算。不过需要注意的是 IndexedDB 也遵从同源协议(same-origin policy)，所以你只能访问同域中存储的数据，而不能访问其他域的。]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>缓存</tag>
        <tag>indexedDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】在Angular中自定义表单控件]]></title>
    <url>%2F2019%2F12%2F12%2F%E3%80%90%E8%AF%91%E3%80%91%E5%9C%A8Angular%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%A8%E5%8D%95%E6%8E%A7%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[原文链接：Custom Form Controls in Angular 在创建表单时，Angular可以帮助我们完成很多事情。我们已经介绍了有关Angular中的Forms的几个主题，例如模型驱动的表单和模板驱动的表单。如果您还没有阅读这些文章，我们强烈建议您先去阅读这些文章，因为这篇文章是基于它们的。Almero Steyn是我们的培训学生之一，后来作为Angular的文档编写团队的一员为正式文档做出了贡献，他还为创建自定义控件撰写了非常不错的介绍。 他的文章启发了我们，我们想更进一步，探讨如何创建与Angular的 form API很好地集成的自定义表单控件。 自定义表单控件注意事项在开始并构建自己的自定义表单控件之前，我们要确保我们对创建自定义表单控件时所起的作用有所了解。 首先，重要的是要认识到，如果有一个原生元素（如&lt;input type=&quot;number&quot;&gt;）可以完美地完成工作，那么我们不应该立即创建自定义表单控件。似乎原生表单元素的功能常常被低估了。尽管我们经常看到可以输入的文本框，但它为我们带来了更多工作。每个原生表单元素都是可访问的，有些输入具有内置的验证，有些甚至在不同平台（例如移动浏览器）上提供了改进的用户体验。 因此，每当考虑创建自定义表单控件时，我们都应该问自己： 是否存在具有相同语义的原生元素？ 如果是，我们是否可以仅依靠该元素并使用CSS和/或渐进式增强功能来更改其外观/行为以满足我们的需求？ 如果不是，自定义控件将是什么样？ 我们如何使其可访问？ 在不同平台上的行为是否不同？ 如何验证？ 可能还有更多要考虑的事情，但这是最重要的。如果确实要创建一个自定义表单控件（在Angular中），则应确保： 它将更改正确传播到DOM / View 它将更改正确传播到Model 如果需要，它带有自定义验证 它将有效性状态添加到DOM，以便可以设置样式 可访问 它适用于模板驱动的表单 它适用于响应式的表单 它需要响应灵敏 在本文中，我们将讨论不同的场景，以演示如何实现这些功能。不过，本文将不涉及可访问性，因为将有后续文章对此进行深入讨论。 创建一个自定义计数器让我们从一个非常简单的计数器组件开始。这个想法是要有一个组件，让我们可以对 model 值递增和递减。是的，如果我们考虑要考虑的事情，我们可能会意识到一个 &lt;input type=&quot;number&quot;&gt;可以解决问题。 但是，在本文中，我们要演示如何实现自定义表单控件，而自定义计数器组件似乎微不足道，以至于使事情看起来不太复杂。此外，我们的计数器组件将具有不同的外观，该外观在所有浏览器中均应相同，无论如何我们都可能会受到原生input元素的限制。 我们从原始组件开始。我们需要的是一个可以更改的 model 值和两个触发更改的按钮。 1234567891011121314151617181920212223import &#123; Component, Input &#125; from '@angular/core';@Component(&#123; selector: 'counter-input', template: ` &lt;button (click)="increment()"&gt;+&lt;/button&gt; &#123;&#123;counterValue&#125;&#125; &lt;button (click)="decrement()"&gt;-&lt;/button&gt; `&#125;)class CounterInputComponent &#123; @Input() counterValue = 0; increment() &#123; this.counterValue++; &#125; decrement() &#123; this.counterValue--; &#125;&#125; 这里没什么特别的。CounterInputComponent有一个counterValue，它被插入到模板中，可以分别通过increment()和decrement()方法对其进行递增或递减。这个组件工作得很好，一旦在应用程序模块上声明了这个组件，我们就可以使用它，比如像这样将它放入另一个组件中： app.module.ts 123456@NgModule(&#123; imports: [BrowserModule], declarations: [AppComponent, CounterInputComponent], bootstrap: [AppComponent]&#125;)export class AppModule &#123;&#125; app.component.ts 123456789import &#123; Component &#125; from '@angular/core';@Component(&#123; selector: 'app-component', template: ` &lt;counter-input&gt;&lt;/counter-input&gt; `,&#125;)class AppComponent &#123;&#125; 很好，但是现在我们想使其与Angular的 Form API一起使用。理想情况下，我们最终得到的是一个自定义控件，该控件可与模板驱动的表单和响应式驱动的表单一起使用。例如，在最简单的情况下，我们应该能够创建一个模板驱动的表单，如下所示： 12345&lt;!-- this doesn't work YET --&gt;&lt;form #form="ngForm" (ngSubmit)="submit(form.value)"&gt; &lt;counter-input name="counter" ngModel&gt;&lt;/counter-input&gt; &lt;button type="submit"&gt;Submit&lt;/button&gt;&lt;/form&gt; 如果您不熟悉该语法，请查看Angular中有关模板驱动表单的文章。好的，但是我们怎么实现？我们需要学习ControlValueAccessor是什么，因为Angular就是使用它来建立表单模型和DOM元素之间的联系。 了解ControlValueAccessor虽然我们的计数器组件有效，但目前尚无法将其连接到外部表单。实际上，如果我们尝试将任何形式的表单模型绑定到我们的自定义控件，则会收到错误消息，提示缺少ControlValueAccessor。而这正是我们实现与Angular中的表单进行正确集成所需要的。 那么，什么是ControlValueAccessor？好吧，还记得我们之前谈到的实现自定义表单控件所需的内容吗？我们需要确保的一件事是，更改从模型传播到视图/ DOM，也从视图传播回模型。这是ControlValueAccessor目的。 ControlValueAccessor是用于处理以下内容的接口： 将表单模型中的值写入视图/ DOM 当视图/ DOM更改时通知其他表单指令和控件 Angular之所以具有这样的界面，是因为DOM元素需要更新的方式可能因input类型而异。例如，普通文本输入框具有value属性，这个是一个需要被写入的属性，而复选框带有checked属性，这是一个需要更新的属性。如果我们深入了解，我们意识到，每个input类型都有一个ControlValueAccessor ，它知道如何更新其视图/ DOM。 DefaultValueAccessor用于处理文本输入和文本区域，SelectControlValueAccessor用于处理选择输入，CheckboxControlValueAccessor用于处理复选框等等。 我们的计数组件需要一个ControlValueAccessor，它知道如何更新counterValue并告知外部变化的信息。一旦实现该接口，便可以与Angular表单进行对话。 实现ControlValueAccessor该ControlValueAccessor接口如下所示： 12345export interface ControlValueAccessor &#123; writeValue(obj: any) : void registerOnChange(fn: any) : void registerOnTouched(fn: any) : void&#125; writeValue（obj：any）是将表单模型中的新值写入视图或DOM属性（如果需要）的方法。这是我们要更新counterValue的地方，因为这就是视图中使用的东西。 registerOnChange（fn：any）是一种注册处理程序的方法，当视图中的某些内容发生更改时会调用该处理程序。它具有一个告诉其他表单指令和表单控件以更新其值的函数。换句话说，这就是我们希望counterValue在视图中进行更改时调用的处理程序函数。 与registerOnChange()相似的registerOnTouched（fn：any）会注册一个专门用于当控件收到触摸事件时的处理程序。在我们的自定义控件中不需要用到它。 ControlValueAccessor需要访问其控件的视图和模型，这意味着自定义表单控件本身必须实现该接口。让我们从writeValue()开始。首先，我们实现接口并更新类签名。 123456import &#123; ControlValueAccessor &#125; from '@angular/forms';@Component(...)class CounterInputComponent implements ControlValueAccessor &#123; ...&#125; 接下来，我们实现writeValue()。如前所述，它从表单模型中获取一个新值并将其写入视图中。在我们的例子中，我们所需要做的只是更新的counterValue属性，因为它是自动插入的。 1234567@Component(...)class CounterInputComponent implements ControlValueAccessor &#123; ... writeValue(value: any) &#123; this.counterValue = value; &#125;&#125; 初始化表单时，将使用表单模型的初始值调用此方法。这意味着它将覆盖默认值0，这很好，但是如果我们考虑前面提到的简单表单设置，我们会意识到表单模型中没有初始值： 1&lt;counter-input name="counter" ngModel&gt;&lt;/counter-input&gt; 这将导致我们的组件呈现一个空字符串。为了快速解决，我们仅在不是undefined时设置该值： 12345writeValue(value: any) &#123; if (value !== undefined) &#123; this.counterValue = value; &#125;&#125; 现在，仅当有实际值写入控件时，它才会覆盖默认值。接下来，我们实现registerOnChange()和registerOnTouched()。registerOnChange()可以通知外界组件内的变化。只要我们愿意，每当在此处传播变更，就可以在这里做一些特殊的工作。registerOnTouched()注册了一个回调函数，只要表单控件是“touched”，该回调便会执行。例如，当 input 元素失去焦点时，它将触发 touch 事件。我们不想在此事件上做任何事情，因此我们可以使用一个空函数来实现该接口。 1234567891011@Component(...)class CounterInputComponent implements ControlValueAccessor &#123; ... propagateChange = (_: any) =&gt; &#123;&#125;; registerOnChange(fn) &#123; this.propagateChange = fn; &#125; registerOnTouched() &#123;&#125;&#125; 很好，我们的计数器现在实现了该ControlValueAccessor接口。我们需要做的下一件事是，只要counterValue在视图中进行更改，就调用propagateChange()。换句话说，如果单击increment()或decrement()按钮，我们希望将新值传播到外界。 让我们相应地更新这些方法。 12345678910111213@Component(...)class CounterInputComponent implements ControlValueAccessor &#123; ... increment() &#123; this.counterValue++; this.propagateChange(this.counterValue); &#125; decrement() &#123; this.counterValue--; this.propagateChange(this.counterValue); &#125;&#125; 我们可以使用属性访问器使此代码更好一些。increment()和decrement()这两种方法，每当counterValue变化时都会调用propagateChange()。让我们使用 getter 和 setter 摆脱多余的代码： 1234567891011121314151617181920212223@Component(...)class CounterInputComponent implements ControlValueAccessor &#123; ... @Input() _counterValue = 0; // 注意'_' get counterValue() &#123; return this._counterValue; &#125; set counterValue(val) &#123; this._counterValue = val; this.propagateChange(this._counterValue); &#125; increment() &#123; this.counterValue++; &#125; decrement() &#123; this.counterValue--; &#125;&#125; CounterInputComponent已经接近完成。即使它实现了ControlValueAccessor接口，也没有任何东西告诉Angular应该怎样做。我们需要注册。 注册ControlValueAccessor实现接口仅仅才完成了一半。众所周知，ES5中不存在接口，这意味着一旦代码被编译，该信息就消失了。因此，虽然我们的组件实现了该接口，但是我们仍然需要使 Angular 接受它。 在关于Angular中的多注册提供商的文章中，我们了解到 Angular 使用了一些 DI 令牌来注入多个值，以便对它们进行某些处理。例如，有一个NG_VALIDATORS令牌为 Angular 提供了表单控件上所有已注册的验证器，我们可以在其中添加自己的验证器。 为了让ControlValueAccessor控制表单控件，Angular内部注入了在NG_VALUE_ACCESSOR令牌上注册的所有值。因此，我们需要做的就是扩展NG_VALUE_ACCESSOR的多注册提供商，让NG_VALUE_ACCESSOR使用我们自己的值访问器实例（也就是我们的组件）。 让我们马上试一下： 12345678910111213141516import &#123; Component, Input, forwardRef &#125; from '@angular/core';import &#123; ControlValueAccessor, NG_VALUE_ACCESSOR &#125; from '@angular/forms';@Component(&#123; ... providers: [ &#123; provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() =&gt; CounterInputComponent), multi: true &#125; ]&#125;)class CounterInputComponent &#123; ...&#125; 如果这段代码对您没有任何意义，您绝对应该查看那篇Angular中的多注册提供商的文章，但最重要的是，我们正在将自定义的值访问器添加到 DI 系统，以便 Angular 可以拿到该值访问器的实例。我们还必须使用useExisting，因为CounterInputComponent将在使用它的组件中，作为指令依赖创建。如果不这样做，则会得到一个新实例，因为这是 Angular 中 DI 的工作方式。forwardRef()回调函数将在这篇文章中进行解释。 太棒了，我们的自定义表单控件现在可以使用了！ 在模板驱动的表单中使用它我们已经看到计数器组件可以按预期工作，但是现在我们希望将其放入实际表单中，并确保它在所有常见情况下都可以工作。 激活 Form API正如我们在Angular中模板驱动的表单文章中所讨论的那样，我们需要像这样激活 Form API： 1234567import &#123; FormsModule&#125; from '@angular/forms';@NgModule(&#123; imports: [BrowserModule, FormsModule], // 在这里添加 FormsModule ...&#125;)export class AppModule &#123;&#125; 没有模型初始化差不多了！还记得我们之前的AppComponent吗？让我们在其中创建一个模板驱动的表单，看看它是否有效。这是一个使用计数器控件而不用值初始化的示例（它将使用自己的内部默认值：0）： 1234567891011@Component(&#123; selector: 'app-component', template: ` &lt;form #form="ngForm"&gt; &lt;counter-input name="counter" ngModel&gt;&lt;/counter-input&gt; &lt;/form&gt; &lt;pre&gt;&#123;&#123; form.value | json &#125;&#125;&lt;/pre&gt; `&#125;)class AppComponent &#123;&#125; 特别提示：使用json管道是调试表单值的好技巧。 form.value返回以JSON结构映射到其名称的所有表单控件的值。这就是为什么JsonPipe会输出一个带有counter计数器值的对象字面量。 具有属性绑定的模型初始化这是另一个使用属性绑定将值绑定到自定义控件的示例： 12345678910111213@Component(&#123; selector: 'app-component', template: ` &lt;form #form="ngForm"&gt; &lt;counter-input name="counter" [ngModel]="outerCounterValue"&gt;&lt;/counter-input&gt; &lt;/form&gt; &lt;pre&gt;&#123;&#123; form.value | json &#125;&#125;&lt;/pre&gt; `&#125;)class AppComponent &#123; outerCounterValue = 5; &#125; 使用ngModel进行双向数据绑定当然，我们可以利用ngModel的双向数据绑定即可实现，只需将语法更改为此： 12&lt;p&gt;ngModel value: &#123;&#123;outerCounterValue&#125;&#125;&lt;/p&gt;&lt;counter-input name="counter" [(ngModel)]="outerCounterValue"&gt;&lt;/counter-input&gt; 多么酷啊？我们的自定义表单控件可与模板驱动的表单API无缝配合！让我们看看使用响应式表单时的表现。 在响应式表单中使用它下面的示例使用 Angular 的响应式表单指令，所以不要忘记添加ReactiveFormsModule到AppModule，就像这篇文章中讨论的。 通过formControlName绑定值一旦设置了代表表单模型的FormGroup，就可以将其绑定到表单元素，并使用formControlName关联每个控件。此示例将值绑定到表单模型中的自定义表单控件： 12345678910111213141516171819202122@Component(&#123; selector: 'app-component', template: ` &lt;form [formGroup]="form"&gt; &lt;counter-input formControlName="counter"&gt;&lt;/counter-input&gt; &lt;/form&gt; &lt;pre&gt;&#123;&#123; form.value | json &#125;&#125;&lt;/pre&gt; `&#125;)class AppComponent implements OnInit &#123; form: FormGroup; constructor(private fb: FormBuilder) &#123;&#125; ngOnInit() &#123; this.form = this.fb.group(&#123; counter: 5 &#125;); &#125;&#125; 添加自定义验证我们要看的最后一件事是如何向我们的自定义控件添加验证。实际上，我们已经写了一篇关于Angular 中的自定义验证器的文章，所有需要了解的内容都写在这里。但是，为了使事情更清楚，我们将通过示例向自定义表单控件中添加一个自定义验证器。 假设我们要让控件在counterValue大于10或小于0时变为无效。如下所示： 12345678910111213141516171819202122232425import &#123; NG_VALIDATORS, FormControl &#125; from '@angular/forms';@Component(&#123; ... providers: [ &#123; provide: NG_VALIDATORS, useValue: (c: FormControl) =&gt; &#123; let err = &#123; rangeError: &#123; given: c.value, max: 10, min: 0 &#125; &#125;; return (c.value &gt; 10 || c.value &lt; 0) ? err : null; &#125;, multi: true &#125; ]&#125;)class CounterInputComponent implements ControlValueAccessor &#123; ...&#125; 我们注册了一个验证器函数，如果控制值有效返回null，则返回该函数；否则，返回一个错误对象。这已经很好用了，我们可以像这样显示错误消息： 12345678&lt;form [formGroup]="form"&gt; &lt;counter-input formControlName="counter" &gt;&lt;/counter-input&gt;&lt;/form&gt;&lt;p *ngIf="!form.valid"&gt;Counter is invalid!&lt;/p&gt;&lt;pre&gt;&#123;&#123; form.value | json &#125;&#125;&lt;/pre&gt; 使验证器可测试不过，我们可以做得更好。使用响应式表单时，我们可能要在具有该表单功能但没有DOM的情况下测试组件。在这种情况下，验证器将不存在，因为它是由计数器组件提供的。通过将验证器函数提取到其自己的声明中并将其导出，可以轻松解决此问题，以便其他模块可以在需要时导入它。 让我们将代码更改为： 12345678910111213141516171819202122232425export function validateCounterRange(c: FormControl) &#123; let err = &#123; rangeError: &#123; given: c.value, max: 10, min: 0 &#125; &#125;; return (c.value &gt; 10 || c.value &lt; 0) ? err : null;&#125;@Component(&#123; ... providers: [ &#123; provide: NG_VALIDATORS, useValue: validateCounterRange, multi: true &#125; ]&#125;)class CounterInputComponent implements ControlValueAccessor &#123; ...&#125; 特别提示：在构建响应式表单时，为了使验证器功能可用于其他模块，优良作法是先声明它们并在注册提供商的配置中引用它们。 现在，可以将验证器导入并添加到我们的表单模型中，如下所示： 1234567891011import &#123; validateCounterRange &#125; from './counter-input';@Component(...)class AppComponent implements OnInit &#123; ... ngOnInit() &#123; this.form = this.fb.group(&#123; counter: [5, validateCounterRange] &#125;); &#125;&#125; 这个自定义控件越来越好了，但是如果验证器是可配置的，那不是真的很酷吗！这样自定义表单控件的使用者可以决定最大和最小值是什么。 使验证可配置理想情况下，我们的自定义控件的使用者应该能够执行以下操作： 12345&lt;counter-input formControlName="counter" counterRangeMax="10" counterRangeMin="0" &gt;&lt;/counter-input&gt; 由于Angular的依赖项注入和属性绑定系统，这非常容易实现。基本上，我们想要做的是让我们的验证器具有依赖项。 让我们从添加输入属性开始。 12345678910111213import &#123; Input &#125; from '@angular/core';...@Component(...)class CounterInputComponent implements ControlValueAccessor &#123; ... @Input() counterRangeMax; @Input() counterRangeMin; ...&#125; 接下来，我们必须以某种方式将这些值传递给我们的validateCounterRange(c: FormControl)，但是对于每个API，它们需要共用一个FormControl。这意味着我们需要使用工厂模式来创建该验证器函数，该工厂创建一个如下所示的闭包： 12345678910111213export function createCounterRangeValidator(maxValue, minValue) &#123; return function validateCounterRange(c: FormControl) &#123; let err = &#123; rangeError: &#123; given: c.value, max: maxValue, min: minValue &#125; &#125;; return (c.value &gt; +maxValue || c.value &lt; +minValue) ? err: null; &#125;&#125; 太好了，我们现在可以使用从组件内部的输入属性获得的动态值来创建验证器函数，并实现 Angular 中用于执行验证的validate()方法： 1234567891011121314151617import &#123; Input, OnInit &#125; from '@angular/core';...@Component(...)class CounterInputComponent implements ControlValueAccessor, OnInit &#123; ... validateFn:Function; ngOnInit() &#123; this.validateFn = createCounterRangeValidator(this.counterRangeMax, this.counterRangeMin); &#125; validate(c: FormControl) &#123; return this.validateFn(c); &#125;&#125; 这可行，但引入了一个新问题：validateFn仅在ngOnInit()中设置。如果counterRangeMax或counterRangeMin通过绑定更改，该怎么办？我们需要根据这些更改创建一个新的验证器函数。幸运的是，有一个ngOnChanges()生命周期挂钩可以使我们做到这一点。我们要做的就是检查输入属性之一是否发生更改，然后重新创建我们的验证函数。我们甚至可以摆脱ngOnInit()，因为无论如何ngOnChanges()都会在ngOnInit()之前被调用： 12345678910111213141516import &#123; Input, OnChanges &#125; from '@angular/core';...@Component(...)class CounterInputComponent implements ControlValueAccessor, OnChanges &#123; ... validateFn:Function; ngOnChanges(changes) &#123; if (changes.counterRangeMin || changes.counterRangeMax) &#123; this.validateFn = createCounterRangeValidator(this.counterRangeMax, this.counterRangeMin); &#125; &#125; ...&#125; 最后一点是，我们需要更新验证器的提供商，因为它不再只是一个函数，而是执行验证的组件本身： 1234567891011121314@Component(&#123; ... providers: [ ... &#123; provide: NG_VALIDATORS, useExisting: forwardRef(() =&gt; CounterInputComponent), multi: true &#125; ]&#125;)class CounterInputComponent implements ControlValueAccessor, OnInit &#123; ...&#125; 信不信由你，我们现在可以为自定义表单控件配置最大值和最小值！如果我们要构建模板驱动的表单，则看起来就像这样： 123456&lt;counter-input ngModel name="counter" counterRangeMax="10" counterRangeMin="0" &gt;&lt;/counter-input&gt; 这也适用于表达式： 123456&lt;counter-input ngModel name="counter" [counterRangeMax]="maxValue" [counterRangeMin]="minValue" &gt;&lt;/counter-input&gt; 如果要构建响应式表单，则可以简单地使用验证器工厂将验证器添加到表单控件中，如下所示： 1234567891011import &#123; createCounterRangeValidator &#125; from './counter-input';@Component(...)class AppComponent implements OnInit &#123; ... ngOnInit() &#123; this.form = this.fb.group(&#123; counter: [5, createCounterRangeValidator(10, 0)] &#125;); &#125;&#125;]]></content>
      <categories>
        <category>技术类</category>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nestjs入门（三）]]></title>
    <url>%2F2019%2F07%2F31%2FNestjs%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[在Nestjs 入门（二）中，我们创建了一个基本的 Nestjs 应用。下面我们基于此进行扩展。 源码地址：awesome-nest 序列化在 entity 中，有时候有些字段不一定要返还给前端，通常我们需要自己做一次筛选，而 Nestjs 中，配合 class-transformer，可以很方便的实现这个功能。 例如，我们有个 entity 的基类common.entity.ts，返还数据的时候，我们不希望把create_at和update_at也带上，这时候就可以使用@Exclude()排除CommonEntity中的这两个字段： 12345678910111213141516171819import &#123; CreateDateColumn, PrimaryGeneratedColumn, UpdateDateColumn &#125; from 'typeorm'import &#123; Exclude &#125; from 'class-transformer'export class CommonEntity &#123; @PrimaryGeneratedColumn('uuid') id: string @Exclude() @CreateDateColumn(&#123; comment: '创建时间', &#125;) create_at: number @Exclude() @UpdateDateColumn(&#123; comment: '更新时间', &#125;) update_at: number&#125; 在对应请求的地方标记使用ClassSerializerInterceptor，此时，GET /api/v1/cats/1这个请求返回的数据中，就不会包含create_at和update_at这两个字段。 1234567891011@Controller('cats')export class CatsController &#123; constructor(private readonly catsService: CatsService) &#123; &#125; @Get(':id') @UseInterceptors(ClassSerializerInterceptor) findOne(@Param('id') id: string): Promise&lt;Array&lt;Partial&lt;CatEntity&gt;&gt;&gt; &#123; return this.catsService.getCat(id) &#125;&#125; 如果某个 controller 中都需要使用ClassSerializerInterceptor来帮我们做一些序列化的工作，可以把 Interceptor 提升到整个 controller： 12345678910111213141516@UseInterceptors(ClassSerializerInterceptor)@Controller('cats')export class CatsController &#123; constructor(private readonly catsService: CatsService) &#123; &#125; @Get(':id') findOne(@Param('id') id: string): Promise&lt;Array&lt;Partial&lt;CatEntity&gt;&gt;&gt; &#123; return this.catsService.getCat(id) &#125; @Post() create(@Body() createCatDto: CreateCatDto): Promise&lt;void&gt; &#123; return this.catsService.createCat(createCatDto) &#125;&#125; 甚至可以在main.ts中把它作为全局的 Interceptor，不过这样不方便进行细粒度地控制。 1234567891011121314async function bootstrap() &#123; const app = await NestFactory.create(AppModule) app.setGlobalPrefix('api/v1') app.useGlobalInterceptors(new ClassSerializerInterceptor(app.get(Reflector))) await app.listen(config.port, config.hostName, () =&gt; &#123; Logger.log( `Awesome-nest API server has been started on http://$&#123;config.hostName&#125;:$&#123;config.port&#125;`, ) &#125;)&#125;bootstrap() 在某些场景下，我们需要对 entity 中某个字段处理后再返回，可以使用@Transform()： 123456789101112@Entity('dog')export class DogEntity extends CommonEntity &#123; @Column(&#123; length: 50 &#125;) @Transform(value =&gt; `dog: $&#123;value&#125;`) name: string @Column() age: number @Column(&#123; length: 100, nullable: true &#125;) breed: string&#125; 此时，name字段经过@Transform的包装就会变成dog: name的格式。如果我们需要根据已有字段构造一个新的字段，可以使用@Expose()： 1234567891011121314151617@Entity('dog')export class DogEntity extends CommonEntity &#123; @Column(&#123; length: 50 &#125;) @Transform(value =&gt; `dog: $&#123;value&#125;`) name: string @Column() age: number @Column(&#123; length: 100, nullable: true &#125;) breed: string @Expose() get isOld(): boolean &#123; return this.age &gt; 10 &#125;&#125; 上面代码会根据查询到的age字段动态计算isOld的值，此时通过 GET 方法请求返回的结果如下： 12345678910111213&#123; "data": [ &#123; "id": "15149ec5-cddf-4981-89a0-62215b30ab81", "name": "dog: nana", "age": 12, "breed": "corgi", "isOld": true &#125; ], "status": 0, "message": "请求成功"&#125; 事务在使用 MySQL 的时候，有时候我们需要使用事务，借助 TypeORM 中可以这样使用事务： 12345678@Delete(':name')@Transaction()delete( @Param('name') name: string, @TransactionManager() manager: EntityManager,): Promise&lt;void&gt; &#123; return this.catsService.deleteCat(name, manager)&#125; @Transaction()将 controller 或者 service 中所有执行包装到一个数据库事务中，@TransportManager提供了一个事务实体管理器，它必须用于在该事务中执行查询： 123async deleteCat(name: string, manager: EntityManager): Promise&lt;void&gt; &#123; await manager.delete(CatEntity, &#123; name &#125;)&#125; 上面代码通过装饰器很方便地进行了事务的操作，如果事务执行过程中有任何错误会自动回滚。 当然，我们也可以手动创建查询运行程序实例，并使用它来手动控制事务状态： 123456789101112131415161718192021222324252627282930import &#123; getConnection &#125; from "typeorm";// 获取连接并创建新的queryRunnerconst connection = getConnection();const queryRunner = connection.createQueryRunner();// 使用我们的新queryRunner建立真正的数据库连await queryRunner.connect();// 现在我们可以在queryRunner上执行任何查询，例如：await queryRunner.query("SELECT * FROM users");// 我们还可以访问与queryRunner创建的连接一起使用的实体管理器：const users = await queryRunner.manager.find(User);// 开始事务：await queryRunner.startTransaction();try &#123; // 对此事务执行一些操作： await queryRunner.manager.save(user1); await queryRunner.manager.save(user2); await queryRunner.manager.save(photos); // 提交事务： await queryRunner.commitTransaction();&#125; catch (err) &#123; // 有错误做出回滚更改 await queryRunner.rollbackTransaction();&#125; QueryRunner提供单个数据库连接。 使用查询运行程序组织事务。 单个事务只能在单个查询运行器上建立。 认证在这个应用内，现在对用户还没有进行认证，通过用户认证可以判断该访问角色的合法性和权限。通常认证要么基于 Session，要么基于 Token。这里就以基于 Token 的 JWT（JSON Web Token） 方式进行用户认证。 首先安装相关依赖： 1$ npm install --save @nestjs/passport passport @nestjs/jwt passport-jwt 然后创建jwt.strategy.ts，用来验证 token，当 token 有效时，允许进一步处理请求，否则返回401(Unanthorized)： 123456789101112131415161718192021222324import &#123; ExtractJwt, Strategy &#125; from 'passport-jwt'import &#123; PassportStrategy &#125; from '@nestjs/passport'import &#123; Injectable, UnauthorizedException &#125; from '@nestjs/common'import config from '../../config'import &#123; UserEntity &#125; from '../entities/user.entity'import &#123; AuthService &#125; from './auth.service'@Injectable()export class JwtStrategy extends PassportStrategy(Strategy) &#123; constructor(private readonly authService: AuthService) &#123; super(&#123; jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(), secretOrKey: config.jwt.secret, &#125;) &#125; async validate(payload: UserEntity) &#123; const user = await this.authService.validateUser(payload) if (!user) &#123; throw new UnauthorizedException('身份验证失败') &#125; return user &#125;&#125; 然后创建auth.service.ts，上面的jwt.strategy.ts会使用这个服务校验 token，并且提供了创建 token 的方法： 1234567891011121314151617181920212223242526272829import &#123; JwtService &#125; from '@nestjs/jwt'import &#123; Injectable &#125; from '@nestjs/common'import &#123; UserEntity &#125; from '../entities/user.entity'import &#123; InjectRepository &#125; from '@nestjs/typeorm'import &#123; Repository &#125; from 'typeorm'import &#123; Token &#125; from './auth.interface'import config from '../../config'@Injectable()export class AuthService &#123; constructor( @InjectRepository(UserEntity) private readonly userRepository: Repository&lt;UserEntity&gt;, private readonly jwtService: JwtService, ) &#123; &#125; createToken(email: string): Token &#123; const accessToken = this.jwtService.sign(&#123; email &#125;) return &#123; expires_in: config.jwt.signOptions.expiresIn, access_token: accessToken, &#125; &#125; async validateUser(payload: UserEntity): Promise&lt;any&gt; &#123; return await this.userRepository.find(&#123; email: payload.email &#125;) &#125;&#125; 这两个文件都会作为服务在对应的module中注册，并且引入PassportModule和JwtModule： 123456789101112131415161718192021import &#123; Module &#125; from '@nestjs/common'import &#123; AuthService &#125; from './auth/auth.service'import &#123; PassportModule &#125; from '@nestjs/passport'import &#123; JwtModule &#125; from '@nestjs/jwt'import &#123; JwtStrategy &#125; from './auth/jwt.strategy'import config from '../config'@Module(&#123; imports: [ PassportModule.register(&#123; defaultStrategy: 'jwt' &#125;), JwtModule.register(config.jwt), ], providers: [ AuthService, JwtStrategy, ], exports: [],&#125;)export class FeaturesModule &#123;&#125; 这时候，就可以使用@UseGuards(AuthGuard())来对需要认证的 API 进行身份校验： 123456789101112131415161718192021222324252627282930313233import &#123; Body, ClassSerializerInterceptor, Controller, Get, Param, Post, UseGuards, UseInterceptors,&#125; from '@nestjs/common'import &#123; CatsService &#125; from './cats.service'import &#123; CreateCatDto &#125; from './cat.dto'import &#123; CatEntity &#125; from '../entities/cat.entity'import &#123; AuthGuard &#125; from '@nestjs/passport'@Controller('cats')@UseGuards(AuthGuard())export class CatsController &#123; constructor(private readonly catsService: CatsService) &#123; &#125; @Get(':id') @UseInterceptors(ClassSerializerInterceptor) findOne(@Param('id') id: string): Promise&lt;Array&lt;Partial&lt;CatEntity&gt;&gt;&gt; &#123; return this.catsService.getCat(id) &#125; @Post() create(@Body() createCatDto: CreateCatDto): Promise&lt;void&gt; &#123; return this.catsService.createCat(createCatDto) &#125;&#125; 通过 Postman 模拟请求时，如果没有带上 token，就会返回下面结果： 1234567&#123; "message": &#123; "statusCode": 401, "error": "Unauthorized" &#125;, "status": 1&#125; 安全Web 安全中，常见有两种攻击方式：XSS（跨站脚本攻击） 和 CSRF（跨站点请求伪造）。 对 JWT 的认证方式，因为没有 cookie，所以也就不存在 CSRF。如果你不是用的 JWT 认证方式，可以使用csurf这个库去解决这个安全问题。 对于 XSS，可以使用helmet去做安全防范。helmet 中有 12 个中间件，它们会设置一些安全相关的 HTTP 头。比如xssFilter就是用来做一些 XSS 相关的保护。 对于单 IP 大量请求的暴力攻击，可以用express-rate-limit来进行限速。 对于常见的跨域问题，Nestjs 提供了两种方式解决，一种通过app.enableCors()的方式启用跨域，另一种像下面一样，在 Nest 选项对象中启用。 最后，所有这些设置都是作为全局的中间件启用，最后main.ts中，和安全相关的设置如下： 1234567891011121314151617181920import * as helmet from 'helmet'import * as rateLimit from 'express-rate-limit'async function bootstrap() &#123; const app = await NestFactory.create(AppModule, &#123; cors: true &#125;) app.use(helmet()) app.use( rateLimit(&#123; windowMs: 15 * 60 * 1000, // 15 minutes max: 100, // limit each IP to 100 requests per windowMs &#125;), ) await app.listen(config.port, config.hostName, () =&gt; &#123; Logger.log( `Awesome-nest API server has been started on http://$&#123;config.hostName&#125;:$&#123;config.port&#125;`, ) &#125;)&#125; HTTP 请求Nestjs 中对Axios进行了封装，并把它作为 HttpService 内置到HttpModule中。HttpService返回的类型和 Angular 的 HttpClient Module一样，都是observables，所以可以使用 rxjs 中的操作符处理各种异步操作。 首先，我们需要导入HttpModule： 1234567891011import &#123; Global, HttpModule, Module &#125; from '@nestjs/common'import &#123; LunarCalendarService &#125; from './services/lunar-calendar/lunar-calendar.service'@Global()@Module(&#123; imports: [HttpModule], providers: [LunarCalendarService], exports: [HttpModule, LunarCalendarService],&#125;)export class SharedModule &#123;&#125; 这里我们把 HttpModule作为全局模块，在sharedModule中导入并导出以便其他模块使用。这时候我们就可以使用HttpService，比如我们在LunarCalendarService中注入HttpService，然后调用其 get方法请求当日的农历信息。这时候get返回的是 Observable。 对于这个 Observable流，可以通过pipe进行一系列的操作，比如我们直接可以使用 rxjs 的map操作符帮助我们对数据进行一层筛选，并且超过 5s 后就会报 timeout 错误，catchError会帮我们捕获所有的错误，返回的值通过of操作符转换为observable： 12345678910111213141516171819import &#123; HttpService, Injectable &#125; from '@nestjs/common'import &#123; of, Observable &#125; from 'rxjs'import &#123; catchError, map, timeout &#125; from 'rxjs/operators'@Injectable()export class LunarCalendarService &#123; constructor(private readonly httpService: HttpService) &#123; &#125; getLunarCalendar(): Observable&lt;any&gt; &#123; return this.httpService .get('https://www.sojson.com/open/api/lunar/json.shtml') .pipe( map(res =&gt; res.data.data), timeout(5000), catchError(error =&gt; of(`Bad Promise: $&#123;error&#125;`)) ) &#125;&#125; 如果需要对axios 进行配置，可以直接在 Module 注册的时候设置： 12345678910111213141516import &#123; Global, HttpModule, Module &#125; from '@nestjs/common'import &#123; LunarCalendarService &#125; from './services/lunar-calendar/lunar-calendar.service'@Global()@Module(&#123; imports: [ HttpModule.register(&#123; timeout: 5000, maxRedirects: 5, &#125;), ], providers: [LunarCalendarService], exports: [HttpModule, LunarCalendarService],&#125;)export class SharedModule &#123;&#125; 模板渲染在 Nestjs 中，可以使用 hbs 作为模板渲染引擎： 1$ npm install --save hbs 在main.ts中，我们告诉 express，static文件夹用来存储静态文件，views中含了模板文件： 12345678910111213141516171819202122232425import &#123; NestFactory &#125; from '@nestjs/core'import &#123; NestExpressApplication &#125; from '@nestjs/platform-express'import &#123; join &#125; from 'path'import &#123; AppModule &#125; from './app.module'import config from './config'import &#123; Logger &#125; from './shared/utils/logger'async function bootstrap() &#123; const app = await NestFactory.create&lt;NestExpressApplication&gt;(AppModule, &#123; cors: true, &#125;) app.setGlobalPrefix('api/v1') app.useStaticAssets(join(__dirname, '..', 'static')) app.setBaseViewsDir(join(__dirname, '..', 'views')) app.setViewEngine('hbs') await app.listen(config.port, config.hostName, () =&gt; &#123; Logger.log( `Awesome-nest API server has been started on http://$&#123;config.hostName&#125;:$&#123;config.port&#125;`, ) &#125;)&#125; 在views下新建一个catsPage.hbs的文件，假设，我们需要在里面填充的数据结构是这样： 1234567891011&#123; cats: [ &#123; id: 1, name: 'yyy', age: 12, breed: 'black cats' &#125; ], title: 'Cats List',&#125; 此时，可以这样写模板： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"/&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"/&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"/&gt; &lt;style&gt; .table .default-td &#123; width: 200px; &#125; .table tbody&gt;tr:nth-child(2n-1) &#123; background-color: rgb(219, 212, 212); &#125; .table tbody&gt;tr:nth-child(2n) &#123; background-color: rgb(172, 162, 162); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&#123;&#123; title &#125;&#125;&lt;/p&gt;&lt;table class="table"&gt; &lt;thead&gt; &lt;tr&gt; &lt;td class="id default-td"&gt;id&lt;/td&gt; &lt;td class="name default-td"&gt;name&lt;/td&gt; &lt;td class="age default-td"&gt;age&lt;/td&gt; &lt;td class="breed default-td"&gt;breed&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &#123;&#123;#each cats&#125;&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123;id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;age&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;breed&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &#123;&#123;/each&#125;&#125; &lt;/tbody&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 需要注意的是，如果你有拦截器，数据会先经过拦截器的处理，然后再填充到模板中。 在 controller 中，通过@Render指定模板的名称，并且在 return 中返回需要填充的数据： 123456789101112131415@Get('page')@Render('catsPage')getCatsPage() &#123; return &#123; cats: [ &#123; id: 1, name: 'yyy', age: 12, breed: 'black cats' &#125; ], title: 'Cats List', &#125;&#125; Nestjs 还支持和其他 SSR 框架集成，比如 Next，Angular Universal，Nuxt。具体使用 Demo 可以分别查看这几个项目nestify，nest-angular，simple-todos。 Swagger 文档Nestjs 中也提供了对 swagger 文档的支持，方便我们对 API 进行追踪和测试： 1$ npm install --save @nestjs/swagger swagger-ui-express 在main.ts中构件文档： 12345678910const options = new DocumentBuilder() .setTitle('Awesome-nest') .setDescription('The Awesome-nest API Documents') .setBasePath('api/v1') .addBearerAuth() .setVersion('0.0.1') .build()const document = SwaggerModule.createDocument(app, options)SwaggerModule.setup('docs', app, document) 此时，访问http://localhost:3300/docs就可以看到 swagger 文档的页面。 对于不同的 API 可以在 controller 中使用@ApiUseTags()进行分类，对于需要认证的 API，可以加上@ApiBearerAuth()，这样在 swagger 中填完 token 后，就可以直接测试 API： 12345678910111213@ApiUseTags('cats')@ApiBearerAuth()@Controller('cats')@UseGuards(AuthGuard())export class CatsController &#123; constructor(private readonly catsService: CatsService) &#123;&#125; @Get('page') @Render('catsPage') getCatsPage(): Promise&lt;any&gt; &#123; return this.catsService.getCats() &#125;&#125; 对于我们定于的 DTO，为了使 SwaggerModule 可以访问类属性，我们必须用 @ApiModelProperty() 装饰器标记所有这些属性： 12345678910111213import &#123; ApiModelProperty &#125; from '@nestjs/swagger'import &#123; IsEmail, IsString &#125; from 'class-validator'export class AccountDto &#123; @ApiModelProperty() @IsString() @IsEmail() readonly email: string @ApiModelProperty() @IsString() readonly password: string&#125; 对于 swagger 文档更多的用法，可以看官网OpenAPI (Swagger)的内容。 热重载在开发的时候，运行npm run start:dev的时候，是进行全量编译，如果项目比较大，全量编译耗时会比较长，这时候我们可以利用 webpack 来帮我们做增量编译，这样会大大增加开发效率。 首先，安装 webpack 相关依赖： 1$ npm i --save-dev webpack webpack-cli webpack-node-externals ts-loader 在根目录下创建一个webpack.config.js： 1234567891011121314151617181920212223242526272829303132const webpack = require('webpack');const path = require('path');const nodeExternals = require('webpack-node-externals');module.exports = &#123; entry: ['webpack/hot/poll?100', './src/main.ts'], watch: true, target: 'node', externals: [ nodeExternals(&#123; whitelist: ['webpack/hot/poll?100'], &#125;), ], module: &#123; rules: [ &#123; test: /.tsx?$/, use: 'ts-loader', exclude: /node_modules/, &#125;, ], &#125;, mode: 'development', resolve: &#123; extensions: ['.tsx', '.ts', '.js'], &#125;, plugins: [new webpack.HotModuleReplacementPlugin()], output: &#123; path: path.join(__dirname, 'dist'), filename: 'server.js', &#125;,&#125;; 在main.ts中启用 HMR： 123456789101112declare const module: any;async function bootstrap() &#123; const app = await NestFactory.create(ApplicationModule); await app.listen(3000); if (module.hot) &#123; module.hot.accept(); module.hot.dispose(() =&gt; app.close()); &#125;&#125;bootstrap(); 在package.json中增加下面两个命令： 123456&#123; "scripts": &#123; "start": "node dist/server", "webpack": "webpack --config webpack.config.js" &#125;&#125; 运行npm run webpack之后，webpack 开始监视文件，然后在另一个命令行窗口中运行npm start。]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>Nestjs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nestjs入门（二）]]></title>
    <url>%2F2019%2F07%2F22%2FNestjs%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[源码：awesome-nest 在 nestjs入门（一） 中，对 Nestjs 一些重要的概念有了一些了解，现在我们开始创建一个基于 Nestjs 的应用吧。 Nestjs 和 Angular 一样，提供了 CLI 工具帮助我们初始化和开发应用程序。 12$ npm install -g @nestjs/cli$ nest new my-awesome-app 这时候你会得到这样的一个目录结构： 运行npm start后，在浏览器访问http://localhost:3000/就可以看到Hello World!。 Controller 和 Service在 Nestjs 中，所有的 controller 和 service 都要在对应的 module 中注册，就像这样： 12345678910import &#123; Module &#125; from '@nestjs/common';import &#123; AppController &#125; from './app.controller';import &#123; AppService &#125; from './app.service';@Module(&#123; imports: [], controllers: [AppController], providers: [AppService],&#125;)export class AppModule &#123;&#125; 在 MVC 模式中，controller 通过 model 获取数据。对应的，在 Nestjs 中，controller 负责处理传入的请求, 并调用对应的 service 完成业务处理，返回对客户端的响应。 通常可以通过 CLI 命令来创建一个 controller： 1$ nest g co cats 这时候，CLI 会自动生成 controller 文件，并且把 controller 注册到对应的 module 中。 和其他一些 node 框架不一样，Nestjs 路由不是集中式管理，而是分散在 controller 中，通过@controller()中声明的（可选）前缀和请求装饰器中指定的任何路由来确定的。 1234567891011121314import &#123; Controller, Get &#125; from '@nestjs/common';import &#123; CatsService &#125; from './cats.service';@Controller('cats')export class CatsController &#123; constructor(private readonly catsService: CatsService) &#123; &#125; @Get(':id') findOne(@Param('id') id: string): string &#123; return this.catsService.getCat(); &#125;&#125; 上面这段代码中，通过 Get 请求去请求http://localhost:3000/cats/1就会调用findOne方法。 如果需要在所有请求之前加上 prefix，可以在main.ts中直接设置 GlobalPrefix： 123456789import &#123; NestFactory &#125; from '@nestjs/core';import &#123; AppModule &#125; from './app.module';async function bootstrap() &#123; const app = await NestFactory.create(AppModule); app.setGlobalPrefix('api/v1'); await app.listen(3000);&#125;bootstrap(); 在 Nestjs 中，controller 就像是调用 service 的指挥者，把对应的请求分发到相应的 service 中去处理。 在 controller 中，我们注意到，在构造函数中注入了CatsService实例，来调用对应 service 中的方法。这就是 Nestjs 中依赖注入的注入方式 — 构造函数注入。 service 可以看做夹在 controller 和 model 之间的一层，在 service 调用 DAO （在 Nestjs 中是各种 ORM 工具或者自己封装的 DAO 层）实现数据库的访问，进行数据的处理整合。 12345678import &#123; Injectable &#125; from '@nestjs/common';@Injectable()export class CatsService &#123; getCat(id: string): string &#123; return `This action returns $&#123;id&#125; cats`; &#125;&#125; 上面代码中通过@Injectable()定义了一个 service，这样你就可以在其他 controller 或者 service 中注入这个 service。 DTO 和 Pipe通过nestjs入门（一）已经介绍了 DTO 的概念，在Nestjs 中，DTO 主要定义如何通过网络发送数据的对象，通常会配合class-validator和class-transformer做校验。 123456789101112import &#123; IsString, IsInt &#125; from 'class-validator';export class CreateCatDto &#123; @IsString() readonly name: string; @IsInt() readonly age: number; @IsString() readonly breed: string;&#125; 12345678910import &#123; Controller, Get, Query, Post, Body, Put, Param, Delete &#125; from '@nestjs/common';import &#123; CreateCatDto &#125; from './dto';@Controller('cats')export class CatsController &#123; @Post() create(@Body() createCatDto: CreateCatDto) &#123; return 'This action adds a new cat'; &#125;&#125; 上面对请求body 定义了一个 DTO，并且在 DTO 中对参数类型进行了限制，如果body中传过来的类型不符合要求，会直接报错。 DTO 中的class-validator 还需要配合 pipe 才能完成校验功能： 12345678910111213141516171819202122232425262728293031import &#123; PipeTransform, ArgumentMetadata, BadRequestException, Injectable,&#125; from '@nestjs/common'import &#123; validate &#125; from 'class-validator'import &#123; plainToClass &#125; from 'class-transformer'import * as _ from 'lodash'@Injectable()export class ValidationPipe implements PipeTransform&lt;any&gt; &#123; async transform(value, metadata: ArgumentMetadata) &#123; const &#123; metatype &#125; = metadata if (!metatype || !this.toValidate(metatype)) &#123; return value &#125; const object = plainToClass(metatype, value) const errors = await validate(object) if (errors.length &gt; 0) &#123; const errorMessage = _.values(errors[0].constraints)[0] throw new BadRequestException(errorMessage) &#125; return value &#125; private toValidate(metatype): boolean &#123; const types = [String, Boolean, Number, Array, Object] return !types.find(type =&gt; metatype === type) &#125;&#125; 这个 pipe 会根据元数据和对象实例，去构建原有类型，然后通过validate去校验。 这个 pipe 一般会作为全局的 pipe 去使用： 123456789async function bootstrap() &#123; const app = await NestFactory.create(ApplicationModule); app.setGlobalPrefix('api/v1'); app.useGlobalPipes(new ValidationPipe()); await app.listen(3000);&#125;bootstrap(); 假设我们没有这层 pipe，那在 controller 中就会进行参数校验，这样就会打破单一职责的原则。有了这一层 pipe 帮助我们校验参数，有效地降低了类的复杂度，提高了可读性和可维护性。 Interceptor 和 Exception Filter代码写到这里，我们发现直接返回了字符串，这样有点太粗暴，需要把正确和错误的响应包装一下。假设我希望返回的格式是这样的： 123456789101112# 请求成功&#123; status: 0, message: '请求成功', data: any&#125;# 请求失败&#123; status: 1, message: string,&#125; 此时，可以利用 AOP 的思想去做这件事。首先，我们需要全局捕获错误的切片层去处理所有的 exception；其次，如果是一个成功的请求，需要把这个返回结果通过一个切片层包装一下。 在 Nestjs 中，返回请求结果时，Interceptor 会在 Exception Filter 之前触发，所以 Exception Filter 会是最后捕获 exception的机会。我们把它作为处理全局错误的切片层。 123456789101112131415161718192021222324252627282930313233343536import &#123; Catch, ArgumentsHost, HttpException, ExceptionFilter, HttpStatus,&#125; from '@nestjs/common'@Catch()export class ExceptionsFilter implements ExceptionFilter &#123; async catch(exception, host: ArgumentsHost) &#123; const ctx = host.switchToHttp() const response = ctx.getResponse() const request = ctx.getRequest() let message = exception.message let isDeepestMessage = false while (!isDeepestMessage) &#123; isDeepestMessage = !message.message message = isDeepestMessage ? message : message.message &#125; const errorResponse = &#123; message: message || '请求失败', status: 1, &#125; const status = exception instanceof HttpException ? exception.getStatus() : HttpStatus.INTERNAL_SERVER_ERROR response.status(status) response.header('Content-Type', 'application/json; charset=utf-8') response.send(errorResponse) &#125;&#125; 而 Interceptor 则负责对成功请求结果进行包装： 1234567891011121314151617181920212223242526272829303132import &#123; Injectable, NestInterceptor, ExecutionContext, CallHandler,&#125; from '@nestjs/common'import &#123; Observable &#125; from 'rxjs'import &#123; map &#125; from 'rxjs/operators'interface Response&lt;T&gt; &#123; data: T&#125;@Injectable()export class TransformInterceptor&lt;T&gt; implements NestInterceptor&lt;T, Response&lt;T&gt;&gt; &#123; intercept( context: ExecutionContext, next: CallHandler, ): Observable&lt;Response&lt;T&gt;&gt; &#123; return next.handle().pipe( map(rawData =&gt; &#123; return &#123; data: rawData, status: 0, message: '请求成功', &#125; &#125; ) ) &#125;&#125; 同样 Interceptor 和 Exception Filter 需要把它定义在全局范围内： 12345678910async function bootstrap() &#123; const app = await NestFactory.create(AppModule); app.setGlobalPrefix('api/v1'); app.useGlobalFilters(new ExceptionsFilter()); app.useGlobalInterceptors(new TransformInterceptor()); app.useGlobalPipes(new ValidationPipe()); await app.listen(3000);&#125; TypeORMTypeORM 相当于 Nestjs 中的 DAO 层，它支持多种数据库，如 PostgreSQL，SQLite 甚至MongoDB（NoSQL）。这里我们以 MySQL 为例，首先在 MySQL 中手动创建一个数据库： 1&gt; CREATE DATABASE test 然后安装 typeorm： 1$ npm install --save @nestjs/typeorm typeorm mysql 通常我们开发的时候，会有多套环境，这些环境中会有不同的数据库配置，所以先建一个config文件夹，放置不同的数据库配置： 123456789101112131415161718192021222324252627282930313233343536// index.tsimport * as _ from 'lodash'import &#123; resolve &#125; from 'path'import productionConfig from './prod.config'const isProd = process.env.NODE_ENV === 'production'let config = &#123; port: 3000, hostName: 'localhost', orm: &#123; type: 'mysql', host: 'localhost', port: 3310, username: 'root', password: '123456', database: 'test', entities: [resolve(`./**/*.entity.ts`)], migrations: ['migration/*.ts'], timezone: 'UTC', charset: 'utf8mb4', multipleStatements: true, dropSchema: false, synchronize: true, logging: true, &#125;,&#125;if (isProd) &#123; config = _.merge(config, productionConfig)&#125;export &#123; config &#125;export default config 1234567891011121314151617181920// prod.config.tsimport &#123; resolve &#125; from 'path'export default &#123; port: 3210, orm: &#123; type: 'mysql', host: 'localhost', port: 3312, username: 'root', password: '123456', database: 'test', entities: [resolve('./**/*.entity.js')], migrations: ['migration/*.ts'], dropSchema: false, synchronize: false, logging: false, &#125;,&#125; 在线上环境强烈不建议开启 orm 的 synchronize功能。本地如果要开启，要注意一点，如果 entity 中定义的字段类型和数据库原有类型不一样，在开启synchronize 后 orm 会执行 drop然后再add的操作，这会导致本地测试的时候数据丢失（这里为了方便，本地测试就把synchronize功能打开，这样写完 entity 就会自动同步到数据库）。 在app.module.ts中导入TypeOrmModule： 12345678910111213141516import &#123; Module &#125; from '@nestjs/common'import &#123; AppController &#125; from './app.controller'import &#123; AppService &#125; from './app.service'import &#123; CatsController &#125; from './cats/cats.controller'import &#123; CatsService &#125; from './cats/cats.service'import &#123; TypeOrmModule, TypeOrmModuleOptions &#125; from '@nestjs/typeorm'import config from './config'@Module(&#123; imports: [ TypeOrmModule.forRoot(config.orm as TypeOrmModuleOptions), ], controllers: [AppController, CatsController], providers: [AppService, CatsService],&#125;)export class AppModule &#123;&#125; 接下来就是写 entity，下面我们定义了一个叫cat的表，id为自增主键： 12345678910111213141516import &#123; Entity, PrimaryGeneratedColumn, Column &#125; from 'typeorm'@Entity('cat')export class CatEntity &#123; @PrimaryGeneratedColumn() id: number @Column(&#123; length: 50 &#125;) name: string @Column() age: number @Column(&#123; length: 100, nullable: true &#125;) breed: string&#125; 这时候，entity 就会同步到数据库，在test数据库中，就能看到cat这张表了。 在某个模块使用这个 entity 的时候，需要在对应的模块中注册，使用 forFeature() 方法定义定义哪些存储库应在当前范围内注册： 12345678910111213141516171819202122import &#123; Module &#125; from '@nestjs/common'import &#123; AppController &#125; from './app.controller'import &#123; AppService &#125; from './app.service'import &#123; CatsController &#125; from './cats/cats.controller'import &#123; CatsService &#125; from './cats/cats.service'import &#123; TypeOrmModule, TypeOrmModuleOptions &#125; from '@nestjs/typeorm'import config from './config'import &#123; CatEntity &#125; from './cats/cat.entity'const ENTITIES = [ CatEntity,]@Module(&#123; imports: [ TypeOrmModule.forRoot(config.orm as TypeOrmModuleOptions), TypeOrmModule.forFeature([...ENTITIES]), ], controllers: [AppController, CatsController], providers: [AppService, CatsService],&#125;)export class AppModule &#123;&#125; 这时候就可以用@InjectRepository() 修饰器向 CatService 注入 CatRepository： 1234567891011121314151617import &#123; Injectable &#125; from '@nestjs/common'import &#123; InjectRepository &#125; from '@nestjs/typeorm'import &#123; CatEntity &#125; from './cat.entity'import &#123; Repository &#125; from 'typeorm'@Injectable()export class CatsService &#123; constructor( @InjectRepository(CatEntity) private readonly catRepository: Repository&lt;CatEntity&gt;, ) &#123; &#125; async getCat(id: number): Promise&lt;CatEntity[]&gt; &#123; return await this.catRepository.find(&#123; id &#125;) &#125;&#125; 这时候去请求http://localhost:3000/api/v1/cats/1这个 API，就会返回下面结果： 12345&#123; "data": [], "status": 0, "message": "请求成功"&#125; 在 typeorm 中，如果需要用到比较复杂的 sql 语句，可以使用 createQueryBuilder帮助你构建： 12345this.catRepository .createQueryBuilder('cat') .Where('name != ""') .andWhere('age &gt; 2') .getMany() 如果 createQueryBuilder不能满足你的要求，可以直接使用query写 sql 语句： 1234this.catRepository.query( 'select * from cat where name != ? and age &gt; ?', [age],) Migration在持续交付项目中，项目会不断迭代上线，这时候就会出现数据库改动的问题，对一个投入使用的系统，通常会使用 migration 帮我们同步数据库。TypeORM 也自带了一个 CLI 工具帮助我们进行数据库的同步。 首先在本地创建一个ormconfig.json文件： 12345678910111213141516171819&#123; "type": "mysql", "host": "localhost", "port": 3310, "username": "root", "password": "123456", "database": "test", "entities": ["./**/*.entity.ts"], "migrations": ["migrations/*.ts"], "cli": &#123; "migrationsDir": "migrations" &#125;, "timezone": "UTC", "charset": "utf8mb4", "multipleStatements": true, "dropSchema": false, "synchronize": false, "logging": true&#125; 这个 json 文件中指定了 entity 和 migration 文件的匹配规则，并且在 CLI 中配置了 migration 文件放置的位置。 这时候运行下面命令就会在 migrations 文件夹下面自动生成1563725408398-update-cat.ts文件 1$ ts-node node_modules/.bin/typeorm migration:create -n update-cat 文件名中1563725408398是生成文件的时间戳。这个文件中会有up和down这两个方法： 1234567891011import &#123;MigrationInterface, QueryRunner&#125; from "typeorm";export class updateCat1563725408398 implements MigrationInterface &#123; public async up(queryRunner: QueryRunner): Promise&lt;any&gt; &#123; &#125; public async down(queryRunner: QueryRunner): Promise&lt;any&gt; &#123; &#125;&#125; up必须包含执行 migration 所需的代码。 down必须恢复任何up改变。在up和down里面有一个QueryRunner对象。 使用此对象执行所有数据库操作。比如我们在 cat 这张表中写入一个假数据： 123456789101112import &#123;MigrationInterface, QueryRunner&#125; from "typeorm";export class updateCat1563725408398 implements MigrationInterface &#123; public async up(queryRunner: QueryRunner): Promise&lt;any&gt; &#123; await queryRunner.query(`insert into cat (id, name, age, breed) values (2, 'test', 3, 'cat') `) &#125; public async down(queryRunner: QueryRunner): Promise&lt;any&gt; &#123; &#125;&#125; 这时候，在 package.json中写入下面 script 并运行npm run migration:run，这时候 cat 表里面就会有一个id为2的假数据。 12345&#123; "scripts": &#123; "migration:run": "ts-node node_modules/.bin/typeorm migration:run", &#125;&#125; 注意，这个ormconfig.json文件的配置是本地环境的配置，如果需要在生成环境使用，可以重新写一份ormconfig-prod.json，然后运行migration命名的时候加上--config ormconfig-prod.json。 用 typeorm 生成的 migration 有一个缺点，sql 和代码都耦合在一起，最好还是 sql 是单独一个文件，migration 脚本是一个文件，这样如果特殊情况下，方便直接在 MySQL 中运行这些 sql 文件。这时候，可以用db-migrate来代替 typeorm 来管理 migration 脚本，db-migrate 会在 migration 目录下面生成一个 js 脚本和两个 sql 文件，这两个 sql 文件一个是up的 sql，一个是down的 sql。 对于已有项目，如果根据数据库从头开始创建对应的 entity 是一件很麻烦的事情，这时候，可以使用typeorm-model-generator来自动生成这些 entity 。比如运行下面命令： 1$ typeorm-model-generator -h 127.0.0.1 -d arya -p 3310 -u root -x 123456 -e mysql -d test -o 'src/entities/' --noConfig true --cf param --ce pascal 这时候就会在src/entities/下面生成cat.ts的 entity 文件： 123456789101112131415161718192021222324252627282930313233343536import &#123;BaseEntity,Column,Entity,Index,JoinColumn,JoinTable,ManyToMany,ManyToOne,OneToMany,OneToOne,PrimaryColumn,PrimaryGeneratedColumn,RelationId&#125; from "typeorm";@Entity("cat",&#123;schema:"test", database:"test" &#125; )export class Cat &#123; @PrimaryGeneratedColumn(&#123; type:"int", name:"id" &#125;) id:number; @Column("varchar",&#123; nullable:false, length:50, name:"name" &#125;) name:string; @Column("int",&#123; nullable:false, name:"age" &#125;) age:number; @Column("varchar",&#123; nullable:true, length:100, name:"breed" &#125;) breed:string | null; &#125; 日志官方给出了日志的解决方案，不过这里我们参照nestify，使用log4js做日志处理。主要原因是 log4js 对日志进行了分级、分盘和落盘，方便我们更好地管理日志。 在 log4js 中日志分为九个等级： 1234567891011export enum LoggerLevel &#123; ALL = 'ALL', MARK = 'MARK', TRACE = 'TRACE', DEBUG = 'DEBUG', INFO = 'INFO', WARN = 'WARN', ERROR = 'ERROR', FATAL = 'FATAL', OFF = 'OFF',&#125; ALL和OFF 这两个等级一般不会直接在业务代码中使用。剩下的七个即分别对应 Logger 实例的七个方法，也就是说，在调用这些方法的时候，就相当于为这些日志定了级。 对于不同的日志级别，在 log4js 中通过不同颜色输出，并且输出时候带上日志输出时间和对应的 module name： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061Log4js.addLayout('Awesome-nest', (logConfig: any) =&gt; &#123; return (logEvent: Log4js.LoggingEvent): string =&gt; &#123; let moduleName: string = '' let position: string = '' const messageList: string[] = [] logEvent.data.forEach((value: any) =&gt; &#123; if (value instanceof ContextTrace) &#123; moduleName = value.context if (value.lineNumber &amp;&amp; value.columnNumber) &#123; position = `$&#123;value.lineNumber&#125;, $&#123;value.columnNumber&#125;` &#125; return &#125; if (typeof value !== 'string') &#123; value = Util.inspect(value, false, 3, true) &#125; messageList.push(value) &#125;) const messageOutput: string = messageList.join(' ') const positionOutput: string = position ? ` [$&#123;position&#125;]` : '' const typeOutput: string = `[$&#123; logConfig.type &#125;] $&#123;logEvent.pid.toString()&#125; - ` const dateOutput: string = `$&#123;Moment(logEvent.startTime).format( 'YYYY-MM-DD HH:mm:ss', )&#125;` const moduleOutput: string = moduleName ? `[$&#123;moduleName&#125;] ` : '[LoggerService] ' let levelOutput: string = `[$&#123;logEvent.level&#125;] $&#123;messageOutput&#125;` switch (logEvent.level.toString()) &#123; case LoggerLevel.DEBUG: levelOutput = Chalk.green(levelOutput) break case LoggerLevel.INFO: levelOutput = Chalk.cyan(levelOutput) break case LoggerLevel.WARN: levelOutput = Chalk.yellow(levelOutput) break case LoggerLevel.ERROR: levelOutput = Chalk.red(levelOutput) break case LoggerLevel.FATAL: levelOutput = Chalk.hex('#DD4C35')(levelOutput) break default: levelOutput = Chalk.grey(levelOutput) break &#125; return `$&#123;Chalk.green(typeOutput)&#125;$&#123;dateOutput&#125; $&#123;Chalk.yellow( moduleOutput, )&#125;$&#123;levelOutput&#125;$&#123;positionOutput&#125;` &#125;&#125;) 在 log4js 中，日志的出口问题（即日志输出到哪里）由 Appender 来解决： 1234567891011121314Log4js.configure(&#123; appenders: &#123; console: &#123; type: 'stdout', layout: &#123; type: 'Awesome-nest' &#125;, &#125;, &#125;, categories: &#123; default: &#123; appenders: ['console'], level: 'debug', &#125;, &#125;,&#125;) config 中配置了debug级别以上的日志会通过console输出。 接下来就是export一个 log class，对外暴露出 log4js 中不同等级的 log 方法以供调用，完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158import * as _ from 'lodash'import * as Path from 'path'import * as Log4js from 'log4js'import * as Util from 'util'import * as Moment from 'moment'import * as StackTrace from 'stacktrace-js'import Chalk from 'chalk'export enum LoggerLevel &#123; ALL = 'ALL', MARK = 'MARK', TRACE = 'TRACE', DEBUG = 'DEBUG', INFO = 'INFO', WARN = 'WARN', ERROR = 'ERROR', FATAL = 'FATAL', OFF = 'OFF',&#125;export class ContextTrace &#123; constructor( public readonly context: string, public readonly path?: string, public readonly lineNumber?: number, public readonly columnNumber?: number, ) &#123;&#125;&#125;Log4js.addLayout('Awesome-nest', (logConfig: any) =&gt; &#123; return (logEvent: Log4js.LoggingEvent): string =&gt; &#123; let moduleName: string = '' let position: string = '' const messageList: string[] = [] logEvent.data.forEach((value: any) =&gt; &#123; if (value instanceof ContextTrace) &#123; moduleName = value.context if (value.lineNumber &amp;&amp; value.columnNumber) &#123; position = `$&#123;value.lineNumber&#125;, $&#123;value.columnNumber&#125;` &#125; return &#125; if (typeof value !== 'string') &#123; value = Util.inspect(value, false, 3, true) &#125; messageList.push(value) &#125;) const messageOutput: string = messageList.join(' ') const positionOutput: string = position ? ` [$&#123;position&#125;]` : '' const typeOutput: string = `[$&#123; logConfig.type &#125;] $&#123;logEvent.pid.toString()&#125; - ` const dateOutput: string = `$&#123;Moment(logEvent.startTime).format( 'YYYY-MM-DD HH:mm:ss', )&#125;` const moduleOutput: string = moduleName ? `[$&#123;moduleName&#125;] ` : '[LoggerService] ' let levelOutput: string = `[$&#123;logEvent.level&#125;] $&#123;messageOutput&#125;` switch (logEvent.level.toString()) &#123; case LoggerLevel.DEBUG: levelOutput = Chalk.green(levelOutput) break case LoggerLevel.INFO: levelOutput = Chalk.cyan(levelOutput) break case LoggerLevel.WARN: levelOutput = Chalk.yellow(levelOutput) break case LoggerLevel.ERROR: levelOutput = Chalk.red(levelOutput) break case LoggerLevel.FATAL: levelOutput = Chalk.hex('#DD4C35')(levelOutput) break default: levelOutput = Chalk.grey(levelOutput) break &#125; return `$&#123;Chalk.green(typeOutput)&#125;$&#123;dateOutput&#125; $&#123;Chalk.yellow( moduleOutput, )&#125;$&#123;levelOutput&#125;$&#123;positionOutput&#125;` &#125;&#125;)Log4js.configure(&#123; appenders: &#123; console: &#123; type: 'stdout', layout: &#123; type: 'Awesome-nest' &#125;, &#125;, &#125;, categories: &#123; default: &#123; appenders: ['console'], level: 'debug', &#125;, &#125;,&#125;)const logger = Log4js.getLogger()logger.level = LoggerLevel.TRACEexport class Logger &#123; static trace(...args) &#123; logger.trace(Logger.getStackTrace(), ...args) &#125; static debug(...args) &#123; logger.debug(Logger.getStackTrace(), ...args) &#125; static log(...args) &#123; logger.info(Logger.getStackTrace(), ...args) &#125; static info(...args) &#123; logger.info(Logger.getStackTrace(), ...args) &#125; static warn(...args) &#123; logger.warn(Logger.getStackTrace(), ...args) &#125; static warning(...args) &#123; logger.warn(Logger.getStackTrace(), ...args) &#125; static error(...args) &#123; logger.error(Logger.getStackTrace(), ...args) &#125; static fatal(...args) &#123; logger.fatal(Logger.getStackTrace(), ...args) &#125; static getStackTrace(deep: number = 2): ContextTrace &#123; const stackList: StackTrace.StackFrame[] = StackTrace.getSync() const stackInfo: StackTrace.StackFrame = stackList[deep] const lineNumber: number = stackInfo.lineNumber const columnNumber: number = stackInfo.columnNumber const fileName: string = stackInfo.fileName const extnameLength: number = Path.extname(fileName).length let basename: string = Path.basename(fileName) basename = basename.substr(0, basename.length - extnameLength) const context: string = _.upperFirst(_.camelCase(basename)) return new ContextTrace(context, fileName, lineNumber, columnNumber) &#125;&#125; 这样在需要输出日志的地方只要这样调用就行： 1Logger.info(id) 可是我们并不希望每个请求都自己打 log，这时候可以把这个 log 作为中间件： 12345678910111213141516import &#123; Logger &#125; from '../../shared/utils/logger'export function logger(req, res, next) &#123; const statusCode = res.statusCode const logFormat = `$&#123;req.method&#125; $&#123;req.originalUrl&#125; ip: $&#123;req.ip&#125; statusCode: $&#123;statusCode&#125;` next() if (statusCode &gt;= 500) &#123; Logger.error(logFormat) &#125; else if (statusCode &gt;= 400) &#123; Logger.warn(logFormat) &#125; else &#123; Logger.log(logFormat) &#125;&#125; 在main.ts中注册： 1234567891011async function bootstrap() &#123; const app = await NestFactory.create(AppModule) app.setGlobalPrefix('api/v1') app.use(logger) app.useGlobalFilters(new ExceptionsFilter()) app.useGlobalInterceptors(new TransformInterceptor()) app.useGlobalPipes(new ValidationPipe()) await app.listen(config.port, config.hostName)&#125; 并且在ExceptionsFilter中也对捕捉到的 Exception 进行日志输出： 123456789101112131415161718192021222324252627282930313233export class ExceptionsFilter implements ExceptionFilter &#123; async catch(exception, host: ArgumentsHost) &#123; const ctx = host.switchToHttp() const response = ctx.getResponse() const request = ctx.getRequest() Logger.error('exception', JSON.stringify(exception)) let message = exception.message let isDeepestMessage = false while (!isDeepestMessage) &#123; isDeepestMessage = !message.message message = isDeepestMessage ? message : message.message &#125; const errorResponse = &#123; message: message || '请求失败', status: 1, &#125; const status = exception instanceof HttpException ? exception.getStatus() : HttpStatus.INTERNAL_SERVER_ERROR Logger.error( `Catch http exception at $&#123;request.method&#125; $&#123;request.url&#125; $&#123;status&#125;`, ) response.status(status) response.header('Content-Type', 'application/json; charset=utf-8') response.send(errorResponse) &#125;&#125; 这样一个基础的日志输出系统差不多就完成了。当然，log4js 的appender还支持下面几种： DateFile：日志输出到文件，日志文件可以安特定的日期模式滚动，例如今天输出到 default-2016-08-21.log，明天输出到 default-2016-08-22.log； SMTP：输出日志到邮件； Mailgun：通过 Mailgun API 输出日志到 Mailgun； levelFilter 可以通过 level 过滤； 等等其他一些 appender，到这里可以看到全部的列表。 比如，下面配置就会把日志输出到加上日期后缀的文件中，并且保留 60 天： 123456789101112131415161718Log4js.configure(&#123; appenders: &#123; fileAppender: &#123; type: 'DateFile', filename: './logs/prod.log', pattern: '-yyyy-MM-dd.log', alwaysIncludePattern: true, layout: &#123; type: 'Flash' &#125;, daysToKeep: 60 &#125; &#125;, categories: &#123; default: &#123; appenders: ['fileAppender'], level: 'info' &#125; &#125;, &#125;) CRUD对于一般的 CRUD 的操作，在 Nestjs 中可以使用@nestjsx/crud这个库来帮我们减少开发量。 首先安装相关依赖： 1npm i @nestjsx/crud @nestjsx/crud-typeorm class-transformer class-validator --save 然后新建dog.entity.ts： 12345678910111213141516import &#123; Entity, PrimaryGeneratedColumn, Column &#125; from 'typeorm'@Entity('dog')export class DogEntity &#123; @PrimaryGeneratedColumn() id: number @Column(&#123; length: 50 &#125;) name: string @Column() age: number @Column(&#123; length: 100, nullable: true &#125;) breed: string&#125; 在dog.service.ts中只需写下面几行代码： 123456789101112import &#123; Injectable &#125; from '@nestjs/common'import &#123; InjectRepository &#125; from '@nestjs/typeorm'import &#123; TypeOrmCrudService &#125; from '@nestjsx/crud-typeorm'import &#123; DogEntity &#125; from './dog.entity'@Injectable()export class DogsService extends TypeOrmCrudService&lt;DogEntity&gt; &#123; constructor(@InjectRepository(DogEntity) repo) &#123; super(repo) &#125;&#125; 在dog.controller.ts中，使用@crud帮助自动生成API： 123456789101112131415import &#123; Controller &#125; from '@nestjs/common'import &#123; Crud, CrudController &#125; from '@nestjsx/crud'import &#123; DogEntity &#125; from './dog.entity'import &#123; DogsService &#125; from './dogs.service'@Crud(&#123; model: &#123; type: DogEntity, &#125;,&#125;)@Controller('dogs')export class DogsController implements CrudController&lt;DogEntity&gt; &#123; constructor(public service: DogsService) &#123;&#125;&#125; 这时候，就可以按照@nestjsx/crud的文档中 API 规则去请求对应的 CRUD 的操作。比如，请求GET api/v1/dogs，就会返回所有 dog 的数组；请求GET api/v1/dogs/1，就会返回 id为1的 dog。 参考使用 CLI 迁移 Node.js 之 log4js 完全讲解 nestify]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>Nestjs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nestjs入门（一）]]></title>
    <url>%2F2019%2F07%2F14%2FNestjs%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Nestjs 是 Node 渐进式框架，底层默认使用 express（可以通过 Adapter 转换到 fastify），可以使用 express 或者 fastify 所有中间件，完美支持 TypeScript。熟悉 Spring 和 Angular 的同学可以很快上手 Nestjs，它大量借鉴了 Spring 和 Angular 中的设计思想。 在开始写hello world之前，我们先来看看 Nestjs 中比较重要的设计思想和概念。 依赖注入依赖注入（Dependency Injection，简称DI）是面向对象中控制反转（Inversion of Control，简称 IoC）最常见的实现方式，主要用来降低代码的耦合度。我们用一个例子来说明什么是控制反转。 假设你要造一辆车，你需要引擎和轮子： 123456789101112import &#123; Engine &#125; from './engine'import &#123; Tire &#125; from './tire'class Car &#123; private engine; private wheel; constructor() &#123; this.engine = new Engine(); this.tire = new Tire(); &#125;&#125; 这时候 Car 这个类依赖于Engine和Tire，构造器不仅需要把依赖赋值到当前类内部属性上还需要把依赖实例化。假设，有很多种类的Car都用了Engine，这时候需要把Engine替换为ElectricEngine，就会陷入牵一发而动全身的尴尬。 那么用 IoC 来改造一下： 123456789101112131415161718192021222324252627282930313233import &#123; Engine &#125; from './engine'import &#123; Tire &#125; from './tire'class Container &#123; private constructorPool; constructor() &#123; this.constructorPool = new Map(); &#125; register(name, constructor) &#123; this.constructorPool.set(name, constructor); &#125; get(name) &#123; const target = this.constructorPool.get(name); return new target(); &#125;&#125;const container = new Container();container.bind('engine', Engine);container.bind('tire', Tire);class Car &#123; private engine; private tire; constructor() &#123; this.engine = container.get('engine'); this.tire = container.get('tire'); &#125;&#125; 此时，container相当于Car和Engine、Tire之间的中转站，Car不需要自己去实例化一个Engine或者Tire，Car和Engine、Tire之间也就没有了强耦合的关系。 从上面例子看出，在使用 IoC 之前，Car需要Engine或者Tire时需要自己主动去创建Engine或者Tire，此时对Engine或者Tire的创建和使用的控制权都在Car手上。 在使用 IoC 之后，Car和Engine或者Tire之间的联系就切断了，当Car需要Engine或者Tire时，IoC Container会主动创建这个对象给Car使用，此时Car获取Engine或者Tire的行为由主动获取变成了被动获取，控制权就颠倒过来。当Engine或者Tire有任何变动，Car不会受到影响，它们之间就完成了解耦。 当我们需要测试Car时，我们不需要把Engine或者Tire全部new一遍来构造Car，只需要把 mock 的Engine或者Tire， 注入到 IoC 容器中就行。 IoC 有很多实现，比如 Java 的 Spring ，PHP 的 Laravel ，前端的 Angular2+ 以及 Node 的 Nestjs等。 在 Nestjs 中，通过@Injectable装饰器向 IoC 容器注册： 123456789101112131415import &#123; Injectable &#125; from '@nestjs/common';import &#123; Cat &#125; from './interfaces/cat.interface';@Injectable()export class CatsService &#123; private readonly cats: Cat[] = []; create(cat: Cat) &#123; this.cats.push(cat); &#125; findAll(): Cat[] &#123; return this.cats; &#125;&#125; 在构造函数中注入CatsService的实例： 12345678910111213141516171819import &#123; Controller, Get, Post, Body &#125; from '@nestjs/common';import &#123; CreateCatDto &#125; from './dto/create-cat.dto';import &#123; CatsService &#125; from './cats.service';import &#123; Cat &#125; from './interfaces/cat.interface';@Controller('cats')export class CatsController &#123; constructor(private readonly catsService: CatsService) &#123;&#125; @Post() async create(@Body() createCatDto: CreateCatDto) &#123; this.catsService.create(createCatDto); &#125; @Get() async findAll(): Promise&lt;Cat[]&gt; &#123; return this.catsService.findAll(); &#125;&#125; CatsService作为一个privider，需要在module中注册，这样在该module启动时，会解析module中所有的依赖，当module销毁时，provider也会一起销毁。 123456789import &#123; Module &#125; from '@nestjs/common';import &#123; CatsController &#125; from './cats/cats.controller';import &#123; CatsService &#125; from './cats/cats.service';@Module(&#123; controllers: [CatsController], providers: [CatsService],&#125;)export class ApplicationModule &#123;&#125; 模块化Nestjs 提供了一个模块化结构，用于将同一领域内的代码组织成单独的模块。模块化的作用就是可以清晰地组织你的应用，并使用外部库扩展应用。 Module 把controller、service和pipe等打包成内聚的功能块，每个模块聚焦于一个特性区域、业务领域、工作流或通用工具。 在 Nestjs 中通过@Module装饰器声明一个模块，@Module接受一个描述模块属性的对象: 123456789101112import &#123; Module &#125; from '@nestjs/common';import &#123; CatsController &#125; from './cats.controller';import &#123; CatsService &#125; from './cats.service';import &#123; CoreModule &#125; from './core/core.module';@Module(&#123; imports: [CoreModule], controllers: [CatsController], providers: [CatsService], exports: [CatsService]&#125;)export class CatsModule &#123;&#125; 每个属于这个模块的controller、service等都需要在这个模块中注册，如果需要引入其他模块或者第三方模块，需要将它注册到imports，通过exports可以将相应的service、module等共享出去。 面向切面编程面向切面编程（Aspect Oriented Programming，简称AOP）主要是针对业务处理过程中的切面进行提取，在某个步骤和阶段进行一些操作，从而达到 DRY（Don’t Repeat Yourself） 的目的。AOP 对 OOP 来说，是一种补充，比如可以在某一切面中对全局的 Log、错误进行处理，这种一刀切的方式，也就意味着，AOP 的处理方式相对比较粗粒度。 在 Nestjs 中，AOP 分为下面几个部分（按顺序排列）： Middlewares Guards Interceptors (在流被操纵之前) Pipes Interceptors (在流被操纵之后) Exception filters (如果发现任何异常) MiddlewaresMiddleware 和 express 的中间件一样，你可以直接使用 express 中的中间件： 12345678910111213141516import * as helmet from 'helmet'async function bootstrap() &#123; const app = await NestFactory.create&lt;NestExpressApplication&gt;(AppModule, &#123; cors: true, logger: false, &#125;) app.use(helmet()) await app.listen(config.port, config.hostName, () =&gt; &#123; Logger.log( `Flash API server has been started on http://$&#123;config.hostName&#125;:$&#123;config.port&#125;`, ) &#125;)&#125; GuardsGuards 和前端路由中的路由守卫一样，主要确定请求是否应该由路由处理程序处理。通过守卫可以知道将要执行的上下文信息，所以和 middleware 相比，守卫可以确切知道将要执行什么。 守卫在每个中间件之后执行的，但在拦截器和管道之前。 123456789101112import &#123; Injectable, CanActivate, ExecutionContext &#125; from '@nestjs/common';import &#123; Observable &#125; from 'rxjs';@Injectable()export class AuthGuard implements CanActivate &#123; canActivate( context: ExecutionContext, ): boolean | Promise&lt;boolean&gt; | Observable&lt;boolean&gt; &#123; const request = context.switchToHttp().getRequest(); return validateRequest(request); // validateRequest 函数实现 Request 的验证 &#125;&#125; InterceptorsInterceptors 可以给每一个需要执行的函数绑定，拦截器将在该函数执行前或者执行后运行。可以转换函数执行后返回的结果，扩展基本函数行为等。 1234567891011121314151617181920212223import &#123; Injectable, NestInterceptor, ExecutionContext, CallHandler,&#125; from '@nestjs/common'import &#123; Observable &#125; from 'rxjs'import &#123; map &#125; from 'rxjs/operators'import &#123; getFormatResponse &#125; from '../../shared/utils/response'export interface Response&lt;T&gt; &#123; data: T&#125;@Injectable()export class TransformInterceptor&lt;T&gt; implements NestInterceptor&lt;T, Response&lt;T&gt;&gt; &#123; intercept( context: ExecutionContext, next: CallHandler, ): Observable&lt;Response&lt;T&gt;&gt; &#123; return next.handle().pipe(map(getFormatResponse)) &#125;&#125; PipesPipe 是具有 @Injectable() 装饰器的类，并实现了 PipeTransform 接口。通常 pipe 用来将输入数据转换为所需的输出或者处理验证。 下面就是一个ValidationPipe，配合class-validator 和 class-transformer ，可以更方便地对参数进行校验。 1234567891011121314151617181920212223242526272829import &#123; PipeTransform, ArgumentMetadata, BadRequestException, Injectable,&#125; from '@nestjs/common'import &#123; validate &#125; from 'class-validator'import &#123; plainToClass &#125; from 'class-transformer'@Injectable()export class ValidationPipe implements PipeTransform&lt;any&gt; &#123; async transform(value, metadata: ArgumentMetadata) &#123; const &#123; metatype &#125; = metadata if (!metatype || !this.toValidate(metatype)) &#123; return value &#125; const object = plainToClass(metatype, value) const errors = await validate(object) if (errors.length &gt; 0) &#123; throw new BadRequestException('Validation failed') &#125; return value &#125; private toValidate(metatype): boolean &#123; const types = [String, Boolean, Number, Array, Object] return !types.find(type =&gt; metatype === type) &#125;&#125; Exception filters内置的 Exception filters 负责处理整个应用程序中的所有抛出的异常，也是 Nestjs 中在 response 前，最后能捕获异常的机会。 123456789101112131415161718import &#123; ExceptionFilter, Catch, ArgumentsHost &#125; from '@nestjs/common';@Catch()export class AnyExceptionFilter implements ExceptionFilter &#123; catch(exception: any, host: ArgumentsHost) &#123; const ctx = host.switchToHttp(); const response = ctx.getResponse(); const request = ctx.getRequest(); response .status(status) .json(&#123; statusCode: exception.getStatus(), timestamp: new Date().toISOString(), path: request.url, &#125;); &#125;&#125; DTO数据访问对象简称DTO（Data Transfer Object）， 是一组需要跨进程或网络边界传输的聚合数据的简单容器。它不应该包含业务逻辑，并将其行为限制为诸如内部一致性检查和基本验证之类的活动。 在 Nestjs 中，可以使用 TypeScript 接口或简单的类来完成。配合 class-validator和class-transformer 可以很方便地验证前端传过来的参数： 12345678910111213141516171819202122import &#123; IsString, IsInt, MinLength, MaxLength &#125; from "class-validator";import &#123; ApiModelProperty &#125; from '@nestjs/swagger'export class CreateCatDto &#123; @ApiModelProperty() @IsString() @MinLength(10, &#123; message: "Name is too short" &#125;) @MaxLength(50, &#123; message: "Name is too long" &#125;) readonly name: string; @ApiModelProperty() @IsInt() readonly age: number; @ApiModelProperty() @IsString() readonly breed: string;&#125; 12345678910import &#123; Controller, Post, Body &#125; from '@nestjs/common';import &#123; CreateCatDto &#125; from './dto';@Controller('cats')export class CatsController &#123; @Post() create(@Body() createCatDto: CreateCatDto) &#123; return 'This action adds a new cat'; &#125;&#125; 如果 Body 中的参数不符合要求，会直接报 Validation failed 错误。 ORMORM 是”对象-关系映射”（Object/Relational Mapping） 的缩写，通过实例对象的语法，完成关系型数据库的操作。通过 ORM 就可以用面向对象编程的方式去操作关系型数据库。 在 Java 中，通常会有 DAO（Data Access Object， 数据访问对象）层，DAO 中包含了各种数据库的操作方法。通过它的方法，对数据库进行相关的操作。DAO 主要作用是分离业务层与数据层，避免业务层与数据层耦合。 在 Nestjs 中，可以用 TypeORM 作为你的 DAO 层，它支持 MySQL / MariaDB / Postgres / CockroachDB / SQLite / Microsoft SQL Server / Oracle / MongoDB / NoSQL。 在 typeORM 中数据库的表对应的就是一个类，通过定义一个类来创建实体。实体（Entity）是一个映射到数据库表（或使用 MongoDB 时的集合）的类，通过@Entity()来标记。 123456789101112131415161718import &#123;Entity, PrimaryGeneratedColumn, Column&#125; from "typeorm";@Entity()export class User &#123; @PrimaryGeneratedColumn() id: number; @Column() firstName: string; @Column() lastName: string; @Column() age: number;&#125; 上面代码将创建以下数据库表： 12345678+-------------+--------------+----------------------------+| user |+-------------+--------------+----------------------------+| id | int(11) | PRIMARY KEY AUTO_INCREMENT || firstName | varchar(255) | || lastName | varchar(255) | || isActive | boolean | |+-------------+--------------+----------------------------+ 使用 @InjectRepository() 修饰器注入 对应的Repository，就可以在这个Repository对象上进行数据库的一些操作。 12345678910111213141516import &#123; Injectable &#125; from '@nestjs/common';import &#123; InjectRepository &#125; from '@nestjs/typeorm';import &#123; Repository &#125; from 'typeorm';import &#123; User &#125; from './user.entity';@Injectable()export class UserService &#123; constructor( @InjectRepository(User) private readonly userRepository: Repository&lt;User&gt;, ) &#123;&#125; async findAll(): Promise&lt;User[]&gt; &#123; return await this.userRepository.find(); &#125;&#125; 参考Nestjs 浅析控制反转 依赖注入和控制反转的理解 从Express到Nestjs，谈谈Nestjs的设计思想和使用方法]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>Nestjs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端工程化中的代码规范和commit规范]]></title>
    <url>%2F2019%2F06%2F26%2F%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E5%92%8Ccommit%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[每个人都有自己的代码书写风格，当团队协作的时候，如果每个人都坚持自己的风格书写，代码将是灾难性的。所以我们需要统一风格，不仅可以减少出 bug 的几率，而且能增加代码的可读性。 代码规范对前端而言，通常我们会配置 eslint、tslint、stylelint等代码检查工具，来帮我们制定代码校验规则。这里拿tslint和stylelint举例，分别对typescript和scss进行代码检查。 1npm install tslint stylelint --save-dev 在项目根目录下面分别创建tslint.json和.stylelintrc文件。然后你就可以像下面这样去定义规则。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// tslint.json&#123; "rules": &#123; "arrow-return-shorthand": true, "indent": [ true, "spaces" ], "max-line-length": [ true, 140 ], "no-trailing-whitespace": true, "no-unnecessary-initializer": true, "no-unused-expression": true, "no-use-before-declare": true, "no-var-keyword": true, "prefer-const": true, "quotemark": [ true, "single" ], "semicolon": [ true, "never" ], "triple-equals": [ true, "allow-null-check" ], "typedef-whitespace": [ true, &#123; "call-signature": "nospace", "index-signature": "nospace", "parameter": "nospace", "property-declaration": "nospace", "variable-declaration": "nospace" &#125; ], "unified-signatures": true, "variable-name": false, "whitespace": [ true, "check-branch", "check-decl", "check-operator", "check-separator", "check-type" ], &#125;&#125; 123456789101112// .stylelintrc&#123; "rules": &#123; "no-empty-source": null, "selector-pseudo-element-no-unknown": [ true, &#123; "ignorePseudoElements": ["ng-deep"] &#125; ] &#125;&#125; lint 检查工具一般会有一些通用的配置，下载后就可以使用，比较有名的像 AirBnb 的 lint 检查规范。在 tslint 和stylelint中也可以直接使用官方推荐的规范： 1npm install stylelint-config-standard --save-dev 1234567// tslint.json&#123; "extends": ["tslint:recommended"], "rules": &#123; // ...rules &#125;&#125; 1234567// .stylelintrc&#123; "extends": ["stylelint-config-standard"], "rules": &#123; // ...rules &#125;&#125; 针对代码风格问题，还可以引入 prettier 来帮助格式化代码，prettier主要优点是对几乎所有前端的代码都可以优化，比如html、css、scss、jsx、ts等。所以所有的代码风格的校验可以都交给prettier，让它完成代码风格的格式化，而 lint 工具主要专注在代码质量的检查。 1npm install prettier --save-dev 12345678910111213141516// .prettierrc&#123; "singleQuote": true, "printWidth": 120, "semi": false, "tabWidth": 2, "useTabs": false, "overrides": [ &#123; "files": ".prettierrc", "options": &#123; "parser": "json" &#125; &#125; ]&#125; 因为prettier内置了一套代码风格，而且只暴露很少的可配置项，所以为了防止 lint 工具和prettier冲突，还需要安装相应的 library： 1npm prettier-stylelint tslint-config-prettier --save-dev 1234567// tslint.json&#123; "extends": ["tslint-config-prettier"], "rules": &#123; // ...rules &#125;&#125; 1234567// .stylelintrc&#123; "extends": ["stylelint-config-standard", "prettier-stylelint"], "rules": &#123; // ...rules &#125;&#125; 配置完后，我们可以通过scripts 帮我们快速格式化代码： 123456789// package.json&#123; "scripts": &#123; "format": "npm run prettier &amp;&amp; npm run lint:ts &amp;&amp; npm run lint:style", "prettier": "prettier --config ./.prettierrc --write 'src/**/!(polyfills).&#123;ts,scss&#125;'", "lint:ts": "tslint -c tslint.json 'src/app/**/!(demo|testing)/!(polyfills).ts' --fix", "lint:style": "stylelint \"src/app/**/*.scss\" --fix", &#125;&#125; 这时候只要每次提交代码之前，运行npm run format就可以帮我们进行代码检查。 但是，这时候有个问题，如果你忘了运行这个命令，你还是可以提交，流程之中就存在漏洞。此时就可以请出husky和lint-staged，利用 git 的 hook 来帮我们在 commit 前自动进行代码检查。 1npm install husky lint-staged --save-dev 1234567891011121314151617181920212223// package.json&#123; // ... "lint-staged": &#123; "src/app/**/!(demo|testing)/!(polyfills).&#123;ts,scss&#125;": [ "prettier --config ./.prettierrc --write", "git add" ], "src/app/**/!(demo|testing)/!(polyfills).ts": [ "tslint -c tslint.json --fix", "git add" ], "src/app/**/*.scss": [ "stylelint \"src/app/**/*.scss\" --fix", "git add" ] &#125;, "husky": &#123; "hooks": &#123; "pre-commit": "lint-staged", &#125; &#125;,&#125; husky会在.git/hooks中写入pre-commit的钩子，这个钩子会在git commit执行的时候触发，而 lint-staged会对此时在暂存区的文件进行 lint 和 prettier 检查，并且会自动修复一些能修复的问题，并重新添加到暂存区。这时候如果检查通过，会把暂存区中的文件提交；检查不过关，则会终止 commit 操作。 commit 规范git 可以帮我们很好地管理代码，但是在多人合作的时候，经常会碰到各种随意的 commit message，当你需要会看 commit message 的时候，就会很头疼。 首先来看一下被业界广泛认可的 Angular commit message规范。 12345&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&lt;BLANK LINE&gt;&lt;body&gt;&lt;BLANK LINE&gt;&lt;footer&gt; 一个 commit message 由三部分构成： 标题行: 必填, 描述主要修改类型和内容 主题内容: 描述为什么修改, 做了什么样的修改, 以及开发的思路等等 页脚注释: 放 Breaking Changes 或 Closed Issues 在这三部分中，&lt;&gt;中的内容分别表示： type: commit 的类型 feat: 新特性 fix: 修改问题 refactor: 代码重构 docs: 文档修改 style: 代码格式修改, 注意不是 css 修改 test: 测试用例修改 chore: 其他修改, 比如构建流程, 依赖管理. pref: 性能提升的修改 build: 对项目构建或者依赖的改动 ci: CI 的修改 revert: revert 前一个 commit scope: commit 影响的范围, 比如: route, component, utils, build… subject: commit 的概述, 建议符合 50/72 formatting body: commit 具体修改内容, 可以分为多行, 建议符合 50/72 formatting footer: 一些备注, 通常是 BREAKING CHANGE 或修复的 bug 的链接. 这时候我们需要工具像 lint 检查一样来帮我们约束 commit message 的书写。 1npm install commitizen cz-conventional-changelog @commitlint/config-conventional @commitlint/cli --save-dev commitizen 会代替你的git commit，cz-conventional-changelog是一个符合Angular commit message规范的 preset，@commitlint/config-conventional则是校验规则。 这里同样需要借助 husky 和 lint-staged： 12345678910111213141516171819// package.json&#123; "scripts": &#123; // ... "commit": "git-cz" &#125; // ... "config": &#123; "commitizen": &#123; "path": "node_modules/cz-conventional-changelog" &#125; &#125;, "husky": &#123; "hooks": &#123; "pre-commit": "lint-staged", "commit-msg": "commitlint -e $GIT_PARAMS" &#125; &#125;,&#125; 123456789101112// .commitlintrc.jsmodule.exports = &#123; extends: ['@commitlint/config-conventional'], rules: &#123; 'type-enum': [ 2, 'always', ["feat", "fix", "docs", "style", "refactor", "chore", "publish"] ], 'subject-case': [0, 'never'], &#125;,&#125; 这时候你就可以用git cz 代替git commit，当然如果习惯了 commit message 规范后，可以直接用git commit，如果 message 不符合规范，是不会 commit 的。 总结代码规范和 commit 规范是前端工程化中的重要一环，工程化可以保证在多人协作的情况下，项目质量的下限。]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>工程化</tag>
        <tag>commit</tag>
        <tag>代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何更好地组织Angular项目]]></title>
    <url>%2F2019%2F04%2F24%2F%E5%A6%82%E4%BD%95%E6%9B%B4%E5%A5%BD%E5%9C%B0%E7%BB%84%E7%BB%87Angular%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[虽然 Angular 官网 已经给出了Angular 项目结构的建议，不过有些地方实践起来还是有需要注意的地方，这里就结合 ng-alain 来讲讲如何更好地组织一个 Angular 项目。 layout和 routes模块首先，我们来看看 ng-alain 的目录结构。 可以看到， app 文件夹下面被分成了core、layout、routes、shared几个目录。 先看layout 和 routes 这两个目录，它们用于整体视图层的组织，为什么要分成两个模块去组织的视图层呢，其实是为了更好地去布局。 如果你把导航栏和页脚在 app.component.ts 中引入，这时候如果跳转到一个没有导航栏和页脚的登陆页面时，你的实现可能会需要写一个指令去控制导航栏和页脚的展现。像 ng-alain 这样剥离布局层的代码，可以让你更方便地组织你的布局。 我们再看整个项目的路由组织，在routes-routing.module.ts 中，通过把基础布局层作为各个顶级路由的component，页面的其他业务相关的component放在children的子路由中，这样以此剥离了布局层的代码，让routes模块更加专注于更核心 UI 层的组织。 在子路由中，我们可以通过loadChildren来进行懒加载，这样保证当前页面 buddle 的大小最小，提高页面加载速度。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899import &#123; NgModule &#125; from '@angular/core';import &#123; Routes, RouterModule &#125; from '@angular/router';import &#123; SimpleGuard &#125; from '@delon/auth';import &#123; environment &#125; from '@env/environment';// layoutimport &#123; LayoutDefaultComponent &#125; from '../layout/default/default.component';import &#123; LayoutFullScreenComponent &#125; from '../layout/fullscreen/fullscreen.component';import &#123; LayoutPassportComponent &#125; from '../layout/passport/passport.component';// dashboard pagesimport &#123; DashboardV1Component &#125; from './dashboard/v1/v1.component';import &#123; DashboardAnalysisComponent &#125; from './dashboard/analysis/analysis.component';import &#123; DashboardMonitorComponent &#125; from './dashboard/monitor/monitor.component';import &#123; DashboardWorkplaceComponent &#125; from './dashboard/workplace/workplace.component';// passport pagesimport &#123; UserLoginComponent &#125; from './passport/login/login.component';import &#123; UserRegisterComponent &#125; from './passport/register/register.component';import &#123; UserRegisterResultComponent &#125; from './passport/register-result/register-result.component';// single pagesimport &#123; CallbackComponent &#125; from './callback/callback.component';import &#123; UserLockComponent &#125; from './passport/lock/lock.component';const routes: Routes = [ &#123; path: '', component: LayoutDefaultComponent, canActivate: [SimpleGuard], canActivateChild: [SimpleGuard], children: [ &#123; path: '', redirectTo: 'dashboard/v1', pathMatch: 'full' &#125;, &#123; path: 'dashboard', redirectTo: 'dashboard/v1', pathMatch: 'full' &#125;, &#123; path: 'dashboard/v1', component: DashboardV1Component &#125;, &#123; path: 'dashboard/analysis', component: DashboardAnalysisComponent &#125;, &#123; path: 'dashboard/monitor', component: DashboardMonitorComponent &#125;, &#123; path: 'dashboard/workplace', component: DashboardWorkplaceComponent &#125;, &#123; path: 'widgets', loadChildren: './widgets/widgets.module#WidgetsModule', &#125;, &#123; path: 'style', loadChildren: './style/style.module#StyleModule' &#125;, &#123; path: 'delon', loadChildren: './delon/delon.module#DelonModule' &#125;, &#123; path: 'extras', loadChildren: './extras/extras.module#ExtrasModule' &#125;, &#123; path: 'pro', loadChildren: './pro/pro.module#ProModule' &#125;, // Exception &#123; path: 'exception', loadChildren: './exception/exception.module#ExceptionModule' &#125;, ], &#125;, // 全屏布局 &#123; path: 'data-v', component: LayoutFullScreenComponent, children: [ &#123; path: '', loadChildren: './data-v/data-v.module#DataVModule' &#125;, ], &#125;, // passport &#123; path: 'passport', component: LayoutPassportComponent, children: [ &#123; path: 'login', component: UserLoginComponent, data: &#123; title: '登录', titleI18n: 'app.login.login' &#125;, &#125;, &#123; path: 'register', component: UserRegisterComponent, data: &#123; title: '注册', titleI18n: 'app.register.register' &#125;, &#125;, &#123; path: 'register-result', component: UserRegisterResultComponent, data: &#123; title: '注册结果', titleI18n: 'app.register.register' &#125;, &#125;, &#123; path: 'lock', component: UserLockComponent, data: &#123; title: '锁屏', titleI18n: 'app.lock' &#125;, &#125;, ], &#125;, // 单页不包裹Layout &#123; path: 'callback/:type', component: CallbackComponent &#125;, &#123; path: '**', redirectTo: 'exception/404' &#125;,];@NgModule(&#123; imports: [ RouterModule.forRoot( routes, &#123; useHash: environment.useHash, // NOTICE: If you use `reuse-tab` component and turn on keepingScroll you can set to `disabled` // Pls refer to https://ng-alain.com/components/reuse-tab scrollPositionRestoration: 'top', &#125; )], exports: [RouterModule],&#125;)export class RouteRoutingModule &#123;&#125; 这个routes-routing.module.ts中export的module会在routes.moudle.ts中注册，而RoutesModule会和LayoutModule、SharedModule、CoreModule一起在整个 APP 的根模块（app.module.ts）中注册。这样，在根模块中完成了对整个项目基础的划分，而每个模块具体做什么，则分散到各个子模块中，在子模块中去组织相应的components、routes、services等。 CoreModuleAngular官网对 core 模块的描述是： 考虑把那些数量庞大、辅助性的、只用一次的类收集到核心模块中，让特性模块的结构更清晰简明。 坚持把那些“只用一次”的类收集到 CoreModule 中，并对外隐藏它们的实现细节。简化的 AppModule 会导入 CoreModule，并且把它作为整个应用的总指挥。 坚持在 core 目录下创建一个名叫 CoreModule 的特性模块（例如在 app/core/core.module.ts 中定义 CoreModule）。 坚持把要共享给整个应用的单例服务放进 CoreModule 中（例如 ExceptionService 和 LoggerService）。 坚持导入 CoreModule 中的资产所需要的全部模块（例如 CommonModule 和 FormsModule）。 为何？ CoreModule 提供了一个或多个单例服务。Angular 使用应用的根注入器注册这些服务提供商，让每个服务的这个单例对象对所有需要它们的组件都是可用的，而不用管该组件是通过主动加载还是惰性加载的方式加载的。 为何？CoreModule 将包含一些单例服务。而如果是由惰性加载模块来导入这些服务，它就会得到一个新实例，而不是所期望的全应用级单例。 坚持把应用级、只用一次的组件收集到 CoreModule 中。 只在应用启动时从 AppModule 中导入它一次，以后再也不要导入它（例如 NavComponent 和 SpinnerComponent）。 为何？真实世界中的应用会有很多只用一次的组件（例如加载动画、消息浮层、模态框等），它们只会在 AppComponent 的模板中出现。 不会在其它地方导入它们，所以没有共享的价值。 然而它们又太大了，放在根目录中就会显得乱七八糟的。 避免在 AppModule 之外的任何地方导入 CoreModule。 为何？如果惰性加载的特性模块直接导入 CoreModule，就会创建它自己的服务副本，并导致意料之外的后果。 为何？主动加载的特性模块已经准备好了访问 AppModule 的注入器，因此也能取得 CoreModule 中的服务。 坚持从 CoreModule 中导出 AppModule 需导入的所有符号，使它们在所有特性模块中可用。 为何？CoreModule 的存在就要让常用的单例服务在所有其它模块中可用。 为何？你希望整个应用都使用这个单例服务。 你不希望每个模块都有这个单例服务的单独的实例。 然而，如果 CoreModule 中提供了一个服务，就可能偶尔导致这种后果。 所以从描述来看，CoreModule 应该只会在 AppModule 中被导入，所以在 ng-alain 的模块注册指导原则中把CoreModule 认为应该是纯服务类模块，通常会放HTTP 拦截器、路由守卫等一些全局性的服务。对于防止CoreModule 被多次导入，官方也给出了解决方案： 坚持防范多次导入 CoreModule，并通过添加守卫逻辑来尽快失败。 为何？守卫可以阻止对 CoreModule 的多次导入。 为何？守卫会禁止创建单例服务的多个实例。 1234567891011121314151617181920212223242526272829&gt; // core/module-import-guard.ts&gt; export function throwIfAlreadyLoaded(parentModule: any, moduleName: string) &#123;&gt; if (parentModule) &#123;&gt; throw new Error(`$&#123;moduleName&#125; has already been loaded. Import Core modules in the AppModule only.`);&gt; &#125;&gt; &#125;&gt; &gt; // core/core.module.ts&gt; import &#123; NgModule, Optional, SkipSelf &#125; from '@angular/core';&gt; import &#123; CommonModule &#125; from '@angular/common';&gt; &gt; import &#123; LoggerService &#125; from './logger.service';&gt; import &#123; NavComponent &#125; from './nav/nav.component';&gt; import &#123; throwIfAlreadyLoaded &#125; from './module-import-guard';&gt; &gt; @NgModule(&#123;&gt; imports: [&gt; CommonModule // we use ngFor&gt; ],&gt; exports: [NavComponent],&gt; declarations: [NavComponent],&gt; providers: [LoggerService]&gt; &#125;)&gt; export class CoreModule &#123;&gt; constructor( @Optional() @SkipSelf() parentModule: CoreModule) &#123;&gt; throwIfAlreadyLoaded(parentModule, 'CoreModule');&gt; &#125;&gt; &#125;&gt; SharedModule和CoreModule相比，SharedModule正好相反，它不应该包含服务，因为SharedModule会在不同业务模块中导入，一旦包含了服务，就会产生不同的实例，有可能会对应用产生负面的影响，所以尽量保证服务的单一性。 SharedModule中正如官网所说，应该包含所有组件（自己写的非业务相关的通用组件）、指令、管道以及其他模块所需要的资产（例如 CommonModule 、 FormsModule、RouterModule、ReactiveFormsModule和第三方通用依赖模块）。 Service对于服务，应该承担应用的数据操作和数据交互的作用，所以类似于 http 请求、storage 的操作、复杂数据的计算等都应交给服务，让组件聚焦于视图，去组织视图层的展示和服务计算数据的收集，而不是承担了较重的数据操作和交互。业务层的服务尽量跟着对应的组件，通常我会在对应组件文件夹下新建一个services的文件夹，存放对应的服务。 Styles至于样式，通常我会把全局性的变量、通用的 css 样式（和业务无关的样式，例如 css reset、自适应相关的全局样式）放在src/styles.scss下，而和业务相关的通用 css 样式(例如某几个组件共用的样式、mixin 等)都会放在assets/css目录下。 总结 AppModule 应该 导入 SharedModule、CoreModule、LayoutModule、RouterModule、Angular 模块(例如：BrowserModule、BrowserAnimationsModule、HttpClientModule)； LayoutModule 应该 导入 SharedModule； LayoutModule 应该 导出所有 layout component； LayoutModule 不应该 导入和声明任何路由； RouterModule 应该 导入 SharedModule、CoreModule、LayoutModule以及RouteRoutingModule； CoreModule应该 只保留providers属性； SharedModule 应该 包含 Angular 通用模块(例如：CommonModule、FormsModule、RouterModule、ReactiveFormsModule)、第三方通用依赖模块、所有组件（自己写的非业务相关的通用组件）、指令、管道； SharedModule应该导出所有包含模块； SharedModule 不应该 有providers属性； Service 应该 承担应用的数据操作和数据交互； Component应该 组织视图层的展示和服务计算数据的收集 样式分层]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>Angualr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一款可以让我吹爆的数字笔记应用]]></title>
    <url>%2F2019%2F01%2F25%2F%E4%B8%80%E6%AC%BE%E5%8F%AF%E4%BB%A5%E8%AE%A9%E6%88%91%E5%90%B9%E7%88%86%E7%9A%84%E6%95%B0%E5%AD%97%E7%AC%94%E8%AE%B0%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[在遇到 Notion 之前，我的笔记记录交给 onenote ，任务管理交给手机端的 Awesome Note 2，零碎的知识收集交给 Pocket。但是不爽的是要在三个应用之间切换，而且 Awesome Note 2 没有桌面版。而 Notion 的出现大大提高了我在笔记、知识库和任务管理上的效率，满足了我对笔记类和任务管理类软件的98%需求。 Notion 简介 Notion 自称是一款「将笔记、知识库和任务管理无缝整合的协作平台」。它具有无限的层级和相互链接的组织弹性，给笔记间的关系提供了足够自由的组织方式；它排版灵活，能够把笔记里的内容按块（Block）进行组织和拖拽，甚至可以做出 Trello 看板进行项目管理；它的内容类型丰富，可以嵌入图片、网页、文档甚至视频，几乎无所不能。 Notion 的界面很简洁，右边是内容编辑区域，左边是目录和一些功能设置。 在我看来 Notion 最让我心动的是以下几点： 丰富的 Block 在 Notion 中 Block 是最基本的单位，文字、视频、图片等都是一个 Block，并且所有的 Block 可以任意拖拽。这种想法类似于乐高积木，通过积木可以扩展出各种你想要的东西。 下面这张图（图来自少数派用户一条小虫）只是一个其中一部分 Block 的示例，Notion 还有强大功能的表格（表格甚至可以插入公式进行计算）、看板等 Block，只要在笔记中输入/，就会跳出各种 Block 供你选择。 模板 面对这么多 Block，可能有时候你不知道怎么组织你的页面，但是官方提供了很多模板，在创建的时候 页面的时候，你可以很快搭建起你想要的页面。如果你嫌官方的模板满足不了你的要求，还可以去这里或者notionpages下载其他人做好的模板。 历史记录 Notion 提供你操作的历史记录，你可以随时恢复之前的操作，这个功能应该是手残党的福音。 布局灵活 Notion 所有的 Block 都可以拖拽，所以你可以非常方便的去组织你的笔记，就像下面这样： 强大的嵌入功能 在 Notion 中，你可以嵌入大部分你做笔记时想嵌入的东西，比如PDF、Excel、word、视频、网页、代码、Google Map等。这些嵌入的东西都可以直接在页面内查看，不需要重新打开其他应用。 Notion 中可以嵌入的类型 支持 Markdown 这个是程序员都喜闻乐见的功能，有了 markdown 的支持后，写笔记更加顺畅。 分享 在 Notion 中，你可以通过 share 按钮把你当前页面分享出去，甚至可以邀请其他人和你一起编辑当前页面。 同步 Notion 同步功能可以说非常迅速，无论在桌面端、网页端还是移动端，任意编辑都能迅速同步。 离线 Notion 可以离线使用，当你离线的时候，Notion 打开速度甚至会快一点，原因我猜是不需要去服务器检查多人协作的情况和更新页面吧。 当然 Notion 作为一款很年轻的应用现在还不是十全十美，如果说 Notion 现在的缺点的话，我觉得有下面几点： 不支持重复提醒 当你使用日历创建任务提醒的时候，不支持创建重复提醒，比如每周一提醒或者每月提醒，所以这种重复提醒类的任务我还是扔给了 Awesome Note 2 。 缺少收集工具 缺少一款类似 Pocket 或者 印象笔记剪藏 的碎片知识收集工具，现在我手动放到 Knowledge Base 页面中，这样很多时候很麻烦，在浏览器端或者手机端，可以把相关链接分享到 Notion，然后再继续整理，这样就可以行程完整的知识库的闭环。 Notion 也出了类似的收集工具，可以点击链接安装。如何使用可以参考官方使用教程 导出功能 选择 markdown 导出的时候常常布局会有问题，现在我选择直接导出 markdown，然后用 Typora 导出为 PDF。 外部模板不能设为默认模板 外部导入的模板不能设为默认模板会让每次创建重复页面的时候有点麻烦，而 Template Button 也只能在当前页面中使用，不是很方便。 网络略慢 Notion 好像用了亚马逊的 AWS，在国内用的话打开会有点慢，但是没有慢到不可接受的程度，如果你在离线状态，还能更快。 我的 Notion 食用方式Notion 中有很多种使用方式，你可以随意组合表格、看板等 Block 来实现你想要的功能，这里简单介绍一下我使用 Notion 的几种方式。 GTDGTD主要负责我的任务管理，Notion 中可以把日历、表格、列表和看板集合于一体，结合筛选和过滤功能，可以非常方便的在同一个界面用不同方式展示你的任务安排和进度。 参考少数派的作者Maybe009在试过不少工具后，我用 Notion 进行更灵活的任务管理中的介绍，我也模仿做了一个类似。 你可以直接用官方提供的 Editorial Calendar 模板来做你的 GTD ，然后通过设置不同的 Filter 来在不同模式下展示不同的任务。而和 Maybe009 在看板中添加预处理项的做法不同的是，我直接使用自带的 Idea 一栏，把它作为一些有想法但没有安排的任务存放处，这样更加方便一些。 个人知识库个人知识库用于对于碎片知识的收集和整理，通常我会把看到一些比较好的文章、段落等放到这边，通过对知识碎片打标签和分类，来进行管理，并且对它们加上状态管理，方便及时查看哪些知识碎片是没有整理过的。 你可以使用 Lightweight CRM 模板来实现这个页面，配合筛选功能和自定义属性，就能很方便地实现自己的知识库的管理。随便提一句，Notion 支持全局的搜索，而且中文也可以哦。 如果你每次都要把链接或者文章贴到这边会比较麻烦，所以我的解决方案是都先发送到 Pocket，然后在 Awesome Note 2 中设定定时提醒，提醒自己归档和整理。 笔记笔记我把它分为 Quick Note 和 Notes，一个套用了 Notion 提供的 Quick Note 的模板，专职于记录下平时一些灵感，突出 Quick 。而 Notes 则和 Knowledge Base 一样使用 Lightweight CRM 模板来实现笔记的归档和整理。 年度目标年度目标当然是用来立一些 flag 啦，用 Tasks 或者 Roadmap 模板都可以实现这样的看板页面。 旅行计划Notion 中真的很合适去写旅行计划，你可以把你收集的攻略、视频都插到计划中，甚至还可以插入 Google Map，写完旅行计划后，你可以直接分享给你的同伴，甚至邀请他一起编辑，真的是神器了。 总结上面只是我自己在 Notion 使用中的一些摸索，Notion 可以做的远远不止这些，通过 Block 之间的不同组合，Notion 的使用有很大的想象空间，虽然这款从2016年出来的应用还有一些小缺点，但是它的理念耳目一新，让人感到兴奋。 另外需要说明的是，Notion 是订阅制，免费用户不限制队友，但是有1000个 Block 和5M 文件上传限制，而个人使用推荐使用 Personal 订阅，4美元一个月，拥有无限 Block，没有上传设置，但是只能你自己编辑。 参考资料notionpages Notion：重新定义数字笔记 notion的使用体验 试过不少工具后，我用 Notion 进行更灵活的任务管理]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手把手教你使用Netlify部署博客及部署自动化]]></title>
    <url>%2F2019%2F01%2F18%2F%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E4%BD%BF%E7%94%A8Netlify%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2%E5%8F%8A%E9%83%A8%E7%BD%B2%E8%87%AA%E5%8A%A8%E5%8C%96%2F</url>
    <content type="text"><![CDATA[我的博客之前一直托管在 coding 上，图片等静态资源放在七牛云的 cdn 上，这样国内国外访问速度都还可以。去年七牛云的 cdn 强制需要做域名备案，备案是不可能的，这辈子都不可能，所以把所有静态资源都直接扔到 coding 上。coding 也发生了几次博客推送后不更新问题，一怒之下，就直接把博客迁到 GitHub Pages，不过对国内用户来说，访问速度和稳定性不是很好。正当我在想怎么办的时候，发现了 Netlify。 Netlify 是一个提供静态资源网络托管的综合平台，提供CI服务，能够将托管 GitHub，GitLab 等网站上的 Jekyll，Hexo，Hugo 等代码自动编译并生成静态网站。 Netlify 有如下的功能: 能够托管服务，免费 CDN 能够绑定自定义域名 能够启用免费的TLS证书，启用HTTPS 支持自动构建 提供 Webhooks 和 API 使用 Netlify首先使用你的 GitHub 账号登陆 Netlify，登陆后进入空间管理中心，，点击New site from git按钮开始部署你的博客： 然后根据自己的托管平台，可以选择GitHub、GitLab或者BitBucket（这里以 GitHub 为例）： 点击GitHub之后会弹出一个让你授权的窗口，给 Netlify 授权后，就会自动读取你 GitHub 的仓库： 选择仓库后，Netlify 会自动识别到 hexo，并填入相关信息，这时候只要无脑点击 Deploy site就可以： 稍等一段时间就可以看到你的博客已经部署成功，并且给你分配了一个二级域名（先记下这个二级域名）： 如果你要绑定自己买的域名，就直接点击第二步Set up custom domain。添加自定义域名，先添加不带www的域名作为主域名，它会自动添加一个www.domain.cc重定向到domain.cc： 设置完，Netlify 会提示你去域名DNS解析处，修改域名的CNAME记录： 去你的 DNS 解析提供商里面，将 CNAME 记录值更改为 Netlify 给你的二级域名： 修改完，就可以看到 Netlify 状态更新： Netlify默认会启用 HTTPS，而且不能关闭，如果你没有证书，它会帮你去Let’s Encrypt申请免费的证书，当然你也可以自己申请证书，以阿里免费的 ssl 证书为例，下载证书证书时选服务器类型为Apache的证书，Netlify 配置填写如下： 自动化部署上面流程走完，其实已经可以自动化部署，只要 push 了代码，就会自动更新，你可以在下面地方查看部署的信息： 如果你不想用 Netlify 的服务，也可以用 Circle 的服务，它和 GitHub 关联，提供 CI 服务。你需要做的事在根目录下新建一个.circle文件夹，里面新建一个config.yml文件（注意把相关信息替换成自己的）： 12345678910111213141516171819202122232425262728293031323334353637383940414243# Javascript Node CircleCI 2.0 configuration file## Check https://circleci.com/docs/2.0/language-javascript/ for more details#version: 2jobs: build: docker: # specify the version you desire here - image: circleci/node:7.10 # Specify service dependencies here if necessary # CircleCI maintains a library of pre-built images # documented at https://circleci.com/docs/2.0/circleci-images/ # - image: circleci/mongo:3.4.4 working_directory: ~/repo steps: - checkout # Download and cache dependencies - restore_cache: keys: - v1-dependencies-&#123;&#123; checksum "package.json" &#125;&#125; # fallback to using the latest cache if no exact match is found - v1-dependencies- - add_ssh_keys: fingerprints: - "你的 ssh key的fingerprints" - run: git config --global user.email "user@domain.com" - run: git config --global user.name "user" - run: npm install - run: sudo npm install hexo-cli -g - save_cache: paths: - node_modules key: v1-dependencies-&#123;&#123; checksum "package.json" &#125;&#125; # run tests! - run: hexo clean - run: hexo g - run: hexo d 这时候，你只要提交代码到这个仓库，circle 就会帮你自动部署了。]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ceph集群部署不完全指南]]></title>
    <url>%2F2018%2F12%2F28%2Fceph%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[Ceph是一个统一的分布式存储系统，设计初衷是提供较好的性能、可靠性和可扩展性。 Ceph项目最早起源于Sage Weil就读博士期间的工作（最早的成果于2004年发表），并随后贡献给开源社区。在经过了数年的发展之后，目前已得到众多云计算厂商的支持并被广泛应用。RedHat及OpenStack都可与Ceph整合以支持虚拟机镜像的后端存储。 Ceph是一个横向扩展系统：它被设计为先天无单点失效问题，可以扩展到无限个节点，并且节点之间没有耦合关系（无共享架构），而传统存储系统控制器之间总有一些组件是共享的（缓存、磁盘）。 Ceph使用Crush算法对数据进行自动化组织管理。Crush算法负责数据对象在集群内的智能分布，随后使用集群节点作为数据的管理器。 ceph 部署的时候根据官网建议： 机械硬盘最小为1T 磁盘越大，单位GB的存储空间越小，但是需要的内存越多，尤其是在recovery,backfill以及reblance时 不推荐将一个盘分多个区，再跑多个OSD进程 不推荐OSD和mon, 或者OSD和mds跑在同一个硬盘上 很多 slow osd的问题往往是由于对磁盘设备的过度使用，请使用专用的磁盘用于安装操作系统以及软件；专用的磁盘设备用于osd daemon, 专门的磁盘设备用于journal 所以一般 ceph 部署时，一个节点最好挂三块盘，一块盘装操作系统，一块存储 OSD 数据，一块存储 OSD 日志，而存储日志的盘最好是 SSD，以便提高性能。 这里因为某些原因，以三台单盘的机器部署 ceph 集群为例，具体配置如下： 系统：Ubuntu 16.04.5 LTS (GNU/Linux 4.4.0-117-generic x86_64) IP 地址及 hostname： ip hostname 172.19.217.71 Ceph-master 172.19.217.72 Ceph-node1 172.19.217.73 Ceph-node2 磁盘状态： 1234$ lsblkNAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTvda 253:0 0 400G 0 disk`-vda1 253:1 0 400G 0 part / 设置免密登录选定一个节点作为主控节点（这里选的172.19.217.71主机），建立从主控节点到其他节点的免密登录。 生成秘钥： 1$ ssh-keygen 拷贝秘钥： 12$ ssh-copy-id root@172.19.217.72 $ ssh-copy-id root@172.19.217.73 修改使hostname和ip对应: 在 /etc/hosts 里追加以下信息: 123172.19.217.71 Ceph-master172.19.217.72 Ceph-node1172.19.217.73 Ceph-node2 安装ntp服务（所有节点）主要是用于ceph-mon之间的时间同步。在所有 Ceph 节点上安装 NTP 服务（特别是 Ceph Monitor 节点），以免因时钟漂移导致故障。确保在各 Ceph 节点上启动了 NTP 服务，并且要使用同一个 NTP 服务器。 1234$ sudo apt install ntpdate$ service ntp stop$ ntpdate ntp.ubuntu.com$ service ntp start 添加ceph用户（所有节点）1、在各 Ceph 节点创建新用户 1$ sudo useradd -d /home/ceph -m ceph 2、确保各 Ceph 节点上新创建的用户都有 sudo 权限 123$ echo "ceph ALL = (root) NOPASSWD:ALL" | tee /etc/sudoers.d/ceph$ chmod 0440 /etc/sudoers.d/ceph tips: 这里虽然添加了 ceph 用户, 但是最后安装时并没有用 ceph 用户来安装， 而是采用 root 用户安装 添加ceph安装源（所有节点）123$ wget -q -O- 'http://mirrors.163.com/ceph/keys/release.asc' | apt-key add -$ echo deb http://mirrors.163.com/ceph/debian-jewel/ $(lsb_release -sc) main | tee /etc/apt/sources.list.d/ceph.list 安装ceph-deploy部署工具(仅主控节点)更新仓库，并安装 ceph-deploy： 12$ apt update$ apt install ceph-deploy ceph安装(仅主控节点)创建部署目录1$ mkdir ceph-cluster &amp;&amp; cd ceph-cluster/ 配置新节点1$ ceph-deploy new Ceph-master Ceph-node1 Ceph-node2 配置完后，目录下会有如下几个文件 12$ lsceph.conf ceph-deploy-ceph.log ceph.mon.keyring 安装1$ ceph-deploy install Ceph-master Ceph-node1 Ceph-node2 都出现如下输出表示安装成功： 12Running command: ceph --versionceph version 10.2.11 (e4b061b47f07f583c92a050d9e84b1813a35671e) 配置并启动 ceph-mon(仅主控节点)1$ ceph-deploy mon create-initial 至此，ceph集群的安装工作完毕。 运行 ceph -s可以看到当前集群的状态，运行ceph health查看 ceph health 的状态： 1HEALTH_OK health 状态应该是 HEALTH_OK，如果有no osds的 error，只需按照下面方法添加 osd即可，如果有其他HEALTH_ERROR，可以参照下面的解决办法去解决。 ceph 鉴权文件分发到各个节点1$ ceph-deploy admin Ceph-master Ceph-node1 Ceph-node2 OSD HEALTH不为 OK 的解决办法 如果碰到下面的 health err且文件系统是 ext4 12$ ceph healthHEALTH_ERR 64 pgs are stuck inactive for more than 300 seconds; 64 pgs stuck inactive; 64 pgs stuck unclean 先用 Tips 中的方法去查看 log，如果 log 中有 filename too long 的 error，先编辑对应的 ceph.conf： 1$ vim ceph.conf 在末尾添加： 123osd_max_object_name_len = 256osd_max_object_namespace_len = 64filestore_xattr_use_omap = true # Just 4 ext4 然后运行下面命令： 12345$ ceph-deploy install Ceph-master Ceph-node1 Ceph-node2$ ceph-deploy --overwrite-conf admin Ceph-master Ceph-node1 Ceph-node2$ ceph-deploy --overwrite-conf mon create-initial 如果碰到too few PGs per OSD (21 &lt; min 30)的 warning，先查看 pool： 12$ sudo ceph osd lspools0 rbd, 查看 rbd pool 的 pgs 和 pgps以及副本数: 12345678$ sudo ceph osd pool get rbd pg_numpg_num: 64$ sudo ceph osd pool get rbd pgp_numpgp_num: 64$ ceph osd dump | grep 'replicated size'pool 0 'rbd' replicated size 3 min_size 2 crush_ruleset 0 object_hash rjenkins pg_num 64 pgp_num 64 last_change 1 flags hashpspool stripe_width 0 健康的 pg_num 和 pgp_num 计算方法： 关于pgmap的数目，osd_num *100 / replica_num，向上取2的幂。比如15个osd，三备份，15 *100/3=500，得到pg_num = 512，线上重新设定这个数值时会引起数据迁移，请谨慎处理。 在这里，pgs为64，因为是3副本的配置，所以当有3个osd的时候，3 *100/3=100，得到pg_num = 128 解决办法：修改默认pool rbd 的 pgs 和 pgps: 12$ sudo ceph osd pool set rbd pg_num 128$ sudo ceph osd pool set rbd pgp_num 128 终极方法 删除 ceph 并清理环境，然后可能就好了~~具体方法见下面 Tips 添加 OSD(仅主控节点)查看未分配分区： 1234567891011121314151617181920$ fdisk -lDisk /dev/vda: 400 GiB, 429496729600 bytes, 838860800 sectorsUnits: sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisklabel type: dosDisk identifier: 0x77ba45a4Device Boot Start End Sectors Size Id Type/dev/vda1 * 2048 838858751 838856704 400G 83 Linux$ df -hFilesystem Size Used Avail Use% Mounted onudev 63G 0 63G 0% /devtmpfs 13G 15M 13G 1% /run/dev/vda1 394G 9.8G 364G 3% /tmpfs 63G 0 63G 0% /dev/shmtmpfs 5.0M 4.0K 5.0M 1% /run/locktmpfs 63G 0 63G 0% /sys/fs/cgroupoverlay 394G 9.8G 364G 3% /var/lib/docker/overlay2/d64af4717c1a56cf37cf6ba00937888a376304627b0791f19d6e5e707e0165b5/merged 这里看到这台机器只有一块盘，所以我们通过目录创建 ceph osd(所有节点)： 123$ rm -rf /var/lib/ceph/osd/ceph-0$ mkdir -p /var/lib/ceph/osd/ceph-0$ chown ceph:ceph /var/lib/ceph/osd/ceph-0 添加 OSD(仅主控节点)： 123$ ceph-deploy osd create Ceph-master$ ceph-deploy osd create Ceph-node1$ ceph-deploy osd create Ceph-node2 这个命令相当于下面磁盘准备和启动 OSD 两条命令： 磁盘准备(仅主控节点) 12345$ ceph-deploy osd prepare Ceph-master:/var/lib/ceph/osd/ceph-0$ ceph-deploy osd prepare Ceph-node1:/var/lib/ceph/osd/ceph-0$ ceph-deploy osd prepare Ceph-node2:/var/lib/ceph/osd/ceph-0 启动 OSD(仅主控节点) 12345$ ceph-deploy osd activate Ceph-master:/var/lib/ceph/osd/ceph-0$ ceph-deploy osd activate Ceph-node1:/var/lib/ceph/osd/ceph-0$ ceph-deploy osd activate Ceph-node2:/var/lib/ceph/osd/ceph-0 添加 mds(仅主控节点)为使用 CephFS 添加 mds, 如果不用 CephFS 可以不添加。 此处只在 master 上添加一个 mds 1$ ceph-deploy mds create Ceph-master 配置 mgrceph 12.0之后必须配置 manager, 且最好有 moniter 的机器上都部署 mgr： 123$ ceph-deploy mgr create Ceph-master$ ceph-deploy mgr create Ceph-node1$ ceph-deploy mgr create Ceph-node2 因为部署的 ceph 版本是 10.2.11，所以这步可以略过。 配置完后用ceph health命令查看时，ceph 状态为 OK 则部署完成。 Tips错误排查查看 log： 12$ cd /var/log/ceph$ cat ceph-osd.0.log 删除osd123456$ ceph osd crush reweight osd.x 0.0 $ ceph osd out osd.x $ service ceph stop osd.x$ ceph osd crush remove osd.x $ ceph auth del osd.x $ ceph osd rm X 如果遇到Error EBUSY: osd.0 is still up; must be down before removal.可以执行下面命令强行标记为down，之后删除即可： 12$ ceph osd down osd.0$ ceph osd rm 0 删除 ceph 并清理环境12345#卸载ceph软件包$ ceph-deploy purge Ceph-master Ceph-node1 Ceph-node2#删除各种配置文件和生成的数据文件$ ceph-deploy purgedata Ceph-master Ceph-node1 Ceph-node2]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>ceph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kubernetes集群部署不完全指南]]></title>
    <url>%2F2018%2F12%2F19%2FKubernetes%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[最近沉迷在 Kubernetes 和 ceph 部署中不能自拔，作为初学者，基本上把可能踩的坑都踩了一遍，先分享一下怎么部署 Kubernetes 集群，过段时间再把 ceph 集群部署和 ceph fs 部署的不完全指南分享一下。 首先，我们要知道 Kubernetes 是什么： Kubernetes简称为k8s，它是 Google 开源的容器集群管理系统。在 Docker 技术的基础上，为容器化的应用提供部署运行、资源调度、服务发现和动态伸缩等一系列完整功能，提高了大规模容器集群管理的便捷性。 K8s 是一个完备的分布式系统支撑平台，具有完备的集群管理能力，多层次的安全防护和准入机制、多租户应用支撑能力、透明的服务注册和发现机制、內建负载均衡器、强大的故障发现和自我修复能力、服务滚动升级和在线扩容能力、可扩展的资源自动调度机制以及多粒度的资源配额管理能力。同时 K8s 提供完善的管理工具，涵盖了包括开发、部署测试、运维监控在内的各个环节。 如果你想更加详细了解 k8s ，可以去看看IBM的视频，讲的还可以。 这个教程是对三台阿里云机器进行 k8s 部署，系统是Ubuntu 16.04.4 LTS。其中一台是 master ，其他两台是 worker。 安装 git12$ sudo apt-get update$ sudo apt-get install git 这步主要为后面部署 ceph 服务。 安装 Docker添加使用 HTTPS 传输的软件包以及 CA 证书 123456$ sudo apt-get update$ sudo apt-get install \ apt-transport-https \ ca-certificates \ curl \ software-properties-common 添加软件源的 GPG 密钥 1$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - 向 source.list 中添加 Docker 软件源 1234$ sudo add-apt-repository \ "deb [arch=amd64] https://download.docker.com/linux/ubuntu \ $(lsb_release -cs) \ stable" 更新 apt 软件包缓存，并安装 docker-ce 12$ sudo apt-get update$ sudo apt-get install docker-ce 在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，Ubuntu 系统上可以使用这套脚本安装： 12$ curl -fsSL get.docker.com -o get-docker.sh$ sudo sh get-docker.sh --mirror Aliyun 测试是否安装正确： 12345678910111213141516171819202122232425262728$ docker run hello-worldUnable to find image 'hello-world:latest' locallylatest: Pulling from library/hello-worldd1725b59e92d: Pull completeDigest: sha256:0add3ace90ecb4adbf7777e9aacf18357296e799f81cabc9fde470971e499788Status: Downloaded newer image for hello-world:latestHello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the "hello-world" image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://hub.docker.com/For more examples and ideas, visit: https://docs.docker.com/get-started/ 安装 kubeadm, kubelet 和 kubectl因为某些你懂的原因，要更换阿里源，并安装kubelet kubeadm kubectl： 12345678$ apt-get update &amp;&amp; apt-get install -y apt-transport-https curl$ curl -s http://packages.faasx.com/google/apt/doc/apt-key.gpg | sudo apt-key add -$ cat &lt;&lt;EOF &gt; /etc/apt/sources.list.d/kubernetes.listdeb http://mirrors.ustc.edu.cn/kubernetes/apt kubernetes-xenial mainEOF$ apt-get update$ apt-get install -y kubelet kubeadm kubectl$ apt-mark hold kubelet kubeadm kubectl 如果遇到gpg: no valid OpenPGP data found.问题，参考这篇文章 使用kubeadm创建一个集群使用 kubeadm 创建 k8s 集群其实还蛮简单，最大的困难是那堵墙，当我费了一整天把那堵墙问题解决后，发现 1.13.0 版本居然提供了中国特供的一个功能，所以把两种方法都写出来，供大家参考。 1.13.0 版本之前首先查询下当前版本需要哪些docker image： 1$ kubeadm config images list --kubernetes-version v1.13.0 必须要指定版本，这样kubeadm才不会去连k8s.io。 新建一个pull_k8s_images.sh，根据查询到需要哪些镜像填写下面内容，以1.13.0为例： 123456789101112131415161718192021222324252627282930K8S_VERSION=v1.13.0ETCD_VERSION=3.2.24DASHBOARD_VERSION=v1.8.3FLANNEL_VERSION=v0.10.0-amd64DNS_VERSION=1.2.6PAUSE_VERSION=3.1docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver:$K8S_VERSIONdocker pull registry.cn-hangzhou.aliyuncs.com/google_containers/kube-controller-manager:$K8S_VERSIONdocker pull registry.cn-hangzhou.aliyuncs.com/google_containers/kube-scheduler:$K8S_VERSIONdocker pull registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy:$K8S_VERSIONdocker pull registry.cn-hangzhou.aliyuncs.com/google_containers/etcd:$ETCD_VERSIONdocker pull registry.cn-hangzhou.aliyuncs.com/google_containers/pause:$PAUSE_VERSIONdocker pull registry.cn-hangzhou.aliyuncs.com/google_containers/coredns:$DNS_VERSIONdocker tag registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver:$K8S_VERSION k8s.gcr.io/kube-apiserver:$K8S_VERSIONdocker tag registry.cn-hangzhou.aliyuncs.com/google_containers/kube-controller-manager:$K8S_VERSION k8s.gcr.io/kube-controller-manager:$K8S_VERSIONdocker tag registry.cn-hangzhou.aliyuncs.com/google_containers/kube-scheduler:$K8S_VERSION k8s.gcr.io/kube-scheduler:$K8S_VERSIONdocker tag registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy:$K8S_VERSION k8s.gcr.io/kube-proxy:$K8S_VERSIONdocker tag registry.cn-hangzhou.aliyuncs.com/google_containers/etcd:$ETCD_VERSION k8s.gcr.io/etcd:$ETCD_VERSIONdocker tag registry.cn-hangzhou.aliyuncs.com/google_containers/pause:$PAUSE_VERSION k8s.gcr.io/pause:$PAUSE_VERSIONdocker tag registry.cn-hangzhou.aliyuncs.com/google_containers/coredns:$DNS_VERSION k8s.gcr.io/coredns:$DNS_VERSIONdocker rmi registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver:$K8S_VERSIONdocker rmi registry.cn-hangzhou.aliyuncs.com/google_containers/kube-controller-manager:$K8S_VERSIONdocker rmi registry.cn-hangzhou.aliyuncs.com/google_containers/kube-scheduler:$K8S_VERSIONdocker rmi registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy:$K8S_VERSIONdocker rmi registry.cn-hangzhou.aliyuncs.com/google_containers/etcd:$ETCD_VERSIONdocker rmi registry.cn-hangzhou.aliyuncs.com/google_containers/pause:$PAUSE_VERSIONdocker rmi registry.cn-hangzhou.aliyuncs.com/google_containers/coredns:$DNS_VERSION 运行脚本： 1$ ./pull_k8s_images.sh 然后用 kubeadm 进行初始化： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071$ kubeadm init \ --pod-network-cidr=192.168.0.0/16 \ --ignore-preflight-errors=cri \ --kubernetes-version=1.13.0 [init] Using Kubernetes version: v1.13.0[preflight] Running pre-flight checks[WARNING SystemVerification]: this Docker version is not on the list of validated versions: 18.09.0. Latest validated version: 18.06[preflight] Pulling images required for setting up a Kubernetes cluster[preflight] This might take a minute or two, depending on the speed of your internet connection[preflight] You can also perform this action in beforehand using 'kubeadm config images pull'[kubelet-start] Writing kubelet environment file with flags to file "/var/lib/kubelet/kubeadm-flags.env"[kubelet-start] Writing kubelet configuration to file "/var/lib/kubelet/config.yaml"[kubelet-start] Activating the kubelet service[certs] Using certificateDir folder "/etc/kubernetes/pki"[certs] Generating "etcd/ca" certificate and key[certs] Generating "etcd/server" certificate and key[certs] etcd/server serving cert is signed for DNS names [izuf6e4bl8eavupeu7q9a1z localhost] and IPs [172.19.217.71 127.0.0.1 ::1][certs] Generating "etcd/healthcheck-client" certificate and key[certs] Generating "etcd/peer" certificate and key[certs] etcd/peer serving cert is signed for DNS names [izuf6e4bl8eavupeu7q9a1z localhost] and IPs [172.19.217.71 127.0.0.1 ::1][certs] Generating "apiserver-etcd-client" certificate and key[certs] Generating "ca" certificate and key[certs] Generating "apiserver" certificate and key[certs] apiserver serving cert is signed for DNS names [izuf6e4bl8eavupeu7q9a1z kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local] and IPs [10.96.0.1 172.19.217.71][certs] Generating "apiserver-kubelet-client" certificate and key[certs] Generating "front-proxy-ca" certificate and key[certs] Generating "front-proxy-client" certificate and key[certs] Generating "sa" key and public key[kubeconfig] Using kubeconfig folder "/etc/kubernetes"[kubeconfig] Writing "admin.conf" kubeconfig file[kubeconfig] Writing "kubelet.conf" kubeconfig file[kubeconfig] Writing "controller-manager.conf" kubeconfig file[kubeconfig] Writing "scheduler.conf" kubeconfig file[control-plane] Using manifest folder "/etc/kubernetes/manifests"[control-plane] Creating static Pod manifest for "kube-apiserver"[control-plane] Creating static Pod manifest for "kube-controller-manager"[control-plane] Creating static Pod manifest for "kube-scheduler"[etcd] Creating static Pod manifest for local etcd in "/etc/kubernetes/manifests"[wait-control-plane] Waiting for the kubelet to boot up the control plane as static Pods from directory "/etc/kubernetes/manifests". This can take up to 4m0s[apiclient] All control plane components are healthy after 18.001547 seconds[uploadconfig] storing the configuration used in ConfigMap "kubeadm-config" in the "kube-system" Namespace[kubelet] Creating a ConfigMap "kubelet-config-1.13" in namespace kube-system with the configuration for the kubelets in the cluster[patchnode] Uploading the CRI Socket information "/var/run/dockershim.sock" to the Node API object "izuf6e4bl8eavupeu7q9a1z" as an annotation[mark-control-plane] Marking the node izuf6e4bl8eavupeu7q9a1z as control-plane by adding the label "node-role.kubernetes.io/master=''"[mark-control-plane] Marking the node izuf6e4bl8eavupeu7q9a1z as control-plane by adding the taints [node-role.kubernetes.io/master:NoSchedule][bootstrap-token] Using token: awsx8h.d8atejb2a1eyrab7[bootstrap-token] Configuring bootstrap tokens, cluster-info ConfigMap, RBAC Roles[bootstraptoken] configured RBAC rules to allow Node Bootstrap tokens to post CSRs in order for nodes to get long term certificate credentials[bootstraptoken] configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token[bootstraptoken] configured RBAC rules to allow certificate rotation for all node client certificates in the cluster[bootstraptoken] creating the "cluster-info" ConfigMap in the "kube-public" namespace[addons] Applied essential addon: CoreDNS[addons] Applied essential addon: kube-proxyYour Kubernetes master has initialized successfully!To start using your cluster, you need to run the following as a regular user: mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/configYou should now deploy a pod network to the cluster.Run "kubectl apply -f [podnetwork].yaml" with one of the options listed at: https://kubernetes.io/docs/concepts/cluster-administration/addons/You can now join any number of machines by running the following on each nodeas root: kubeadm join --token &lt;token&gt; &lt;master-ip&gt;:&lt;master-port&gt; --discovery-token-ca-cert-hash sha256:&lt;hash&gt; 1.13.0版本之后Kubenetes默认Registries地址是k8s.gcr.io，很明显，在国内并不能访问gcr.io，因此在kubeadm v1.13之前的版本，安装起来非常麻烦，但是在1.13版本中终于解决了国内的痛点，其增加了一个--image-repository参数，默认值是k8s.gcr.io，我们将其指定为国内镜像地址：registry.aliyuncs.com/google_containers，其它的就可以完全按照官方文档来愉快的玩耍了。 运行： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172$ kubeadm init \ --image-repository registry.aliyuncs.com/google_containers \ --pod-network-cidr=192.168.0.0/16 \ --ignore-preflight-errors=cri \ --kubernetes-version=1.13.0 [init] Using Kubernetes version: v1.13.0[preflight] Running pre-flight checks [WARNING SystemVerification]: this Docker version is not on the list of validated versions: 18.09.0. Latest validated version: 18.06[preflight] Pulling images required for setting up a Kubernetes cluster[preflight] This might take a minute or two, depending on the speed of your internet connection[preflight] You can also perform this action in beforehand using 'kubeadm config images pull'[kubelet-start] Writing kubelet environment file with flags to file "/var/lib/kubelet/kubeadm-flags.env"[kubelet-start] Writing kubelet configuration to file "/var/lib/kubelet/config.yaml"[kubelet-start] Activating the kubelet service[certs] Using certificateDir folder "/etc/kubernetes/pki"[certs] Generating "etcd/ca" certificate and key[certs] Generating "etcd/server" certificate and key[certs] etcd/server serving cert is signed for DNS names [izuf6e4bl8eavupeu7q9a1z localhost] and IPs [172.19.217.71 127.0.0.1 ::1][certs] Generating "etcd/healthcheck-client" certificate and key[certs] Generating "etcd/peer" certificate and key[certs] etcd/peer serving cert is signed for DNS names [izuf6e4bl8eavupeu7q9a1z localhost] and IPs [172.19.217.71 127.0.0.1 ::1][certs] Generating "apiserver-etcd-client" certificate and key[certs] Generating "ca" certificate and key[certs] Generating "apiserver" certificate and key[certs] apiserver serving cert is signed for DNS names [izuf6e4bl8eavupeu7q9a1z kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local] and IPs [10.96.0.1 172.19.217.71][certs] Generating "apiserver-kubelet-client" certificate and key[certs] Generating "front-proxy-ca" certificate and key[certs] Generating "front-proxy-client" certificate and key[certs] Generating "sa" key and public key[kubeconfig] Using kubeconfig folder "/etc/kubernetes"[kubeconfig] Writing "admin.conf" kubeconfig file[kubeconfig] Writing "kubelet.conf" kubeconfig file[kubeconfig] Writing "controller-manager.conf" kubeconfig file[kubeconfig] Writing "scheduler.conf" kubeconfig file[control-plane] Using manifest folder "/etc/kubernetes/manifests"[control-plane] Creating static Pod manifest for "kube-apiserver"[control-plane] Creating static Pod manifest for "kube-controller-manager"[control-plane] Creating static Pod manifest for "kube-scheduler"[etcd] Creating static Pod manifest for local etcd in "/etc/kubernetes/manifests"[wait-control-plane] Waiting for the kubelet to boot up the control plane as static Pods from directory "/etc/kubernetes/manifests". This can take up to 4m0s[apiclient] All control plane components are healthy after 18.001547 seconds[uploadconfig] storing the configuration used in ConfigMap "kubeadm-config" in the "kube-system" Namespace[kubelet] Creating a ConfigMap "kubelet-config-1.13" in namespace kube-system with the configuration for the kubelets in the cluster[patchnode] Uploading the CRI Socket information "/var/run/dockershim.sock" to the Node API object "izuf6e4bl8eavupeu7q9a1z" as an annotation[mark-control-plane] Marking the node izuf6e4bl8eavupeu7q9a1z as control-plane by adding the label "node-role.kubernetes.io/master=''"[mark-control-plane] Marking the node izuf6e4bl8eavupeu7q9a1z as control-plane by adding the taints [node-role.kubernetes.io/master:NoSchedule][bootstrap-token] Using token: awsx8h.d8atejb2a1eyrab7[bootstrap-token] Configuring bootstrap tokens, cluster-info ConfigMap, RBAC Roles[bootstraptoken] configured RBAC rules to allow Node Bootstrap tokens to post CSRs in order for nodes to get long term certificate credentials[bootstraptoken] configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token[bootstraptoken] configured RBAC rules to allow certificate rotation for all node client certificates in the cluster[bootstraptoken] creating the "cluster-info" ConfigMap in the "kube-public" namespace[addons] Applied essential addon: CoreDNS[addons] Applied essential addon: kube-proxyYour Kubernetes master has initialized successfully!To start using your cluster, you need to run the following as a regular user: mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/configYou should now deploy a pod network to the cluster.Run "kubectl apply -f [podnetwork].yaml" with one of the options listed at: https://kubernetes.io/docs/concepts/cluster-administration/addons/You can now join any number of machines by running the following on each nodeas root: kubeadm join --token &lt;token&gt; &lt;master-ip&gt;:&lt;master-port&gt; --discovery-token-ca-cert-hash sha256:&lt;hash&gt; 如果我们想使用非root用户操作kubectl，可以使用以下命令，这也是kubeadm init运行后输出的一部分： 123$ mkdir -p $HOME/.kube$ sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config$ sudo chown $(id -u):$(id -g) $HOME/.kube/config 如果用kubeadm init初始化失败了，用下面命令清理环境重新kubeadm init： 1$ kubeadm reset 使用下面命令查看当前 pods 的状态： 123456789$ kubectl get pods --all-namespacesNAMESPACE NAME READY STATUS RESTARTS AGEkube-system coredns-78d4cf999f-7rt56 0/1 Pending 0 3m59skube-system coredns-78d4cf999f-kx2vg 0/1 Pending 0 3m59skube-system etcd-izuf6e4bl8eavupeu7q9a1z 1/1 Running 0 3m10skube-system kube-apiserver-izuf6e4bl8eavupeu7q9a1z 1/1 Running 0 3m19skube-system kube-controller-manager-izuf6e4bl8eavupeu7q9a1z 1/1 Running 0 3m21skube-system kube-proxy-m7wnw 1/1 Running 0 3m59skube-system kube-scheduler-izuf6e4bl8eavupeu7q9a1z 1/1 Running 0 3m10s 如果遇到下面错误： 1Unable to connect to the server: x509: certificate signed by unknown authority (possibly because of "crypto/rsa: verification error" while trying to verify candidate authority certificate "kubernetes") 运行下面命令解决证书问题后再查看： 1234$ mv $HOME/.kube $HOME/.kube.bak$ mkdir -p $HOME/.kube$ sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config$ sudo chown $(id -u):$(id -g) $HOME/.kube/config 通过上面 pods 状态可以看到CoreDND的状态是Pending，就是因为我们还没有安装网络插件。使用下面命令安装calico网络插件： 12$ kubectl apply -f https://docs.projectcalico.org/v3.3/getting-started/kubernetes/installation/hosted/rbac-kdd.yaml$ kubectl apply -f https://docs.projectcalico.org/v3.3/getting-started/kubernetes/installation/hosted/kubernetes-datastore/calico-networking/1.7/calico.yaml 这时候再查看 pods 的状态： 12345678910$ kubectl get pods --all-namespacesNAMESPACE NAME READY STATUS RESTARTS AGEkube-system calico-node-ph4gd 2/2 Running 0 83skube-system coredns-78d4cf999f-7rt56 1/1 Running 0 22mkube-system coredns-78d4cf999f-kx2vg 1/1 Running 0 22mkube-system etcd-izuf6e4bl8eavupeu7q9a1z 1/1 Running 0 21mkube-system kube-apiserver-izuf6e4bl8eavupeu7q9a1z 1/1 Running 0 21mkube-system kube-controller-manager-izuf6e4bl8eavupeu7q9a1z 1/1 Running 0 21mkube-system kube-proxy-m7wnw 1/1 Running 0 22mkube-system kube-scheduler-izuf6e4bl8eavupeu7q9a1z 1/1 Running 0 21m 可以看到STATUS全部变为了Running，表示安装成功，接下来就可以加入其他节点以及部署应用了。 Master 隔离默认情况下，由于安全原因，集群并不会将pods部署在Master节点上。但是在开发环境下，我们可能就只有一个Master节点，这时可以使用下面的命令来解除这个限制： 1$ kubectl taint nodes --all node-role.kubernetes.io/master- 加入工作节点SSH到其他机器上，成为 root 用户（如：sudo su -），安装 kubeadm, kubelet and kubectl。 然后复制上面的运行kubeadm init命令时最后一句输出，并运行它的： 1$ kubeadm join --token &lt;token&gt; &lt;master-ip&gt;:&lt;master-port&gt; --discovery-token-ca-cert-hash sha256:&lt;hash&gt; 这时候回到master 节点服务器，运行下面命令查看节点状态： 1234$ kubectl get nodesNAME STATUS ROLES AGE VERSIONizuf6e4bl8eavupeu7q9a0z Ready &lt;none&gt; 98s v1.13.0izuf6e4bl8eavupeu7q9a1z Ready master 75m v1.13.0 如果我们忘记了Master节点的加入token，可以使用如下命令来查看： 1$ kubeadm token list 默认情况下，token的有效期是24小时，如果我们的token已经过期的话，可以使用以下命令重新生成： 1$ kubeadm token create 如果我们也没有--discovery-token-ca-cert-hash的值，可以使用以下命令生成: 1$ openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/dev/null | openssl dgst -sha256 -hex | sed 's/^.* //' 至此一个简单的 k8s 集群部署就差不多了。 Tips查看k8s日志： 1$ journalctl -f -u kubelet 查看节点信息： 1$ kubectl describe node izuf6e4bl8eavupeu7q9a0z 用kubeadm reset重新部署 k8s 时记得把./kube下面的文件也一起删掉: 123456$ rm -rf $HOME/.kube#其他节点$ kubeadm reset$ iptables -P FORWARD ACCEPT$ iptables -F &amp;&amp; iptables -t nat -F &amp;&amp; iptables -t mangle -F &amp;&amp; iptables -X 总结最后，k8s 部署最大的坑是墙~]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ivy-Angular下一代渲染引擎]]></title>
    <url>%2F2018%2F11%2F30%2FIvy-Angular%E4%B8%8B%E4%B8%80%E4%BB%A3%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[截止到2018年11月30号，根据is-angular-ivy-ready显示，Angular Ivy 已经完成了93.46%，基本上接近完工。但是国内对 Ivy 介绍却很少，这次把今年4月ng-conf2018中关于 Angular Ivy 的PPT翻译一下，希望让更多人了解到和 Angular Ivy 有关的一些信息。 点击可以查看PPT 正如 Brad 先前提到的，Angular 的价值观以我们的用户，开发者和社区为中心。 Ivy 的目标是为 Angular 的价值观服务。 Ivy 专注于用户，通过让浏览器下载更少的资源，使应用程序启动更快，来提高用户体验。 它通过简化 API 和构建系统来帮助开发人员。 最后，它通过使编译管道更友好来帮助社区，从而为第三方贡献提供了可能性。 这些目标要求我们对编写代码的方式有不同的看法，并且我们希望与你分享这将为你的应用程序带来的结果和好处。 但首先，不要害怕！ 我们在这里所做的工作是100％向后兼容的，因此你不必对你的应用程序进行任何更改。 你的升级体验将与你对 Angular 团队的期望一样顺畅。 升级版本后，你将获得新的好处，并且你的应用程序仍然能很好的工作。 升级到 Ivy 意味着你的应用程序将继续工作而不会进行任何更改。 将有新的 API让你可以利用 Ivy 的一些更高级的功能。 现在，当我说Ivy向后兼容时，我真的想要强调它的重要性。 在谷歌，我们现在有超过600个应用程序，它们都是构建在新的Angular之上。 我们还有一个版本政策，这意味着我们不允许在旧版本的Angular上保留现有的应用程序。 因为我们每天都在将Angular同步到Google，所以所有应用程序都需要每次同步之后继续工作。 我们几乎不可能做出一个破坏性的改变。 因此，当你获得代码时，你可以确信它已被现实世界的应用程序充分验证过。 Ivy 有很多东西，但 Ivy 背后的一个重要思想就是我们所谓的 “locality”。简而言之，这意味着当编译器翻译模板时，只允许使用对它来说 “local” 的信息。local 意味着只有与组件描述直接关联的信息。这与当前 Angular 渲染管道的全局优化方法形成对比。那么让我们来谈谈 locality 给 Angular 带来的一些好处： Locality 允许第三方库将预编译模板发送到 NPM。这很重要，因为对于使用这些库的应用程序来说，它将极大地简化和加速编译。 有了 locality ，AoT / JIT的区别变得很小，几乎消失了。允许一个人自由地混合使用两者，例如在测试和开发中。对于生产，我们仍然只推荐 AoT。 Locality 不再需要Metadata.json文件。这极大地简化了第三方库的发布和开发以及与现有工具链的互用性。 Locality 大大修剪了编译图。这允许简化构建工具并更快地重建大型项目。 而我个人的最爱：Locality 支持元编程。今天，无法在运行时创建组件，Ivy 将成为可能。一个元编程的例子是高阶组件。 （不仅仅是为了让HOC成为可能而倡导HOC。） Locality 只是我们对 Ivy 坚持的一个原则。还有其他原则，但我们没有时间在这里讨论它们。 “today”是指2018年4月18日。 你可以看到Ivy开始于runtime，与模板编译器的工作重叠。一旦完成这些，beta版将开始进行Google的内部验证流程。此验证过程包括确保Ivy不会对使用Angular的600多个内部应用程序进行重大更改。这确保了在Ivy发布之前将完全向后兼容。 下面是 Ivy 核心开发者 Kara Erickson 的PPT介绍 Ivy 那么改变了什么？除了 Locality 之外，主要的变化是新系统的设计考虑了 tree-shaking。换句话说，渲染器代码的重写方式使得你未使用的任何 Angular 代码都可以简单地在构建步骤中被 tree-shaking 掉。这真的令人兴奋，因为这意味着你将留下一个更小的bundle。 我们正在进行的更改都在幕后 - 所以作为 Angular 开发人员 - 你实际上不必更改你正在编写的代码。但我会花一些时间来解释这个新设计是如何工作的，因为它实际上非常酷，我真的希望你理解为什么你会看到，使用 Ivy 后比用现在版本的 Angular 会得到更好的结果。 让我们先谈谈 tree-shaking。 如果你还没有听说过 tree-shaking，那么它本质上是一个构建优化步骤，可确保未使用的代码不会最终出现在你发送到浏览器的最终包中。通常，未使用的代码来自第三方库。 举一个简单的例子，如果你在第三方库中使用someFn，但是在这里没有使用过unusedFn，一个 tree-shaking 工具可以确保unusedFn不会在你最终的 bundle 中。 有一些工具可以做到这一点，比如： rollup，它使用 live code inclusion 来确保未使用的代码不会添加到你的 bundle 中 Uglify，它分析已经打包的代码并尝试从中删除没有的代码 无论你选择哪种工具，它们的功效取决于你编写代码的方式。 我会告诉你我的意思。 例如，假设你有一个从第三方导入的someFn，它在你的main函数中使用。 tree-shaking 通常使用引用的静态分析来确定要在 bundle 中保留哪些代码。 因为someFn在main函数中被引用，所以它将保留在 bundle 中。 UnusedFn不是，所以它不会在最终的 bundle 中。 但是我们换一个场景，如果只有条件检查通过，你才能使用unusedFn。 当你运行代码时，条件将最终为false，因此你仍然不需要unusedFn。 它会从 bundle 中删除吗？ 答案是否定的，因为在main中引用了unUsedFn。 请记住，tree-shaking 通常使用引用的静态分析。 它将尝试在不实际运行程序的情况下找出所需内容，并且存在限制。 通常，它必须假设最坏的情况以确保生成的程序是正确的，因此在这种情况下，它不确定该值在运行时将是什么，所以将保留unusedFn。 因此，当我们编写框架代码时，我们必须考虑避免这种情况。 Ok，有了上面的铺垫，让我们回到渲染管道以及它是如何被重构的。 首先，快速概述当前渲染器的工作原理。 目前，你编写的模板 HTML 通过 Angular 编译器运行，并生成代表模板结构的高度优化的JS 代码。 在运行时，此数据结构将传递给 Angular 解释器，Angular 解释器使用数据来确定如何创建DOM。 在实践中，它看起来像这样。 假设你有一个hello world模板，它只是一个带有class的div。 当前，编译器可能生成类似这样的东西，一些defs代表模板的结构。 例如，viewDef 包含div的elementDef和hello world的textDef。 然后在运行时将此定义传递给 Angular 解释器，Angular 使用该def来确定要运行哪些操作以正确生成DOM。 这非常有效。 唯一的问题是每个Angular模板都经过相同的代码路径，因此解释器不会提前知道它将看到哪种模板。 因此，它需要检查是否需要为其提供的模板执行每个操作。 正如我们之前所述，因为静态分析的工作方式，这些条件检查在运行时的值是什么并不重要，这里引用的所有函数都将保留在最终的 bundle 中，即使在代码路径中是没用过。 当我们设计 Ivy 时，我们考虑到了这个问题。 当我们不能提前知道你的模板长什么样子时，我们如何确保未运行的代码不包含在 bundle 中？ 这里有一个聪明的解决方案。 不生成模板数据并将其传递给解释器，然后解释运行哪些操作。 我们直接生成一组模板指令。 这些指令将完成自己正确创建DOM的工作。 因此，我们不再需要一个解释器来检查是否需要每个操作，并且引用未使用的函数。 对于和之前相同的模板，我们可能会生成这样的东西。 有三个指令： elementStart - 它将在DOM中创建元素 text - 将在DOM中创建文本节点 elementEnd - 基本上会执行一些内部处理 所以现在如果你看一下Angular代码，我们不需要进行任何条件检查。 我们只有原子函数来转换DOM，并根据你编写的模板生成。 因此，如果你没有使用某些Angular功能，例如container或listener或pipe……他们的指令就不会从你编写的模板中生成。 因为它们尚未生成，所以不会有引用，并且可以通过 tree-shaking 安全地删除它们。 我们已经将这个策略用于我们可以想到的每个功能。因此，如果你不使用queries或结构指令或生命周期钩子，那么可以通过 tree-shaking 工具删除该代码。 这真的很酷，因为这意味着你只需要关注实际使用的 Angular 特性，同时你的 bundle 大小可以显着缩小。 这反过来可以提高你的应用程序的启动性能，我知道很多人都在关注。 生成指令的另一个好处是 Ivy 生成的代码更容易阅读和理解。 为什么这很重要？ 如果你能够理解并完成框架对代码执行的操作，则可以更轻松地调试 Angular 应用程序。 在2018 ng-conf 上 Angular团队给出了一个 ivy 的 todo 应用的 demo :ivy-todo-list，这个应用的 bundle 大小是12.2kb，这个 todo app 的 demo 就在github angular 的仓库中，地址：https://github.com/angular/angular/tree/master/packages/core/test/bundling/todo； 这个todo 在本地跑起来需要安装 Bazel ， 然后通过 bazel 去运行这个app。 你喜欢这些演示吗？ 所以非常神奇的东西正在为 Ivy 而来。 我对 Ivy 的承诺感到非常兴奋，这是我们最重要的事情。 在我们将这个演示文稿包起来之前，我想解决一下我们与 Brad 一起做的旧赌注。 早在2016年5月，是两年前 Brad 向你们所有人做出了这个承诺。 有些人可能还记得这张幻灯片。 是的，如果我们得到10Kb以下的Angular Hello World，Brad就会答应一块蛋糕。 布拉德没有说明它是 minified 还是压缩后的数字，但可以肯定地说我们击败了两者。 这个 Todo 应用压缩后12.2 Kb。 在当前的Angular中，压缩的Hello World大约为36 Kb，而Kara已经发现我们的hello world 最小化后 7.3kb，压缩后 2.7kb。 所以 Ivy 成功地击败了10KB的门槛。 我们不仅仅是刚刚跨过这个门槛，而是大幅度地超过这个门槛。]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手把手教你生成足迹地图]]></title>
    <url>%2F2018%2F11%2F21%2F%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E7%94%9F%E6%88%90%E8%B6%B3%E8%BF%B9%E5%9C%B0%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[项目地址：travelMap 一直想有个东西记录一下去过的地方，百度地图上有个足迹功能，能记录你去过的地方，不过你没办法在其他地方去调用这个功能，相对来说不是特别方便。 网上常见的足迹地图方案是用jvectormap去写的，但是jvectormap缩放后不能得到更详细地地图信息。于是就借助leaflet-echarts3做了一个足迹地图。leaflet-echarts3虽然只提供uglify以后的合并版本，但是写一个简单的足迹地图还是绰绰有余。 这个项目使用很简单，如果你不会编程也没关系，我把用户数据独立出来，你只要查找一下经纬度，照着格式填写就行。 首先，先点击下载这个项目travelMap。下载解压后，文件夹中有下面几个文件（.gitignore可能你会看不到）： 在这些文件中，你只需要编辑mapData.js就行，其他都不需要你修改任何代码。 为了方便编辑对应的文件，推荐去下载微软的visualstudio code打开对应的文件。 安装完visualstudio code，在File–&gt;Open Folder中打开刚刚解压的文件夹： 这时候你可以看到相应的数据，只要按照一样的格式添加相应的数据就行。拿下面一行数据举例，说明一下各个参数代表的意义： 1&#123;name: '巴塞罗那', value: 30, description: '2018年5月', geoCoord:[41.3825,2.1769]&#125;, 上面一行中： value表示地图上黄色点的大小，数值越大，显示的大小越大； geoCoord表示了经纬度，相关数据可以通过gpsspg查到，查到的数据之间放到[]中就行； name和description表示了鼠标悬浮在黄色点上显示的内容，如下图所示： 这里对非编程人员提醒一下，所有的符号必须是英文状态下打出来的，如果是中文状态会报错，修改前可以在编辑器里面尝试输入一下中文状态和英文状态下的符号，能很明显看出不同。最后每一行结尾的逗号不要漏掉了，这个要注意一下。 修改完数据，双击文件夹中的index.html，就会调用你本机的浏览器（或者把这个文件拖到浏览器中打开），这时候就可以看到你自己的足迹地图了。每次修改后，刷新一下浏览器，就可以看到修改后的效果了。 如果你想玩点更高级的，推荐去Echarts实例看看相关图表，随便选个实例点进去，然后根据配置项手册的说明生成一个自己的的图表吧。]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>Echarts</tag>
        <tag>足迹</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端常见知识点总结]]></title>
    <url>%2F2018%2F11%2F20%2F%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[文中部分源码地址：https://github.com/tc9011/Front-end-basics HTML行内元素和块级元素的区别行内元素：a、img、b、i、input、label、em、span、strong、select等 块级元素：div、section、h1、h2、h3、h4、h5、h6、table、menu、ol、ul、form、hr等 可变元素（根据上下文语境决定该元素为块元素或者内联元素）：button、iframe、script、del等 块级元素会独占一行，其宽度自动填满其父元素宽度；行内元素不会独占一行，相邻的行内元素会排列在同一行里，知道一行排不下，才会换行，其宽度随元素的内容而变化 块级元素可以设置 width,height属性，行内元素设置width, height无效 （注意：块级元素即使设置了宽度，仍然是独占一行的） 块级元素可以设置margin 和padding. 行内元素的水平方向的padding-left,padding-right,margin-left,margin-right 都产生边距效果，但是竖直方向的padding-top,padding-bottom,margin-top,margin-bottom都不会产生边距效果。（水平方向有效，竖直方向无效） 块级元素可以容纳内联元素和其他块元素，内联元素只能容纳文本或者其他内联元素(内联元素中嵌套块级元素时，块级元素无法继承内联元素的属性。) script标签的defer和async的区别&lt;script&gt;标签可能会阻塞html解析，从而影响首页加载速度，可以使用async进行异步加载或者用defer进行延迟加载。 async属性表示脚本会在下载后尽快执行，但不能保证脚本会按照顺序执行。 defer属性表示脚本会先下载，但会在整个页面都解析完成后再运行，并且按照脚本出现的先后顺序执行。 用网上一张图能比较明显得看出两者的不同之处。 蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表 HTML 解析。 这两个属性只适用于外联脚本。 扩展阅读： 详解defer和async的原理及应用 SVG 和 Canvas的区别 从图像类别区分，Canvas是基于像素的位图，而SVG却是基于矢量图形。位图是最小单位由象素构成的图，缩放会失真；而矢量图通过多个对象的组合生成的，对其中的每一个对象的纪录方式，都是以数学函数来实现的，缩放不失真。 从渲染模式上来说，Canvas属于 即时模式，而SVG则是 保留模式 ,这两种模式的区别可以参见 cshao 的博文： http://www.lifelaf.com/blog/?p=354。 从结构上说，Canvas没有图层的概念，所有的修改整个画布都要重新渲染，而SVG则可以对单独的标签进行修改。 从操作对象上说，Canvas是基于HTML canvas标签，通过宿主提供的Javascript API对整个画布进行操作的，而SVG则是基于XML元素的。 从功能上讲，SVG发布日期较早，所以功能相对Canvas比较完善。 关于动画，Canvas更适合做基于位图的动画，而SVG则适合图表的展示。关于SVG和Canvas的运行场景可参考MSCN关于 如何为您的网站在Canvas和SVG之间做出选择： 从搜索引擎角度分析，由于svg是有大量标签组成，所以可以通过给标签添加属性，便于爬虫搜索。 参考文章： Canvas 与 SVG的主要区别 Canvas or SVG？一张好图，两手准备，就在 ECharts 4.0 canvas和svg性能方面选择 meta标签和viewportmeta标签是HTML中头部的一个辅助性标签，它位于HTML文档头部的 和&lt;title&gt;标记之间，常用于定义页面的说明，关键字，最后修改日期，和其它的元数据。这些元数据将服务于浏览器（如何布局或重载页面），搜索引擎和其它网络服务。meta虽对用户不可见，但是它的用处非常大，设置合适的meta标签可以很大程度上提高网站页面的可用性。 根据meta标签属性不同，可以分为两大类：http-equiv和name。 http-equiv：顾名思义，equivalent，相当于，就是相当于http协议中文件头的作用，它可以向浏览器传回一些有用的信息，以帮助正确和精确地显示网页内容，与之对应的属性值为content，content中的内容其实就是各个参数的变量值。meta标签中http-equiv属性语法格式是：&lt;meta http-equiv=&quot;参数&quot; content=&quot;具体的描述&quot;&gt;。其中，http-equiv属性主要有以下参数： content-Type(显示字符集的设定)：说明，设定页面使用的字符集，推荐使用HTML5的方式；用法，＜meta http-equiv=&quot;content-Type&quot; content=&quot;text/html; charset=utf-8&quot;＞。 X-UA-Compatible(浏览器采用何种版本渲染当前页面)：说明，用于告知浏览器用何种版本渲染页面，一般设置为最新模式；用法，&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt; //指定IE和Chrome使用最新版本渲染当前页面。 cache-control(指定请求和响应遵循的缓存机制)： 用法1说明，指导浏览器如何缓存某个响应以及缓存多长时间；用法，&lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot;&gt;。一共有以下几种用法：1.no-cache，先发送请求，与服务器确认该资源是否被更改，如果未被更改，则使用缓存。2.no-store，不允许缓存，每次都要去服务器下载完整的缓存，这也是基于安全考虑。3.public，缓存所有响应，但并非必须。因为max-age也可以做到相同效果。4.private，只为单个用户缓存，因此不允许任何中继进行缓存。（CDN）5.maxage，表示当前请求开始，该响应在多久内能被缓存和重用，而不去服务器重新请求。例如：max-age=60表示响应可以再缓存和重用 60 秒。 用法2(禁止百度自动转码)说明，用于禁止当前页面在移动端浏览时，被百度自动转码。所以可以在head中加入例子中的那句话，就可以避免百度自动转码了。&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-siteapp&quot;&gt;。 expires(网页到期时间)：说明，用于设定网页的到期时间，过期后网页必须重新到服务器上传输；用法，&lt;meta http-equiv=&quot;expires&quot; content=&quot;Sunday 26 October 2016 01:00 GMT&quot; /&gt;。 refresh(自动刷新并指向某页面)：说明，自动刷新并指向新页面；用法，&lt;meta http-equiv=&quot;Refresh content=&quot;2; URL=http://www.root.net&quot;&gt;。 Set-Cookie(cookie设定)：说明，设置cookie，如果网页过期，那么存在网页的cookie也将会被删除；用法，＜meta http-equiv=&quot;Set-Cookie&quot; content=&quot;cookievalue=xxx; expires=Friday, 12-Jan-2001 18:18:18 GMT； path=/&quot;＞// 必须使用GMT的时间格式。 Pragma(cache模式)：说明，禁止从浏览器从本地计算机的缓存中访问页面内容；用法，＜meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot;＞。 name：主要用于描述网页，比如网页的关键词，叙述等。与之对应的属性值为content，content中的内容是对name填入类型的具体描述，便于搜索引擎抓取。meta标签中name属性语法格式是&lt;meta name=&quot;参数&quot; content=&quot;具体的描述&quot;&gt;。其中，name主要有以下参数： keyword(关键字)：说明，用于告诉搜索引擎，网页的关键字；用法，&lt;meta name=&quot;keywords&quot; content=&quot;博客，前端&quot;&gt;。 description(网站内容的描述)：说明，用于告诉搜索引擎，网站的主要内容；用法，&lt;meta name=&quot;description&quot; content=&quot;热爱前端与编程&quot;&gt;。 viewport(移动端的窗口)：说明，这个属性常用于设计移动端网页；用法，&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;。 robots(定义搜索引擎爬虫的索引方式)：说明，robots用于告诉爬虫哪些页面需要索引，哪些页面不需要索引。content的参数有all（搜索引擎将索引此网页与继续通过此网页的链接索引，等价于index，follow）、none（ 搜索引擎将忽略此网页，等价于noindex，nofollow）、index（搜索引擎索引此网页）、noindex（搜索引擎不索引此网页）、follow（搜索引擎继续通过此网页的链接索引搜索其它的网页）、nofollow（ 搜索引擎不继续通过此网页的链接索引搜索其它的网页）。默认是all；用法，&lt;meta name=&quot;robots&quot; content=&quot;none&quot;&gt;。 author(作者)：说明，标注网页的作者；用法，＜meta name=&quot;author&quot; content = &quot;root,root@21cn.com&quot;＞。 其中viewport有以下属性： 1234567&lt;meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no" /&gt;// width 设置viewport宽度，为一个正整数，或字符串`device-width`// height 设置viewport高度正整数或者`device-height`，一般设置了宽度，会自动解析出高度，可以不用设置// initial-scale 默认缩放比例（初始缩放比例），为一个数字，可以带小数// minimum-scale 允许用户最小缩放比例，为一个数字，可以带小数// maximum-scale 允许用户最大缩放比例，为一个数字，可以带小数// user-scalable 是否允许手动缩放 data - xxx 属性的作用是什么HTML5规范里增加了一个自定义data属性，可以往HTML里面添加任意以 data-开头的属性, 这些属性页面上是不显示的，它不会影响到你的页面布局和风格，但它却是可读可写的。存储的（自定义）数据能够被页面的 JavaScript 中利用，以创建更好的用户体验（不进行 Ajax 调用或服务器端数据库查询）。组成：属性名不应该包含任何大写字母，并且在前缀data-之后必须有至少一个字符。属性值可以是任意字符串。 JavaScript访问 在外部使用JavaScript去访问这些属性的值同样非常简单。你可以使用getAttribute()配合它们完整的HTML名称去读取它们，但标准定义了一个更简单的方法：DOMStringMap你可以使用dataset读取到数据。 为了使用dataset对象去获取到数据属性，需要获取属性名中data-之后的部分(要注意的是破折号连接的名称需要改写为骆驼拼写法(如”index-number”转换为”indexNumber”))。 CSS访问 通过generated content使用函数attr()来显示data-parent的内容： 123article::before &#123; content: attr(data-parent);&#125; 你也同样可以在CSS中使用属性选择器根据data来改变样式： 123456article[data-columns='3'] &#123; width: 400px;&#125;article[data-columns='4'] &#123; width: 600px;&#125; CSSCSS盒子模型盒模型又称框模型（Box Model）,包含了元素内容（content）、内边距（padding）、边框（border）、外边距（margin）几个要素。如图： 盒模型分为IE模型和标准模型。 标准模型元素宽度width=content，高度计算相同： IE模型元素宽度width=content+padding+border，高度计算相同： 通过css3新增的属性 box-sizing: content-box | border-box分别设置盒模型为标准模型（content-box）和IE模型（border-box）。 通过 box-sizing: content-box | border-box属性可以更好的控制元素的大小，比如增加padding时仍然可以控制元素大小，防止元素增大对布局产生影响。 在JavaScript中，通过document.compatMode可以知道当前采用了什么模式，值为BackCompat 表示怪异模式，CSS1Compat 表示标准模式。 CSS优先级内联样式 &gt; ID选择器 &gt; 类选择器 = 属性选择器 = 伪类 &gt; 类型选择器 = 伪元素 &gt; 通用选择器* &gt; 继承的样式 link和@import的区别 link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。 link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。 link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。 link支持使用JavaScript控制DOM去改变样式；而@import不支持。 负margin 当static元素的margin-top/margin-left被赋予负值时，元素将被拉进指定的方向。 但如果你设置margin-bottom/right为负数，元素并不会如你所想的那样向下/右移动，而是将后续的元素拖拉进来，覆盖本来的元素。 如果没有设定width属性，设定负margin-left/right会将元素拖向对应的方向，并增加宽度，此时的margin的作用就像padding一样。 参考文章： 负margin用法权威指南 深入理解CSS中的margin负值 布局（以三栏布局为例） 自身浮动 注意DOM文档的书写顺序，先写两个侧边栏，再写main，更换后则侧栏会被挤到下一列，这种布局方式比较简单明了，但缺点是渲染时先渲染了侧边栏，而不是比较重要的主面板。 123456789101112131415161718192021&lt;style&gt; .sub&#123; width: 100px; float: left; background: #00abff; &#125; .extra&#123; width: 200px; float: right; background: red; &#125; .main&#123; margin-left: 100px; margin-right: 200px; background: pink; &#125;&lt;/style&gt;&lt;div class="sub"&gt;sub&lt;/div&gt;&lt;div class="extra"&gt;extra&lt;/div&gt;&lt;div class="main"&gt;main&lt;/div&gt; 绝对定位法 本方法不限制DOM书写顺序，先写主面板会使主面板部分优先渲染。如果中间栏含有最小宽度限制，或是含有宽度的内部元素，则浏览器窗口小到一定程度，主面板与侧栏会发生重叠。 12345678910111213141516171819202122&lt;style&gt; .sub, .extra &#123; position: absolute; top: 0; width: 200px; &#125; .sub &#123; left: 0; background: red; &#125; .extra &#123; right: 0; background: #00abff; &#125; .main &#123; margin: 0 200px; background: pink; &#125;&lt;/style&gt;&lt;div class="sub"&gt;left&lt;/div&gt;&lt;div class="main"&gt;main&lt;/div&gt;&lt;div class="extra"&gt;right&lt;/div&gt; margin负值法 圣杯布局 主面板设置宽度为100%，主面板与两个侧栏都设置浮动，常见为左浮动，这时两个侧栏会被主面板挤下去。通过负边距将浮动的侧栏拉上来，左侧栏的负边距为100%，刚好是窗口的宽度，因此会从主面板下面的左边跑到与主面板对齐的左边，右侧栏此时浮动在主面板下面的左边，设置负边距为负的自身宽度刚好浮动到主面板对齐的右边。为了避免侧栏遮挡主面板内容，在外层设置左右padding值为左右侧栏的宽度，给侧栏腾出空间，此时主面板的宽度减小。由于侧栏的负margin都是相对主面板的，两个侧栏并不会像我们理想中的停靠在左右两边，而是跟着缩小的主面板一起向中间靠拢。此时使用相对布局，调整两个侧栏到相应的位置。 在这种写法中DOM元素的书写顺序不得更改；主面板部分优先渲染（一般主面板会比侧栏内容重要）；当面板的main内容部分比两边的子面板宽度小的时候，布局就会乱掉。可以通过设置main的min-width属性或使用双飞翼布局避免问题。 1234567891011121314151617181920212223242526272829303132&lt;style&gt; .main &#123; float: left; width: 100%; min-width: 400px; background: #00abff; &#125; .sub &#123; float: left; width: 190px; margin-left: -100%; position: relative; left: -190px; background: red; &#125; .extra &#123; float: left; width: 230px; margin-left: -230px; position: relative; right: -230px; background: pink; &#125; #bd &#123; padding: 0 230px 0 190px; &#125;&lt;/style&gt;&lt;div id="bd"&gt; &lt;div class="main"&gt;main&lt;/div&gt; &lt;div class="sub"&gt;sub&lt;/div&gt; &lt;div class="extra"&gt;extra&lt;/div&gt;&lt;/div&gt; 双飞翼布局 双飞翼布局在圣杯布局上做了改进，在main元素上加了一层div, 并设置margin,由于两侧栏的负边距都是相对于main-wrap而言，main的margin值变化便不会影响两个侧栏，因此省掉了对两侧栏设置相对布局的步骤。 在这种写法中，主面板部分优先渲染（一般主面板会比侧栏内容重要）；圣杯采用的是padding，而双飞翼采用的margin，解决了圣杯布局main的最小宽度不能小于左侧栏的缺点；双飞翼布局不用设置相对布局，以及对应的left和right值；通过引入相对布局，可以实现三栏布局的各种组合，例如对右侧栏设置position: relative; left: 190px;,可以实现sub+extra+main的布局。 123456789101112131415161718192021222324252627&lt;style&gt; .main-wrap &#123; float: left; width: 100%; background: #00abff; &#125; .sub &#123; float: left; width: 190px; margin-left: -100%; background: red; &#125; .extra &#123; float: left; width: 230px; margin-left: -230px; background: pink; &#125; .main &#123; margin: 0 230px 0 190px; &#125;&lt;/style&gt;&lt;div class="main-wrap"&gt; &lt;div class="main"&gt;main&lt;/div&gt;&lt;/div&gt;&lt;div class="sub"&gt;sub&lt;/div&gt;&lt;div class="extra"&gt;extra&lt;/div&gt; flex 12345678910111213141516171819202122232425262728293031323334&lt;style&gt; .layout &#123; display: flex; &#125; .main &#123; flex: 1; &#125; .aside &#123; width: 200px; &#125;&lt;/style&gt;&lt;div class="layout"&gt; &lt;aside class="aside"&gt;侧边栏宽度固定&lt;/aside&gt; &lt;div class="main"&gt;主内容栏宽度自适应&lt;/div&gt;&lt;/div&gt;&lt;div class="layout"&gt; &lt;div class="main"&gt;主内容栏宽度自适应&lt;/div&gt; &lt;aside class="aside"&gt;侧边栏宽度固定&lt;/aside&gt;&lt;/div&gt;&lt;div class="layout"&gt; &lt;aside class="aside"&gt;左侧边栏宽度固定&lt;/aside&gt; &lt;div class="main"&gt;主内容栏宽度自适应&lt;/div&gt; &lt;aside class="aside"&gt;右侧边栏宽度固定&lt;/aside&gt;&lt;/div&gt;&lt;div class="layout"&gt; &lt;aside class="aside"&gt;第1个侧边栏宽度固定&lt;/aside&gt; &lt;aside class="aside"&gt;第2个侧边栏宽度固定&lt;/aside&gt; &lt;div class="main"&gt;主内容栏宽度自适应&lt;/div&gt;&lt;/div&gt;&lt;div class="layout"&gt; &lt;div class="main"&gt;主内容栏宽度自适应&lt;/div&gt; &lt;aside class="aside"&gt;第1个侧边栏宽度固定&lt;/aside&gt; &lt;aside class="aside"&gt;第2个侧边栏宽度固定&lt;/aside&gt;&lt;/div&gt; 参考文章： CSS布局十八般武艺都在这里了 我熟知的三种三栏网页宽度自适应布局方法 垂直居中 单行文本 123456789101112&lt;style&gt; .common &#123; background: #00abff; &#125; #demo1 &#123; height: 100px; line-height: 100px; &#125;&lt;/style&gt;&lt;div id="demo1" class="common"&gt; demo 1&lt;/div&gt; 元素高度不固定（在这里是子元素高度不固定） vertical-align vertical-align 只对 table-cell 以及 inline-element 起作用，对于块级元素不起作用，vertical-align 的值是相对于其父元素的，父元素必须是行内元素。 1234567891011121314151617&lt;style&gt; .common &#123; background: #00abff; &#125; #demo2 &#123; display: table; height: 100px; margin-top: 10px; &#125; #demo2 span &#123; display: table-cell; vertical-align: middle; &#125;&lt;/style&gt;&lt;div id="demo2" class="common"&gt; &lt;span&gt;demo 2&lt;/span&gt;&lt;/div&gt; flex 1234567891011121314&lt;style&gt; .common &#123; background: #00abff; &#125; #demo3 &#123; display: flex; align-items: center; height: 100px; margin-top: 10px; &#125;&lt;/style&gt;&lt;div id="demo3" class="common"&gt; &lt;div&gt;demo3&lt;/div&gt;&lt;/div&gt; transform 123456789101112131415161718&lt;style&gt; .common &#123; background: #00abff; &#125; #demo4 &#123; position: relative; height: 100px; margin-top: 10px; &#125; #demo4 div &#123; position: absolute; top: 50%; transform: translate(0, -50%); &#125;&lt;/style&gt;&lt;div id="demo4" class="common"&gt; &lt;div&gt;demo 4&lt;/div&gt;&lt;/div&gt; 元素高度固定（在这里是子元素高度固定） absolute + calc 12345678910111213141516171819&lt;style&gt; .common &#123; background: #00abff; &#125; #demo5 &#123; position: relative; height: 100px; margin-top: 10px; &#125; #demo5 div &#123; position: absolute; height: 50px; top: calc(50% - 25px ); /*减去子元素高度的一半*/ background: white; &#125;&lt;/style&gt;&lt;div id="demo5" class="common"&gt; &lt;div&gt;demo 5&lt;/div&gt;&lt;/div&gt; absolute + margin-top 12345678910111213141516171819&lt;style&gt; .common &#123; background: #00abff; &#125; #demo6 &#123; position: relative; height: 100px; margin-top: 10px; &#125; #demo6 div &#123; position: absolute; height: 50px; margin-top: 25px; /*减去子元素高度的一半*/ background: white; &#125;&lt;/style&gt;&lt;div id="demo6" class="common"&gt; &lt;div&gt;demo 6&lt;/div&gt;&lt;/div&gt; 水平居中 行内元素 给其父元素设置 text-align:center ，即可实现行内元素水平居中。 12345678&lt;style&gt; #demo1 &#123; text-align: center; &#125;&lt;/style&gt;&lt;div id="demo1"&gt; &lt;span&gt;hello world&lt;/span&gt;&lt;/div&gt; 块级元素 定宽元素 margin: 0 auto 1234567891011121314&lt;style&gt; .common &#123; background: #00abff; &#125; #demo2 &#123; width: 100px; margin: 0 auto; &#125;&lt;/style&gt;&lt;div id="demo2" class="common"&gt; demo 2&lt;/div&gt; absolute + 负margin 1234567891011121314&lt;style&gt; .common &#123; background: #00abff; &#125; #demo3 &#123; width: 100px; position: absolute; left: 50%; margin-left: calc( -0.5 * 100px ); /*-0.5*宽度*/ &#125;&lt;/style&gt;&lt;div id="demo3" class="common"&gt; demo 3&lt;/div&gt; absolute + margin: auto 123456789101112131415&lt;style&gt; .common &#123; background: #00abff; &#125; #demo4 &#123; position: absolute; left: 0; right: 0; width: 100px; margin: auto; &#125;&lt;/style&gt;&lt;div id="demo4" class="common"&gt; demo 4&lt;/div&gt; 不定宽元素 flex 12345678910111213&lt;style&gt; .common &#123; background: #00abff; &#125; #demo5 &#123; display: flex; width: 100%; justify-content: center; &#125;&lt;/style&gt;&lt;div id="demo5"&gt; &lt;p class="common"&gt;demo 5&lt;/p&gt;&lt;/div&gt; transform 12345678910111213&lt;style&gt; .common &#123; background: #00abff; &#125; #demo6 &#123; position: absolute; left: 50%; transform: translate(-50%); &#125;&lt;/style&gt;&lt;div id="demo6" class="common"&gt; demo 6&lt;/div&gt; grid + justify-content 12345678910111213&lt;style&gt; .common &#123; background: #00abff; &#125; #demo7 &#123; display: grid; width: 100%; justify-content: center; &#125;&lt;/style&gt;&lt;div id="demo7"&gt; &lt;p class="common"&gt;demo 7&lt;/p&gt;&lt;/div&gt; grid + justify-slef 123456789101112131415&lt;style&gt; .common &#123; background: #00abff; &#125; #demo8 &#123; display: grid; width: 100% &#125; #demo8 .common &#123; justify-self:center; &#125;&lt;/style&gt;&lt;div id="demo8"&gt; &lt;p class="common"&gt;demo 8&lt;/p&gt;&lt;/div&gt; 扩展阅读： CSS实现水平垂直居中的1010种方式 16种方法实现水平居中垂直居中 CSS画圆、三角形和梯形圆：宽高相等，border的圆角是宽高的一半。 123456.circle &#123; width: 100px; height: 100px; border-radius: 50%; background: #00abff;&#125; 三角形：每条border实际上是梯形的，所以当宽高为0时，border设为固定宽度时，实际上是一个由四个三角形拼成的，以border宽度为长度的正方形，此时要变成三角形，只要把其他三边设置为透明即可。 123456.triangle &#123; width: 0; height: 0; border: 50px solid transparent; border-bottom: 100px solid #00abff;&#125; 梯形：因为border实际上是梯形的，只要有固定宽度，高度为0即可，当然其他三边也要变成透明。 123456#trapezoid &#123; width: 50px; height: 0; border: 50px solid transparent; border-bottom: 100px solid #00abff;&#125; 扩展阅读： CSS画三角形原理 纯CSS画的基本图形（矩形、圆形、三角形、多边形、爱心、八卦等） 自适应16：9的矩形用padding占位： 123456789101112131415161718&lt;style type="text/css"&gt; .b169 &#123; width: 100%; height: 0; padding-bottom: 56.2%; position: relative; &#125; .b169&gt;.innerb169 &#123; width: 100%; height: 100%; background-color: gainsboro; position: absolute; &#125;&lt;/style&gt;&lt;div class="b169"&gt; &lt;div class="innerb169"&gt;your html&lt;/div&gt;&lt;/div&gt; flex布局容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 容器属性 flex-direction：决定主轴的方向（即项目的排列方向）。 flex-wrap：默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 flex-flow：是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 justify-content：定义了项目在主轴上的对齐方式。 align-items：定义项目在交叉轴上如何对齐。 align-content：定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 项目属性 order：定义项目的排列顺序。数值越小，排列越靠前，默认为0。 flex-grow：定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 flex-shrink：定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 flex-basis：定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 flex：是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 align-self：允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 Flex 布局教程：语法篇 Flex 布局教程：实例篇 清除浮动当父级元素中的子元素全部浮动后，会导致父元素的高度坍塌，从而影响父元素的布局，所以需要通过清除浮动将父元素的高度撑起来。 1234567891011121314151617181920212223242526272829&lt;style&gt; .topDiv &#123; width: 500px; border: 2px solid black; &#125; .floatDiv &#123; width: 100px; height: 100px; border: 2px dotted red; color: red; margin: 4px; float: left; &#125; .bottomDiv &#123; width: 500px; height: 100px; margin: 5px 0; border: 2px dotted black; &#125; .textDiv &#123; color: blue; border: 2px solid blue; &#125;&lt;/style&gt;&lt;div class="topDiv"&gt; &lt;div class="textDiv"&gt;...&lt;/div&gt; &lt;div class="floatDiv"&gt;float left&lt;/div&gt;&lt;/div&gt;&lt;div class="bottomDiv"&gt;...&lt;/div&gt; clear 在浮动元素的父级元素末尾插入了一个没有内容的块级元素，并且定义他们的clear的样式。 12345678910111213141516171819202122232425262728293031323334&lt;style&gt; .topDiv &#123; width: 500px; border: 2px solid black; &#125; .floatDiv &#123; width: 100px; height: 100px; border: 2px dotted red; color: red; margin: 4px; float: left; &#125; .bottomDiv &#123; width: 500px; height: 100px; margin: 5px 0; border: 2px dotted black; &#125; .textDiv &#123; color: blue; border: 2px solid blue; clear: left; &#125; .blankDiv &#123; clear: both; /* or left */ &#125;&lt;/style&gt;&lt;div class="topDiv"&gt; &lt;div class="textDiv"&gt;...&lt;/div&gt; &lt;div class="floatDiv"&gt;float left&lt;/div&gt; &lt;div class="blankDiv"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class="bottomDiv"&gt;...&lt;/div&gt; 伪元素 1234567891011121314151617181920212223242526272829303132333435&lt;style&gt; .topDiv &#123; width: 500px; border: 2px solid black; &#125; .floatDiv &#123; width: 100px; height: 100px; border: 2px dotted red; color: red; margin: 4px; float: left; &#125; .bottomDiv &#123; width: 500px; height: 100px; margin: 5px 0; border: 2px dotted black; &#125; .textDiv &#123; color: blue; border: 2px solid blue; &#125; .clearfix:after &#123; content: ''; height: 0; display: block; clear: both; &#125;&lt;/style&gt;&lt;div class="topDiv clearfix"&gt; &lt;div class="textDiv"&gt;...&lt;/div&gt; &lt;div class="floatDiv"&gt;float left&lt;/div&gt;&lt;/div&gt;&lt;div class="bottomDiv"&gt;...&lt;/div&gt; overflow 在父级元素上添加了一个值为auto的overflow属性，构件了一个BFC（块格式化上下文），从而父元素的高度立即被撑起，将浮动元素包裹在内。在这里overflow可以是除visible外任何有效值，不过overflow: auto;对SEO友好一点。 123456789101112131415161718192021222324252627282930&lt;style&gt; .topDiv &#123; width: 500px; border: 2px solid black; overflow: auto; &#125; .floatDiv &#123; width: 100px; height: 100px; border: 2px dotted red; color: red; margin: 4px; float: left; &#125; .bottomDiv &#123; width: 500px; height: 100px; margin: 5px 0; border: 2px dotted black; &#125; .textDiv &#123; color: blue; border: 2px solid blue; &#125;&lt;/style&gt;&lt;div class="topDiv"&gt; &lt;div class="textDiv"&gt;...&lt;/div&gt; &lt;div class="floatDiv"&gt;float left&lt;/div&gt;&lt;/div&gt;&lt;div class="bottomDiv"&gt;...&lt;/div&gt; 扩展阅读： 清除浮动的四种方式及其原理理解 BFC浮动元素和绝对定位元素，非块级盒子的块级容器（例如inline-blocks, table-cells, 和 table-captions），以及overflow值不为visiable的块级盒子，都会为他们的内容创建新的BFC（块级格式上下文）。 BFC中的元素的布局是不受外界的影响（我们往往利用这个特性来消除浮动元素对其非浮动的兄弟元素和其子元素带来的影响。）并且在一个BFC中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列。 满足下列条件之一就可以触发BFC： 根元素，即HTML元素 float的值不为none overflow的值不为visible display的值为inline-block、table-cell、table-caption position的值为absolute或fixed BFC布局规则： 内部的Box会在垂直方向，一个接一个地放置。 Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠。 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 BFC的区域不会与float box重叠。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 计算BFC的高度时，浮动元素也参与计算。 BFC的作用： 解决margin叠加问题 123456789101112&lt;style&gt; .common &#123; color:black; background: #FF0000; width: 200px; line-height: 100px; text-align:center; margin: 50px; &#125;&lt;/style&gt;&lt;div class="common"&gt;...&lt;/div&gt;&lt;div class="common"&gt;...&lt;/div&gt; 上面两个div元素发生了外边距折叠，两个div之间的margin是50px而不是100px，如果想让两个元素之间是100px，可以新建一个BFC： 1234567891011121314151617&lt;style&gt; .common &#123; color:black; background: #FF0000; width: 200px; line-height: 100px; text-align:center; margin: 50px; &#125; .bfc &#123; overflow: hidden; &#125;&lt;/style&gt;&lt;div class="bfc"&gt; &lt;div class="common"&gt;...&lt;/div&gt;&lt;/div&gt;&lt;div class="common"&gt;...&lt;/div&gt; 用于布局 下面代码中aside创建了一个BFC，由于BFC的左外边距会触碰到包含块容器的左外边框，即使存在浮动也是如此，所以main和aside的左外边距都会触碰到包含块容器的左外边框。 1234567891011121314&lt;style&gt; .aside &#123; width: 100px; height: 150px; float: left; background: blue; &#125; .main &#123; height: 200px; background: #f00; &#125;&lt;/style&gt;&lt;div class="aside"&gt;&lt;/div&gt;&lt;div class="main"&gt;&lt;/div&gt; 要解决这个问题，可以给main创建一个BFC，这样利用BFC的区域不会与float box重叠的特性完成一个两栏布局： 12345678910111213141516&lt;style&gt; .aside &#123; width: 100px; height: 150px; float: left; background: blue; &#125; .main &#123; height: 200px; background: #f00; overflow: hidden; &#125;&lt;/style&gt;&lt;div class="aside"&gt;&lt;/div&gt;&lt;div class="main"&gt;&lt;/div&gt; 清除浮动 清除浮动有一个方法是添加overflow属性，这就是利用BFC的计算高度包括浮动元素的特性。 扩展阅读： 深入理解BFC 深入理解BFC和Margin Collapse CSS之BFC详解 CSS外边距合并（margin collapsing）块级元素的上外边距（margin-top）和下外边距（margin-bottom）有时会合并（或折叠）为一个外边距，其大小取其中的最大者，这种行为称为外边距折叠（margin collapsing）。 下面列出了会发生外边距折叠的三种基本情况： 相邻元素之间 毗邻的两个元素之间的外边距会折叠（除非后一个元素需要清除之前的浮动）。 父元素与其第一个或最后一个子元素之间如果在父元素与其第一个子元素之间不存在边框、内边距、行内内容，也没有创建块格式化上下文、或者清除浮动将两者的 margin-top 分开；或者在父元素与其最后一个子元素之间不存在边框、内边距、行内内容、height、min-height、max-height将两者的 margin-bottom 分开，那么这两对外边距之间会产生折叠。此时子元素的外边距会“溢出”到父元素的外面。 空的块级元素如果一个块级元素中不包含任何内容，并且在其 margin-top 与 margin-bottom 之间没有边框、内边距、行内内容、height、min-height 将两者分开，则该元素的上下外边距会折叠。 一些需要注意的地方： 上述情况的组合会产生更复杂的外边距折叠。 即使某一外边距为0，这些规则仍然适用。因此就算父元素的外边距是0，第一个或最后一个子元素的外边距仍然会“溢出”到父元素的外面。 如果参与折叠的外边距中包含负值，折叠后的外边距的值为最大的正边距与最小的负边距（即绝对值最大的负边距）的和。 如果所有参与折叠的外边距都为负，折叠后的外边距的值为最小的负边距的值。这一规则适用于相邻元素和嵌套元素。 如何避免： 浮动元素不会与任何元素发生叠加，也包括它的子元素 创建了 BFC 的元素不会和它的子元素发生外边距叠加 绝对定位元素和其他任何元素之间不发生外边距叠加，也包括它的子元素 inline-block 元素和其他任何元素之间不发生外边距叠加，也包括它的子元素 普通流中的块级元素的 margin-bottom 永远和它相邻的下一个块级元素的 margin-top 叠加，除非相邻的兄弟元素 clear 普通流中的块级元素（没有 border-top、没有 padding-top）的 margin-top 和它的第一个普通流中的子元素（没有clear）发生 margin-top 叠加 普通流中的块级元素（height为 auto、min-height为0、没有 border-bottom、没有 padding-bottom）和它的最后一个普通流中的子元素（没有自身发生margin叠加或clear）发生 margin-bottom叠加 如果一个元素的 min-height 为0、没有 border、没有padding、高度为0或者auto、不包含子元素，那么它自身的外边距会发生叠加 参考文章： 深度剖析Margin塌陷，BFC，Containing Block之间的关系 外边距合并 inline-block、BFC、边距合并 深入理解CSS外边距折叠（Margin Collapse） 移动端适配物理像素(physical pixel) 物理像素又被称为设备像素，他是显示设备中一个最微小的物理部件。每个像素可以根据操作系统设置自己的颜色和亮度。正是这些设备像素的微小距离欺骗了我们肉眼看到的图像效果。 设备独立像素(density-independent pixel) 设备独立像素也称为密度无关像素，可以认为是计算机坐标系统中的一个点，这个点代表一个可以由程序使用的虚拟像素(比如说CSS像素)，然后由相关系统转换为物理像素。 CSS像素 CSS像素是一个抽像的单位，主要使用在浏览器上，用来精确度量Web页面上的内容。一般情况之下，CSS像素称为与设备无关的像素(device-independent pixel)，简称DIPs。 屏幕密度 屏幕密度是指一个设备表面上存在的像素数量，它通常以每英寸有多少像素来计算(PPI)。 设备像素比(device pixel ratio) 设备像素比简称为dpr，其定义了物理像素和设备独立像素的对应关系。它的值可以按下面的公式计算得到： 1设备像素比 ＝ 物理像素 / 设备独立像素 在JavaScript中，可以通过window.devicePixelRatio获取到当前设备的dpr。而在CSS中，可以通过-webkit-device-pixel-ratio，-webkit-min-device-pixel-ratio和 -webkit-max-device-pixel-ratio进行媒体查询，对不同dpr的设备，做一些样式适配(这里只针对webkit内核的浏览器和webview)。 dip或dp,（device independent pixels，设备独立像素）与屏幕密度有关。dip可以用来辅助区分视网膜设备还是非视网膜设备。 在不同的屏幕上，CSS像素所呈现的物理尺寸是一致的，而不同的是CSS像素所对应的物理像素具数是不一致的。在普通屏幕下1个CSS像素对应1个物理像素，而在Retina屏幕下，1个CSS像素对应的却是4个物理像素。 viewport Flexible通过JS来动态改写meta标签： 动态改写&lt;meta&gt;标签 给&lt;html&gt;元素添加data-dpr属性，并且动态改写data-dpr的值 给&lt;html&gt;元素添加font-size属性，并且动态改写font-size的值 其他尺寸通过下面scss函数将px转化为rem： 123456789@function px2em($px, $base-font-size: 16px) &#123; @if (unitless($px)) &#123; @warn "Assuming #&#123;$px&#125; to be in pixels, attempting to convert it into pixels for you"; @return px2em($px + 0px); // That may fail. &#125; @else if (unit($px) == em) &#123; @return $px; &#125; @return ($px / $base-font-size) * 1em;&#125; 文字不建议用rem，因为我们不希望文本在Retina屏幕下变小，另外，我们希望在大屏手机上看到更多文本。可以用这样一个mixin来解决文字字号大小问题： 1234567891011@mixin font-dpr($font-size)&#123; font-size: $font-size; [data-dpr="2"] &amp; &#123; font-size: $font-size * 2; &#125; [data-dpr="3"] &amp; &#123; font-size: $font-size * 3; &#125;&#125; vm配合rem 1&lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243// 页面适配// 所有单位均需采用rem(视觉图的像素值)方法计算相应的虚拟像素值$vm_design: 360; // 根据需要替换成设计稿的值,比如设计稿的宽度是360px$vm_fontsize: $vm_design / 10; // 是$vm_design的十分之一@function rem($px) &#123; @return ($px / $vm_fontsize) * 1rem;&#125;// 页面适配// 根元素大小使用vw单位html &#123; font-size: ($vm_fontsize / $vm_design) * 100vw; // 同时通过Media Queries 限制根元素最大最小值 @media screen and (max-width: 320px) &#123; font-size: 32px; &#125; @media screen and (min-width: 540px) &#123; font-size: 54px; &#125;&#125;// body 也增加最大最小宽度限制,避免默认100%宽度的 block 元素跟随 body 而过大过小body &#123; max-width: 540px; min-width: 320px;&#125;html &#123; width: 100%; height: 100%; margin: 0; padding: 0; -webkit-text-size-adjust: 100%; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); background: transparent; box-sizing: border-box;&#125;body &#123; width: 100%; height: 100%; -webkit-overflow-scrolling: touch;&#125; 参考文章： 使用Flexible实现手淘H5页面的终端适配 再聊移动端页面的适配 如何在Vue项目中使用vw实现移动端适配 JavaScriptJavaScript的数据类型6种简单数据类型（也称为基本数据类型）：Undefined、Null、Boolean、Number、String、Symbol 1种复杂数据类型： Object null被认为是一个空对象的引用，使用typeOf操作符会返回Object，所以类型判断时通常用Object.prototype.toString.call()去判断，比如: Object.prototype.toString.call(&#39;1&#39;) === &quot;[object String]&quot; == 和 === 的区别==操作符会先进行类型转换再进行比较，类型转换按照一下规则进行： 如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值（false转换成0，true转换成1） 如果一个操作数是字符串，另一个操作数是数值，在比较前先将字符串转换为数值 如果是对象，调用对象的valueOf()方法得到基本类型后按第一条规则再进行比较 null和undefined相等（undefined值派生自null值） 两个都是对象，比较它们是不是指向同一个对象 两边有一个是NaN，==返回false，!=返回true（Nan不等于NaN） ===操作符在比较前不会进行类型转换，是严格相等，注意undefined === null 返回false。 附上Number()函数的转换规则如下： 如果是Boolean值，true和false将分别被转换为1和0 如果是数字值，只是简单的传入和返回 如果是null，返回0 如果是undefined，返回NaN 如果是字符串，遵循下列规则 如果字符串只包含数字，则将其转换成十进制数值 如果字符串中包含有效的浮点格式，则将其转换成对应的浮点数值 如果字符串中包含有效的十六进制格式，则将其转换成相同大小的十进制整数 如果字符串是空，则将其转换成0 如果字符串中包含除上述格式之外的字符串，则将其转换成NaN。 如果是对象，则调用对象的valueof()方法，然后依照前面的规则转换成返回值。如果返回值是NaN，则调用对象的toString()方法，然后再次依照前面的规则转换返回的字符串值。 只有当加法运算时，其中一方是字符串类型，就会把另一个也转为字符串类型。其他运算只要其中一方是数字，那么另一方就转为数字。并且加法运算会触发三种类型转换：将值转换为原始值，转换为数字，转换为字符串。 Object.is(value1, value2) 也是判断两个值是否相同；如果下列任何一项成立，则两个值相同： 两个值都是 undefined 两个值都是 null 两个值都是 true 或者都是 false 两个值是由相同个数的字符按照相同的顺序组成的字符串 两个值指向同一个对象 两个值都是数字并且 都是正零 +0 都是负零 -0 都是 NaN 都是除零和 NaN 外的其它同一个数字这种相等性判断逻辑和传统的 == 运算不同，== 运算符会对它两边的操作数做隐式类型转换（如果它们类型不同），然后才进行相等性比较，（所以才会有类似 “” == false 为 true 的现象），但 Object.is 不会做这种类型转换。这与===运算符也不一样。===运算符（和==运算符）将数字值-0和+0视为相等，并认为Number.NaN不等于NaN。 对象转基本类型对象在转换基本类型时，首先会调用 valueOf 然后调用 toString。并且这两个方法你是可以重写的。当然你也可以重写 Symbol.toPrimitive ，该方法在转基本类型时调用优先级最高。 12345678910111213let a = &#123; valueOf() &#123; return 0; &#125;, toString() &#123; return '1'; &#125;, [Symbol.toPrimitive]() &#123; return 2; &#125;&#125;1 + a // =&gt; 3'1' + a // =&gt; '12' BOM是什么，有哪些BOM对象BOM（Browser Object Model）是浏览器对象模型的缩写，它提供了独立于内容而与浏览器窗口进行交互的对象，并且每个对象都提供了很多方法与属性。 BOM对象包括：window对象、location对象、navigation对象、screen对象和history对象。 创建对象的几种方法 字面量 123var o = &#123; name: 'tc9011',&#125;; 构造函数 1var o1 = new Object(&#123;name: 'tc9011'&#125;); 123456789function Human(firstName, lastName) &#123; this.firstName = firstName; this.lastName = lastName; this.fullName = function () &#123; return this.firstName + ' ' + this.lastName; &#125;;&#125;var tc = new Human('t', 'c'); Object.create 12345const person = &#123; isHuman: true,&#125;;const me = Object.create(person); 工厂模式 123456789101112131415function createPerson(name, age, job)&#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function ()&#123; console.log(this.name); &#125;; return o;&#125;var person1 = createPerson('tc',27,'SE');var person2 = createPerson('zj',23,'Designer');console.log(person1.name); // tcconsole.log(person2.name); // zj 原型模式 1234567891011function Human() &#123;&#125;Human.prototype.firstName = 't';Human.prototype.lastName = 'c';Human.prototype.fullName = function () &#123; return this.firstName + ' ' + this.lastName;&#125;;var p1 = new Human();console.log(p1.firstName); // tconsole.log(p1.lastName); // cp1.fullName(); // t c 组合模式 12345678910111213141516171819function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.friends = ['tc','zj'];&#125;Person.prototype = &#123; constructor: Person, sayName: function () &#123; console.log(this.name); &#125;&#125;;var person1 = new Person('tc',29,'se');var person2 = new Person('zj',24,'art');person1.friends.push('wcx');console.log(person1.friends); //["tc", "zj", "wcx"]console.log(person2.friends); //["tc", "zj"]console.log(person1.friends === person2.friends); //falseconsole.log(person1.sayName === person2.sayName); //true 扩展阅读： JavaScript深入之创建对象的多种方式以及优缺点 当new Foo()时发生了什么 创建一个新对象 将新创建的空对象的_proto_指向其构造函数Foo的原型（链接到原型） 将构造函数的作用域赋给新对象（绑定this，因此this指向了这个新对象） 执行构造函数中的代码（为这个新对象添加属性） 返回新对象 123456789new Person("John");function create() &#123; var obj = &#123;&#125;; obj.__proto__ = Person.prototype; // 此时便建立了obj对象的原型链： // obj-&gt;Person.prototype-&gt;Object.prototype-&gt;null var result = Person.call(obj, arguments); // 相当于obj.Person("John") return typeof result === 'object' ? result : obj; // 如果无返回值或者返回一个非对象值，则将obj返回作为新对象&#125; 扩展阅读： new创建对象的过程发生了什么 JavaScript深入之new的模拟实现 Interview Map #new let 和 const let let用来声明变量，但所声明的变量只在let命令所在的代码块中有效（let的作用域是块，而var的作用域是函数）： 123456789101112131415// 在for循环中，设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。for (var i = 0; i &lt; 10; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, 1000);&#125; // 10, 10, 10, 10, 10, 10, 10, 10, 10, 10for (let i = 0; i &lt; 10; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, 1000);&#125; // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。在代码块内，使用 let 命令声明变量之前，该变量都是不可用的。这在语 法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。 123456var a = 0;if (true) &#123; a = 10; // ReferenceError: a is not defined let a;&#125; 由于TDZ的存在，let中也不存在变量提升: 12345console.log(a); // undefinedvar a = 10;console.log(b); // Uncaught ReferenceError: b is not definedlet b = 10; let不允许重复声明: 1234if (true) &#123; let a; let a; // SyntaxError: Identifier 'a' has already been declared&#125; const const声明一个只读的常量。一旦声明，常量的值就不能改变。const一旦声明变量，就必须立即初始化，不能留到以后赋值。 12345const number = 1;number = 3; // TypeError: Assignment to constant variable.const bar; // SyntaxError: Missing initializer in const declarationbar = 1; const只在声明所在的块级作用域内有效。声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。 const与let一样不可重复声明。 const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址 不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向 的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是 固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。 1234const person = &#123;&#125;;person.name = 'tc9011';console.log(person.name); // tc9011 argumentsarguments对象是所有（非箭头）函数中都可用的局部变量。你可以使用arguments对象在函数中引用函数的参数。此对象包含传递给函数的每个参数，第一个参数在索引0处。 arguments对象不是一个 Array 。它类似于Array，但除了length属性和索引元素之外没有任何Array属性。 但是它可以被转换为一个真正的Array： 12345678910111213141516171819function f() &#123; var args1 = Array.prototype.slice.call(arguments); var args2 = [].slice.call(arguments); // ES2015 const args3 = Array.from(arguments); const args4 = [...arguments]; console.log(args1); console.log(args2); console.log(args3); console.log(args4);&#125;f('1', '2');// [ '1', '2' ]// [ '1', '2' ]// [ '1', '2' ]// [ '1', '2' ] JavaScript作用域链全局执行环境是最外围的一个执行环境。在web浏览器中，全局执行环境被认为是window对象。因此所有全局变量和函数都是作为window对象的属性和方法创建的。 某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁。 每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境会被推入一个环境栈中。在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。 当代码在一个环境中执行时，会创建变量对象的一个作用域链。作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问。 作用域链的前端始终是当前执行的代码所在环境的变量对象。如果这个环境是函数，则其活动对象作为变量对象。活动对象在最开始时只包含一个变量-arguments对象（这个对象在全局环境中不存在）。作用域链中的下一个变量对象来自外部环境，而再下一个对象则来自于下一个外部环境。这样一直延续到全局执行环境，全局执行环境的变量对象始终都是作用域中的最后一个对象。 作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。 什么是闭包闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数： 12345678910function foo() &#123; var a = 0; function bar() &#123; console.log(a); &#125; return bar;&#125;var baz = foo();baz(); // 0 构成闭包的必要条件有两个： 函数内部有函数（foo函数中有bar） 外部函数的局部变量被内部函数引用（a被bar函数引用） 闭包本质源自两点，词法作用域和函数当作值传递。当函数可以记住并访问所在的词法作用域，并在当前词法作用域之外执行，就产生了闭包。 闭包有下面三种常见形式： 调用函数里面的函数 12345678910function foo() &#123; var a = 0; function bar() &#123; console.log(a); &#125; return bar;&#125;var baz = foo();baz(); // 0 回调函数 12345678910111213141516171819202122232425function foo() &#123; var a = 0; function bar() &#123; console.log(a); &#125; baz(bar);&#125;function baz(fn) &#123; fn();&#125;foo(); // 0/************分割线**************/var a = 0;setTimeout(function () &#123; console.log(a);&#125;, 1000);function setTimeout(fn, delay) &#123; // delay code fn(); // 0&#125; 对象 12345678910111213141516171819202122function coolModule() &#123; var something = "cool"; var another = [1, 2, 3]; function doSomething() &#123; console.log(something); &#125; function doAnother() &#123; console.log(another.join(' ! ')); &#125; return &#123; doSomething: doSomething, doAnother: doAnother, &#125;;&#125;var foo = coolModule();foo.doSomething(); // coolfoo.doAnother(); // 1 ! 2 ! 3 IIFE(立即执行函数表达式)方式 严格来说它并不是闭包，因为它并不是在本身词法作用域以外执行的。a是通过普通词法作用域查找发现的，而不是闭包。 1234var a = 0;(function () &#123; console.log(a); // 0&#125;)(); 为什么a是通过词法作用域查找发现的？上面代码中的匿名函数实际上是一个函数表达式。 举个例子，比如下面代码初始化了变量count，将其值设置为5。当然这个变量是没有必要的，因为可以直接把值传递给函数: 123456var count = 5;outputNumbers(count);/*********等价于***********/outputNumbers(5); 这样做之所以可行，是因为变量只不过是值的另一种表现形式，因此用实际的值替换变量没有问题。再看下面的例子： 1234var someFunction = function() &#123; // 这里是块级作用域&#125;；someFunction(); 这个例子先定义了一个函数，然后立即调用它，定义函数的方式是创建一个匿名函数，并把匿名函数赋值给变量someFunction。而调用函数的方式是在函数名称后面添加一对()，通过前面的例子我们知道，可以使用实际的值来取代变量count，这里如果用函数值直接取代函数名，会导致错误： 123function() &#123; // 这里是块级作用域 &#125;(); // 出错 这是因为JavaScript将function关键字当作一个函数声明的开始，而函数声明后面不能跟()。但是函数表达式后面可以跟()。要将函数声明转换成函数表达式，只要像下面这样加上()就可以： 123(function() &#123; // 这里是块级作用域&#125;)(); 所以最开始的例子中，等价于以下代码： 12345var a = 0;var fn = function () &#123; console.log(a); // 0&#125;;fn(); 所以这里对a的引用只是通过词法作用域查找而得到的。由于在匿名函数中定义的任何变量，都会在执行结束时被销毁，所以可以解决for循环中通过var定义的i在全局中都指向同一个i的问题： 12345678910111213for (var i = 1; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(i) // 5 5 5 5 &#125;, 1000);&#125;for (var i = 1; i &lt; 5; i++) &#123; (function (j) &#123; setTimeout(function() &#123; console.log(j) // 1 2 3 4 &#125;, 1000); &#125;)(i);&#125; 在这个例子中，因为setTimeout中的匿名函数是一个闭包，它能够访问IIFE作用域中的所有变量，比如这里的j。也就是说IIFE创建了可以被封闭起来的闭包。 闭包可以用在许多地方。它的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 扩展阅读： IIFE是闭包吗 原型和原型链每个实例对象（object ）都有一个私有属性（称之为 __proto__）指向它的原型对象（prototype）。该原型对象也有一个自己的原型对象 ，层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。 几乎所有 JavaScript 中的对象都是位于原型链顶端的Object的实例。 无论什么时候，只要创建一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象，而且只有函数才有prototype属性（也就是说实例对象和函数都有原型对象，只是实例对象通过_proto_访问自己的原型对象，而函数是通过prototype）。 在默认情况下。所有原型对象都会自动获得一个constructor（构造函数）属性。这个属性包含一个指向prototype属性所在函数的指针。通过这个构造函数还可以继续为原型对象添加其他属性和方法。 创建自定义的构造函数之后，其原型对象默认只会取得constructor属性；至于其他方法，则都是从Object继承而来。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。ECMA-262第五版中管这个指针叫[[prototype]]。虽然在脚本中没有标准的方式访问[[prototype]]，但Firefox、Safari和Chrome在每个对象上都支持一个属性_proto_；而在其他实现中，这个属性对脚本是完全不可见的。不过，最重要的是，这个连接存在于实例与构造函数的原型对象之间，而不是存在与实例与构造函数之间。 举个例子： 从上图可以看出person1和person2的构造函数是是Person，也就是： 1person1.constructor === Person 而Person构造函数的原型的对象的constructor也指向Person，即： 1Person.prototype.constructor === Person 每个对象都有__proto__属性，在这里person1实例的_proto_属性指向构造函数的原型对象，即： 12person1.__proto__ === Person.prototypeperson1.__proto__.constructor === Person 每一个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。如果让原型对象等于另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是所谓原型链的基本概念。 12345678910111213141516171819function SuperType() &#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function () &#123; return this.property;&#125;;function SubType() &#123; this.subproperty = false;&#125;// 继承SuperTypeSubType.prototype = new SuperType(); // 重写原型对象，代之以一个新类型的实例SubType.prototype.getSubValue = function () &#123; return this.subproperty;&#125;;var instance = new SubType();console.log(instance.getSuperValue()); //true JavaScript的继承 原型链继承 通过重写原型对象，代之以一个新类型的实例，来扩展原型搜索机制，从而实现继承： 1234567891011121314151617181920function Father() &#123; this.lastName = 't'; this.isHuman = true;&#125;var father = new Father();console.log(father.isHuman); // tconsole.log(father.lastName); // truefunction Son() &#123; this.firstName = 'c';&#125;Son.prototype = new Father(); // 重写Son的原型对象var son = new Son();console.log(son.lastName); // tconsole.log(son.isHuman); // true console.log(son.firstName); // c 缺点： 包含引用类型值的原型属性会被所有实例共享 1234567891011121314151617181920212223242526272829function Father() &#123; this.lastName = 't'; this.isHuman = true; this.card = &#123; // 引用类型会被所有实例共享 bank: '', ID: '' &#125;;&#125;var father = new Father();console.log(father.isHuman); // tconsole.log(father.lastName); // truefunction Son() &#123; this.firstName = 'c';&#125;Son.prototype = new Father();var son = new Son();console.log(son.lastName); // tconsole.log(son.isHuman); // true console.log(son.firstName); // cson.card.bank = 'BOC'; // son实例改变card的值会影响其他实例var son2 = new Son();console.log(son2.card.bank); // BOC 在创建子类型的实例时，不能向父类型的构造函数中传递参数 因此实践中很少会单独使用原型链。 借助构造函数继承（经典继承） 通过使用apply()和call()方法在新创建的对象上执行构造函数。 123456789101112131415161718192021function Father(name) &#123; this.lastName = name; this.isHuman = true; this.card = &#123; bank: 'ICBC', &#125;;&#125;function Son() &#123; this.firstName = 'c'; Father.call(this, 't'); // 向父类型传参&#125;var son = new Son();console.log(son.card.bank); // 'ICBC'console.log(son.lastName); // tson.card.bank = 'BOC';console.log(son.card.bank); // 'BOC'var son2 = new Son();console.log(son2.card.bank); // 'ICBC' 优点： 避免了引用类型的属性被所有实例共享 创建子类型的实例时，可以向父类型的构造函数中传递参数 缺点： 方法都在构造函数中定义，因此函数复用就无从谈起。 所以借用构造函数的技术也很少单独使用。 组合继承 使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。 1234567891011121314151617181920212223242526272829303132function Father(name) &#123; this.name = name; this.isHuman = true; this.card = &#123; bank: 'ICBC', &#125;;&#125;Father.prototype.getName = function () &#123; console.log(this.name);&#125;;function Son(name) &#123; Father.call(this, name);&#125;Son.prototype = new Father();var son = new Son('tc');console.log(son.isHuman); // trueconsole.log(son.name); // tcson.getName(); // tcconsole.log(son.card.bank); // ICBCson.card.bank = 'BOC';console.log(son.card.bank); // BOCvar son2 = new Son('zj');console.log(son2.isHuman); // trueconsole.log(son2.name); // zjson2.getName(); // zjconsole.log(son2.card.bank); // ICBC 优点： 融合原型链继承和构造函数的优点 缺点： 都会调用两次父类型的构造函数，一次在创建子类型原型的时候，另一次在子类型构造函数内部 是 JavaScript 中最常用的继承模式。 原型式继承 通过Object.create()实现继承。 12345678910111213141516var person = &#123; name: 'tc', friend: ['a', 'b', 'c']&#125;;var anotherPerson = Object.create(person);anotherPerson.name = 'zz';anotherPerson.friend.push('d');console.log(anotherPerson.friend); // [ 'a', 'b', 'c', 'd' ]var yetAnotherPerson = Object.create(person);yetAnotherPerson.name = 'jj';yetAnotherPerson.friend.push('e');console.log(yetAnotherPerson.friend); // [ 'a', 'b', 'c', 'd', 'e' ]console.log(person.friend); // [ "a", "b", "c", "d", "e" ] 优点： 在不需要创建构造函数，且想让一个对象与另一个对象保持类似的情况下，可以很方便地实现继承 缺点： 引用类型的属性被所有实例共享 寄生式继承 通过创建一个用于封装继承过程的函数来实现继承，该函数内部以某种方式（不一定是使用下面的Object.create()）来增强对象，最后返回该对象。 123456789101112131415var person = &#123; name: 'tc', friend: ['a', 'b', 'c']&#125;;function createAnother(original) &#123; var clone = Object.create(original); clone.sayHi = function () &#123; console.log('hi') &#125;; return clone;&#125;var anotherPerson = createAnother(person);anotherPerson.sayHi(); // hi 缺点： 不能做到函数复用 在主要考虑对象的情况下，可以使用寄生式继承。 寄生组合式继承 通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。本质上，就是使用寄生式继承来继承父类型的原型，然后再将结果指定给子类型的原型。 123456789101112131415161718192021222324252627282930function inheritPrototype(Son, Father) &#123; var prototype = Object.create(Father.prototype); // create object prototype.constructor = Son; Son.prototype = prototype;&#125;function Father(name) &#123; this.name = name; this.colors = ['red','blue','green'];&#125;Father.prototype.sayName = function () &#123; console.log(this.name);&#125;;function Son(name, age) &#123; Father.call(this,name); this.age = age;&#125;inheritPrototype(Son, Father);Son.prototype.sayAge = function () &#123; console.log(this.age);&#125;;var son = new Son('a', 11);console.log(son.name); // aconsole.log(son.colors); // [ 'red', 'blue', 'green' ]son.sayAge(); // 11son.sayName(); // a 优点： 只调用一次父类构造函数 原型链保持不变，能正常使用instanceof和isPrototypeOf() 普遍认为寄生组合式继承是引用类型最理想的继承范式。 JavaScript中的thisthis是函数运行时，在函数体内部自动生成的一个对象，只能在函数体内部使用。 this总是指向调用它的对象，通过apply()和call()可以手动改变this的指向。 纯函数调用 this代表全局对象window或global(在node中)，下面的bar()的调用可以看成window.bar()或者global.bar()(在node中)： 12345var x = 1;function bar() &#123; console.log(this.x); &#125;bar(); // 1 作为对象的方法调用 this指向调用它的对象。 12345678910111213function sayHi() &#123; console.log(`$&#123;this.name&#125; say hi`); console.log(this === o);&#125;var o = &#123; name: 'tc9011', sayHi: sayHi,&#125;;o.sayHi(); // tc901 say hi// true 作为构造函数调用 this指向构造函数生成的对象。 123456789var name = 'tc';function Person(name) &#123; this.name = name;&#125;var a = new Person('tc9011');console.log(a.name); // tc9011console.log(this.name); // tc apply或call调用 apply()和call()作用都是改变函数的调用对象（两者的区别在于第一参数后面的接受参数的形式，call()方法接受的是若干个参数的列表，而apply()方法接受的是一个包含多个参数的数组。）。它们的第一个参数就表示改变后的调用这个函数的对象。因此，这时this指的就是这第一个参数。 12345678910111213141516171819function sayName(age, isHuman) &#123; this.age = age; this.isHuman = isHuman; console.log(this.name); console.log(this.age); console.log(this.isHuman)&#125;var o = &#123; name: 'tc9011', sayName: sayName,&#125;;var o2 = &#123; name: 'tc',&#125;;o.sayName.call(o2, 15, true); // tc 15 trueo.sayName.apply(o2, [16, false]); // tc 16 false 需要注意的是，在箭头函数中，不会绑定this，this的指向始终由最近一层非箭头函数决定，并且this值不可以被改变，在函数的生命周期内始终保持一致。 123456789function foo() &#123; setTimeout(() =&gt; &#123; console.log('id:', this.id); &#125;, 100)&#125;var id = 21;foo.call(&#123;id: 42&#125;); // id: 42 call和apply改变了函数的this上下文后便执行该函数,而bind则是返回改变了上下文后的一个函数。 深拷贝与浅拷贝浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。 深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。 浅拷贝 12345678910111213141516171819202122232425262728293031// shallow copy in the arrayvar array1 = [0, 1, 2, 3, &#123; name: 'a' &#125;];var array2 = array1.slice();console.log(array2); // [ 0, 1, 2, 3, &#123; name: 'a' &#125; ]array2.push(4);array2[4].name = 'b';console.log(array1); // [ 0, 1, 2, 3, &#123; name: 'b' &#125; ]console.log(array2); // [ 0, 1, 2, 3, &#123; name: 'b' &#125;, 4 ]// common shallow copyfunction shallowCopy(source) &#123; if (!source || typeof source !== 'object') &#123; throw new Error('error arguments'); &#125; var targetObj = source.constructor === Array ? [] : &#123;&#125;; for (var keys in source) &#123; if (source.hasOwnProperty(keys)) &#123; targetObj[keys] = source[keys]; &#125; &#125; return targetObj;&#125;var a = &#123; name: 'a',&#125;;var b = shallowCopy(a);console.log(b); // &#123; name: 'a' &#125; 深拷贝 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// 通过递归实现深拷贝，但是没有办法处理源对象内部循环引用的问题，同时对Date，Funcion等类型值也没有实现真正的深度复制，但是这些类型的值在重新定义的时候一般都是直接覆盖，所以也不会对源对象产生影响，从一定程度上来说也算是实现了一个深拷贝。function deepCopy(source) &#123; if (!source || typeof source !== 'object') &#123; throw new Error('error arguments'); &#125; var targetObj = source.constructor === Array ? [] : &#123;&#125;; for (var keys in source) &#123; if (source.hasOwnProperty(keys)) &#123; if (source[keys] &amp;&amp; typeof source[keys] === 'object') &#123; targetObj[keys] = source[keys].constructor === Array ? [] : &#123;&#125;; targetObj[keys] = deepCopy(source[keys]); &#125; else &#123; targetObj[keys] = source[keys]; &#125; &#125; &#125; return targetObj;&#125;var o1 = &#123; arr: [1, 2, 3], obj: &#123; key: 'value' &#125;, fun: function()&#123; return 1; &#125;&#125;;var o2 = deepCopy(o1);console.log(o2 === o1); // falseconsole.log(o2.obj === o1.obj); // falseconsole.log(o2.fun === o1.fun); // true// 通过`JSON.parse`和`JSON.stringify`实现深拷贝，在序列化JavaScript对象时，所有函数和原型成员会被有意忽略，这个实现可以满足一些比较简单的情况，能够处理JSON格式所能表示的所有数据类型，同时如果在对象中存在循环应用的情况也无法正确处理。function deepCopy(source)&#123; return JSON.parse(JSON.stringify(source));&#125;var o1 = &#123; arr: [1, 2, 3], obj: &#123; key: 'value' &#125;, func: function()&#123; return 1; &#125;&#125;;var o2 = deepCopy(o1);console.log(o2); // &#123; arr: [ 1, 2, 3 ], obj: &#123; key: 'value' &#125; &#125;// 通用的深拷贝function deepCopy(source) &#123; if (!source || typeof source !== 'object') &#123; throw new Error ('error arguments'); &#125; var targetObj = Object.prototype.toString.call(source) === '[object Array]' ? [] : &#123;&#125;; for (var key in source) &#123; if (source.hasOwnProperty(key)) &#123; if (source[key] &amp;&amp; typeof source[key] === 'object') &#123; targetObj[key] = Object.prototype.toString.call(source) === '[object Array]' ? [] : &#123;&#125;; targetObj[key] = deepCopy(source[key]); &#125; else if (source[key] &amp;&amp; Object.prototype.toString.call(source[key]) === '[object Function]') &#123; targetObj[key] = new Function("return " + source[key].toString())(); &#125; else &#123; targetObj[key] = source[key]; &#125; &#125; &#125; return targetObj;&#125;var o1 = &#123; arr: [1, 2, 3], obj: &#123; key: 'value' &#125;, fun: function()&#123; return 1; &#125;&#125;;var o2 = deepCopy(o1);console.log(o2 === o1); // falseconsole.log(o2.obj === o1.obj); // falseconsole.log(o2.fun === o1.fun); // falseo2.obj.key = 'tc';console.log(o2); // &#123; arr: [ 1, 2, 3 ], obj: &#123; key: 'tc' &#125;, fun: [Function] &#125;console.log(o1); // &#123; arr: [ 1, 2, 3 ], obj: &#123; key: 'value' &#125;, fun: [Function: fun] &#125; setTimeout与setIntervalsetTimeout含义是定时器，到达一定的时间触发一次，但是setInterval含义是计时器，到达一定时间触发一次，并且会持续触发。 1234567891011// setTimeout模拟setIntervalfunction run() &#123; //其他代码 setTimeout(function()&#123; run(); &#125;, 10000);&#125;setInterval(function()&#123; run();&#125;, 10000); 参考资料： 注意点——setTimeout、setInterval使用 你真的了解setTimeout和setInterval吗？ 事件循环js引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕d， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码…，如此反复，这样就形成了一个无限的循环。这就是“事件循环（Event Loop）”。 可以通过下面两个例子直观地看一下，事件循环执行的时候的顺序： 12345678910111213141516171819$.on('button', 'click', function onClick() &#123; setTimeout(function () &#123; console.log('You clicked the button!'); &#125;, 2000);&#125;);console.log('Hi!');setTimeout(function timeout() &#123; console.log('Click the button!');&#125;, 5000);console.log('Welcome to loupe.');// Hi!// Welcome to loupe.// Click the button!// 当你点击按钮时会输出：// You clicked the button! 1234567891011121314setTimeout(function () &#123; console.log(1);&#125;);new Promise(function (resolve, reject) &#123; console.log(2) resolve(3)&#125;).then(function (val) &#123; console.log(val);&#125;);// 2// 3// 1 不同的异步任务被分为两类：微任务（micro task）和宏任务（macro task）。 以下事件属于宏任务： setInterval() setTimeout() setImmediate() I/O 以下事件属于微任务 process.nextTick new Promise() MessageChannel 当当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行。 浏览器和 node 环境执行顺序不同，浏览器是先把一个栈以及栈中的微任务走完，才会走下一个栈。node 环境里面是把所以栈走完，才走微任务: 1234567891011121314151617181920212223242526console.log(1);// 栈setTimeout(function () &#123; console.log(2); // 微任务 Promise.resolve(100).then(function () &#123; console.log('promise') &#125;)&#125;);let promise = new Promise(function (resolve, reject) &#123; console.log(7); // 栈 resolve(100)&#125;).then(function (data) &#123; // 微任务 console.log(data)&#125;);// 栈setTimeout(function () &#123; console.log(3)&#125;);console.log(5);// 浏览器结果：1 7 5 100 2 promise 3// node 结果：1 7 5 100 2 3 promise 扩展阅读： 带你彻底弄懂Event Loop 事件流事件流描述的是从页面中接收事件的顺序。 DOM2级事件中addEventListener()接收3个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。当这个布尔值为true时，表示在捕获阶段调用事件处理程序；若果是false，表示在冒泡阶段调用事件处理程序。 事件冒泡 IE的事件流叫做事件冒泡，即事件开始时由最具体的元素接收，然后逐级向上传播到较为不具体的节点（文档）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; #wrap &#123; width: 200px; height: 200px; background: mediumpurple; &#125; #outer &#123; position: relative; top: 50px; left: 50px; width: 100px; height: 100px; background: #00abff; &#125; #inner &#123; position: relative; top: 25px; left:25px; width: 50px; height: 50px; background: white; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="wrap"&gt; &lt;div id="outer"&gt; &lt;div id="inner"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; var wrap = document.getElementById('wrap'); var outer = document.getElementById('outer'); var inner = document.getElementById('inner'); wrap.addEventListener('click',function()&#123; alert('789'); &#125;,false); outer.addEventListener('click',function()&#123; alert('456'); &#125;,false); inner.addEventListener('click',function()&#123; alert('123'); &#125;,false);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 当点击页面中心白色的部分时，先是弹出123，接着弹出456，最后弹出789。因此当容器元素及其嵌套元素都在冒泡阶段调用事件处理程序时：事件按事件冒泡的顺序执行事件处理程序。 所有浏览器都支持事件冒泡，但在具体实现上还有一些差别。IE9、Firefox、Chrome和Safari则将事件一直冒泡到window对象。 事件捕获 Netscape Communicator的事件流是事件捕获流。事件捕获的思想是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。事件捕获的用意在于在事件到达预定目标之前捕获它。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; #wrap &#123; width: 200px; height: 200px; background: mediumpurple; &#125; #outer &#123; position: relative; top: 50px; left: 50px; width: 100px; height: 100px; background: #00abff; &#125; #inner &#123; position: relative; top: 25px; left:25px; width: 50px; height: 50px; background: white; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="wrap"&gt; &lt;div id="outer"&gt; &lt;div id="inner"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; var wrap = document.getElementById('wrap'); var outer = document.getElementById('outer'); var inner = document.getElementById('inner'); wrap.addEventListener('click',function()&#123; alert('wrap'); &#125;,true); outer.addEventListener('click',function()&#123; alert('outer'); &#125;,true); inner.addEventListener('click',function()&#123; alert('inner'); &#125;,true);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 当点击页面中心白色的部分时，先是弹出wrap，接着弹出outer，最后弹出inner。因此当容器元素及其嵌套元素都在捕获阶段调用事件处理程序时：事件按事件捕获的顺序执行事件处理程序。 IE9、Safari、Chrome、Opera和Firefox也都支持这种事件流模型。尽管DOM2级事件规范要求事件应该从document对象开始传播，但这些浏览器都是从window对象开始捕获事件的。 建议放心地使用事件冒泡，在有特殊需要的时候再使用事件捕获。 DOM事件流 当同一个元素即在冒泡阶段注册了事件，又在捕获阶段注册了同一事件，那么当事件被触发时，事件的执行顺序又会是如何的？这就涉及到DOM事件流。 DOM2级事件规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。 首先发生的是事件捕获，为截获事件提供了机会。然后是实际的目标接收到事件。最后一个阶段是冒泡阶段，可以在这个阶段对事件做出响应。 在DOM事件流中，实际的目标在捕获阶段不会接收到事件。这意味着在捕获阶段，事件从document到&lt;html&gt;再到&lt;body&gt;后就停止了。下一个阶段是处于目标阶段，于是事件再&lt;div&gt;上发生，并在事件处理中被看成冒泡阶段的一部分。然后，冒泡阶段发生，事件又传播回文档。 多数支持DOM事件流的浏览器都实现了一种特定的行为，即使DOM2级事件规范明确要求捕获阶段不会涉及事件目标，但IE9、Safari、Chrome、Firefox和Opera9.5及更高版本都会在捕获阶段触发事件对象上的事件。结果，就是有两个机会在目标对象上面操作事件。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; #wrap &#123; width: 200px; height: 200px; background: mediumpurple; &#125; #outer &#123; position: relative; top: 50px; left: 50px; width: 100px; height: 100px; background: #00abff; &#125; #inner &#123; position: relative; top: 25px; left:25px; width: 50px; height: 50px; background: white; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="wrap"&gt; &lt;div id="outer"&gt; &lt;div id="inner"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; var wrap = document.getElementById('wrap'); var outer = document.getElementById('outer'); var inner = document.getElementById('inner'); wrap.addEventListener('click',function()&#123; alert('789'); &#125;,false); outer.addEventListener('click',function()&#123; alert('456'); &#125;,false); inner.addEventListener('click',function()&#123; alert('123'); &#125;,false); wrap.addEventListener('click',function()&#123; alert('wrap'); &#125;,true); outer.addEventListener('click',function()&#123; alert('outer'); &#125;,true); inner.addEventListener('click',function()&#123; alert('inner'); &#125;,true);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; target 和 currentTargettarget：指向触发事件监听的对象。 currentTarget：指向添加监听事件的对象。 在事件处理程序内部，对象this始终等于currentTarget的值，而target则只包含事件的实际目标。如果直接将事件处理程序指定给了目标元素，则this、currentTarget和target包含相同的值： 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;button id="btn"&gt;click&lt;/button&gt;&lt;script&gt; var btn = document.getElementById('btn'); btn.onclick = function (event) &#123; alert(event.currentTarget === this); //true alert(event.target === this); //true &#125;; document.body.onclick = function (event) &#123; alert(event.currentTarget === document.body); // true alert(this === document.body); // true alert(event.target === btn); // true alert(event.currentTarget === this); // true alert(event.target === this); // false &#125;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 事件委托事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;ul id="parent-list"&gt; &lt;li id="post-1"&gt;Item 1&lt;/li&gt; &lt;li id="post-2"&gt;Item 2&lt;/li&gt; &lt;li id="post-3"&gt;Item 3&lt;/li&gt; &lt;li id="post-4"&gt;Item 4&lt;/li&gt; &lt;li id="post-5"&gt;Item 5&lt;/li&gt; &lt;li id="post-6"&gt;Item 6&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; document.getElementById("parent-list").addEventListener("click", function(e) &#123; if(e.target &amp;&amp; e.target.nodeName === "LI") &#123; console.log("List item ", e.target.id.replace("post-", ""), " was clicked!"); &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 事件委托可以显著的提高事件的处理速度，减少内存的占用。 使用事件在动态绑定事件的情况下是可以减少很多重复工作的。比如在多个列表项中，我们给每个列表项都绑定了事件；在很多时候，我们需要通过 AJAX 或者用户操作动态的增加或者去除列表项元素，那么在每一次改变的时候都需要重新给新增的元素绑定事件，给即将删去的元素解绑事件；如果用了事件委托就没有这种麻烦了，因为事件是绑定在父层的，和目标元素的增减是没有关系的，执行到目标元素是在真正响应执行事件函数的过程中去匹配的。 适合用事件委托的事件：click，mousedown，mouseup，keydown，keyup，keypress。 JavaScript跨域通信JavaScript进行DOM操作、通信时如果目标与当前窗口不满足同源条件，浏览器为了安全会阻止跨域操作。常见的跨域解决方案有以下几种： JSONP JSONP是JSON with padding（填充式JSON或参数式JSON）的简写，是应用JSON的一种方法。JSONP由两部分组成：回调函数和数据。 JSONP是通过动态&lt;script&gt;元素来使用的，使用时可以为src属性指定一个跨域URL。这里的&lt;script&gt;元素可以不受限制地从其他域加载资源。因为JSONP是有效的JavaScript代码，所以在请求完成后，即在JSONP响应加载到页面中以后，就会立即执行： 12345678910function todo(data)&#123; console.log('The author is: '+ data.name);&#125;var script = document.createElement('script');script.src = 'http://tc9011.com/author?callback=todo';document.body.appendChild(script);/* 服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。 */todo(&#123;"name": "tc9011"&#125;); JSONP只能实现GET请求。 CORS CORS（Cross-Origin Resource Sharing，跨源资源共享）定义了在必须访问跨源资源时，浏览器与服务器如何沟通。CORS背后的基本思想，就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是失败。 比如一个简单的使用GET或POST发送的请求，它没有自定义的头部，而主体内容是text/plain。在发送该请求时，需要给它附加一个额外的Origin头部，其中包含请求页面的源信息，以便服务器根据这个头部信息来决定是否给予响应下面是Origin头部的一个示例： 1Origin: http://tc9011.com 如果服务器认为这个请求可以接受，就在Access-Control-Allow-Origin头部中回发相同的源信息（如果是公共资源，可以回发*）： 1Access-Control-Allow-Origin: http://tc9011.com 如果没有这个头部，或者有这个头部但源信息不匹配，浏览器就会驳回请求。请求和响应都不包含cookie信息。 CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。 HTML5跨文档消息传递(XDM) window.postMessage() 方法可以安全地实现跨源通信。 window.postMessage() 方法接收三个参数： message：将要发送到其他 window的数据； targetOrigin：指定哪些窗口能接收到消息事件，其值可以是字符串”*”（表示无限制）或者一个URI； transfer：可选参数，是一串和message 同时传递的 Transferable对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。 1234567891011121314151617181920212223// index.html//获取iframe元素iFrame = document.getElementById('myframe')//iframe加载完毕后再发送消息，否则子页面接收不到messageiFrame.onload = function()&#123; //iframe加载完立即发送一条消息 iFrame.contentWindow.postMessage('MessageFromIndex1','*');&#125;// iframePage.html//回调函数function receiveMessageFromIndex ( event ) &#123; console.log( 'receiveMessageFromIndex', event )&#125;//监听message事件window.addEventListener("message", receiveMessageFromIndex, false); 以上是比较常见的跨域通信方法，其他跨域通信方法可以参考：跨域通信总结。 sessionStorage ，localStorage 和 cookie 的区别 特性 Cookie localStorage sessionStorage 同源限制 是 是 是 数据的生命期 一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效 除非被清除，否则永久保存 仅在当前会话下有效，关闭页面或浏览器后被清除 存放数据大小 4K左右 一般为5MB 一般为5MB 与服务器端通信 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 仅在客户端（即浏览器）中保存，不参与和服务器的通信 仅在客户端（即浏览器）中保存，不参与和服务器的通信 浏览器渲染原理 处理 HTML 标记并构建 DOM Tree。 处理 CSS 标记并构建 CSS Rule Tree 。 解析完成后，浏览器引擎会通过DOM Tree 和 CSS Rule Tree 来构造 Rendering Tree。注意： Rendering Tree 渲染树并不等同于DOM树，因为一些像Header或display:none的东西就没必要放在渲染树中了。 CSS 的 Rule Tree主要是为了完成匹配并把CSS Rule附加上Rendering Tree上的每个Element。也就是DOM结点。也就是所谓的Frame。 然后，计算每个Frame（也就是每个Element）的位置，这又叫layout和reflow过程。 最后通过调用操作系统Native GUI的API绘制。 扩展阅读： 浏览器的工作原理：新式网络浏览器幕后揭秘 浏览器渲染过程与性能优化 渲染树构建、布局及绘制 回流（Reflow）和重绘（Repaint）回流：当Render Tree中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。 会导致回流的操作： 页面首次渲染 浏览器窗口大小发生改变 元素尺寸或位置发生改变 元素内容变化（文字数量或图片大小等等） 元素字体大小变化 添加或者删除可见的DOM元素 激活CSS伪类（例如：:hover） 查询某些属性或调用某些方法 一些常用且会导致回流的属性和方法： clientWidth、clientHeight、clientTop、clientLeft offsetWidth、offsetHeight、offsetTop、offsetLeft scrollWidth、scrollHeight、scrollTop、scrollLeft scrollIntoView()、scrollIntoViewIfNeeded() getComputedStyle() getBoundingClientRect() scrollTo() 重绘 ：当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。 回流一定触发重绘，但是重绘不一定触发回流。回流比重绘的代价要更高。 现代浏览器会对频繁的回流或重绘操作进行优化： 浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。 当你访问以下属性或方法时，浏览器会立刻清空队列： clientWidth、clientHeight、clientTop、clientLeft offsetWidth、offsetHeight、offsetTop、offsetLeft scrollWidth、scrollHeight、scrollTop、scrollLeft width、height getComputedStyle() getBoundingClientRect() 因为队列中可能会有影响到这些属性或方法返回值的操作，即使你希望获取的信息与队列中操作引发的改变无关，浏览器也会强行清空队列，确保你拿到的值是最精确的。 如何避免： 避免使用table布局。 尽可能在DOM树的最末端改变class。 避免设置多层内联样式。 将动画效果应用到position属性为absolute或fixed的元素上。 避免使用CSS表达式（例如：calc()）。 避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。 避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。 也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。 选自： 浏览器的回流与重绘 (Reflow &amp; Repaint) 前端路由的原理 基于hash（location.hash+hashchange事件） URL中#及其后面的部分为hash： 123const url = require('url');const a = url.parse('http://tc9011.com/achievemnet/#hash/a');console.log(a.hash); // #hash/a hash仅仅是客户端的一个状态，也就是说，当向服务器发请求的时候，hash部分并不会发过去，所以url中hash值的变化并不会重新加载页面。hash值的改变，都会在浏览器的访问历史中增加一个记录，也就是能通过浏览器的回退、前进按钮控制hash的切换。 通过监听window对象的hashChange事件，可以实现简单的路由: 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href="#home"&gt;home&lt;/a&gt;&lt;a href="#main"&gt;main&lt;/a&gt;&lt;div id="content"&gt;&lt;/div&gt;&lt;script&gt; const div = document.getElementById('content'); window.onhashchange = function () &#123; const hash = window.location.hash; const path = hash.substring(1); switch (path) &#123; case '/': div.innerHTML = 'home'; break; case '/users': div.innerHTML = 'users'; break; default: div.innerHTML = '404'; &#125; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 基于HTML5 History API（history.pushState()+popState事件） 通过HTML5中history对象上的pushState()方法或replaceState()方法可以修改url的地址，并在popstate事件中能监听地址的改变，不同的是，手动的进行pushState()并不会触发popstate事件。 history.pushState()和history.replaceState()方法都可以接收三个参数：状态对象、新状态的标题和可选的相对URL。这两个API的相同之处是都会操作浏览器的历史记录，而不会引起页面的刷新。不同之处在于，pushState会增加一条新的历史记录，而replaceState则会替换当前的历史记录。这两个api，加上state改变触发的popstate事件，提供了单页应该的另一种路由方式。 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p id="menu"&gt; &lt;a href="/profile" title="profile"&gt;profile&lt;/a&gt; &lt;a href="/account" title="account"&gt;account&lt;/a&gt;&lt;/p&gt;&lt;div class="main" id="main"&gt;&lt;/div&gt;&lt;script&gt; (function()&#123; var menubox = document.getElementById('menu'); var mainbox = document.getElementById('main'); menubox.addEventListener('click',function(e)&#123; e.preventDefault(); var elm = e.target; var uri = elm.href; var tlt = elm.title; history.pushState(&#123;path:uri,title:tlt&#125;,null,uri); mainbox.innerHTML = 'current page is '+tlt; &#125;); window.addEventListener('popstate',function(e)&#123; var state = e.state; console.log(state); mainbox.innerHTML = 'current page is ' + state.title; &#125;) &#125;)()&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 浏览器缓存浏览器缓存分为强缓存和协商缓存。当客户端请求某个资源时，获取缓存的流程如下： 先根据这个资源的一些 http header 判断它是否命中强缓存，如果命中，则直接从本地获取缓存资源（返回码为200 OK （from disk cache）），不会发请求到服务器； 当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些request header验证这个资源是否命中协商缓存，称为http再验证，如果命中，服务器将请求返回（返回码为304 Not Modified），但不返回资源，而是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源； 强缓存和协商缓存共同之处在于，如果命中缓存，服务器都不会返回资源； 区别是，强缓存不对发送请求到服务器，但协商缓存会。 当协商缓存也没命中时，服务器就会将资源发送回客户端。 当 ctrl+f5 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存； 当 f5 刷新网页时，跳过强缓存，但是会检查协商缓存； 强缓存： Expires：该字段是 http1.0 时的规范，值为一个绝对时间的 GMT 格式的时间字符串，代表缓存资源的过期时间 Cache-Control：该字段是 http1.1 的规范，浏览器缓存里, Cache-Control是金字塔顶尖的规则，它藐视一切其他设置，只要其他设置与其抵触，一律覆盖之。不仅如此， 它还是一个复合规则， 包含多种值,，横跨 存储策略， 过期策略 两种，同时在请求头和响应头都可设置。其值可取为以下值： 12345678910111213141516171819Cache request directives： Cache-Control: max-age=&lt;seconds&gt; Cache-Control: max-stale[=&lt;seconds&gt;] Cache-Control: min-fresh=&lt;seconds&gt; Cache-Control: no-cache Cache-Control: no-store Cache-Control: no-transform Cache-Control: only-if-cachedCache response directives： Cache-Control: must-revalidate Cache-Control: no-cache Cache-Control: no-store Cache-Control: no-transform Cache-Control: public Cache-Control: private Cache-Control: proxy-revalidate Cache-Control: max-age=&lt;seconds&gt; Cache-Control: s-maxage=&lt;seconds&gt; 协商缓存： Last-Modified ：值为资源最后更新的GMT时间，随服务器response返回。Last-Modified 是 ETag 的fallback机制， 优先级比ETag 低， 且只能精确到秒， 因此不太适合短时间内频繁改动的资源。 不仅如此， 服务器端的静态资源， 通常需要编译打包， 可能出现资源内容没有改变， 而Last-Modified却改变的情况。 If-Modified-Since ：缓存校验字段, 其值为上次响应头的Last-Modified值，通过比较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存。 ETag ：表示资源内容的唯一标识，随服务器response返回。浏览器可以根据ETag值缓存数据，节省带宽。如果资源已经改变，ETag可以帮助防止同步更新资源的相互覆盖。ETag 优先级比 Last-Modified 高。 If-None-Match ：服务器通过比较请求头部的If-None-Match与当前资源的ETag是否一致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存。优先级比If-Modified-Since高。 无法被浏览器缓存的请求： HTTP信息头中包含Cache-Control:no-cache，pragma:no-cache，或Cache-Control:max-age=0等告诉浏览器不用缓存的请求 需要根据Cookie，认证信息等决定输入内容的动态请求是不能被缓存的 经过HTTPS安全加密的请求（有人也经过测试发现，ie其实在头部加入Cache-Control：max-age信息，firefox在头部加入Cache-Control:Public之后，能够对HTTPS的资源进行缓存，参考《HTTPS的七个误解》） POST请求无法被缓存 HTTP响应头中不包含Last-Modified/Etag，也不包含Cache-Control/Expires的请求无法被缓存 扩展阅读： 浏览器缓存机制剖析 【Web缓存机制系列】2 – Web浏览器的缓存机制 PromisePromise 对象有以下两个特点。 对象的状态不受外界影响。 Promise 对象代表一个异步操作，有三种状态： pending （进行中）、fulfilled （已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。 一旦状态改变，就不会再变，任何时候都可以得到这个结果。 Promise 对象的状态改变，只有两种可能：从 pending 变为fulfilled和从 pending 变为 rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为resolved（已定型）。如果改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是 resolve 和 reject 。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。resolve 函数的作用是，将 Promise 对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject 函数的作用是，将 Promise 对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。Promise 实例生成以后，可以用then方法分别指定 resolved状态和rejected 状态的回调函数。注意，调用resolve 或 reject 并不会终结 Promise 的参数函数的执行。then 方法可以接受两个回调函数作为参数。第一个回调函数是 Promise 对象的状态变为 resolved 时调用，第二个回调函数是 Promise 对象的状态变为 rejected 时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受 Promise 对象传出的值作为参数。 123456789101112131415161718192021222324252627282930313233const ajaxPromise = () =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; const xhr = new XMLHttpRequest(); xhr.open('GET', 'http://tc9011.com'); xhr.send(); xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123; resolve(JSON.parse(xhr.responseText)); &#125; else &#123; reject(JSON.parse(xhr.responseText)); &#125; &#125;; &#125;);&#125;;// 第一种写法ajaxPromise.then( res =&gt; &#123; console.log(res); &#125;, error =&gt; &#123; console.log(error);&#125;);// 第二种写法ajaxPromise .then(res =&gt; &#123; console.log(res); &#125;) .catch(error =&gt; &#123; console.log(error); &#125;); catch用于指定发生错误时的回调函数。Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个 catch 语句捕获。上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面 then 方法执行中的错误，也更接近同步的写法（ try/catch ）。因此，建议总是使用 catch 方法，而不使用 then 方法的第二个参数。 12345678910111213141516const fs = require('fs');const getData = (fileName, type) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; fs.readFile(fileName, type, (err, data) =&gt; &#123; err ? reject(err) : resolve(data); &#125;); &#125;);&#125;;getData('./file.txt', 'sample') .then(data =&gt; &#123; console.log(data); &#125;) .catch(err =&gt; &#123; console.log(err); &#125;); Promise实现原理： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199// 判断变量否为functionconst isFunction = variable =&gt; typeof variable === 'function'// 定义Promise的三种状态常量const PENDING = 'PENDING'const FULFILLED = 'FULFILLED'const REJECTED = 'REJECTED'class MyPromise &#123; constructor (handle) &#123; if (!isFunction(handle)) &#123; throw new Error('MyPromise must accept a function as a parameter') &#125; // 添加状态 this._status = PENDING // 添加状态 this._value = undefined // 添加成功回调函数队列 this._fulfilledQueues = [] // 添加失败回调函数队列 this._rejectedQueues = [] // 执行handle try &#123; handle(this._resolve.bind(this), this._reject.bind(this)) &#125; catch (err) &#123; this._reject(err) &#125; &#125; // 添加resovle时执行的函数 _resolve (val) &#123; const run = () =&gt; &#123; if (this._status !== PENDING) return // 依次执行成功队列中的函数，并清空队列 const runFulfilled = (value) =&gt; &#123; let cb; while (cb = this._fulfilledQueues.shift()) &#123; cb(value) &#125; &#125; // 依次执行失败队列中的函数，并清空队列 const runRejected = (error) =&gt; &#123; let cb; while (cb = this._rejectedQueues.shift()) &#123; cb(error) &#125; &#125; /* 如果resolve的参数为Promise对象，则必须等待该Promise对象状态改变后, 当前Promsie的状态才会改变，且状态取决于参数Promsie对象的状态 */ if (val instanceof MyPromise) &#123; val.then(value =&gt; &#123; this._value = value this._status = FULFILLED runFulfilled(value) &#125;, err =&gt; &#123; this._value = err this._status = REJECTED runRejected(err) &#125;) &#125; else &#123; this._value = val this._status = FULFILLED runFulfilled(val) &#125; &#125; // 为了支持同步的Promise，这里采用异步调用 setTimeout(run, 0) &#125; // 添加reject时执行的函数 _reject (err) &#123; if (this._status !== PENDING) return // 依次执行失败队列中的函数，并清空队列 const run = () =&gt; &#123; this._status = REJECTED this._value = err let cb; while (cb = this._rejectedQueues.shift()) &#123; cb(err) &#125; &#125; // 为了支持同步的Promise，这里采用异步调用 setTimeout(run, 0) &#125; // 添加then方法 then (onFulfilled, onRejected) &#123; const &#123; _value, _status &#125; = this // 返回一个新的Promise对象 return new MyPromise((onFulfilledNext, onRejectedNext) =&gt; &#123; // 封装一个成功时执行的函数 let fulfilled = value =&gt; &#123; try &#123; if (!isFunction(onFulfilled)) &#123; onFulfilledNext(value) &#125; else &#123; let res = onFulfilled(value); if (res instanceof MyPromise) &#123; // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调 res.then(onFulfilledNext, onRejectedNext) &#125; else &#123; //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数 onFulfilledNext(res) &#125; &#125; &#125; catch (err) &#123; // 如果函数执行出错，新的Promise对象的状态为失败 onRejectedNext(err) &#125; &#125; // 封装一个失败时执行的函数 let rejected = error =&gt; &#123; try &#123; if (!isFunction(onRejected)) &#123; onRejectedNext(error) &#125; else &#123; let res = onRejected(error); if (res instanceof MyPromise) &#123; // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调 res.then(onFulfilledNext, onRejectedNext) &#125; else &#123; //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数 onFulfilledNext(res) &#125; &#125; &#125; catch (err) &#123; // 如果函数执行出错，新的Promise对象的状态为失败 onRejectedNext(err) &#125; &#125; switch (_status) &#123; // 当状态为pending时，将then方法回调函数加入执行队列等待执行 case PENDING: this._fulfilledQueues.push(fulfilled) this._rejectedQueues.push(rejected) break // 当状态已经改变时，立即执行对应的回调函数 case FULFILLED: fulfilled(_value) break case REJECTED: rejected(_value) break &#125; &#125;) &#125; // 添加catch方法 catch (onRejected) &#123; return this.then(undefined, onRejected) &#125; // 添加静态resolve方法 static resolve (value) &#123; // 如果参数是MyPromise实例，直接返回这个实例 if (value instanceof MyPromise) return value return new MyPromise(resolve =&gt; resolve(value)) &#125; // 添加静态reject方法 static reject (value) &#123; return new MyPromise((resolve ,reject) =&gt; reject(value)) &#125; // 添加静态all方法 static all (list) &#123; return new MyPromise((resolve, reject) =&gt; &#123; /** * 返回值的集合 */ let values = [] let count = 0 for (let [i, p] of list.entries()) &#123; // 数组参数如果不是MyPromise实例，先调用MyPromise.resolve this.resolve(p).then(res =&gt; &#123; values[i] = res count++ // 所有状态都变成fulfilled时返回的MyPromise状态就变成fulfilled if (count === list.length) resolve(values) &#125;, err =&gt; &#123; // 有一个被rejected时返回的MyPromise状态就变成rejected reject(err) &#125;) &#125; &#125;) &#125; // 添加静态race方法 static race (list) &#123; return new MyPromise((resolve, reject) =&gt; &#123; for (let p of list) &#123; // 只要有一个实例率先改变状态，新的MyPromise的状态就跟着改变 this.resolve(p).then(res =&gt; &#123; resolve(res) &#125;, err =&gt; &#123; reject(err) &#125;) &#125; &#125;) &#125; finally (cb) &#123; return this.then( value =&gt; MyPromise.resolve(cb()).then(() =&gt; value), reason =&gt; MyPromise.resolve(cb()).then(() =&gt; &#123; throw reason &#125;) ); &#125;&#125; Promise实现每隔一秒输出1，2，3，4，5 123456789101112131415161718192021// Promise.all()var arr = []var output = (i) =&gt; new Promise(res =&gt; &#123; setTimeout(()=&gt;&#123; console.log(i) res() &#125;, 1000*i)&#125;)for (var i=0; i&lt;5; i++) &#123; arr.push(output(i))&#125;Promise.all(arr).then(()=&gt; console.log(5))// async awaitvar sleep = () =&gt; new Promise (res =&gt; setTimeout(res, 1000))(async function () &#123; for (let i=0; i&lt;5; i++) &#123; await sleep() console.log(i) &#125;&#125;)() 扩展阅读： Promise实现原理（附源码） GeneratorGenerator 函数有多种理解角度。从语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator函数内部的每一个状态。形式上，Generator 函数是一个普通函数，但是有两个特征。一是， function关键字与函数名之间有一个星号；二是，函数体内部使用yield 表达式，定义不同的内部状态。 12345678910function* helloWorldGenerator() &#123; yield 'hello'; yield 'world'; return 'ending';&#125;var hw = helloWorldGenerator();hw.next(); // &#123; value: 'hello', done: false &#125;hw.next(); // &#123; value: 'world', done: false &#125;hw.next(); // &#123; value: 'ending', done: true &#125; 这个例子中，调用helloWorldGenerator函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的next方法，就会返回一个有着 value 和done 两个属性的对象。 value 属性表示当前的内部状态的值，是yield 表达式后面那个表达式的值； done属性是一个布尔值，表示是否遍历结束。遍历器对象的next方法的运行逻辑如下。 （1）遇到yield 表达式，就暂停执行后面的操作，并将紧跟在 yield 后面的那个表达式的值，作为返回的对象的 value属性值。 （2）下一次调用 next方法时，再继续往下执行，直到遇到下一个 yield表达式。 （3）如果没有再遇到新的yield表达式，就一直运行到函数结束，直到 return 语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。 （4）如果该函数没有return语句，则返回的对象的value 属性值为undefined。 yield表达式与return语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值。区别在于每次遇到yield，函数暂停执行，下一次再从该位置继续向后执行，而return语句不具备位置记忆的功能。一个函数里面，只能执行一次（或者说一个） return语句，但是可以执行多次（或者说多个）yield表达式。正常函数只能返回一个值，因为只能执行一次return ；Generator 函数可以返回一系列的值，因为可以有任意多个yield 。 Generator 函数返回一个遍历器对象，所以可以直接用for...of语句对 Generator 函数进行遍历： 123456789101112131415161718var arr = [1, [[2, 3], 4], [5, 6]];var flat = function* (a) &#123; var length = a.length; for (var i = 0; i &lt; length; i++) &#123; var item = a[i]; if (typeof item !== 'number') &#123; yield* flat(item); &#125; else &#123; yield item; &#125; &#125; &#125;;for (var f of flat(arr)) &#123; console.log(f);&#125;// 1 2 3 4 5 6 yield表达式本身没有返回值，或者说总是返回undefined。next 方法可以带一个参数，该参数就会被当作上一个 yield 表达式的返回值。 12345678910function* f() &#123; for (var i = 0; true; i++) &#123; var reset = yield i; if (reset) &#123; i = -1; &#125; &#125;&#125;var g = f();g.next(); // &#123; value: 0, done: false &#125;g.next(); // &#123; value: 1, done: false &#125;g.next(true); // &#123; value: 0, done: false &#125; 上面代码先定义了一个可以无限运行的 Generator 函数f，如果next方法没有参数，每次运行到 yield 表达式，变量reset的值总是undefined。当next方法带一个参数true时，变量reset就被重置为这个参数（即true），因此i会等于-1，下一轮循环就会从-1开始递增。 next 方法传参这个功能有很重要的语法意义。Generator 函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过 next方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值。也就是说，可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。 下面看看如何使用 Generator 函数，执行一个真实的异步任务: 12345678910111213141516var fetch = require('node-fetch');function* gen()&#123; var url = 'https://api.github.com/users/github'; var result = yield fetch(url); console.log(result.bio);&#125;var g = gen();var result = g.next();result.value.then(function(data)&#123; return data.json();&#125;).then(function(data)&#123; g.next(data);&#125;); 上面代码中，首先由var g = gen();执行 Generator 函数，获取遍历器对象，然后使用next 方法，执行异步任务的第一阶段。由于 Fetch 模块返回的是一个 Promise 对象，因此要用then 方法调用下一个next 方法。 async 和 awaitasync函数就是 Generator 函数的语法糖。 虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便。如果要Generator 函数自动执行，一般会用co模块。而async 函数自带执行器。也就是说， async 函数的执行，与普通函数一模一样。 async 和 await ，比起星号和 yield ，语义更清楚了。 async 表示函数里有异步操作， await 表示紧跟在后面的表达式需要等待结果。并且async 函数的返回值是 Promise 对象。 123456789101112function timeout(ms) &#123; return new Promise(resolve =&gt; &#123; setTimeout(resolve, ms); &#125;);&#125;async function asyncPrint(value, ms) &#123; await timeout(ms); console.log(value);&#125;asyncPrint('hello world', 50); 上面代码指定50毫秒以后，输出hello world。正常情况下，await命令后面是一个 Promise 对象。如果不是，会被转成一个立即resolve的 Promise 对象。 async 函数返回一个 Promise 对象。async 函数内部return语句返回的值，会成为then 方法回调函数的参数。 123456async function f() &#123; return 'hello';&#125;f().then(v =&gt; console.log(v));// hello 123456789async function asyncFunc() &#123; const result = await otherAsyncFunc(); console.log(result);&#125; // 等价于:function asyncFunc() &#123; return otherAsyncFunc().then(result =&gt; &#123; console.log(result); &#125;);&#125; 扩展阅读： promise、async和await之执行顺序的那点事 Set 和 MapES6 提供了新的数据结构 Set 和 Map。 Set 类似于数组，但是成员的值都是唯一的，没有重复的值。 Set内部判断两个值是否不同，使用的算法叫做“Same-value equality”，它类似于精确相等运算符（ === ），主要的区别是 NaN 等于自身，而精确相等运算符认为 NaN 不等于自身。 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。 1[...new Set(array)] // 一行代码数组去重 JS中prototype、__proto__、supert分别是什么每个对象都有一个__proto__属性，指向对应构造函数的原型对象。 每个函数都有一个prototype属性，指向函数的原型对象。 Class同时拥有__proto__和prototype属性。 Class通过extend继承后： 子类的__proto__属性表示构造函数的继承，指向父类 子类的prototype属性的__proto__属性表示方法的继承，总是指向父类的prototype属性 在子类中，super关键字代表父类实例。子类实例的构建基于对父类实例的加工，只有super方法才能返回父类实例。子类没有this对象，通过继承父类this对象（即super），然后对其进行加工。 Web安全 XSS XSS是跨站脚本攻击（Cross-Site Scripting）的简称。它允许恶意web用户将代码植入到提供给其它用户使用的页面中。XSS分为很多种，比较常见的两种是基于反射的 XSS攻击 、基于存储的XSS攻击。 基于反射的 XSS攻击 一般是通过给别人发送带有恶意脚本代码参数的 URL，当 URL 地址被打开时，特有的恶意代码参数被 HTML 解析、执行。 举一个例子，比如你的 Web 页面中包含有以下代码： 1234567891011Select your language:&lt;select&gt; &lt;script&gt; document.write('' + '&lt;option value=1&gt;' + location.href.substring(location.href.indexOf('default=') + 8) + '&lt;/option&gt;' ); document.write('&lt;option value=2&gt;English&lt;/option&gt;'); &lt;/script&gt;&lt;/select&gt; 攻击者可以直接通过 URL (类似：https://xx.com/xx?default=alert(document.cookie)注入可执行的脚本代码。 为了防止出现基于反射的 XSS攻击，需要确保这么几件事情： Web 页面渲染的所有内容或者渲染的数据都必须来自于服务端。 尽量不要从 URL，document.referrer，document.forms 等这种 DOM API 中获取数据直接渲染。 尽量不要使用 eval, new Function()，document.write()，document.writeln()，window.setInterval()，window.setTimeout()，innerHTML，document.creteElement() 等可执行字符串的方法。 如果做不到以上几点，也必须对涉及 DOM 渲染的方法传入的字符串参数做 escape 转义。 前端渲染的时候对任何的字段都需要做 escape 转义编码。 基于存储的XSS攻击 一般存在于 Form 表单提交等交互功能，如发帖留言，提交文本信息等，黑客利用的 XSS 漏洞，将内容经正常功能提交进入数据库持久保存，当前端页面获得后端从数据库中读出的注入代码时，恰好将其渲染执行。 比如你发了一篇文章，里面包含恶意脚本： 1你好！当你看到这段文字时，你的信息已经不安全了！&lt;script&gt;alert('xss')&lt;/script&gt; 后端没有对文章进行过滤，直接保存文章内容到数据库。当其他读者看这篇文章的时候，包含的恶意脚本就会执行。 为了防止基于存储的XSS攻击，需要前后端共同努力： 后端在入库前应该选择不相信任何前端数据，将所有的字段统一进行转义处理。 后端在输出给前端数据统一进行转义处理。 前端在渲染页面 DOM 的时候应该选择不相信任何后端数据，任何字段都需要做转义处理。 CSRF 跨站请求伪造 CSRF（Cross-site request forgery），是一种对网站的恶意利用。CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。 完成 CSRF 攻击必须要有三个条件： 用户已经登录了站点 A，并在本地记录了 cookie 在用户没有登出站点 A 的情况下（也就是 cookie 生效的情况下），访问了恶意攻击者提供的引诱危险站点 B (B 站点要求访问站点A)。 站点 A 没有做任何 CSRF 防御 如何预防： 正确使用 GET，POST 请求和 cookie 在非 GET 请求中增加 token 为每个用户生成一个唯一的 cookie token，所有表单都包含同一个伪随机值，这种方案最简单，因为攻击者不能获得第三方的 cookie(理论上)，所以表单中的数据也就构造失败，但是由于用户的 cookie 很容易由于网站的 XSS 漏洞而被盗取，所以这个方案必须要在没有 XSS 的情况下才安全。 每个 POST 请求使用验证码，这个方案算是比较完美的，但是需要用户多次输入验证码，用户体验比较差，所以不适合在业务中大量运用。 渲染表单的时候，为每一个表单包含一个 csrfToken，提交表单的时候，带上 csrfToken，然后在后端做 csrfToken 验证。 扩展阅读： 常见 Web 安全攻防总结 Web安全的三个攻防姿势 聊一聊WEB前端安全那些事儿 前端安全系列（一）：如何防止XSS攻击？ 前端安全系列之二：如何防止CSRF攻击？ 尾调用优化尾调用指某个函数的最后一步是调用另一个函数。尾调用不一定出现在函数尾部，只要是最后一步操作即可。 123456789101112131415161718192021// tail callfunction f() &#123; return g(x);&#125;function f3(x) &#123; if (x &gt; 0) &#123; return m(x); &#125; return n(x);&#125;// these are not tail callsfunction f1() &#123; let y = g(x); return y;&#125;function f2() &#123; return g(x) + 1;&#125; 函数调用会在内存形成一个”调用记录”，又称”调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用记录上方，还会形成一个B的调用记录。等到B运行结束，将结果返回到A，B的调用记录才会消失。如果函数B内部还调用函数C，那就还有一个C的调用记录栈，以此类推。所有的调用记录，就形成一个”调用栈”（call stack）。 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。 这就叫做”尾调用优化”（Tail call optimization），即只保留内层函数的调用记录。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用记录只有一项，这将大大节省内存。这就是”尾调用优化”的意义。 递归非常耗费内存，因为需要同时保存成千上百个调用记录，很容易发生”栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用记录，所以永远不会发生”栈溢出”错误。 123456789101112131415161718192021// recursive without tail callfunction factorial(x) &#123; if (x &lt;= 0) &#123; return 1; &#125; else &#123; return x * factorial(x-1); // (A) &#125;&#125;// tail recursivefunction factorial(n) &#123; return facRec(n, 1);&#125;function facRec(x, acc) &#123; if (x &lt;= 1) &#123; return acc; &#125; else &#123; return facRec(x-1, x*acc); &#125;&#125; ES6的尾调用优化只在严格模式下开启，正常模式是无效的。 参考文章： 尾调用优化 Tail call optimization in ECMAScript 6 柯里化柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。 1234567891011// ES5function curry(fn) &#123; var args = [].slice.call(arguments, 1); return function() &#123; var newArgs = args.concat([].slice.call(arguments)); return fn.apply(this, newArgs); &#125;;&#125;// ES6const curry = ( fn, arr = []) =&gt; (...args) =&gt; ( a =&gt; a.length === fn.length? fn(...a) : curry(fn, a))([...arr, ...args]) 扩展阅读： JavaScript专题之函数柯里化 函数式编程之柯里化与反柯里化 js 中的多个连续的箭头函数与柯里化 bind()函数的实现bind()方法创建一个新的函数， 当这个新函数被调用时其this置为提供的值，其参数列表前几项置为创建时指定的参数序列。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253if (!Function.prototype.bind) &#123; Function.prototype.bind = function (oThis) &#123; if (typeof this !== 'function') &#123; throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable'); &#125; // 获取 bind 中传入的参数 var aArgs = Array.prototype.slice.call(arguments, 1), // this 指向调用 bind 的对象 fToBind = this, fNOP = function () &#123;&#125;, fBound = function () &#123; // this instanceof fNOP === true 时,说明返回的 fBound 被当做 new 的构造函数调用 // fToBind 指向调用bind的函数, 这里的 this 是bind函数被调用后，返回的新函数中的this return fToBind.apply(this instanceof fNOP ? this : oThis, // 获取调用时(fBound)的传参.bind 返回的函数入参往往是这么传递的 aArgs.concat(Array.prototype.slice.call(arguments))); &#125;; // 维护原型关系 if (this.prototype) &#123; fNOP.prototype = this.prototype; &#125; // 下行的代码使fBound.prototype是fNOP的实例,因此 // 返回的fBound若作为new的构造函数,new生成的新对象作为this传入fBound,新对象的__proto__就是fNOP的实例 fBound.prototype = new fNOP(); return fBound; &#125;&#125;// 简化版本Function.prototype.bind2 = function(context) &#123; if(typeof this !== 'function') &#123; throw new TypeError('Error') &#125; const that = this // 保留之前的参数，为了下面的参数拼接 const args = [...arguments].slice(1) return function F() &#123; // 如果被new创建实例，不会被改变上下文！ if(this instanceof F) &#123; return new that(...args, ...arguments) &#125; // args.concat(...arguments): 拼接之前和现在的参数 // 注意：arguments是个类Array的Object, 用解构运算符..., 直接拿值拼接 return that.apply(context, args.concat(...arguments)) &#125;&#125; 12345678function foo() &#123; this.b = 100; return this.a;&#125;var func = foo.bind(&#123;a: 1&#125;);func(); // 1new func(); // foo &#123; b: 100 &#125; 参考文章： Function.prototype.bind() 手写bind()函数，理解MDN上的标准Polyfill JavaScript深入之bind的模拟实现 扩展阅读： JavaScript深入之call和apply的模拟实现 防抖和节流防抖（debounce） 函数去抖就是对于一定时间段的连续的函数调用，只让其执行一次，把触发非常频繁的事件（比如按键）合并成一次执行。 123456789101112131415161718// 第一种function debounce(method, context) &#123; clearTimeout(method.tId); method.tId = setTimeout(function () &#123; method.call(context); &#125;, 100);&#125;// 第二种function debounce(fn) &#123; let timeout = null; // 创建一个标记用来存放定时器的返回值 return function () &#123; clearTimeout(timeout); // 每当用户输入的时候把前一个 setTimeout clear 掉 timeout = setTimeout(() =&gt; &#123; // 然后又创建一个新的 setTimeout, 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数 fn.apply(this, arguments); &#125;, 500); &#125;;&#125; 应用场景： 每次 resize/scroll 触发统计事件 文本输入的验证（连续输入文字后发送 AJAX 请求进行验证，验证一次就好） 节流（throttle） 函数节流背后的基本思想是指，保证每 X 毫秒恒定的执行次数，比如每200ms检查下滚动位置，并触发 CSS 动画。 1234567891011function throttle(fn, interval = 300) &#123; let canRun = true; return function () &#123; if (!canRun) return; canRun = false; setTimeout(() =&gt; &#123; fn.apply(this, arguments); canRun = true; &#125;, interval); &#125;;&#125; 应用场景： DOM 元素的拖拽功能实现（mousemove） 射击游戏的 mousedown/keydown 事件（单位时间只能发射一颗子弹） 计算鼠标移动的距离（mousemove） Canvas 模拟画板功能（mousemove） 搜索联想（keyup） 监听滚动事件判断是否到页面底部自动加载更多：给 scroll 加了 debounce 后，只有用户停止滚动后，才会判断是否到了页面底部；如果是 throttle 的话，只要页面滚动就会间隔一段时间判断一次 扩展阅读： 实例解析防抖动（Debouncing）和节流阀（Throttling） 函数节流与函数防抖 JavaScript专题之跟着underscore学防抖 JavaScript专题之跟着 underscore 学节流 CommonJS、AMD和CMD三者都是JavaScript模块化的规范。CommonJS是针对后端；AMD和CMD是针对前端。 CommonJS 在CommonJS中，通过require()加载模块，exports对象用于导出当前模块的方法或变量，是唯一的导出口；module对象就代表模块本身。 在node编译过程中，会对JavaScript内容进行头尾包装:(function (exports, require, module, __filename, __dirname) { // 代码 })，这样每个模块文件中就都存在着require、exports、module这3个变量。 这种写法适合服务端，因为在服务器读取模块都是在本地磁盘，加载速度很快。但是如果在客户端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于”假死”状态。 因此，浏览器端的模块，不能采用”同步加载”（synchronous），只能采用”异步加载”（asynchronous）。这就是AMD规范诞生的背景。 AMD AMD是”Asynchronous Module Definition”的缩写，意思就是”异步模块定义”。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。 1define(['dep1','dep2'],function(dep1,dep2)&#123;...&#125;); AMD中依赖前置，js可以方便知道依赖模块是谁，立即加载。 CMD CMD是 “Common Module Definition” 的缩写， 是seajs推崇的规范，CMD则是依赖就近，用的时候再require。它写起来是这样的： 1define(function(require,exports,module)&#123;...&#125;); 与AMD模块规范相比，CMD模块更接近于Node对CommonJS规范的定义。 参考文章： Javascript模块化编程（二）：AMD规范 ES6模块CommonJS模块的区别ES6 模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以 及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。 比如，CommonJS 模块就是对象，输入时必须查找对象属性。 1234567// CommonJS模块let &#123; start, exists, readFile &#125; = require('fs');// 等同于let _fs = require('fs');let start = _fs.start;let exists = _fs.exists;let readFile = _fs.readFile; 上面代码的实质是整体加载 fs 模块（即加载 fs 的所有方法），生成一个对象 （_fs ），然后再从这个对象上面读取3个方法。这种加载称为“运行时加载”，因 为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。 ES6 模块不是对象，而是通过 export命令显式指定输出的代码，再通过 import 命令输入。 1import &#123; start, exists, readFile &#125; from 'fs'; 上面代码的实质是从 fs 模块加载3个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。 由于 ES6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠 静态分析实现的功能。 除了静态加载带来的各种好处，ES6 模块还有以下好处: 不再需要 UMD 模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目 前，通过各种工具库，其实已经做到了这一点。 将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者 navigator 对象的属性。 不再需要对象作为命名空间（比如 Math 对象），未来这些功能可以通过模块 提供。 clientWidth、offsetWidth和scrollWidth区别偏移量 偏移量包括元素在屏幕上占用的所有可见空间。元素的可见大小由其高度和宽度决定，包括所有内边距、滚动条和边框大小（注意，不包括外边距）。 offsetHeight：元素在垂直方向上占用的空间大小，以像素计。包括元素的高度、（可见的）水平滚动条的高度、上下边框的高度 offsetWidth：元素在水平方向上占用的空间大小，以像素计。包括元素的宽度、（可见的）垂直滚动条的宽度、左右边框的宽度 offsetLeft：元素的左外边框至包含元素的左内边框之间的像素距离 offsetTop：元素的上边框至包含元素的上内边框之间的像素距离 客户区大小 元素的客户区大小，指的是元素内容及其内边距所占据的空间大小（注意，不包括边框）。 clientWidth属性是元素内容区宽度加上左右内边距宽度； clientHeight属性是元素内容区高度加上上下内边距的高度。 滚动大小 滚动大小指的是包含滚动内容的元素的大小。 scrollHeight：在没有滚动条的情况下，元素内容的总高度 scrollWidth：在没有滚动条的情况下，元素内容的总宽度 scrollLeft：被隐藏在内容区域左侧的像素数。通过设置这个属性可以改变元素的滚动位置 scrollTop：被隐藏在内容区域上方的像素数。通过设置这个属性可以改变元素的滚动位置 innerHTML 、 innerText 、 outerHTML 和 outerText 区别innerHTML：从对象的起始位置到终止位置的全部内容,包括Html标签。innerText：从起始位置到终止位置的内容,但它去除Html标签。 outerHTML：除了包含innerHTML的全部内容外, 还包含对象标签本身。 outerText：设置(包括标签)或获取(不包括标签)对象的文本。 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p id="p1"&gt;hello &lt;/p&gt;&lt;p id="p2"&gt; &lt;span&gt;hey &lt;/span&gt;&lt;/p&gt;&lt;script&gt; var p1 = document.getElementById('p1'); var p2 = document.getElementById('p2'); console.log(p1.innerHTML); console.log(p1.outerHTML); console.log(p1.innerText); console.log(p1.outerText); console.log(p2.innerHTML); console.log(p2.outerHTML); console.log(p2.innerText); console.log(p2.outerText);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在Chrome69.0.3497.100中打印结果如下： 1234567891011hello &lt;p id="p1"&gt;hello &lt;/p&gt;hellohello &lt;span&gt;hey &lt;/span&gt;&lt;p id="p2"&gt; &lt;span&gt;hey &lt;/span&gt;&lt;/p&gt;heyhey 在Firefox38.6.1中打印结果如下： 123456789101112"hello ""&lt;p id="p1"&gt;hello &lt;/p&gt;" undefinedundefined" &lt;span&gt;hey &lt;/span&gt;""&lt;p id="p2"&gt; &lt;span&gt;hey &lt;/span&gt;&lt;/p&gt;"undefinedundefined innerHTML与outerHTML在设置对象的内容时包含的HTML会被解析，而innerText与outerText则不会。 在设置时，innerHTML与innerText仅设置标签内的文本，而outerHTML与outerText设置包括标签在内的文本。 innerHTML是符合W3C标准的属性，尽可能地去使用innerHTML，而少用innerText 。 Object.assign()Object.assign() 方法用于将所有可枚举属性（自有属性）的值从一个或多个源对象复制到目标对象。它将返回目标对象。 如果目标对象中的属性具有相同的键，则属性将被源中的属性覆盖。后来的源的属性将类似地覆盖早先的属性。 12345678const object1 = &#123; a: 1, b: 2, c: 3,&#125;;const object2 = Object.assign(&#123;c: 4, d: 5&#125;, object1);console.log(object2.c, object2.d); // 3 5 拷贝过程中将调用源对象的getter方法，并在target对象上使用setter方法实现目标对象的拷贝。 Object.assgin 只能深拷贝第一层, 深层的还是浅拷贝： 123456789101112const object3 = &#123; a: &#123; b: 1, &#125;, b: 1,&#125;;const object4 = Object.assign(&#123;c: 4, d: 5&#125;, object3);console.log(object4.a); // &#123; b: 1 &#125;object4.a.b = 2;console.log(object3.a.b); // 2 扩展阅读： ES6之Object.assign()详解 ES2015系列(二) 理解Object.assign forEach、Map 和 reduce 的区别forEach()：对数组的每个元素执行一次提供的函数（不会返回执行结果，只是修改原来的数组）。 map() ：创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。 reduce() ：对累计器和数组中的每个元素（从左到右）应用一个函数，将其简化为单个值。 123456789101112131415161718var array = [1, 2 , 3 , 4];array.forEach((value, index) =&gt; &#123; console.log(`NO.$&#123;index + 1&#125; value is $&#123;value&#125;`);&#125;);// NO.1 value is 1// NO.2 value is 2// NO.3 value is 3// NO.4 value is 4var array2 = array.map(value =&gt; value * 2);console.log(array2); // [ 2, 4, 6, 8 ]array2.push(5);console.log(array); // [ 1, 2, 3, 4 ]console.log(array2); // [ 2, 4, 6, 8, 5 ]var array3 = array.reduce((previousValue, currentValue) =&gt; previousValue + currentValue);console.log(array3); // 10 执行速度：reduce() &gt; map() &gt; forEach()（jsperf中测试用例测试结果）。 三者的实现： 123456789101112131415161718192021Array.prototype.map = function (fn) &#123; var resultArray = []; for (var i = 0,len = this.length; i &lt; len ; i++) &#123; resultArray[i] = fn.apply(this,[this[i],i,this]); &#125; return resultArray;&#125;Array.prototype.forEach = function (fn) &#123; for (var i = 0,len = this.length; i &lt; len ; i++) &#123; fn.apply(this,[this[i],i,this]); &#125;&#125;Array.prototype.reduce= function (fn) &#123; var formerResult = this[0]; for (var i = 1,len = this.length; i &lt; len ; i++) &#123; formerResult = fn.apply(this,[formerResult,this[i],i,this]); &#125; return formerResult;&#125; 参考文章： JavaScript中Map和ForEach的区别 如何形象地解释 JavaScript 中 map、foreach、reduce 间的区别？ 正则表达式 字符 描述 \ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“n”匹配字符“n”。“\n”匹配一个换行符。串行“\\”匹配“\”而“\(”则匹配“(”。 ^ 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\n”或“\r”之前的位置。 * 匹配前面的子表达式零次或多次。例如，zo能匹配“z”以及“zoo”。等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。 ? 匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“does”或“does”中的“do”。?等价于{0,1}。 {n} n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。 {n,} n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。 {n,m} m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。 ? 当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。 . 匹配除“\`n”之外的任何单个字符。要匹配包括“`n”在内的任何字符，请使用像“`(. \n)`”的模式。 (pattern) 匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$[Math Processing Error]0…$9属性。要匹配圆括号字符，请使用“\(”或“\)”。 (?:pattern) 匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“`( )”来组合一个模式的各个部分是很有用。例如“industr(?:y ies)”就是一个比“industry industries`”更简略的表达式。 (?=pattern) 正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“`Windows(?=95 98 NT 2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows`”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?!pattern) 正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“`Windows(?!95 98 NT 2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows`”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始 (?&lt;=pattern) 反向肯定预查，与正向肯定预查类拟，只是方向相反。例如，“`(?&lt;=95 98 NT 2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows`”。 (?&lt;!pattern) 反向否定预查，与正向否定预查类拟，只是方向相反。例如“`(?&lt;!95 98 NT 2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows`”。 x\ y 匹配x或y。例如，“`z food”能匹配“z”或“food”。“(z f)ood”则匹配“zood”或“food`”。 [xyz] 字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。 [^xyz] 负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“p”。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。 [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。 \b 匹配一个单词边界，也就是指单词和空格间的位置。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。 \B 匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。 \cx 匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。 \d 匹配一个数字字符。等价于[0-9]。 \D 匹配一个非数字字符。等价于[^0-9]。 \f 匹配一个换页符。等价于\x0c和\cL。 \n 匹配一个换行符。等价于\x0a和\cJ。 \r 匹配一个回车符。等价于\x0d和\cM。 \s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。 \S 匹配任何非空白字符。等价于[^ \f\n\r\t\v]。 \t 匹配一个制表符。等价于\x09和\cI。 \v 匹配一个垂直制表符。等价于\x0b和\cK。 \w 匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。 \W 匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。 \xn 匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“\x41”匹配“A”。“\x041”则等价于“\x04&amp;1”。正则表达式中可以使用ASCII编码。. \num 匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“(.)\1”匹配两个连续的相同字符。 \n 标识一个八进制转义值或一个向后引用。如果\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。 \nm 标识一个八进制转义值或一个向后引用。如果\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\nm将匹配八进制转义值nm。 \nml 如果n为八进制数字（0-3），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。 \un 匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\u00A9匹配版权符号（©）。 常用正则表达式: 用户名 /^[a-z0-9_-]{3,16}$/ 密码 /^[a-z0-9_-]{6,18}$/ 十六进制值 /^#?([a-f0-9]{6}\ [a-f0-9]{3})$/ 电子邮箱 /^([a-z0-9_.-]+)@([\da-z.-]+).([a-z.]{2,6})$[Math Processing Error]//^[a-z\d]+(.[a-z\d]+)*@(\da-z?)+(.{1,2}[a-z]+)+$/ URL /^(https?:\/\/)?([\da-z.-]+).([a-z.]{2,6})([\/\w .-])\/?$/ IP 地址 /((2[0-4]\d\ 25[0-5]\ [01]?\d\d?).){3}(2[0-4]\d\ 25[0-5]\ [01]?\d\d?)//^(?:(?:25[0-5]\ 2[0-4][0-9]\ [01]?[0-9][0-9]?).){3}(?:25[0-5]\ 2[0-4][0-9]\ [01]?[0-9][0-9]?)$/ HTML 标签 /^&lt;([a-z]+)([^&lt;]+)(?:&gt;(.)&lt;\/\1&gt;\ \s+\/&gt;)$/ 删除代码\注释 (?&lt;!http:\ \S)//.*$ Unicode编码中的汉字范围 /^[\u2E80-\u9FFF]+$/ 参考文章： 正则表达式手册 Fetch 和 Ajax的区别XMLHttpRequest 是一个设计粗糙的 API，不符合关注分离（Separation of Concerns）的原则，配置和调用方式非常混乱，而且基于事件的异步模型写起来也没有现代的 Promise，generator/yield，async/await 友好。 通常使用XHR发送一个请求是这样: 12345678910var xhr = new XMLHttpRequest();xhr.open('GET', url);xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123; console.log(JSON.parse(xhr.responseText)); &#125;&#125;;xhr.send(); 使用Fetch后是这样: 12345678fetch(url) .then(function (response) &#123; return response.json(); &#125;).then(function (data) &#123; console.log(data); &#125;).catch(function (e) &#123; console.log('error'); &#125;); 所以Fetch 优点主要有： 语法简洁，更加语义化 基于标准 Promise 实现，支持 async/await 同构方便，使用 isomorphic-fetch 不过Fetch还有一些坑，比如: Fetch 请求默认是不带 cookie 的，需要设置 fetch(url, {credentials: &#39;include&#39;}) 服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。 所有版本的IE均不支持原生Fetch 参考文章： Ajax 与 Fetch 的比较 node 中的EventEmitter怎么实现功能node 的events模块只提供了一个EventEmitter类，这个类实现了node异步事件驱动架构的基本模式——观察者模式，提供了绑定事件和触发事件等事件监听器模式一般都会提供的API： 1234567var eventEmitter = require('events').EventEmitter;var test = new eventEmitter();test.on('触发', function(data) &#123; console.log(data);&#125;)test.emit('触发', 'test') 观察者(Observer)模式是一种设计模式，应用场景是当一个对象的变化需要通知其他多个对象而且这些对象之间需要松散耦合时。在这种模式中，被观察者(主体)维护着一组其他对象派来(注册)的观察者，有新的对象对主体感兴趣就注册观察者，不感兴趣就取消订阅，主体有更新的话就依次通知观察者们。 1234567891011121314151617181920212223242526272829303132333435363738function Subject() &#123; this.listeners = &#123;&#125;&#125;Subject.prototype = &#123; // 增加事件监听器 addListener: function(eventName, callback) &#123; if(typeof callback !== 'function') throw new TypeError('"listener" argument must be a function') if(typeof this.listeners[eventName] === 'undefined') &#123; this.listeners[eventName] = [] &#125; this.listeners[eventName].push(callback) // 放到观察者对象中 &#125;, // 取消监听某个回调 removeListener: function(eventName, callback) &#123; if(typeof callback !== 'function') throw new TypeError('"listener" argument must be a function') if(Array.isArray(this.listeners[eventName]) &amp;&amp; this.listeners[eventName].length !== 0) &#123; var callbackList = this.listeners[eventName] for (var i = 0, len=callbackList.length; i &lt; len; i++) &#123; if(callbackList[i] === callback) &#123; this.listeners[eventName].splice(i,1) // 找到监听器并从观察者对象中删除 &#125; &#125; &#125; &#125;, // 触发事件：在观察者对象里找到这个事件对应的回调函数队列，依次执行 triggerEvent: function(eventName,...args) &#123; if(this.listeners[eventName]) &#123; for(var i=0, len=this.listeners[eventName].length; i&lt;len; i++)&#123; this.listeners[eventName][i](...args) &#125; &#125; &#125;&#125; 参考文章： 深入浅出Node.js（四）：Node.js的事件机制 认识node核心模块–深入EventEmitter 1234567891011var a = 1;var b = &#123; a: 2, m: function() &#123; console.log(this); return this.a++ + 1; &#125;&#125;;console.log(b.m());var p = Object.create(b);console.log(p.m()); 网络浏览器输入URL后发生了什么 在浏览器地址栏输入URL 浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤 如果资源未缓存，发起新请求 如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。 检验新鲜通常有两个HTTP头进行控制Expires和Cache-Control： HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期 HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大新鲜时间 浏览器解析URL获取协议，主机，端口，path 浏览器组装一个HTTP（GET）请求报文 浏览器获取主机ip地址，过程如下： 浏览器缓存 本机缓存 hosts文件 路由器缓存 ISP DNS缓存 DNS递归查询（可能存在负载均衡导致每次IP不一样） 打开一个socket与目标IP地址，端口建立TCP链接，三次握手如下： 客户端发送一个TCP的SYN=1，Seq=X的包到服务器端口 服务器发回SYN=1， ACK=X+1， Seq=Y的响应包 客户端发送ACK=Y+1， Seq=Z TCP链接建立后发送HTTP请求 服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序 服务器检查HTTP请求头是否包含缓存验证信息如果验证缓存新鲜，返回304等对应状态码 处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作 服务器将响应报文通过TCP连接发送回浏览器 浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下： 主动方发送Fin=1， Ack=Z， Seq= X报文 被动方发送ACK=X+1， Seq=Z报文 被动方发送Fin=1， ACK=X， Seq=Y报文 主动方发送ACK=Y， Seq=X报文 浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同 如果资源可缓存，进行缓存 对响应进行解码（例如gzip压缩） 根据资源类型决定如何处理（假设资源为HTML文档） 解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本，这些操作没有严格的先后顺序，以下分别解释 构建DOM树： Tokenizing：根据HTML规范将字符流解析为标记 Lexing：词法分析将标记转换为对象并定义属性和规则 DOM construction：根据HTML标记关系将对象组成DOM树 解析过程中遇到图片、样式表、js文件，启动下载 构建CSSOM树： Tokenizing：字符流转换为标记流 Node：根据标记创建节点 CSSOM：节点创建CSSOM树 根据DOM树和CSSOM树构建渲染树: 从DOM树的根节点遍历所有可见节点，不可见节点包括：1）script,meta这样本身不可见的标签。2)被css隐藏的节点，如display: none 对每一个可见节点，找到恰当的CSSOM规则并应用 发布可视节点的内容和计算样式 js解析如下： 浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时document.readystate为loading HTML解析器遇到没有async和defer的script时，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容 当解析器遇到设置了async属性的script时，开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载。异步脚本禁止使用document.write()，它们可以访问自己script和之前的文档元素 当文档完成解析，document.readState变成interactive 所有defer脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，禁止使用document.write() 浏览器在Document对象上触发DOMContentLoaded事件 此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，document.readState变为complete,window触发load事件 显示页面（HTML解析过程中会逐步显示页面） 参考文章： 细说浏览器输入URL后发生了什么 从浏览器地址栏输入url到显示页面的步骤(以HTTP为例) HTTPS中SSL握手过程开始加密通信之前，客户端和服务器首先必须建立连接和交换参数，这个过程叫做握手（handshake）。整个握手过程可以用下图说明。 握手阶段分成五步： 客户端给出协议版本号、一个客户端生成的 随机数（Client random），以及客户端支持的加密方法。 服务器确认双方使用的加密方法，并给出数字证书、以及一个 服务器生成的随机数（Server random）。 客户端确认数字证书有效，然后生成一个新的 随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给服务器。 服务器使用自己的私钥，获取客户端发来的随机数（即Premaster secret）。 客户端和服务器根据约定的加密方法，使用前面的三个随机数，生成 对话密钥（session key），用来加密接下来的整个对话过程。 参考文章： HTTPS详解 常见状态码200 OK：请求成功，请求所希望的响应头或数据体将随此响应返回 301 Moved Permanently：被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。 302 Found：请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。302重定向可能会有URL规范化及网址劫持的问题。可能被搜索引擎判为可疑转向，甚至认为是作弊。 304 Not Modified：如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304 响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。 400 Bad Request：语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求；请求参数有误。 403 Forbidden：服务器已经理解请求，但是拒绝执行它。与 401 响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个 404 响应，假如它不希望让客户端获得任何信息。 404 Not Found：请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。 500 Internal Server Error：服务器遇到了不知道如何处理的情况。 501 Not Implemented：此请求方法不被服务器支持且无法被处理。只有GET和HEAD是要求服务器支持的，它们必定不会返回此错误代码。 502 Bad Gateway：此错误响应表明服务器作为网关需要得到一个处理这个请求的响应，但是得到一个错误的响应。 504 Gateway Timeout：当服务器作为网关，不能及时得到响应时返回此错误代码。 参考文章： HTTP 响应代码 其他 一篇很有意思的文章：JavaScript实现倒计时 你真的知道怎么用javascript来写一个倒计时吗 ? React生命周期老版本中： 新版本中： React生命周期主要包括三个阶段：初始化阶段、运行中阶段和销毁阶段，在React不同的生命周期里，会依次触发不同的钩子函数。 扩展阅读： State &amp; 生命周期 图解ES6中的React生命周期 React 生命周期]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】Angular7 - CLI提示、虚拟滚动、拖放等]]></title>
    <url>%2F2018%2F10%2F20%2F%E3%80%90%E8%AF%91%E3%80%91Angular7%20-%20CLI%E6%8F%90%E7%A4%BA%E3%80%81%E8%99%9A%E6%8B%9F%E6%BB%9A%E5%8A%A8%E3%80%81%E6%8B%96%E6%94%BE%E7%AD%89%2F</url>
    <content type="text"><![CDATA[原文地址：Version 7 of Angular — CLI Prompts, Virtual Scroll, Drag and Drop and more Angular 7.0.0 release版本正式发布！这是跨整个平台的主要版本，包括核心框架，Angular Material和具有同步主要版本的CLI工具。此版本包含了工具链的一些新功能，并已经促成了几个主要合作伙伴的发布。 虚拟滚动可以提高应用程序的性能 如何更新到v7访问update.angular.io以获取有关更新应用程序的详细信息和指导，但由于我们在v6中所做的工作，更新到v7只需要一个命令： 1ng update @angular/cli @angular/core v7版本早期使用者报告说，升级速度比以往任何时候都快，许多应用程序的升级时间不到10分钟。 CLI提示现在，CLI将在运行诸如ng new或ng add @angular/material之类的常用命令时提示用户，以帮助你发现CLI内置的路由或支持SCSS等功能。 CLI提示已添加到Schematics中，因此任何发布Schematics的包都可以通过向Schematics集合添加x-prompt来利用它们。 123456"routing": &#123; "type": "boolean", "description": "Generates a routing module.", "default": false, "x-prompt": "Would you like to add Angular routing?"&#125;, 应用性能我们继续关注性能，我们分析了整个Angular生态系统中的常见错误。我们发现许多开发人员在生产环境中包含了reflect-metadata的polyfill，然而这只是在开发中需要的。 要解决此问题，v7版本的部分更新将自动从polyfills.ts文件中删除它，然后在JIT模式下构建应用程序时将其作为构建步骤包含在内，默认情况下从生成版本中删除此polyfill。 使用v7版本时，新项目会默认使用CLI中的Bundle Budgets。当初始 bundle 超过2MB，新应用程序将发出警告，超过5MB时将会报错。这些参数可以在angular.json中更改。 12345"budgets": [&#123; "type": "initial", "maximumWarning": "2mb", "maximumError": "5mb"&#125;] 这些budgets与利用Chrome Data Saver功能的用户可以看到的警告一致。 Chrome Data Saver Angular Material &amp; the CDKMaterial Design在2018年有了重大更新。更新到V7版本的Angular Material用户应该会看到反映Material Design规范更新的微小视觉差异。 Material Design更新了包括开发人员应该意识到的小变化 CDK的新用户现在可以通过导入DragDropModule或ScrollingModule来使用虚拟滚动和拖放。 虚拟滚动虚拟滚动基于列表的可见部分从DOM中加载和卸载元素，使得有可能为拥有非常大的可滚动列表的用户构建非常快速的体验。 123&lt;cdk-virtual-scroll-viewport itemSize="50" class="example-viewport"&gt; &lt;div *cdkVirtualFor="let item of items" class="example-item"&gt;&#123;&#123;item&#125;&#125;&lt;/div&gt;&lt;/cdk-virtual-scroll-viewport&gt; 阅读更多关于虚拟滚动的信息 拖放在示例仪表板上的拖放功能 CDK现在支持拖放功能，并且包括当用户移动元素时的自动渲染、用于列表重新排序( moveItemInArray )和在列表之间移动元素( transferrarrayitem)的辅助方法。 123&lt;div cdkDropList class="list" (cdkDropListDropped)="drop($event)"&gt; &lt;div class="box" *ngFor="let movie of movies" cdkDrag&gt;&#123;&#123;movie&#125;&#125;&lt;/div&gt;&lt;/div&gt; 123drop(event: CdkDragDrop&lt;string[]&gt;) &#123; moveItemInArray(this.movies, event.previousIndex, event.currentIndex);&#125; 阅读更多关于拖放的信息 提高Selects的可访问性通过在mat-form-field中使用原生select元素来提高应用程序的可访问性。原生select具有一些性能、可访问性和可用性优势，但是我们保留mat-select，它可以完全控制选项的呈现。 了解有关mat-select和mat-form-field字段的更多信息。 Angular ElementsAngular Elements现在支持对自定义元素使用web标准进行内容投影。 1&lt;my-custom-element&gt;This content can be projected!&lt;/my-custom-element&gt; 合作伙伴发布Angular的成功很大程度上归功于社区，为此，我们一直在与最近启动的几个社区项目合作。 StackBlitz 2.0支持多窗口编辑和Angular Language Service Angular Console — 一个可下载的控制台，用于在本地机器上启动和运行Angular项目 @angular/fire — AngularFire在NPM上有了一个新的家，并首次为Angular发布了稳定的版本 NativeScript — 现在可以使用NativeScript一套代码适配Web端和移动端 StackBlitz — StackBlitz 2.0 已经发布，现在包括了 Angular Language Service和更多的功能，比如多个Tab页同时编辑 文档更新我们一直在努力改进我们的指南和参考资料。关于Angula.io的文档现在包括了Angular CLI的参考资料。 依赖更新我们更新了对主要第三方项目的依赖。 TypeScript 3.1 RxJS 6.3 Node 10 — 我们增加了对Node 10的支持，并且仍然支持Node 8 Ivy呢？我们一直在继续致力于一项名为Ivy的新计划——我们的下一代渲染管道。Ivy目前正在积极开发中，并不是V7版本的一部分。我们已经开始用现有应用程序来验证向后的兼容性，并将在未来几个月内，一旦Ivy准备就绪，就发布可选择Ivy的预览版。]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Angular中使用JWT认证]]></title>
    <url>%2F2018%2F09%2F07%2F%E5%9C%A8Angular%E4%B8%AD%E4%BD%BF%E7%94%A8JWT%E8%AE%A4%E8%AF%81%2F</url>
    <content type="text"><![CDATA[项目地址: grading-system 基于session的认证和基于token的认证的方式已经被广泛使用。在session认证中，服务端会存储一份用户登录信息，这份登录信息会在响应时传递给浏览器并保存为Cookie，在下次请求时，会带上这份登录信息，这样就能识别请求来自哪个用户。 在基于session的认证中，每个用户都要生成一份session，这份session通常保存在内存中，随着用户量的增加，服务端的开销会增大，而且对分布式应用不是很友好。 在token认证中，服务端不需要保留用户认证信息。当用户登录时，服务器验证用户信息后会返回一个token，这个token存储在客户端，并且在每次请求的请求头中都带上这个token，这样服务端验证token后就可以返回数据。 JWT（JSON Web Token）是一个开放标准（RFC 7519），它定义了一种紧凑且独立的方式，可以在各方之间作为JSON对象安全地传输信息。 此信息可以通过数字签名进行验证和信任。特别适用于分布式站点的单点登录（SSO）场景。 JWT的构成JWT由.分隔的三个部分组成，它们是： 头部（Header） 荷载（Playload） 签名（Signature） 也就是说，JWT只是一个具有以下格式的字符串： 1header.payload.signature 头部头部通常由两部分组成：令牌的类型（即JWT）以及正在使用的散列算法，例如HMAC SHA256或RSA。 1234&#123; "alg": "HS256", "typ": "JWT"&#125; 然后，对这个JSON进行Base64编码，形成JWT的第一部分。 1ewogICJhbGciOiAiSFMyNTYiLAogICJ0eXAiOiAiSldUIgp9 荷载JWT的第二部分是荷载，其中包含声明。 声明是关于实体（通常是用户）和其他数据的声明。声明有三种：注册的声明、公开的声明和私有的声明。 JWT规范定义了七个在标准中注册的声明名称，它们是： iss： JWT签发者 sub： JWT所面向的用户 aud：接收JWT的一方 exp：JWT的过期时间，这个过期时间必须要大于签发时间 nbf：定义在什么时间之前，该JWT都是不可用的. iat： JWT的签发时间 jti： JWT的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。 对于特定情况，可以使用公共的声明名称。 这些包括： auth_time：身份验证发生的时间 acr：认证上下文类的引用 nonce：用于将客户端会话与ID Token关联的值 最后，还有私有的声明名称，可以使用它们来传达与身份相关的信息，例如姓名或部门。 由于公共和私人的声明未注册，请注意避免名称冲突。 比如，我们定义一个palyload: 123456&#123; "sub": "1234567890", "name": "tc9011", "admin": true, "exp": 1441594722&#125; 然后将其进行base64加密，得到JWT的第二部分: 1ewogICJzdWIiOiAiMTIzNDU2Nzg5MCIsCiAgIm5hbWUiOiAidGM5MDExIiwKICAiYWRtaW4iOiB0cnVlLAogICJleHAiOiAxNDQxNTk0NzIyCn0= 签名签名由base64编码后的头、base64编码后的荷载和secret组成。 例如，将上面的两个编码后的字符串都用句号.连接在一起（头部在前），就形成了： 1ewogICJhbGciOiAiSFMyNTYiLAogICJ0eXAiOiAiSldUIgp9.ewogICJzdWIiOiAiMTIzNDU2Nzg5MCIsCiAgIm5hbWUiOiAidGM5MDExIiwKICAiYWRtaW4iOiB0cnVlLAogICJleHAiOiAxNDQxNTk0NzIyCn0= 然后，将上面拼接完的字符串用secret作为秘钥进行HS256加密。 1234HMACSHA256( base64UrlEncode(header) + "." + base64UrlEncode(payload), secret) 使用JWT一般在会在请求头中加入Authorization，并加上Bearer进行标注： 12345fetch('api/v1/user/1', &#123; headers: &#123; 'Authorization': 'Bearer ' + token &#125;&#125;) 服务端会验证token，如果验证通过就会返回相应的资源。 不过要注意，因为荷载是base64编码，这种编码可以对称解密，所以在荷载中不应该存放用户的敏感信息，比如密码。所以一般JWT用来向Web传递一些非敏感信息，例如用户名、所属部门等。 在Angular中使用JWT这里我们以Angular6和koa2（使用TypeScript）为例，介绍一下如何在你的Angular应用中使用JWT。 服务端首先在jwt.io官网上找到node的JWT的库：jsonwebtoken。 可以看到官网把这个库对标准注册声明字段的支持情况以及加密方式的支持情况都列出来了。除了这个库，还需要使用koa一个中间件：koa-jwt，用来对HTTP请求进行JWT认证。你可以通过下面命令安装这两个库： 1npm i koa-jwt jsonwebtoken --save 在app.ts中： 1234567import * as jwt from 'koa-jwt';app.use(jwt(&#123; secret: Secret &#125;).unless(&#123; path: [/\/register/, /\/login/, /\/groups/], &#125;)); 这里的secret就是你自己定义的秘钥，unless方法用来排除一些不需要进行JWT认证的api。koa-jwt中间件需要放在路由中间件之前，这样就可以对所有路由（除了unless中设置的路由外）进行JWT的检查。只有正确之后才能正确的访问。 除此之外，你还要自定义一个401错误处理的中间件，如果没有token，或者token失效，该中间件会给出对应的错误信息。如果没有自定义中间件的话，会直接将 koa-jwt 暴露的错误信息直接返回给用户。 12345678910export const errorHandle = (ctx, next) =&gt; &#123; return next().catch((err) =&gt; &#123; if (err.status === 401) &#123; ctx.status = 401; handleError(&#123;ctx, message: '登录过期，请重新登录', err: err.originalError ? err.originalError.message : err.message&#125;); &#125; else &#123; throw err; &#125; &#125;);&#125;; 然后把这个中间件放在koa-jwt之前： 1234567app.use(errorHandle);app.use(jwt(&#123; secret: Secret&#125;).unless(&#123; path: [/\/register/, /\/login/, /\/groups/],&#125;)); 在用户登陆时候，生成token，返回给客户端： 123456789101112131415161718192021// 生成 token 返回给客户端const token = jsonwebtoken.sign(&#123; user: &#123; workNumber: user.workNumber, realName: user.realName, group: user.group, role: user.role &#125;, // 设置 token 过期时间 exp: Math.floor(Date.now() / 1000) + (60 * 60 * 24), // 1天&#125;, Secret);handleSuccess(&#123; ctx, message: '登陆成功!', response: &#123; token, lifeTime: Math.floor(Date.now() / 1000) + (60 * 60 * 24) // 1天 &#125;&#125;); 需要注意的是，在使用 jsonwebtoken.sign() 时，需要传入的 secret 参数，这里的 secret 必须要与 前面设置 jwt() 中的 secret 一致。 客户端在Angular中，我们需要使用@auth0/angular2-jwt这个库来帮助我们在Angular中处理JWT: 1npm install @auth0/angular-jwt --save 在app.module.ts中引入JwtModule这个模块（注意，引入该模块的同时也要引入HttpClientModule模块）： 12345678910111213141516171819202122import &#123; JwtModule &#125; from '@auth0/angular-jwt';import &#123; HttpClientModule &#125; from '@angular/common/http';export function tokenGetter() &#123; return localStorage.getItem('token');&#125;@NgModule(&#123; bootstrap: [AppComponent], imports: [ // ... HttpClientModule, JwtModule.forRoot(&#123; config: &#123; tokenGetter: tokenGetter, whitelistedDomains: ['localhost:3001'], blacklistedRoutes: ['localhost:3001/auth/'] &#125; &#125;) ]&#125;)export class AppModule &#123;&#125; 在JwtModule的config中： tokenGetter：从localStorage中获取token； whitelistedDomains：允许发送认证的请求的域名； blacklistedRoutes：你不希望替换header中Authorization信息的api列表。 接着创建一个全局的auth.service.ts服务，方便在登陆的时候获取用户相关信息及权限，这个服务中有个login方法，用来处理登陆后返回的token信息，并把token存到LocalStorage中，这样在token失效前，下次用户登陆时就不需要输入用户名和密码： 12345678910111213login(loginInfo: LoginInfo): Observable&lt;boolean&gt; &#123; return this.passportService.postLogin(loginInfo).pipe(map( (res: LoginRes) =&gt; &#123; // 登陆成功后获取token，并存到localStorage this.storageService.setLocalStorage('token', res.token); const decodedUser = this.decodeUserFromToken(res.token); this.setCurrentUser(decodedUser); this.msg.success('登录成功!'); return this.loggedIn; &#125; ) );&#125; 在这个login方法中，decodeUserFromToken封装了@auth0/angular2-jwt中提供的decodeToken方法，注意decodeToken方法解析出来的只是服务端jsonwebtoken.sign()中的JSON对象，所以需要通过.操作获取jsonwebtoken.sign()中定义的user： 123decodeUserFromToken(token): User &#123; return this.jwtHelperService.decodeToken(token).user;&#125; 在这个服务中，定义了两个变量loggedIn和isAdmin，用来标识用户是否登录和其相应的权限，方便在Angular路由中控制可以访问的视图。 有登录当然就有登出，登出时只需把token从LocalStorage中移除，并把几个变量重置即可： 123456logout(): void &#123; this.storageService.removeLocalStorage('token'); this.loggedIn = false; this.isAdmin = false; this.currentUser = new User();&#125; AuthService的完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import &#123; Injectable, Injector &#125; from '@angular/core';import &#123; Router &#125; from '@angular/router';import &#123; JwtHelperService &#125; from '@auth0/angular-jwt';import &#123; Observable &#125; from 'rxjs';import &#123; map &#125; from 'rxjs/operators';import &#123; LoginInfo, LoginRes, User &#125; from '../../views/passport/interfaces/passport';import &#123; PassportService &#125; from '../../views/passport/services/passport.service';import &#123; StorageService &#125; from '../storage/storage.service';import &#123; NzMessageService &#125; from 'ng-zorro-antd';@Injectable()export class AuthService &#123; public loggedIn = false; public isAdmin = false; public currentUser: User = new User(); constructor(private jwtHelperService: JwtHelperService, private router: Router, private injector: Injector, private passportService: PassportService, private storageService: StorageService) &#123; const token = localStorage.getItem('token'); if (token) &#123; const decodedUser = this.decodeUserFromToken(token); this.setCurrentUser(decodedUser); &#125; &#125; get msg(): NzMessageService &#123; return this.injector.get(NzMessageService); &#125; login(loginInfo: LoginInfo): Observable&lt;boolean&gt; &#123; return this.passportService.postLogin(loginInfo).pipe(map( (res: LoginRes) =&gt; &#123; this.storageService.setLocalStorage('token', res.token); const decodedUser = this.decodeUserFromToken(res.token); this.setCurrentUser(decodedUser); this.msg.success('登录成功!'); return this.loggedIn; &#125; ) ); &#125; logout(): void &#123; this.storageService.removeLocalStorage('token'); this.loggedIn = false; this.isAdmin = false; this.currentUser = new User(); &#125; decodeUserFromToken(token): User &#123; return this.jwtHelperService.decodeToken(token).user; &#125; setCurrentUser(decodedUser): void &#123; this.loggedIn = true; this.currentUser.workNumber = decodedUser.workNumber; this.currentUser.realName = decodedUser.realName; this.currentUser.group = decodedUser.group; this.currentUser.role = decodedUser.role; this.isAdmin = decodedUser.role &gt; 10; delete decodedUser.role; &#125;&#125; 至此，在你的Angular应用中就引入了JWT认证，当然，你也可以不使用@auth0/angular2-jwt，自己手写一个HTTP拦截器，手动设置每次请求的header： 123456789101112131415161718192021@Injectable()export class AuthInterceptor implements HttpInterceptor &#123; intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; &#123; const token = localStorage.getItem("token"); if (token) &#123; const cloned = req.clone(&#123; headers: req.headers.set("Authorization", "Bearer " + token) &#125;); return next.handle(cloned); &#125; else &#123; return next.handle(req); &#125; &#125;&#125; 不过这样的话，token Base64解码也需要自己手写，稍微麻烦一点。 总结JWT因为是基于JSON的，所以通用性很强，很多语言已经存在jwt相关的库。不过使用JWT的时候需要注意以下几点： 保存好secret秘钥，这个秘钥只能在服务端存在 给token设置一个过期时间，因为一旦token生成，它就永远有效，除非token密钥被更改或过期 在payload中只能存储一些业务逻辑所必要的非敏感信息]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows下几款好用的免费软件]]></title>
    <url>%2F2018%2F07%2F22%2Fwindows%E4%B8%8B%E5%87%A0%E6%AC%BE%E5%A5%BD%E7%94%A8%E7%9A%84%E5%85%8D%E8%B4%B9%E8%BD%AF%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[之前公司内部禁用了破解软件，所以找了一些免费的软件代替，不过意外发现几款比较好用的免费软件。 Bandizip官网：Bandizip Bandizip是一款来自韩国的免费压缩工具，虽然免费但是意外地好用。 如果有解压Mac下的压缩文件的需求，7-Zip对中文解压会乱码，WinRAR需要安装5.0.1以上版本，不过winRAR这个版本需要付费去广告，而Bandizip的兼容性非常出色，解压无乱码，界面很干净清爽，不像某些国产压缩软件，花花绿绿。 Bandizip 同样支持文件右键菜单快速压缩/解压缩文件和文件夹，甚至还可以在右键菜单上快速预览压缩包里的文件列表。 右键压缩 右键解压 预览 当然，什么分卷压缩和加密压缩也不在话下： 支持的格式包括: 7Z, ACE, AES, ALZ, ARJ, BH, BIN, BZ, BZ2, CAB, Compound(MSI), EGG, GZ, IMG, ISO, ISZ, LHA, LZ, LZH, LZMA, PMA, RAR, RAR5, SFX(EXE), TAR, TBZ, TBZ2, TGZ, TLZ, TXZ, UDF, WIM, XPI, XZ, Z, ZIP, ZIPX, ZPAQ，而且不同格式的文件的icon也会略有不同，并且可以自定义： 不过在Windows上虽然Bandizip免费，但Mac版却是收费版本。所以推荐win系统的朋友可以尝试一下这款优秀的免费软件。 Snipaste官网：Snipaste 这款免费的截图+贴图软件居然是一个个人独立开发项目，作者开发了三年，相比其他一些截图软件，这款软件在截图后的处理上做得很友好，如果比功能的话可能没有收费的snagit来的多，不过在免费里面已经算很良心了，唯一有点遗憾的是没有滚动截图的功能。 截图带了自动检测界面元素区域功能，这样截图更加方便，点击左键截图后还可以进行编辑，比如加个箭头或者文字说明什么的： 比较贴心的是，截图的时候可以通过放大镜精确控制截图范围，而且还可以显示光标所在像素的颜色，并且能复制当前像素点的 RGB 值： 编辑时还有打码功能，方便截图的时候去除一些涉及隐私的信息： 贴图就是使图片成为一个窗口并置顶显示： 贴图功能我个人常用的场景是需要将两个不同截图进行对比的时候会用，不过作者给出了关于贴图的更多使用场景。 基本上Snipaste可以覆盖大部分的使用场景，再加上免费，称得上是非常良心了。 ScreenToGif官网：ScreenToGif ScreenToGif是一款录制Gif的小工具，免安装版只有818KB，使用也很方便。 启动界面 按下F7就可以录制，录制界面也非常简洁，把要录制的对象放在视图框内就行： 录制界面 录制完后在编辑界面中提供了很多工具给你编辑录制的gif 最后保存的时候编码器会分析不变的像素，对录制的gif进行压缩处理。 总得来说ScreenToGif在使用上非常简单，效果也不错。 这里就罗列这三款软件，Windows上还有其他一些免费的软件，比如MobaXterm（SSH软件）、Typora（Markdown工具），Visual Studio Code（写代码利器），Fiddler（抓包工具）等，就不一一罗（wo）列（tai）出（lan）来（le）。 最后，如果觉得付费软件很好，在承受范围内可以考虑付费，毕竟码农开发一款软件也很辛苦的。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>软件</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《ES6标准入门》学习笔记]]></title>
    <url>%2F2018%2F06%2F25%2F%E3%80%8AES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[ECMAScript6简介ES6与ECMAScript2015的关系ES6既是一个历史名词，也是一个泛指，含义是5.1版以后的JavaScript的下一代标准，涵盖了ES2015、ES2016、ES2017等，而ES2015则是正式名称，特指该年发布的正式版本的语言标准。 语法提案的批准流程一个新的语法从提案到变成正式标准，需要经历五个阶段。每个阶段的变动都需要由TC901139委员会批准。 Stage0 - Strawman（展示阶段） Stage1 - Proposal（征求意见阶段） Stage2 - Draft（草案阶段） Stage3 - Candidate（候选人阶段） Stage4 - Finished（定案阶段） ECMAScript 当前的所有提案，可以在 TC39 的官方网站Github.com/tc39/ecma262 查看。 部署进度各大浏览器的最新版本对ES6的支持情况：ECMAScript 6 compatibility table 查看Node已经实现的ES6特性： 1node --v8-option | grep harmony 查看你的浏览器支持ES6的程度：ES-Checker Babel转码器Bable是一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码。 配置文件.babelrcBabel 的配置文件是.babelrc，存放在项目的根目录下。使用Babel的第一步， 就是配置这个文件。 1234567891011&#123; // 设定转码规则 "presets": [ "latest", "react", "stage-2" ], // 插件 "plugins": []&#125; 1234567891011121314# 最新转码规则$ npm install --save-dev babel-preset-latest# react 转码规则$ npm install --save-dev babel-preset-react# 不同阶段语法提案的转码规则（共有4个阶段），选装一个$ npm install --save-dev babel-preset-stage-0$ npm install --save-dev babel-preset-stage-1$ npm install --save-dev babel-preset-stage-2$ npm install --save-dev babel-preset-stage-3 注意，以下所有 Babel工具和模块的使用，都必须先写好.babelrc。 命令行转码babel-clibabel-cli用于命令行转码。 全局安装1$ npm install --global babel-cli 本地安装1$ npm install --save-dev babel-cli package.json： 12345678&#123; "scripts": &#123; "build": "babel src -d lib" &#125;, "devDependencies": &#123; "babel-cli": "^6.26.0" &#125;&#125; 基本用法1234567891011121314151617# 转码结果输出到标准输出$ babel example.js# 转码结果写入一个文件# --out-file 或 -o 参数指定输出文件$ babel example.js --out-file compiled.js# 或者$ babel example.js -o compiled.js# 整个目录转码# --out-dir 或 -d 参数指定输出目录$ babel src --out-dir lib# 或者$ babel src -d lib# -s 参数生成source map文件$ babel src -d lib -s babel-nodebabel-cli工具自带一个babel-node命令，提供一个支持ES6的REPL环境。它支持Node的REPL环境的所有功能，而且可以直接运行ES6代码。 12345678$ babel-node&gt; (x =&gt; x * 2)(1)2# 或者$ babel-node es6.js2 babel-node也可以安装在项目中： 1$ npm install --save-dev babel-cli package.json： 12345&#123; "scripts": &#123; "script-name": "babel-node script.js" &#125;&#125; babel-register babel-register模块改写require命令，为它加上一个钩子。此后，每当使用require 加载.js 、.jsx、.es和.es6后缀名的文件，就会先用Babel 进行转码。 1$ npm install --save-dev babel-register 接着，在项目中创建 register.js 文件并添加如下代码： 12require("babel-register");require("./index.js"); 这样做可以把 Babel注册到 Node 的模块系统中并开始编译其中 require 的所有文件。 现在我们可以使用 register.js 来代替 node index.js 来运行了。 1$ node register.js 需要注意的是， babel-register 只会对 require 命令加载的文件转码，而不会对当前文件转码。另外，由于它是实时转码，所以只适合在开发环境使用。 babel-core如果某些代码需要调用 Babel 的 API 进行转码，就要使用babel-core模块。 1$ npm install babel-core --save 然后在项目中就可以调用babel-core： 12345678910111213141516171819var babel = require('babel-core');// 字符串转码babel.transform('code();', options);// =&gt; &#123; code, map, ast &#125;// 文件转码（异步）babel.transformFile('filename.js', options, function(err, result) &#123; result; // =&gt; &#123; code, map, ast &#125;&#125;);// 文件转码（同步）babel.transformFileSync('filename.js', options);// =&gt; &#123; code, map, ast &#125;// Babel AST转码babel.transformFromAst(ast, code, options);// =&gt; &#123; code, map, ast &#125; 配置对象options，可以参看官方文档http://babeljs.io/docs/usage/options/。 例子： 123456789var es6Code = 'let x = n =&gt; n + 1';var es5Code = require('babel-core') .transform(es6Code, &#123; presets: ['latest'] &#125;) .code;// 转换成：// '"use strict";\n\nvar x = function x(n) &#123;\n return n + 1;\n&#125;;' babel-polyfillBabel 默认只转换新的 JavaScript 句法（syntax），而不转换新的 API，比如 Iterator 、Generator、Set、Maps、Proxy、Reflect、Symbol、promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码。 Babel 默认不转码的 API 非常多，详细清单可以查看模块的definitions.js文件。 必须使用babel-polyfill，为当前环境提供一个垫片： 1$ npm install --save babel-polyfill 然后，在脚本头部，加入如下一行代码： 123import 'babel-polyfill';// 或者require('babel-polyfill'); 与其他工具的配合ESLint1$ npm install --save-dev eslint babel-eslint 然后，在项目根目录下，新建一个配置文件 .eslintrc，在其中加入parser字段： 123456&#123; "parser": "babel-eslint", "rules": &#123; ... &#125;&#125; Mocha如果需要执⾏使⽤ES6 语法的测试脚本，可以修改package.json的scripts.test： 123"scripts": &#123; "test": "mocha --ui qunit --compilers js:babel-core/register"&#125; --compilers参数指定脚本的转码器，规定后缀名为 js的文件，都需要使用babel-core/register。 let和const命令let命令基本用法let用来声明变量，但所声明的变量只在let命令所在的代码块中有效： 1234567&#123; let a = 10; var b = 1;&#125;a // ReferenceError: a is not defined.b // 1 下面代码如果使用var，最后输出是10： 1234567var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10 上面代码中，变量i是var命令声明的，在全局范围内都有效，所以全局只有一 个变量i。每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的函数内部的console.log(i)，里面的i指向的就是全局的i。也就是说，所 有数组a的成员里面的i，指向的都是同一个i，导致运行时输出的是最后一 轮的i的值，也就是10。 如果使用let，声明的变量仅在块级作用域内有效，最后输出的是6。 1234567var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 6 上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一 轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的 变量i时，就在上一轮循环的基础上进行计算。 在for循环中，设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。 123456789for (let i = 0; i &lt; 3; i++) &#123; let i = 'abc'; console.log(i);&#125;// abc// abc// abc// 输出3次abc，表明函数内部的变量i与循环变量i不在同一个作用域 不存在变量提升var会发生变量提升的现象，即变量在声明前可以使用，值为undefined。 let所声明的变量一定要在声明后使用，否则报错。 1234567// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错let bar = 2; 暂时性死区只要块级作用域内存在let命令，它所声明的变量就绑定这个区域，不再受外部的影响。 123456var tmp = 123;if (true) &#123; tmp = 'abc'; // ReferenceError let tmp;&#125; 上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。 ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的 变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 在代码块内，使用 let 命令声明变量之前，该变量都是不可用的。这在语 法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。 1234567891011if (true) &#123; // TDZ开始 tmp = 'abc'; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ结束 console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123&#125; TDZ意味着typeof不再是百分之百安全的操作： 12typeof x; // ReferenceErrorlet x; 如果一个变量根本没有被声明，使用typeof反而不会报错： 1typeof undecalared_variable // 'undefined' 12345678910111213function bar(x = y, y = 2) &#123; // y未声明，属于死区 return [x, y];&#125;bar(); // Uncaught ReferenceError: y is not defined/*******修改后********/function bar(x = 2, y = x) &#123; return [x, y];&#125;bar(); // [2, 2] 123var x = x; // 不报错let x = x; // Uncaught ReferenceError: x is not defined ES6 规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。 暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。 不允许重复声明let不允许在相同作用域内，重复声明同一个变量： 123456789101112131415// 报错function test () &#123; let a = 10; var a = 1;&#125;test();// 报错function test() &#123; let a = 10; let a = 1;&#125;test(); 123456789function func(arg) &#123; let arg; // 报错&#125;function func(arg) &#123; &#123; let arg; // 不报错 &#125;&#125; 块级作用域为什么需要块级作用域ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。 内层变量覆盖外层变量 12345678910var tmp = new Date();function f() &#123; console.log(tmp); if (false) &#123; var tmp = 'hello'; // 变量提升，导致内层tmp覆盖外层tmp &#125;&#125;f(); // undefined 用来计数的循环变量泄露为全局变量 1234567var s = 'hello';for (var i = 0; i &lt; s.length; i++) &#123; console.log(s[i]); // 循环结束后，i泄露成全局变量&#125;console.log(i); // 5 ES6的块级作用域let为JavaScript新增了块级作用域： 1234567function f1() &#123; let n = 5; if (true) &#123; let n = 10; &#125; console.log(n); // 5&#125; ES6允许块级作用域的任意嵌套： 123456789&#123;&#123;&#123;&#123; &#123;let insane = 'hello world'&#125; console.log(insane); // 报错&#125;&#125;&#125;&#125;;&#123;&#123;&#123;&#123; let insane = 'hello world'; &#123;let insane = 'hello world'&#125; // 内层作用域可以定义外层作用域同名变量&#125;&#125;&#125;&#125;; 块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再 必要了： 1234567891011// IIFE写法(function () &#123; var tmp = ....; ....&#125;());// 块级作用域写法&#123; let tmp = ...; ...&#125; 块级作用域与函数声明ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用： 123456789101112131415161718192021222324function f() &#123; console.log('i am outside');&#125;(function () &#123; if (false) &#123; // 重复声明一次函数f，在作用域外不可用 function f() &#123; console.log('i am inside'); &#125; &#125; f();&#125;());// es5下if中的f函数会被提升到函数头部(function () &#123; function f() &#123; console.log('i am inside'); &#125; if (false) &#123; &#125; f();&#125;()); 但是以上代码在ES6浏览器中运行还是会报错，ES6规定，浏览器为了兼容可以不遵守上面规定，有自己的实现方式： 允许在块级作用域内声明函数 函数声明类似于var，即会提升到全局作用域或作用域的头部 函数声明还会提升到所在的块级作用域的头部 以上三条规则只对ES6浏览器实现有效，在其他环境的实现不用遵守。 根据以上三条规则，在浏览器的ES6环境中，块级作用域内声明的函数，行为类似于var声明的变量： 12345678910111213141516171819202122232425262728293031323334// 浏览器的ES6环境function f() &#123; console.log('i am outside');&#125;(function () &#123; if (false) &#123; // 重复声明一次函数f function f() &#123; console.log('i am inside'); &#125; &#125; f();&#125;());// Uncaught TypeError: f is not a function/********实际运行的代码**********/// 浏览器的ES6环境function f() &#123; console.log('i am outside');&#125;(function () &#123; var f = undefined; if (false) &#123; // 重复声明一次函数f function f() &#123; console.log('i am inside'); &#125; &#125; f();&#125;());// Uncaught TypeError: f is not a function 应该避免在块级作用域内声明函数，如果确实需要，应该写成函数表达式，而不是函数声明语句。 ES6的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号就会报错。 do表达式本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。 1234&#123; let t = f(); t = t * t + 1; // 在块级作用域外，没办法得到t&#125; 现在有一个提案，使得块级作用域可以变成表达式，也就是说可以返回值，办法就是在块级作用域之前加上do，使它变为do表达式： 1234let x = do &#123; // x会得到整个块级作用域的返回值 let t = f(); t * t + 1;&#125;; const命令基本用法const声明一个只读的常量。一旦声明，常量的值就不能改变。const一旦声明变量，就必须立即初始化，不能留到以后赋值。 const只在声明所在的块级作用域内有效。声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。 const与let一样不可重复声明。 本质const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址 不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向 的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是 固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个 对象声明为常量必须非常小心。 12345678const foo = &#123;&#125;;// 为foo添加一个属性，可以成功foo.prop = 123;foo.prop // 123// 将foo指向另一个对象，就会报错foo = &#123;&#125;; // TypeError: "foo" is read-only 如果真想将对象冻结，应该使用object.freeze方法： 12345const foo = Object.freeze(&#123;&#125;);// 常规模式时，下面一行不起作用// 严格模式时，该行会报错foo.prop = 123; 除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。 12345678var constantize = (obj =&gt; &#123; Object.freeze(obj); Object.keys(obj).forEach((key, i) =&gt; &#123; if (typeof obj[key] === 'object') &#123; constantize(obj[key]); &#125; &#125;);&#125;); ES6声明变量的六种方法ES6的六种声明变量的方法：var命令、function命令、let命令、const命令、import命令和class命令。 顶层对象的属性顶层对象，在浏览器环境中指的是window对象，在node指的是global对象。 顶层对象的属性与全局变量挂钩，被认为是JavaScript语言最大的设计败笔之一。 这样的设计带来了几个很大的问题： 首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）； 其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）； 最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。 另一 方面， window 对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。 ES6为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。 1234567var a = 1;// 如果在node的REPL环境，可以写成global.a// 或者采用通用方法，写成this.awindow.a // 1let b = 1;window.b // undefined global对象ES5 的顶层对象在各种实现里面是不统一的： 浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。 浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。 Node 里面，顶层对象是global，但其他环境都不支持。 同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性： 全局环境中，this会返回顶层对象。但是Node 模块和 ES6 模块中，this返回的是当前模块。 函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但严格模式下，this会返回undefined。 不管是严格模式，还是普通模式，new Function(&#39;return this&#39;)()，总 是会返回全局对象。但是，如果浏览器用了CSP（Content Security Policy，内容安全政策），那么eval、new Function这些方法都可能无法使用。 综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种 勉强可以使用的方法： 1234567891011// 方法一(typeof window !== 'undefined' ? window : (typeof process === 'object' &amp;&amp; typeof require === 'function' &amp;&amp; typeof global === 'object') ? global : this);// 方法二var getGlobal = function () &#123; if (typeof self !== 'undefined') &#123; return self; &#125; if (typeof window !== 'undefined') &#123; return window; &#125; if (typeof global !== 'undefined') &#123; return global; &#125; throw new Error('unable to locate global object');&#125;; 现在有一个提案，在语言标准的层面，引入global作为顶层对象。也就是说，在 所有环境下，global都是存在的，都可以从它拿到顶层对象。 垫片库system.global模拟了这个提案： 1234567891011121314/* 保证各种环境中，global对象都是存在的 */// CommonJS的写法require('system.global/shim')();// ES6模块的写法import shim from 'system.global/shim'; shim();/* 将顶层对象放入变量global中 */// CommonJS的写法var global = require('system.global')();// ES6模块的写法import getGlobal from 'system.global';const global = getGlobal(); 变量的解构赋值数组的解构赋值基本用法ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。 以前，为变量赋值，只能直接指定值： 123let a = 1;let b = 2;let c = 3; ES6允许写成下面这样： 1let [a, b, c] = [1, 2, 3]; 本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被 赋予对应的值。 1234567891011121314151617181920let [foo, [[bar], baz]] = [1, [[2]], 3];foo // 1bar // 2baz // 3let [ , , third] = ['foo', 'bar', 'baz'];third // 'baz'let [x, , y] = [1, 2, 3];x // 1y //3let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4]let [x, y, ...z] = ['a'];x // 'a'y // undefinedz // [] 如果解构不成功，变量的值就等于undefined： 12let [foo] = [];let [bar, foo] = [1]; 以上两种情况都属于解构不成功，foo的值都会等于undefined。 另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。 这种情况下，解构依然可以成功。 12345678910// 不完全解构，但是可以成功let [x, y] = [1, 2, 3];x // 1y // 2let [a, [b], d] = [1, [2, 3], 4];a // 1b // 2d // 4 如果等号的右边不是数组（或者严格地说，不是可遍历的结构），那么将会报错。 对于Set结构，也可以使用数组的解构赋值： 12let [x, y, z] = new Set(['a', 'b', 'c']);x // 'a' 只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值 1234567891011function * fibs() &#123;// fibs是一个Generator函数，原生具有Iterator接口 let a = 0; let b = 1; while (true) &#123; yield a; [a, b] = [b, a + b]; &#125;&#125;let [first, second, third, fourth, fifth, sixth] = fibs();sixth // 5 默认值结构赋值允许指定默认值 12345let [foo = true] = [];foo // truelet [x, y = 'b'] = ['a']; // x='a', y='b'let [x, y = 'b'] = ['a', undefined]; // x='a', y='b' ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以， 如果一个数组成员不严格等于undefined，默认值是不会生效的。 12345let [x = 1] = [undefined];x // 1let [x = 1] = [null];x // null 如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候， 才会求值： 1234567891011121314function f() &#123; console.log('aaa');&#125;let [x = f()] = [1];/*******等价于*******/let x;if ([1][0] === undefined) &#123; x = f();&#125; else &#123; x = [1][0];&#125; 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。 对象的解构赋值123let &#123; foo, bar&#125; = &#123; foo: 'aaa', bar: 'bbb'&#125;;foo // 'aaa'bar // 'bbb' 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值： 123456let &#123; bar, foo&#125; = &#123; foo: 'aaa', bar: 'bbb'&#125;;foo // 'aaa'bar // 'bbb'let &#123; baz &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;;baz // undefined 如果变量名与属性名不一致，必须写成下面这样： 1234567let &#123; foo: baz &#125; = &#123; foo: 'aaa', bar: 'bbb'&#125;;baz // 'aaa'let obj = &#123; first: 'hello', last: 'world' &#125;;let &#123; first: f, last: l &#125; = obj;f // 'hello'l // 'world' 对象的解构赋值是下面形式的简写，也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变 量。真正被赋值的是后者，而不是前者。 12345let &#123; foo: foo, bar: bar &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;;let &#123; foo: baz &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;;baz // 'aaa'foo // error: foo is not defined 解构也可以用于嵌套解构的对象： 12345678910let obj = &#123; p: [ 'Hello', &#123; y: 'world' &#125; ]&#125;;let &#123; p: [x, &#123; y &#125;] &#125; = obj;x // 'Hello'y // 'world' 这时p是模式，不是变量，因此不会被赋值。如果p也要作为变量赋值，可以写成下面这样： 123456789101112131415161718192021let obj = &#123; p: [ 'Hello', &#123; y: 'world' &#125; ]&#125;;let &#123; p, p: [x, &#123; y &#125;] &#125; = obj;x // 'Hello'y // 'world'p // ["Hello", &#123;y: "World"&#125;]/*****************另一个例子*****************/let obj = &#123;&#125;;let arr = [];(&#123; foo: obj.prop, bar: arr[0] &#125; = &#123; foo: 123, bar: true &#125;);obj // &#123;prop:123&#125;arr // [true] 对象解构也可以指定默认值： 123456789101112131415var &#123;x = 3&#125; = &#123;&#125;;x // 3var &#123;x, y = 5&#125; = &#123;x: 1&#125;;x // 1y // 5var &#123;x: y = 3&#125; = &#123;&#125;;y // 3var &#123;x: y = 3&#125; = &#123;x: 5&#125;;y // 5var &#123;message: msg = 'something went wrong'&#125; = &#123;&#125;;msg // 'something went wrong' 默认值生效的条件是，对象的属性值严格等于undefined。 如果解构失败，变量的值等于undefined。 如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。 如果要将一个已经声明的变量用于解构赋值，必须非常小心： 123456789// 错误的写法let x;&#123;x&#125; = &#123;x: 1&#125;;// syntaxError: syntax error// 正确写法let x;(&#123;x&#125; = &#123;x: 1&#125;); JavaScript 引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才 能解决这个问题。 解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式： 123(&#123;&#125; = [true, false]);(&#123;&#125; = 'abc');(&#123;&#125; = []); 对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量： 12let &#123; log, sin, cos &#125; = Math;// 将Math对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。 由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构： 1234let arr = [1, 2, 3];let &#123;0 : first, [arr.length - 1] : last&#125; = arr;first // 1last // 3 字符串的结构赋值字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象： 123456const [a, b ,c, d, e] = 'hello';a // 'h'b // 'e'c // 'l'd // 'l'e // 'o' 类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值： 12let &#123;length: len&#125; = 'hello';len // 5 数值和布尔值的解构赋值解构赋值时，如果等号右边是数值和布尔值，则会先转为对象： 12345let &#123;toString: s&#125; = 123;s === Number.prototype.toString // truelet &#123;toString: s&#125; = true;s === Boolean.prototype.toString; // true 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由 于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。 12let &#123;prop: x&#125; = undefined; // TypeErrorlet &#123;prop: y&#125; = null; // TypeError 函数参数的解构赋值12345678function add([x, y]) &#123; return x + y;&#125;add([1, 2]); // 3[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);// [3, 7] 函数参数的解构也可以使用默认值： 12345678function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, 0]move(&#123;&#125;); // [0, 0]move(); // [0, 0] undefined就会触发函数参数的默认值： 12[1, undefined, 3].map((x = 'yes') =&gt; x);// [1, 'yes', 3] 圆括号问题解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。 由此带来的问题是，如果模式中出现圆括号怎么处理。ES6的规则是，只要有可能 导致解构的歧义，就不得使用圆括号。 但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。 不能使用圆括号的情况 变量声明语句 123456789// 全部报错,它们都是变量声明语句，模式不能使用圆括号let [(a)] = [1];let &#123;x: (c)&#125; = &#123;&#125;;let (&#123;x: c&#125;) = &#123;&#125;;let &#123;(x: c)&#125; = &#123;&#125;;let &#123;(x): c&#125; = &#123;&#125;;let &#123; o: (&#123;p: p&#125;) &#125; = &#123; o: &#123; p: 2 &#125; &#125;; 函数参数 12345678910// 函数参数也属于变量声明，因此不能带有圆括号// 报错function f([(z)]) &#123; return z;&#125;// 报错function f([z, (x)]) &#123; return x;&#125; 赋值语句的模式 123456// 全部报错,将整个模式放在圆括号之中，导致报错(&#123; p: a &#125;) = &#123; p: 42 &#125;;([a]) = [5];// 报错,将一部分模式放在圆括号之中，导致报错[(&#123; p: a &#125;), &#123; x: c &#125;] = [&#123;&#125;, &#123;&#125;]; 可以使用圆括号的情况可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号： 123[(b)] = [3]; // 正确(&#123; p: (d) &#125; = &#123;&#125;); // 正确[(parseInt.prop)] = [3]; // 正确 上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其 次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成 员，跟圆括号无关；第二行语句中，模式是p，而不是d；第三行语句与第一行 语句的性质一致。 用途 交换变量的值 123let x = 1;let y = 2;[x, y] = [y, x]; 从函数返回多个值 函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有 了解构赋值，取出这些值就非常方便： 1234567891011121314// 返回一个数组function example() &#123; return [1, 2, 3];&#125;let [a, b, c] = example();// 返回一个对象function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;let &#123;foo, bar&#125; = example(); 函数参数的定义 12345678910111213// 参数是一组无次序的值function f([x, y, z]) &#123; // do something&#125;f(&#123;z: 3, y: 2, x: 1&#125;);// 参数是一组有次序的值function f([x, y, z]) &#123; // do something&#125;f([1, 2, 3]); 提取JSON数据 12345678910let jsonData = &#123; id: 42, status: 'ok', data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, 'ok', [867, 5309] 参数函数的默认值 1234567891011jQuery.ajax = function (url, &#123; async = true, beforeSend = function () &#123;&#125;, cache = true, complete = function () &#123;&#125;, crossDomain = false, global = true, // ....more config&#125;) &#123; // ... do stuff&#125;; 遍历Map结构 任何部署了Iterator接口的对象，都可以用for…of循环遍历。Map结构原生支 持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便。 12345678910111213141516171819var map = new Map();map.set('first', 'hello');map.set('second', 'world');for (let [key, value] of map) &#123; console.log(key + 'is' + value);&#125;// first is hello// second is world// 获取键名for (let [key] of map) &#123; console.log(key);&#125;// 获取键值for (let [value] of map) &#123; console.log(value);&#125; 输入模块的指定方法 加载模块时，往往需要指定输入哪些方法。结构赋值使得输入语句非常清晰： 1const &#123; SourceMapConsumer, SourceNode &#125; = require('source-map'); 字符串的扩展字符的Unicode表示法JavaScript允许采用\uxxxx形式表示一个字符，其中xxxx表示字符的Unicode码点。 但是，这种表示法只限于码点在\u0000~\uFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。 ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符： 12345678'\u&#123;20BB7&#125;'// ""'\u&#123;41&#125;\u&#123;42&#125;\u&#123;43&#125;'// "ABC"'\u&#123;1F680&#125;' === '\uD83D\uDE80'// true 字符串的遍历器接口ES6为字符串添加了遍历器接口，使得字符串可以被for...of循环遍历： 1234567for (let codePoint of 'foo') &#123; console.log(codePoint);&#125;// 'f'// 'o'// 'o' 除了遍历字符串，这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。 includes(), startsWith(), endsWith() includes()：返回布尔值，表示是否找到了参数字符串 startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部 endsWith()：返回布尔值，表示参数字符串串是否在原字符串串的尾部 12345var s = 'hello world!';s.startsWith('hello'); // trues.endsWith('!'); // trues.includes('o'); // true 这三个方法都支持第二个参数，表示开始搜索的位置： 12345var s = 'hello world!';s.startsWith('world', 6); // trues.endsWith('hello', 5); // trues.includes('hello', 6); // false endWith的行为与其他两个方法有所不同。它针对前n个字符，而且其他两个方法针对从第n个位置直到字符串结束。 repeat()repeat()方法返回一个新字符串，表示将原字符串重复n次： 123'x'.repeat(3); // 'xxx''hello'.repeat(2); // 'hellohello''na'.repeat(0); // '' 参数如果是小数，会被取整： 1'na'.repeat(2.9); // 'nana' 如果repeat的参数是负数或者Infinity，会报错。但是参数是0到-1之间的小数，由于会先进行取整运算，所以等同于0。 参数NaN等同于0。 如果repeat的参数是字符串，则会先转换成数字： 12'na'.repeat('na'); // '''na'.repeat('3'); // 'nanana' padStart(), padEnd()ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部 或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。 12345'x'.padStart(5, 'ab'); // 'ababx''x'.padStart(4, 'ab'); // 'abax''x'.padEnd(5, 'ab'); // 'xabab''x'.padEnd(4, 'ab'); // 'xaba' 上面代码中，padStart和padEnd一共接受两个参数，第一个参数用来指定字 符串的最小长度，第二个参数是用来补全的字符串。 如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。 如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会 截去超出位数的补全字符串。 如果省略第二个参数，默认使用空格补全长度。 padStart的常见用途是为数值补全指定位数和提示字符串格式： 1234'1'.padStart(10, '0'); // 0000000001'12'.padStart(10, 'YYYY-MM-DD'); // 'YYYY-MM-12''09-12'.padStart(10, 'YYYY-MM-DD'); // 'YYYY-MM-09-12' 模板字符串模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当 作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。 123456console.log(`string text line 1string text line 2`);// 字符串中嵌入变量var name = 'Bob', time = 'today';`Hello $&#123;name&#125;, how are you $&#123;time&#125;?` 如果在模板字符串中需要使用反引 号，则前面要用反斜杠转义。 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。 模板字符串中嵌入变量，需要将变量名写在${}中，大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性，甚至还能调用函数： 12345function fn() &#123; return 'hello world';&#125;`foo $&#123;fn()&#125; bar`// foo hello world bar 如果大括号中的值不是字符串，将按照一般的规则转为字符串。 如果模板字符串中的变量没有声明，将报错。 模板字符串甚至还能嵌套： 12345678910111213141516171819202122232425const tmpl = addrs =&gt; ` &lt;table&gt; $&#123;addrs.map(addr =&gt; ` &lt;tr&gt;&lt;td&gt;$&#123;addr.first&#125;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;$&#123;addr.last&#125;&lt;/td&gt;&lt;/tr&gt; `).join('')&#125; &lt;/table&gt;`;const data = [ &#123;first: '&lt;jane&gt;', last: 'Bond'&#125;, &#123;first: 'Lars', last: '&lt;Croft&gt;'&#125;,];console.log(tmpl(data));// &lt;table&gt;//// &lt;tr&gt;&lt;td&gt;&lt;jane&gt;&lt;/td&gt;&lt;/tr&gt;// &lt;tr&gt;&lt;td&gt;Bond&lt;/td&gt;&lt;/tr&gt;// // &lt;tr&gt;&lt;td&gt;Lars&lt;/td&gt;&lt;/tr&gt;// &lt;tr&gt;&lt;td&gt;&lt;Croft&gt;&lt;/td&gt;&lt;/tr&gt;// // &lt;/table&gt; 如果需要引用模板字符串本身，在需要时执行，可以像下面这样写: 123456789// 写法一let str = 'return' + '`hello $&#123;name&#125;!`';let func = new Function('name', str);func('Jack'); // 'hello Jack!// 写法二let str = '(name) =&gt; `hello $&#123;name&#125;!`';let func = eval.call(null, str);func('Jack'); // 'hello Jack! 实例：模板编译1234567var template = ` &lt;ul&gt; &lt;% for(var i=0; i &lt; data.supplies.length; i++) &#123; %&gt; &lt;li&gt;&lt;%= data.supplies[i] %&gt;&lt;/li&gt; &lt;% &#125; %&gt; &lt;/ul&gt;`; 如果要编译这个模板字符串， 一种思路是将其转换为JavaScript表达式字符串。 1234567echo('&lt;ul&gt;');for (var i=0; i &lt; data.supplies.length; i++) &#123; echo('&lt;li&gt;'); echo(data.supplies[i]); echo('&lt;/li&gt;');&#125;;echo('&lt;/ul&gt;'); 1234567var evalExpr = /&lt;%=(.+?)%&gt;/g;var expr = /&lt;%([\s\S]+?)%&gt;/g;template = template .replace(evalExpr, '`); \n echo($1); \n echo(`') .replace(expr, '`); \n $1 \n echo(`');template = 'echo(`' + template + '`);'; 然后将template封装在一个函数里面返回： 12345678910111213var script = `(function parse(data)&#123; var output = ""; function echo(html)&#123; output += html; &#125; $&#123;template&#125; return output; &#125;)`;return script; 将上面内容拼装成一个模板编译函数compile： 1234567891011121314151617181920212223242526272829303132function compile(template) &#123; var evalExpr = /&lt;%=(.+?)%&gt;/g; var expr = /&lt;%([\s\S]+?)%&gt;/g; template = template .replace(evalExpr, '`); \n echo($1); \n echo(`') .replace(expr, '`); \n $1 \n echo(`'); template = 'echo(`' + template + '`);'; var script = `(function parse(data)&#123; var output = ""; function echo(html)&#123; output += html; &#125; $&#123;template&#125; return output; &#125;)`; return script;&#125;var parse = eval(compile(template));div.innerHTML = parse(&#123;supplies: ['boom', 'mop', 'cleaner']&#125;);// &lt;ul&gt;// &lt;li&gt;boom&lt;/li&gt;// &lt;li&gt;mop&lt;/li&gt;// &lt;li&gt;cleaner&lt;/li&gt;// &lt;/ul&gt; 标签模板模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将 被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。 123alert `123`;// 等同于alert(123); 标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧 跟在后面的模板字符串就是它的参数。 但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。 123456var a = 5;var b = 10;tag `Hello $&#123;a+b&#125; world $&#123;a*b&#125;`;// 等同于tag(['Hello ', ' world ', ''], 15, 50); 上面代码中，模板字符串前面有一个标识名tag，它是一个函数。整个表达式的 返回值，就是tag函数处理模板字符串后的返回值。 函数tag依次会接收到多个参数： 1234567function tag(stringArr, value1, value2) &#123; // ....&#125;// 等同于function tag(stringArr, ...values) &#123; // ....&#125; tag函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量 替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、 第二个成员与第三个成员之间，以此类推。 tag 函数的其他参数，都是模板字符串各个变量被替换后的值。由于本例中，模 板字符串含有两个变量，因此tag会接受到value1和value2两个参数。 tag函数所有参数的实际值如下： 第一个参数：[&#39;Hello &#39;, &#39; world &#39;, &#39;&#39;] 第二个参数：15 第三个参数：50 下面是tag函数的一种写法： 1234567891011121314151617181920var a = 5;var b = 10;function tag(s, v1, v2) &#123; console.log(s[0]); console.log(s[1]); console.log(s[2]); console.log(v1); console.log(v2); return 'ok';&#125;tag `Hello $&#123;a+b&#125; world $&#123;a*b&#125;`;// 'Hello '// ' world '// ''// 15// 50// 'ok' 下面是一个更复杂的例子，展示了如何将各个参数按照原来的位置拼合回去： 1234567891011121314151617181920212223242526272829var total = 30;var msg = passthru`The total is $&#123;total&#125; ($&#123;total*1.05&#125; with tax)`;function passthru(literals) &#123; var result = ''; var i = 0; while (i &lt; literals.length) &#123; result += literals[i++]; if (i &lt; arguments.length) &#123; result += arguments[i]; &#125; &#125; return result;&#125;msg // "The total is 30 (31.5 with tax)"/*********passthru函数采用rest参数的写法如下**********/function passthru(literals, ...values) &#123; var output = ''; for (var index = 0; index &lt; values.length; index++) &#123; output += literals[index] + values[index]; &#125; output += literals[index]; return output;&#125; “标签模板”的一个重要应用，就是过滤HTML字符串，防止用户输入恶意内容： 123456789101112131415 var message = SaferHTML`&lt;p&gt;$&#123;sender&#125; has sent you a message.&lt;/p&gt;`;function SaferHTML(templateData) &#123; var s = templateData[0]; for (var i = 1; i &lt; arguments.length; i++) &#123; var arg = String(arguments[i]); s += arg.replace(/&amp;/g, '&amp;amp;') .replace(/&lt;/g, '&amp;lt;') .replace(/&gt;/g, '&amp;gt;'); s += templateData[i]; &#125; return s;&#125; 上面代码中，sender变量往往是用户提供的，经过 SaferHTML函数处理，里面的特殊字符都会被转义： 12345var sender = '&lt;script&gt;alert("abc")&lt;/script&gt;'; // 恶意代码var message = SaferHTML`&lt;p&gt;$&#123;sender&#125; has sent you a message.&lt;/p&gt;`;message// &lt;p&gt;&amp;lt;script&amp;gt;alert("abc")&amp;lt;/script&amp;gt; has sent you a message.&lt;/p&gt; 标签模板的另一个应用，就是多语言转换（国际化处理）： 1i18n`welcome to $&#123;siteName&#125;, you are visitor number $&#123;visitorNumber&#125;`; 模板字符串本身并不能取代Mustache之类的模板库，因为没有条件判断和循环处理 功能，但是通过标签函数，你可以自己添加这些功能。 模板处理函数的第一个参数（模板字符串数组），还有一个raw属性： 12console.log`123`;// ['123', raw: Array[1]] raw属性，保存的是转义后的原字符串。 String.raw()ES6还为原生的String对象，提供了一个raw方法。 String.raw方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转 义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。 12345String.raw`Hi\n$&#123;2+3&#125;!`;// 'Hi\\n5!'String.raw`Hi\u000A!`;// 'Hi\\u000A!' 如果原字符串的斜杠已经转义，那么String.raw不会做任何处理。 String.raw方法可以作为处理模板字符串的基本方法，它会将所有变量替换， 而且对斜杠进行转义，方便下一步作为字符串来使用。 String.raw方法也可以作为正常的函数使用。这时，它的第一个参数，应该是 一个具有 raw 属性的对象，且 raw 属性的值应该是一个数组： 12345String.raw(&#123; raw: 'test' &#125;, 0, 1, 2);// 't0e1s2t'//等同于String.raw(&#123; raw: ['t', 'e', 's', 't'] &#125;, 0, 1, 2); 正则的扩展RegExp构造函数ES6 中，如果 RegExp 构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达 式的修饰符，只使用新指定的修饰符。 12new RegExp(/abc/ig, 'i').flags;// 'i' 字符串的正则方法字符串对象共有4个方法，可以使用正则表达 式：match()、replace()、search()和split()。 ES6 将这4个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上： String.prototype.match 调用RegExp.prototype[Symbol.match] String.prototype.replace调用RegExp.prototype[Symbol.replace] String.prototype.search调用RegExp.prototype[Symbol.search] String.prototype.split调用RegExp.prototype[Symbol.split] ###U修饰符 ES6对正则表达式添加了u修饰符，含义为Unicode模式，用来处理大于\uFFFF的Unicode字符。也就是说，会正确处理四个字节的 UTF-16 编码。 12/^\uD83D/u.test('\uD83D\uDC2A'); // false/^\uD83D/.test('\uD83D\uDC2A'); // true 上面代码中，\uD83D\uDC2A是一个四个字节的 UTF-16 编码，代表一个字符。 但是，ES5 不支持四个字节的 UTF-16 编码，会将其识别为两个字符，导致第二行 代码结果为true。加了u修饰符以后，ES6 就会识别其为一个字符，所以第一行代码结果为false。 一旦加上u修饰符号，就会修改下面这些正则表达式的行为。 点字符 .在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于0xFFFF的Unicode字符，.不能识别，必须加上u修饰符。 Unicode字符表示法 ES6新增了大括号表示Unicode字符，这种表示方法在正则表达式中必须加上u修饰符，才能识别当中的大括号。 量词 使用u修饰符后，所有量词都会正确识别码点大于0xFFFF的 Unicode 字符。 1234/a&#123;2&#125;/.test('aa'); // true/a&#123;2&#125;/u.test('aa'); // true/&#123; 2&#125;/.test('' ); // false/&#123; 2&#125;/u.test('' ); // true 预定义模式 u修饰符也影响到预定义模式，能否正确识别码点大于0xFFFF的Unicode字符： 12/^\s$/.test('' ); // false/^\s$/u.test('' ); // true \s是预定义模式，匹配所有不是空格的字符。只有加了u修饰符，它才能正确匹配码点大于0xFFFF的Unicode字符。 利用这点，可以写出一个正确返回字符串长度的函数： 123456789function codePointLength(text) &#123; var result = text.match(/[\s\S]/gu); return result ? result.length : 0;&#125;var s = '';s.length; // 4codePointLength(s); // 2 i修饰符 有些 Unicode 字符的编码不同，但是字型很相近，比如， \u004B与\u212A都是大写的K： 12/[a-z]/i.test('\u212A'); // false/[a-z]/iu.test('\u212A'); // true y修饰符ES6 还为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符。 y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成 功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可， 而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。 123456789var s = 'aaa_aa_a';var r1 = /a+/g;var r2 = /a+/y;r1.exec(s); // ['aaa']r2.exec(s); // ['aaa']r1.exec(s); // ['aa']r2.exec(s); // null 上面代码有两个正则表达式，一个使用g修饰符，另一个使用y修饰符。这两个 正则表达式各执行了两次，第一次执行的时候，两者行为相同，剩余字符串都是_aa_a。由于g修饰没有位置要求，所以第二次执行会返回结果，而y修饰 符要求匹配必须从头部开始，所以返回null。 如果改一下正则表达式，保证每次都能头部匹配，y修饰符就会返回结果了： 12345var s = 'aaa_aa_a';var r = /a+_/y;r.exec(s); // ['aaa_']r.exec(s); // ['aa_'] 使用lastIndex属性，可以更好地说明y修饰符： 12345678910111213141516const REGEX = /a/g;// 指定从2号位置（y）开始匹配REGEX.lastIndex = 2;// 匹配成功const match = REGEX.exec('xaya');// 在3号位匹配成功match.index; // 3// 下一次匹配从4号位开始REGEX.lastIndex; // 4// 4号位开始匹配失效REGEX.exec('xaxa'); // null 12345678910111213141516// y修饰符同样遵守lastIndex属性，但是要求必须在lastIndex指定的位置发现匹配const REGEX = /a/y;// 指定从2号位开始匹配REGEX.lastIndex = 2;// 不是粘连，匹配失败REGEX.exec('xaya'); // null// 指定从3号位置开始匹配REGEX.lastIndex = 3;// 3号位是粘连，匹配成功const match = REGEX.exec('xaxa');match.index; // 3REGEX.lastIndex; // 4 在split方法中使用y修饰符，原字符串必须以分隔符开头。这也意味着，只要匹配成功，数组的第一个成员肯定是空字符串: 12345678910111213// 没有找到匹配'x##'.split(/#/y);// ['x##']// 找到两个匹配'##x'.split(/#/y);// ['', '', 'x']'#x#'.split(/#/y);// ['', 'x#']'##'.split(/#/y);// ['', '', ''] y修饰符的一个应用，是从字符串提取 token， y修饰符确保了匹配之间不会有漏掉的字符： 1234567891011121314151617const TOKEN_Y = /\s*(\+|[0-9]+)\s*/y;const TOKEN_G = /\s*(\+|[0-9]+)\s*/g;tokenize(TOKEN_Y, '3 + 4');// ['3', '+', '4']tokenize(TOKEN_G, '3 + 4');// ['3', '+', '4']function tokenize(TOKEN_REGEX, str) &#123; let result = []; let match; while (match = TOKEN_REGEX.exec(str)) &#123; result.push(match[1]); &#125; return result;&#125; 上面代码中，如果字符串里面没有非法字符，y修饰符与g修饰符的提取结果是一样的。但是，一旦出现非法字符，两者行为就不一样。 sticky属性ES6 的正则对象多了sticky属性，表示是否设置了y修饰符。 flags属性ES6 为正则表达式新增了flags属性，会返回正则表达式的修饰符。 具名组匹配简介正则表达式使用圆括号进行组匹配： 1const RE_DATE = /(\d&#123;4&#125;)-(\d&#123;2)-(\d&#123;2&#125;)/; 上面代码中，正则表达式里面有三组圆括号。使用exec方法，就可以将这三组匹配结果提取出来： 1234const matchObj = RE_DATE.exec('1999-12-31');const year = matchObj[1]; // 1999const month = matchObj[2]; // 12const day = matchObj[3]; // 31 现在有一个“具名组匹配”（Named Capture Groups）的提案，允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用： 123456const RE_DATE = /(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2)-(?&lt;day&gt;\d&#123;2&#125;)/;const matchObj = RE_DATE.exec('1999-12-31');const year = matchObj.groups.year; // 1999const month = matchObj.groups.month; // 12const day = matchObj.groups.day; // 31 上面代码中，“具名组匹配”在圆括号内部，模式的头部添加“问号 + 尖括号 + 组 名”（?&lt;year&gt;），然后就可以在exec方法返回结果的groups属性上引用该组名。同时，数字序号依然有效。 如果具名组没有匹配，那么对应的groups对象属性会是undefined。 数值的扩展二进制和八进制表示法ES6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。 120b111110111 === 503 // true0o767 === 503 // true 如果要将0b和0o前缀的字符串数值转为十进制，要使用Number方法： 12Number('0b111'); // 7Number('0o10'); // 8 Number.isFinite(), Number.isNaN()ES6在Number对象上，新提供了Number.isFinite()和Number.isNaN()两个方法。 Number.isFinite()用来检查一个数值是否为有限的。 12345Number.isFinite(15); // trueNumber.isFinite(NaN); // falseNumber.isFinite(Infinity); // falseNumber.isFinite('foo'); // falseNumber.isFinite(true); // false Number.isNaN()用来检查一个值是否为NaN： 12Number.isNaN(NaN); // trueNumber.isNaN(15); // false Number.parseInt(), Number.parseFloat()ES6 将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。 1234567// ES5写法parseInt('12.34'); // 12parseInt('123.45#'); // 123.45// ES6写法Number.parseInt('12.34'); // 12Number.parseFloat('123.45#'); // 123.45 这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。 ###Number.isInteger() Number.isInteger()用来判断一个值是否为整数。需要注意的是，在JavaScript 内部，整数和浮点数是同样的储存方法，所以3和3.0被视为同一个值。 12345Number.isInteger(25); // trueNumber.isInteger(25.0); // trueNumber.isInteger(25.1); // falseNumber.isInteger('15'); // falseNumber.isInteger(true); // false Number.EPSILONES6在Number对象上面，新增一个极小的常量Number.EPSILON： 12345Number.EPSILON;// 2.220446049250313e-16Number.EPSILON.toFixed(20);// '0.00000000000000022204' 引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。我们知道浮 点数计算是不精确的: 123456780.1 + 0.2// 0.300000000000000040.1 + 0.2 - 0.3// 5.551115123125783e-175.551115123125783e-17.toFixed(20);// '0.00000000000000005551' 但是如果这个误差能够小于 Number.EPSILON，就可以得到正确结果。因此，Number.EPSILON的实质是一个可以接受的误差范围。 123456function withinErrorMargin(left, right) &#123; return Math.abs(left - right) &lt; Number.EPSILON;&#125;withinErrorMargin(0.1 + 0.2, 0.3); // truewithinErrorMargin(0.2 + 0,2, 0.3); // false 安全整数和Number.isSafeInteger()ES6引入了Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER表示JavaScript能够准确表示的整数范围的上下限（-2^53到2^53之间，不含两点）。 Number.isSafeInteger()是用来判断一个整数是否落在这个范围之内。实际使用这个函数时，需要注意。验证运算结果是否落在安全整数的范围内，不要 只验证运算结果，而要同时验证参与运算的每个值。 Math对象的扩展Math.trunc()Math.trunc()方法用于去除一个数的小数部分，返回整数部分： 123Math.trunc(4.1); // 4Math.trunc(4.9); // 4Math.trunc(-0.1); // -0 对于非数值，Math.trunc()内部使用Number方法先将其转为数值。对于空值和无法截取整数的值，返回NaN。 ####Math.sign() Math.sign()方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。 它会返回五种值： 参数为正数，返回+1 参数为负数，返回-1 参数为0，返回0 参数为-0，返回-0 其他值，返回NaN Math.cbrt()Math.cbrt()方法用于计算一个数的立方根： 123Math.cbrt(-1); // -1Math.cbrt(0); // -1Math.cbrt(2); // 1.2599210498948734 对于非数值，Math.cbrt()方法内部也是先使用Number方法将其转为数值。 Math.clz32()JavaScript的整数使用32位二进制形式表示，Math.clz32()方法返回一个数的32位无符号整数形式有多少个前导0。 1234Math.clz32(0); // 32,0的二进制形式全为0Math.clz32(1); // 31,1的二进制形式是 0b1Math.clz32(1000); // 22,1000的二进制形式是0b1111101000Math.clz32(0b01000000000000000000000000000000); // 1 对于小数，Math.clz32()方法只考虑整数部分。对于空值或其他类型的值，Math.clz32()方法会将它们先转为数值，然后再计算。 ####Math.imul() Math.imul()方法返回两个数以32位带符号整数形式相乘的结果，返回的也是一个 32位的带符号整数。 如果只考虑最后32位，大多数情况下，Math.imul(a, b)与a * b的结果是相 同的，即该方法等同于(a * b)|0的效果（超过32位的部分溢出）。之所以需要 部署这个方法，是因为JavaScript有精度限制，超过2的53次方的值无法精确表示。 这就是说，对于那些很大的数的乘法，低位数值往往都是不精确的， Math.imul 方法可以返回正确的低位数值。 ####Math.fround() Math.fround()方法返回一个数的单精度浮点数形式。 对于整数来说，Math.fround方法返回结果不会有任何不同，区别主要是那些无 法用64个二进制位精确表示的小数。这时，Math.fround方法会返回最接近这个 小数的单精度浮点数。 Math.hypot()Math.hypot()方法返回所有参数的平方和的平方根。 对于非数值，Math.hypot()先将其转为数值。只要有一个参数无法转为数值，返回NaN。 对数方法 Math.expm1() Math.expm1(x)返回e x - 1，即Math.exp(x) - 1 Math.log1p() Math.log1p(x)返回1+x的自然对数，即Math.log(1+x)，如果x小于-1，返回NaN Math.log10() Math.log10(x)返回10为底的x的对数。如果x小于0，返回NaN Math.log2() Math.log2()返回2为底的x的对数。如果x小于0，返回NaN 双曲函数方法 Math.sinh(x) 返回x的双曲正弦（hyperbolic sine） Math.cosh(x) 返回x的双曲余弦（hyperbolic cosine） Math.tanh(x) 返回x的双曲正切（hyperbolic tangent） Math.asinh(x) 返回x的反双曲正弦（inverse hyperbolic sine） Math.acosh(x) 返回x的反双曲余弦（inverse hyperbolic cosine） Math.atanh(x) 返回x的反双曲正切（inverse hyperbolic tangent） 指数运算符ES2016 新增了一个指数运算符** 122 ** 2 // 42 ** 3 // 8 指数运算符可以与等号结合，形成一个新的赋值运算符**=: 1234567let a = 1.5;a **= 2;// 等同于 a = a * alet b = 4;b **= 3;// 等同于 b = b * b * b Integer数据类型JavaScript 所有数字都保存成64位浮点数，这决定了整数的精确程度只能到53个二 进制位。大于这个范围的整数，JavaScript 是无法精确表示的，这使得 JavaScript 不适合进行科学和金融方面的精确计算。 现在有一个提案，引入了新的数据类型 Integer（整数），来解决这个问题。整数类 型的数据只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。 为了与 Number 类型区别，Integer 类型的数据必须使用后缀n表示： 11n + 2n // 3n typeof运算符对于 Integer 类型的数据返回integer。 JavaScript 原生提供Integer对象，用来生成Integer类型的数值。转换规则基本与Number()一致。 运算在数学运算方面，Iteger类型的+、-、*和**这四个二元运算符，与Number类型的行为一致。除法运算/会舍去小数部分，返回一个整数： 19n / 5n // 1n 几乎所有的 Number 运算符都可以用在 Integer，但是有两个除外：不带符号的右 移位运算符&gt;&gt;&gt;和一元的求正运算符+，使用时会报错。前者是因为&gt;&gt;&gt;要求 最高位补0，但是 Integer 类型没有最高位，导致这个运算符无意义。后者是因为一 元运算符+在 asm.js 里面总是返回 Number 类型或者报错。 Integer 类型不能与 Number 类型进行混合运算： 121n + 1// 报错 相等运算符==会改变数据类型，也是不允许混合使用。 精确相等运算符===不会改变数据类型，因此可以混合使用。 函数的扩展函数参数的默认值基本用法ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面： 123456function log(x, y = 'world') &#123; console.log(x, y);&#125;log('hello'); // hello worldlog('hello', ''); // hello 参数变量是默认声明的，所以不能用let或const再次声明。 使用参数默认值时，函数不能有同名参数。 另外，一个容易忽略的地方是，参数默认值不是传值的，而是每次都重新计算默认 值表达式的值。也就是说，参数默认值是惰性求值的。 与解构赋值默认值结合使用123456789101112131415function foo(&#123;x, y = 5&#125;) &#123; console.log(x, y);&#125;foo(&#123;&#125;); // undefined 5foo(&#123;x: 1&#125;); // 1 5foo(); // TypeError: Cannot read property 'x' of undefined/*****避免报错******/function foo(&#123;x, y = 5&#125; = &#123;&#125;) &#123; console.log(x, y);&#125;foo() // undefined 5 123456789101112131415161718function fetch(url, &#123; body = '', method = 'GET', headers = &#123;&#125;&#125;) &#123; console.log(method);&#125;fetch('http://example.com', &#123;&#125;);// 'GET'fetch('http://example.com');// 报错/*****避免报错******/function fetch(url, &#123; method = 'GET'&#125; = &#123;&#125;) &#123; console.log(method);&#125;fetch('http://example.com');// 'GET' 下面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空 对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体 属性的对象，但是没有设置对象解构赋值的默认值 123456789101112131415161718192021222324// 写法一function m1(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;// 写法二function m2(&#123;x, y&#125; = &#123;x: 0, y: 0&#125;) &#123; return [x, y];&#125;m1(); // [0, 0]m2(); // [0, 0]m1(&#123;x: 3, y: 8&#125;); // [3, 8]m2(&#123;x: 3, y: 8&#125;); // [3, 8]m1(&#123;x: 3&#125;); // [3, 0]m2(&#123;x: 3&#125;); // [3, undefined]m1(&#123;&#125;); // [0, 0]m2(&#123;&#125;); // [undefined, undefined]m1(&#123;z: 3&#125;); // [0, 0]m2(&#123;z: 3&#125;); // [undefined, undefined] 参数默认值的位置通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的: 12345678function f(x = 1, y) &#123; return [x, y];&#125;f(); // [1, undefined]f(2); // [2, undefined]f(,1); // 报错f(undefined, 1); // [1, 1] 如果传入undefined，将触发该参数等于默认值，null则没有这个效果。 函数的length属性指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。 这是因为length属性的含义是，该函数预期传入的参数个数。某个参数指定默认 值以后，预期传入的参数个数就不包括这个参数了。同理，下面的rest参数也不会 计入length属性。 1(function(...args) &#123;&#125;).length; // 0 如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。 作用域一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域 （context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。 12345678910111213141516171819202122var x = 1;function f(x, y = x) &#123; //调用函数 f 时，参数形成一个单独的作用域。在这个作用域里面，默认值变量x 指向第⼀个参数 x console.log(y);&#125;f(2); // 2/**********************************/let x = 1;function f(y = x) &#123; //上面代码中，函数 f 调用时，参数 y = x 形成一个单独的作用域。这个作用域里 面，变量 x 本身没有定义，所以指向外层的全局变量 x 。函数调用时，函数体内部的局部变量x影响不到默认值变量x let x = 2; console.log(y);&#125;f(); // 1 下面这样写，会报错: 1234567var x = 1;function foo(x = x) &#123; // ....&#125;foo(); // ReferenceError: x is not defined 上面代码中，参数x = x形成一个单独作用域。实际执行的是 let x = x 由于暂时性死区的原因，这行代码会报错”x 未定义“。 如果参数的默认值是一个函数，该函数的作用域也遵守这个规则。 应用利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误： 123456789function throwIfMissing() &#123; throw new Error('Missing parameter');&#125;function foo(mustBeProvided = throwIfMissing()) &#123; return mustBeProvided;&#125;foo(); // Error: Missing parameter rest 参数ES6引入rest参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中。 1234567891011function add(...values) &#123; let sum = 0; for (var val of values) sum += val; &#125; return sum; &#125; add(2, 5, 3); // 10 rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。 函数length属性，不包括rest参数。 严格模式ES2016规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。 这样规定的原因是，函数内部的严格模式，同时适用于函数体和函数参数。但是， 函数执行的时候，先执行函数参数，然后再执行函数体。这样就有一个不合理的地方，只有从函数体之中，才能知道参数是否应该以严格模式执行，但是参数却应该先于函数体执行。 两种方法可以规避这种限制。第一种是设定全局性的严格模式，这是合法的；第二种是把函数包在一个无参数的立即执行函数里面。 name属性函数的name属性，返回函数的函数名。 需要注意的是，如果将一个匿名函数赋值给一个变量，ES5 的name属性，会返回空字符串，而 ES6 的name属性会返回 实际的函数名。 箭头函数基本用法ES6允许使用=&gt;定义函数： 1var f = v =&gt; v; 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来。 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外 面加上括号，否则会报错。 如果箭头函数只有一行语句，且不需要返回值，可以采用下面的写法，就不用写大括号了: 1let fn = () =&gt; void doesNotReturn(); 箭头函数可以与变量解构结合使用: 123456const full = (&#123;first, last&#125;) =&gt; first + ' ' + last; // 等同于 function full(person) &#123; return person.first + ' ' + person.last &#125; 使用注意点 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象 不可以当做构造函数，也就是说，不可以使用new命令，否则会抛出一个错误 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替 不可以用yield命令，因此箭头函数不能用作 Generator 函数 this对象的指向是可变的，但是在箭头函数中，它是固定的，总是指向函数定义生效时所在的对象。 123456789function foo() &#123; setTimeout(() =&gt; &#123; console.log('id:', this.id); &#125;, 100) &#125; var id = 21; foo.call(&#123;id: 42&#125;); // id: 42 箭头函数可以让 setTimeout 里面的 this ，绑定定义时所在的作用域，而不是指向运行时所在的作用域。 1234567891011121314151617function Timer() &#123; this.s1 = 0; this.s2 = 0; setInterval(() =&gt; this.s1++, 1000); setInterval(function () &#123; this.s2++; &#125;, 1000);&#125;var timer = new Timer();setTimeout(() =&gt; console.log('s1: ', timer.s1), 3100);setTimeout(() =&gt; console.log('s2: ', timer.s2), 3100);// s1: 3// s2: 0 上面代码中， Timer 函数内部设置了两个定时器，分别使用了箭头函数和普通函 数。前者的this绑定定义时所在的作用域（即 Timer 函数），后者的this指 向运行时所在的作用域（即全局对象）。所以，3100毫秒之后，timer.s1被更 新了3次，而timer.s2一次都没更新。 箭头函数可以让this指向固定化，这种特性很有利于封装回调函数。 this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因 是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。 除了this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变arguments、super、new.target。 由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。 嵌套的箭头函数12345678let insert = (value) =&gt; (&#123;into: (array) =&gt; (&#123;after: (afterValue) =&gt; &#123; array.splice(array.indexOf(afterValue) + 1, 0, value); return array; &#125; &#125;)&#125;);insert(2).into([1, 3]).after(1); // [1, 2, 3] 绑定this箭头函数可以绑定this对象，大大减少了显式绑定this对象的写法（call、apply、bind）。但是，箭头函数并不适用于所有场合，所以ES7 提出了“函数绑定”（function bind）运算符，用来取代call、apply、bind调用。虽然该语法还是ES7的一个提案，但是Babel已经支持。 函数绑定运算符是并排的两个冒号（::），双冒号左边是一个对象，右边是一个函 数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。 1234567foo::bar;// 等同于bar.bind(foo);foo::bar(...arguments);// 等同于bar.apply(foo, arguments); 如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上 面: 1234567var method = obj::obj.foo;// 等同于var method = ::obj.foo;let log = ::console.log;// 等同于var log = console.log.bind(console); 由于双冒号运算符返回的还是原对象，因此可以采用链式写法: 1234567891011121314// 例一import &#123; map, takeWhile, forEach &#125; from "iterlib";getPlayers()::map(x =&gt; x.character())::takeWhile(x =&gt; x.strength &gt; 100)::forEach(x =&gt; console.log(x));// 例二let &#123; find, html &#125; = jake;document.querySelectorAll("div.myClass")::find("p")::html("hahaha"); 尾调用优化什么是尾调用尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说 清楚，就是指某个函数的最后一步是调用另一个函数。 123function f(x) &#123; return g(x); &#125; 上面代码中，函数f的最后一步是调用函数g，这就叫尾调用。 以下三种情况 不属于尾调用： 123456789101112131415// 情况一function f(x) &#123; let y = g(x); return y;&#125;// 情况二function f(x) &#123; return g(x) + 1;&#125;// 情况三function f(x) &#123; g(x);&#125; 尾调用不一定出现在函数尾部，只要是最后一步操作即可: 123456function f(x) &#123; if (x &gt; 0) &#123; return m(x); &#125; return n(x);&#125; 尾调用优化函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame）， 保存调用位置和内部变量等信息。如果在函数 A 的内部调用函数 B ，那么在 A 的调用帧上方，还会形成一个 B 的调用帧。等到 B 运行结束，将结果返回 到 A ， B 的调用帧才会消失。如果函数 B 内部还调用函数 C ，那就还有一个 C 的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用 位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层 函数的调用帧就可以了。 12345678910111213141516function f() &#123; let m = 1; let n = 2; return g(m + n);&#125;f();// 等同于function f() &#123; return g(3);&#125;f();// 等同于g(3); 上面代码中，如果函数g不是尾调用，函数 f 就需要保存内部变量m和n的 值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到 最后一步，完全可以删除f(x)的调用帧，只保留g(3)的调用帧。 这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如 果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大 大节省内存。这就是“尾调用优化”的意义。 注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的 调用帧，否则就无法进行“尾调用优化”。 尾递归函数调用自身，称为递归。如果尾调用自身，就称为尾递归。 递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错 误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会 发生“栈溢出”错误。 123456function factorial(n) &#123; if (n === 1) return 1; return n * factorial(n - 1);&#125;factorial(5); // 120 上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度O(n)。 如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。 123456function factorial(n, total) &#123; if (n === 1) return total; return factorial(n-1, n * total);&#125;factorial(5, 1); // 120 非尾递归的Fibonacci数列实现： 12345678function Fibonacci(n) &#123; if (n &lt;= 1) &#123;return 1&#125;; return Fibonacci(n - 1) + Fibonacci(n - 2);&#125;Fibonacci(10); // 89Fibonacci(100); // 堆栈溢出Fibonacci(500); // 堆栈溢出 尾递归优化过后： 123456789function Fibonacci2(n, ac1 = 1, ac2 = 1) &#123; if (n &lt;= 1) &#123;return ac2&#125;; return Fibonacci2(n - 1, ac2, ac1 + ac2);&#125;Fibonacci2(100); // 573147844013817200000Fibonacci2(1000); // 7.0330367711422765e+208Fibonacci2(10000); // Infinity 由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入 了语言规格。ES6 是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部 署“尾调用优化”。这就是说，ES6 中只要使用尾递归，就不会发生栈溢出，相对节省内存。 递归函数的改写尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的 方法，就是把所有用到的内部变量改写成函数的参数。这样做的缺点就是不太直观。 两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的 函数。 12345678910function tailFactorial(n, total) &#123; if (n === 1) return total; return tailFactorial(n - 1, n * total);&#125;function factorial(n) &#123; return tailFactorial(n, 1);&#125;factorial(5); // 120 函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成 单参数的形式。这里也可以使用柯里化。 1234567891011121314function currying(fn, n) &#123; return function (m) &#123; return fn.call(this, m, n); &#125;;&#125;function tailFactorial(n, total) &#123; if (n === 1) return total; return tailFactorial(n - 1, n * total);&#125;const factorial = currying(tailFactorial, 1);factorial(5); // 120 第二种方法就简单多了，就是采用 ES6 的函数默认值。 123456function factorial(n, total = 1) &#123; if (n === 1) return total; return factorial(n - 1, n * total);&#125;factorial(5); // 120 总结一下，递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命 令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。对于其 他支持“尾调用优化”的语言（比如Lua，ES6），只需要知道循环可以用递归代替， 而一旦使用递归，就最好使用尾递归。 严格模式ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。 这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。 func.arguments：返回调用时函数的参数。 func.caller：返回调用当前函数的那个函数。 尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式 禁用这两个变量，所以尾调用模式仅在严格模式下生效。 尾递归优化的实现那么正常模式下，或者那些不支持该功能的环境 中，可以采用“循环”换掉“递 归”来实现尾递归优化。它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么 只要减少调用栈，就不会溢出。 蹦床函数（trampoline）可以将递归执行转为循环执行。 123456function trampoline(f) &#123; while (f &amp;&amp; f instanceof Function) &#123; f = f(); &#125; return f;&#125; 上面就是蹦床函数的一个实现，它接受一个函数 f 作为参数。只要 f 执行后返回 一个函数，就继续执行。注意，这里是返回一个函数，然后执行该函数，而不是函 数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题。 123456789101112131415161718192021function sum(x, y) &#123; if (y &gt; 0) &#123; return sum(x + 1, y - 1); &#125; else &#123; return x; &#125;&#125;sum(1, 100000); // Uncaught RangeError: Maximum call stack size exceeded(…)/**************改写后**************/function sum(x, y) &#123; if (y &gt; 0) &#123; return sum.bind(null, x + 1, y - 1); &#125; else &#123; return x; &#125;&#125;trampoline(sum(1, 100000)); // 100001 蹦床函数并不是真正的尾递归优化，下面的实现才是： 123456789101112131415161718192021222324252627function tco(f) &#123; var value; var active = false; var accumulated = []; return function accumulator() &#123; accumulated.push(arguments); if (!active) &#123; active = true; while (accumulated.length) &#123; value = f.apply(this, accumulated.shift()); &#125; active = false; return value; &#125; &#125;;&#125;var sum = tco(function (x, y) &#123; if (y &gt; 0) &#123; return sum(x + 1, y + 1); &#125; else &#123; return x; &#125;&#125;);sum(1, 100000); // 100001 tco函数是尾递归优化的实现，它的奥妙就在于状态变量active。默认情况下，这个变量是不激活的。一旦进入尾递归优化的过程，这 个变量就激活了。然后，每一轮递归sum返回的都是undefined，所以就避免 了递归执行；而accumulated数组存放每一轮sum执行的参数，总是有值的，这就保证了accumulator函数内部的while循环总是会执行。这样就很巧妙地 将“递归”改成了“循环”，而后一轮的参数会取代前一轮的参数，保证了调用栈只有一层。 函数参数的尾逗号ES2017允许函数的最后一个参数有尾逗号。此前，函数定义和调用时，都不允许最后一个参数后面出现逗号。 数组的扩展扩展运算符含义扩展运算符（spread）是...。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。 12345678console.log(...[1, 2, 3]);// 1 2 3console.log(1, ...[2, 3, 4], 5);// 1 2 3 4 5[...document.querySelectorAll('div')];// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;] 该运算符主要用于函数调用: 12345678910function push(array, ...items) &#123; array.push(...items);&#125;function add(x, y) &#123; return x + y;&#125;var numbers = [4, 38];add(...numbers); 扩展运算符与正常的函数参数可以结合使用，非常灵活: 123function f(v, w, x, y, z) &#123;&#125;var args = [0, 1];f(-1, ...args, 2, ...[3]); 扩展运算符后面还可以放置表达式： 1234const arr = [ ...(x &gt; 0 ? ['a'] : []), 'b',]; 如果扩展运算符后面是一个空数组，则不产生任何效果。 替代数组的apply方法由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数： 12345678910111213// ES5的写法function f(x, y, z) &#123; // ...&#125;var args = [0, 1, 2];f.apply(null, args);// ES6的写法function f(x, y, z) &#123; // ...&#125;var args = [0, 1, 2];f(...args); 扩展运算符的应用 合并数组 12345678910111213141516// ES5[1, 2].concat(more);// ES6[1, 2, ...more];var arr1 = ['a', 'b'];var arr2 = ['c'];var arr3 = ['d', 'e'];// ES5的合并数组arr1.concat(arr2, arr3);// ['a', 'b', 'c', 'd', 'e']// ES6的合并数组[...arr1, ...arr2, ...arr3];// ['a', 'b', 'c', 'd', 'e'] 与解构赋值结合 12345// ES5a = list[0], rest = list.slice(1);// ES6[a, ...rest] = list; 如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。 函数的返回值 JavaScript 的函数只能返回一个值，如果需要返回多个值，只能返回数组或对象。 扩展运算符提供了解决这个问题的一种变通方法。 12var dateFields = readDateFields(database);var d = new Date(...dateFields); 字符串 扩展运算符还可以将字符串转为真正的数组： 12[...'hello']// ['h', 'e', 'l', 'l', 'o'] 上面的写法，有一个重要的好处，那就是能够正确识别32位的Unicode字符。 实现了Iterator接口的对象 任何 Iterator 接口的对象，都可以用扩展运算符转为真正的 数组。 12var nodeList = document.querySelectorAll('div');var array = [...nodeList]; 上面代码中，querySelectorAll方法返回的是一个nodeList对象。它不是数 组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因 就在于NodeList对象实现了 Iterator。 对于那些没有部署 Iterator 接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。 Map和Set结构，Generator函数 扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的 对象，都可以使用扩展运算符，比如 Map 结构。 Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。 Array.from()Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历的对象。 123456789101112let arrayLike = &#123; '0': 'a', '1': 'b', '2': 'c', length: 3&#125;;// ES5的写法var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']// ES6的写法let arr2 = Array.from(arrayLike); // ['a', 'b', 'c'] 实际应用中，常见的类似数组的对象是DOM操作返回的NodeList集合，以及函数内 部的arguments对象。Array.from都可以将它们转为真正的数组。 只要是部署了Iterator接口的数据结构，Array.from都能将其转为数组。 Array.from方法还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换。 Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组： 123456Array.from(arrayLike, x =&gt; x * x);// 等同于Array.from(arrayLike).map(x =&gt; x * x);Array.from([1, 2, 3], (x) =&gt; x * x);// [1, 4, 9] 如果map函数里面用到了this关键字，还可以传入Array.from的第三个参数，用来绑定this。 Array.from()可以将各种值转为真正的数组，并且还提供map功能。这实际上 意味着，只要有一个原始的数据结构，你就可以先对它的值进行处理，然后转成规 范的数组结构，进而就可以使用数量众多的数组方法。 12Array.from(&#123;length: 2&#125;, () =&gt; 'jack');// ['jack', 'jack'] Array.from()的另一个应用是，将字符串转为数组，然后返回字符串的长度。 因为它能正确处理各种Unicode字符，可以避免JavaScript将大于\uFFFF的 Unicode字符，算作两个字符的bug。 Array.of()Array.of方法用于将一组值，转换为数组。 这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。 123456Array.of(3); // [3]Array.of(3, 11, 8); // [3, 11, 8]Array(); // []Array(3); // [,,,]Array(3, 11, 8); // [3, 11, 8] Array.of总是返回参数值组成的数组。如果没有参数，就返回一个空数组。 数组实例的copyWithin() 数组实例的copyWithin()方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。 它接受三个参数: target（必需）：从该位置开始替换数据。 start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。 end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值， 表示倒数。 这三个参数都应该是数值，如果不是，会自动转为数值: 12[1, 2, 3, 4, 5].copyWithin(0, 3);// [4, 5, 3, 4, 5] 数组实例的find()和findIndex()数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回 调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成 员，然后返回该成员。如果没有符合条件的成员，则返回undefined。 12[1, 4, -5, 10].find((n) =&gt; n &lt; 0);// -5 find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。 数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件 的数组成员的位置，如果所有成员都不符合条件，则返回-1。 123[1, 5, 10, 15].findIndex(function (value, index, arr) &#123; return value &gt; 9;&#125;); // 2 这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。 另外，这两个方法都可以发现NaN。 数组实例的fill()fill方法使用给定值，填充一个数组： 12345['a', 'b', 'c'].fill(7);// [7, 7, 7]new Array(3).fill(7);// [7, 7, 7] fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置： 12['a', 'b', 'c'].fill(7, 1, 2);// ['a', 7, 'c'] 数组实例的entries(), keys()和values()entries(),keys()和values()用于遍历数组。都返回一个遍历器对象，可以用for...of循环遍历，唯一的区别是key()是对键名的遍历，values()是键值的遍历，entries()是对键值对的遍历： 1234567891011121314151617for (let index of ['a', 'b'].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of ['a', 'b'].values()) &#123; console.log(elem);&#125;// 'a'// 'b'for (let [index, elem] of ['a', 'b'].entries()) &#123; console.log(index, elem);&#125;// 0 'a'// 1 'b' 可以手动调用遍历器对象的next方法进行遍历： 12345let letter = ['a', 'b', 'c'];let entries = letter.entries();console.log(entries.next().value); // [0, 'a']console.log(entries.next().value); // [1, 'b']console.log(entries.next().value); // [2, 'c'] 数组实例的includes()includes()方法返回一个布尔值，表示某个数组是否包含给定的值。 123[1, 2, 3].includes(2); // true[1, 2, 3].includes(4); // false[1, 2, 3].includes(NaN); // true 该方法的第二个参数表示搜索的起始位置，默认为 0 。如果第二个参数为负数， 则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为 -4 ，但数组长 度为 3 ），则会重置为从 0 开始。 没有该方法之前，我们通常使用数组的indexof放，检查是否包含某个值。indexof方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出 现位置，所以要去比较是否不等于 -1 ，表达起来不够直观。二是，它内部使用严 格相等运算符（ === ）进行判断，这会导致对 NaN 的误判。 另外，Map 和 Set 数据结构有一个has方法： Map 结构的 has 方法，是用来查找键名的，比如Map.prototype.has(key) 、WeakMap.prototype.has(key)、Reflct.has(target, propertyKey) Set 结构的has方法，是用来查找值的，比如Set.prototype.has(value)、WeakSet.prototype.has(value) 数组的空位数组的空位指，数组的某一个位置没有任何值。比如， Array构造函数返回的组都是空位。 1Array(3); // [, , ,] 注意，空位不是undefined，一个位置的值等于undefined，依然是有值的。空位是没有任何值， in 运算符可以说明这一点: 120 in [undefined, undefined, undefined]; // true0 in [, , ,] // false 上面代码说明，第一个数组的0号位置是有值的，第二个数组的0号位置没有值。 ES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位。 ES6 则是明确将空位转为undefined。 由于空位的处理规则非常不统一，所以建议避免出现空位。 对象的扩展属性的简洁表示法ES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。 1234567891011121314151617var foo = 'bar';var baz = &#123;foo&#125;;baz // &#123;foo: 'bar'&#125;// 等同于var baz = &#123;foo: foo&#125;;/*************分隔线**************/function f(x ,y) &#123; return &#123;x, y&#125;;&#125;// 等同于function f(x, y) &#123; return &#123;x: x, y: y&#125;;&#125; 上面代码表明，ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性 值为变量的值。 除了属性简写，方法也可以简写。 123456789101112var o = &#123; method() &#123; return 'hello'; &#125;&#125;;// 等同于var o = &#123; method: function () &#123; return 'hello'; &#125;&#125;; 注意，简洁写法的属性名总是字符串，这会导致一些看上去比较奇怪的结果: 12345678910var obj = &#123; class() &#123;&#125;&#125;;// 等同于var obj = &#123; 'class': function () &#123; &#125;&#125;; class是字符串，所以不会因为它属于关键字，而导致语法解析报错。 如果某个方法的值是一个 Generator 函数，前面需要加上星号。 属性名表达式ES6 允许字面量定义对象时，用表达式作为对象的属性名，即把表达式放在方括号内。 12345let propKey = 'foo';let obj = &#123; [propKey]: true, ['a' + 'bc']: 123&#125;; 表达式还可以用于定义方法名。注意，属性名表达式与简洁表示法，不能同时使用，会报错。 123456789101112let obj = &#123; ['h' + 'ello']() &#123; return 'hi'; &#125;&#125;;obj.hello(); // hi// 报错var foo = 'bar';var bar = 'abc';var baz = &#123; [foo] &#125;; 注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串 [object Object]，这一点要特别小心。 方法的name属性函数的name属性，返回函数名。对象方法也是函数，因此也有name属性。 如果对象的方法使用了取值函数（getter）和存值函数（setter）， 则name属性不是在该方法上面，而是该方法的属性的描述对象的get和set属性上面，返回值是方法名前加上get和set。 123456789101112const obj = &#123; get foo() &#123;&#125;, set foo(x) &#123;&#125;&#125;;obj.foo.name;// TypeError: Cannot read property 'name' of undefinedconst descriptor = Object.getOwnPropertyDescriptor(obj, 'foo');descriptor.get.name; // 'get foo'descriptor.set.name; // 'set foo' 有两种特殊情况：bind方法创造的函数，name属性返回bound加上原函数的名字；Function构造函数创造的函数，name属性返回anonymous。 如果对象的方法是一个 Symbol 值，那么name属性返回的是这个 Symbol 值的描述。 Object.is()ES6 提出“Same-value equality”（同值相等）算法，用来解决在所有环境中，只要两个值是 一样的，它们就应该相等的问题。Object.is就是部署这个算法的新方法。它用来比较两个值是否严格相等， 与严格比较运算符（===）的行为基本一致。 不同之处只有两个：一是+0不等于-0，二是NaN等于自身。 1234Object.is('foo', 'foo'); // trueObject.is(&#123;&#125;, &#123;&#125;); // falseObject.is(+0, -0); // falseObject.is(NaN, NaN); // true Object.assign()基本用法Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象。该方法的第一个参数是目标对象，后面的参数都是源对象。注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属 性会覆盖前面的属性。 123456var target = &#123;a: 1, b: 1&#125;;var source1 = &#123;b: 2, c: 2&#125;;var source2 = &#123;c: 3&#125;;Object.assign(target, source1, source2);target; // &#123;a: 1, b: 2, c: 3&#125; 如果只有一个参数，Object.assign会直接返回该参数。如果该参数不是对象，则会先转成对象，然后返回。undefined和null无法转成对象，所以如果它们作为参数，就会报错。 如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首 先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果undefined和null不在首参数，就不会报错。 字符串会以数组形式，拷贝入目标对象。这是因为只有字 符串的包装对象，会产生可枚举属性。 Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）。 属性名为 Symbol 值的属性，也会被Object.assign拷贝。 注意点Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某 个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。 12345var obj1 = &#123;a: &#123;b: 1&#125;&#125;;var obj2 = Object.assign(&#123;&#125;, obj1);obj1.a.b = 2;obj2.a.b // 2 对于这种嵌套的对象，一旦遇到同名属性，Object.assign的处理方法是替换，而不是添加。 有一些函数库提供Object.assign的定制版本（比如 Lodash的_.defaultsDeep方法），可以解决浅拷贝的问题，得到深拷贝的合并。 Object.assign可以用来处理数组，但是会把数组视为对象。 12Object.assign([1, 2, 3], [4, 5]);// [4, 5, 3] Object.assign把数组视为属性名为0、1、2的对象，因此源数组的0号属性4覆盖了目标数组的0号属性1。 常见用途 为对象添加属性 12345class Point &#123; constructor(x, y) &#123; Object.assign(this, &#123;x, y&#125;); &#125;&#125; 为对象添加方法 1234567891011121314151617Object.assign(SomeClass.prototype, &#123; someMethod(arg1, arg2) &#123; // ... &#125;, anotherMethod() &#123; // ... &#125;&#125;);// 等同于SomeClass.prototype.someMethod = function (arg1, arg2) &#123; // ...&#125;;SomeClass.prototype.anotherMethod = function () &#123; // ...&#125;; 克隆对象 123function clone(origin) &#123; return Object.assign(&#123;&#125;, origin);&#125; 上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆。 不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码: 1234function clone(orgin) &#123; let orginProto = Object.getPrototypeOf(orgin); return Object.assign(Object.create(orginProto), orgin);&#125; 合并多个对象 1const merge = (target, ...sources) =&gt; Object.assign(target, ...sources); 为属性指定默认值 12345678910const DEFAULTS = &#123; logLevel: 0, outputFormat: 'html'&#125;;function processContent(options) &#123; options = Object.assign(&#123;&#125;, DEFAULTS, options); console.log(options); // ...&#125; 注意，由于存在浅拷贝的问题，DEFAULTS对象和options对象的所有属性的 值，最好都是简单类型，不要指向另一个对象。否则，DEFAULTS对象的该属性很 可能不起作用。 属性的可枚举性和遍历可枚举性对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。 12345678let obj = &#123;foo: 123&#125;;Object.getOwnPropertyDescriptor(obj, 'foo');// &#123;// value: 123,// writable: true,// enumerable: true,// configurable: true// &#125; 描述对象的 enumerable 属性，称为”可枚举性“，如果该属性为false，就表示某些操作会忽略当前属性。 目前，有四个操作会忽略enumerable为false的属性： for…in循环：只遍历对象自身的和继承的可枚举的属性。 Object.keys()：返回对象自身的所有可枚举的属性的键名。 JSON.stringify()：只串行化对象自身的可枚举的属性。 Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。 实际上，引入“可枚举”（ enumerable ）这个概念的 最初目的，就是让某些属性可以规避掉for…in操作，不然所有内部属性和方法 都会被遍历到。比如，对象原型的toString方法，以及数组的length属性，就通过“可枚举性”，从而避免被for…in遍历到。 ES6 规定，所有 Class 的原型的方法都是不可枚举的。 操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象 自身的属性。所以，尽量不要用for…in循环，而用Object.keys()代替。 属性的遍历ES6 一共有5种方法可以遍历对象的属性： for…in for…in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。 Object.keys(obj) Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）。 Object.getOwnPropertyNames(obj) Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含Symbol 属性，但是包括不可枚举属性）。 Object.getOwnPropertySymbols(obj) Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol属性。 Reflect.ownKeys(obj) Reflect.ownKeys返回一个数组，包含对象自身的所有属性，不管属性名是Symbol 或字符串，也不管是否可枚举。 以上的5种⽅方法遍历对象的属性，都遵守同样的属性遍历的次序规则: 首先遍历所有属性名为数值的属性，按照数字排序。 其次遍历所有属性名为字符串的属性，按照生成时间排序。 最后遍历所有属性名为 Symbol 值的属性，按照生成时间排序。 Object.getOwnPropertyDescriptors()Object.getOwnPropertyDescriptor方法会返回某个对象属性的描述对象（descriptor）。ES2017 引入了Object.getOwnPropertyDescriptors法，返回指定对象所有自身属性（非继承属性）的描述对象。 12345678910111213141516const obj = &#123; foo: 123, get bar() &#123; return 'abc' &#125;&#125;;Object.getOwnPropertyDescriptors(obj);// &#123; foo:// &#123; value: 123,// writable: true,// enumerable: true,// configurable: true &#125;,// bar:// &#123; get: [Function: bar],// set: undefined,// enumerable: true,// configurable: true &#125; &#125; 该方法的引入目的，主要是为了解决Object.assign()无法正确拷贝get属性和set属性的问题。 12345678910111213141516const source = &#123; set foo(value) &#123; console.log(value);; &#125;&#125;;const target1 = &#123;&#125;;Object.assign(target1, source);Object.getOwnPropertyDescriptor(target1, 'foo');// &#123;// value: undefined,// writable: true,// enumerable: true,// configurable: true// &#125; Object.assign方法将source对象的foo属性拷贝给target1对象，结果该属性的值undefined。这是因为Object.assign方法总是拷贝一个属性的值，而不拷贝它背后的赋值方法或取值方法。这时，Object.getOwnPropertyDescriptors方法配合Object.defineProperties方法，就可以实现正确拷贝: 12345678910111213const source = &#123; set foo(value) &#123; console.log(value); &#125;&#125;;const target2 = &#123;&#125;;Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));Object.getOwnPropertyDescriptor(target2, 'foo');// &#123; get: undefined,// set: [Function: foo],// enumerable: true,// configurable: true &#125; Object.getOwnPropertyDescriptors方法的另一个用处，是配合Object.create方法，将对象属性克隆到一个新对象。这属于浅拷贝。 12345678const clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));// 或者const shallowClone = (obj) =&gt; Object.create( Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj)); 另外，Object.getOwnPropertyDescriptors方法可以实现一个对象继承另一个 对象。以前，继承另一个对象，常常写成下面这样： 1234const obj = &#123; _proto_: port, foo: 123,&#125;; ES6 规定_proto_只有浏览器要部署，其他环境不用部署。如果去除_proto_，上面代码就改成这样： 1234567891011const obj = Object.create(prot);obj.foo = 123;// 或者const obj = Object.assign( Object.create(prot), &#123; foo: 123, &#125;); 有了Object.getOwnPropertyDescriptors，就可以这样写： 123456const obj = Object.create( prot, Object.getOwnPropertyDescriptors(&#123; foo: 123, &#125;)); Object.getOwnPropertyDescriptors也可以用来实现Mixin模式: 12345678910111213141516let mix = (object) =&gt; (&#123; with: (...mixins) =&gt; mixins.reduce( (c, mixin) =&gt; Object.create( c, Object.getOwnPropertyDescriptors(mixin) ), object)&#125;);// multiple mixins examplelet a = &#123;a: 'a'&#125;;let b = &#123;b: 'b'&#125;;let c = &#123;c: 'c'&#125;;let d = mix(c).with(a, b);d.c // 'c'd.b // 'b'd.a // 'a' _ protp _属性，Object.setPrototypeOf()，Object.getPrototypeOf()_ protp _属性 _protp_属性，用来读取或设置当前对象的prototype对象。 该属性没有写入 ES6 的正文，而是写入了附录，原因是 __proto__前后的双下划 线，说明它本质上是一个内部属性，而不是一个正式的对外的 API，只是由于浏览 器广泛支持，才被加入了 ES6。标准明确规定，只有浏览器必须部署这个属性，其 他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此， 无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的Object.setPrototypeOf()（写操作）、Object.getPrototypeOf()（读操作）、Object.create()（生成操作）代替。 实现上，__proto__调用的是Object.prototype.__proto__。 如果一个对象本身部署了__proto__属性，则该属性的值就是对象的原型。 Object.setPrototypeOf()Object.setPrototypeOf方法的作用与__proto__相同，用来设置一个对象的prototype对象，返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法。 12345678910let proto = &#123;&#125;;let obj = &#123; x: 10 &#125;;Object.setPrototypeOf(obj, proto);proto.y = 20;proto.z = 40;obj.x // 10obj.y // 20obj.z // 40 上面代码将proto对象设为obj对象的原型，所以从obj对象可以读取proto对象的属性。 如果第一个参数不是对象，会自动转为对象。但是由于返回的还是第一个参数，所以这个操作不会产生任何效果。 undefined和null无法转为对象，所以如果第一个参数是undefined或null，就会报错。 Object.getPrototypeOf()Object.getPrototypeOf()方法用于读取一个对象的原型对象。 如果参数不是对象，会被自动转为对象。 Object.keys()，Object.values()，Object.entries()Object.keys()ES5 引入了Object.keys()方法，返回一个数组，成员是参数对象自身的（不含继 承的）所有可遍历（enumerable）属性的键名。 Object.values()Object.values()方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。返回数组的成员顺序，与本章的《属性的遍历》部分介绍的排列规则一致。 123var obj = &#123;100: 'a', 2: 'b', 7: 'c'&#125;;Object.values(obj);// ["b", "c", "a"] 上面代码中，属性名为数值的属性，是按照数值大小，从小到大遍历的，因此返回 的顺序是b、c、a。 Object.values只返回对象自身的可遍历属性。 Object.values会过滤属性名为 Symbol 值的属性。 Object.values方法的参数是一个字符串，会返回各个字符组成的一个数组。 如果参数不是对象，Object.values会先将其转为对象。由于数值和布尔值的包 装对象，都不会为实例添加非继承的属性。所以，Object.values会返回空数 组。 Object.entriesObject.entries方法返回一个数组，成员是参数对象自身的（不含继承的）所 有可遍历（enumerable）属性的键值对数组。 除了返回值不一样，该方法的行为与Object.values基本一致。 Object.entries的基本用途是遍历对象的属性: 123456let obj = &#123;one: 1, two: 2&#125;;for (let [k, v] of Object.entries(obj)) &#123; console.log(`$&#123;JSON.stringify(k)&#125;: $&#123;JSON.stringify(v)&#125;`);&#125;// "one": 1// "two": 2 Object.entries方法的另一个用处是，将对象转为真正的Map结构： 123var obj = &#123; foo: 'bar', baz: 42 &#125;;var map = new Map(Object.entries(obj));map // Map &#123; foo: "bar", baz: 42 &#125; 对象的扩展运算符 解构赋值 对象的解构赋值用于从一个对象取值，相当于将所有可遍历的、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。 1234let &#123;x, y, ...z&#125; = &#123;x: 1, y: 2, a: 3, b: 4&#125;;x // 1y // 2z // &#123;a: 3, b: 4&#125; 由于解构赋值要求等号右边是一个对象，所以如果等号右边是undefined或null，就会报错，因为它们无法转为对象。 解构赋值必须是最后一个参数，否则会报错。 注意，解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对 象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。 另外，解构赋值不会拷贝继承自原型对象的属性。 123456let o1 = &#123; a: 1 &#125;;let o2 = &#123; b: 2 &#125;;o2._proto_ = o1;let &#123; ...o3 &#125; = o2;o3 // &#123; b: 2 &#125;o3.a // undefined 1234567var o = Object.create(&#123;x: 1, y: 2&#125;);o.z = 3;let &#123;x, ...&#123;y, z&#125;&#125; = o;x // 1y // undefinedz // 3 Object.create({x: 1, y: 2})为对象o的原型继承了{x: 1, y: 2}，let {x, ...{y, z}} = o;中变量x是单纯的解构赋值，所以可以读取对象o继承的属性；变量y和z是双重解构赋值，只能读取对象o自身的属性，所以只有变量z可以赋值成功。 解构赋值的一个用处，是扩展某个函数的参数，引入其他操作： 123456789function baseFunction(&#123;a, b&#125;) &#123; // ...&#125;function wrapperFunction(&#123;x, y, ...restConfig&#125;) &#123; // 使用x和y参数进行操作 // 其余参数传给原始函数 return baseFunction(restConfig);&#125; 扩展运算符 扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。 123let z = &#123;a: 3, b: 4&#125;;let n = &#123;...z&#125;;n // &#123;a: 3, b: 4&#125; 上面的例子只是拷贝了对象实例的属性，如果想完整克隆一个对象，还拷贝对象原 型的属性，可以采用下面的写法: 1234567891011// 写法一const clone1 = &#123; _proto_: Object.getPrototypeOf(obj), ...obj&#125;;// 写法二const clone2 = Object.assign( Object.create(Object.getPrototypeOf(obj)), obj); 扩展运算符可以用于合并两个对象: 123let ab = &#123;...a, ...b&#125;;// 等同于let ab = Object.assign(&#123;&#125;, a, b); 如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。如果把自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值。 与数组的扩展运算符一样，对象的扩展运算符后面可以跟表达式。如果扩展运算符后面是一个空对象，则没有任何效果。 如果扩展运算符的参数是null或undefined，这两个值会被忽略，不会报错。 扩展运算符的参数对象之中，如果有取值函数get，这个函数是会执行的。 Null传导运算符编程实务中，如果读取对象内部的某个属性，往往需要判断一下该对象是否存在。 比如，要读取message.body.user.firstName，安全的写法是写成下面这样: 1234const firstName = (message &amp;&amp; message.body &amp;&amp; message.body.user &amp;&amp; message.body.user.firstName) || 'default'; 这样的层层判断非常麻烦，因此现在有一个提案，引入了“Null 传导运算符”（null propagation operator）?.，简化上面的写法。 1const firstName = message?.body?.user?.firstName || 'default'; “Null 传导运算符”有四种用法: obj?.prop // 读取对象属性 obj?.[expr] // 同上 func?.(...args) // 函数或对象方法的调用 new C?.(...args)// 构造函数的调用 Symbol概述ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他 人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就 有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二 的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入 Symbol 的原 因。 ES6 引入了一种新的原始数据类型symbol，表示独一无二的值。它是JavaScript语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。 symbol值通过symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。 123let s = Symbol();typeof s; // symbol 注意，Symbol函数前不能使用new命令，否则会报错。这是因为生成的Symbol是一个原始类型的值，不是对象。也就是说，由于Symbol值不是对象， 所以不能添加属性。基本上，它是一种类似于字符串的数据类型。 symbol函数可以接受一个字符串作为参数，表示对Symbol实例的描述，主要是 为了在控制台显示，或者转为字符串时，比较容易区分。 12345678var s1 = Symbol('foo');var s2 = Symbol('bar');s1 // symbol(foo)s2 // symbol(bar)s1.toString(); // "symbol(foo)"s2.toString(); // "symbol(bar)" 如果 Symbol 的参数是一个对象，就会调用该对象的toString方法，将其转为字符串，然后再生成一个Symbol值。 Symbol函数的参数只是表示对当前Symbol值的描述，因此相同参数的Symbol函数的返回值是不相等的。 Symbol 值不能与其他类型的值进行运算，会报错。但是，Symbol 值可以显式转为字符串。另外，Symbol 值也可以转为布尔值，但是不能转为数值。 作为属性名的Symbol由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于 对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的 情况非常有用，能防止某一个键被不小心改写或覆盖。 1234567891011121314151617var mySymbol = Symbol();// 第一种写法var a = &#123;&#125;;a[mySymbol] = 'hello!';// 第二种写法var a = &#123; [mySymbol]: 'hello!'&#125;;// 第三种写法var a = &#123;&#125;;Object.defineProperty(a, mySymbol, &#123;value: 'hello!'&#125;);// 以上写法都得到相同的结果a[mySymbol] // 'hello!' 注意，Symbol 值作为对象属性名时，不能用点运算符。因为点运算符后面总是字符串，所以不会读取mySymbol作为标识名所指代的那个值。同理，在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。 Symbol 类型还可以用于定义一组常量，保证这组常量的值都是不相等的。常量使用 Symbol 值最大的好处，就是其他任何值都不可能有相同的值了，因此可以保证switch语句会按设计的方式工作。 还有一点需要注意，Symbol 值作为属性名时，该属性还是公开属性，不是私有属 性。 属性名的遍历Symbol 作为属性名，该属性不会出现在for…in、for…of循环中，也不会被 Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol 属性名。 Object.getOwnPropertySymbols方法返回一个数组，成员是当前对象的所有用作属性名的Symbol值。 1234567891011var obj = &#123;&#125;;var a = Symbol('a');var b = Symbol('b');obj[a] = 'hello';obj[b] = 'world';var objectSymbols = Object.getOwnPropertySymbols(obj);objectSymbols// [Symbol(a), Symbol(b)] Reflect.ownKeys方法可以返回所有类型的键名，包括常规键名和Symbol键名： 12345678let obj = &#123; [Symbol('my_key')]: 1, enum: 2, nonEnum: 3&#125;;Reflect.ownKeys(obj);// ['enum', 'nonEnum', Symbol(my_Key)] 由于以 Symbol 值作为名称的属性，不会被常规方法遍历得到。我们可以利用这个 特性，为对象定义一些非私有的、但又希望只用于内部的方法: 1234567891011121314151617181920212223242526var size = Symbol('size');class Collection &#123; constructor() &#123; this[size] = 0; &#125; add(item) &#123; this[this[size]] = item; this[size]++; &#125; static sizeOf(instance) &#123; return instance[size]; &#125;&#125;var x = new Collection();Collection.sizeOf(x); // 0x.add('foo');Collection.sizeOf(x); // 1Object.keys(x); // ['0']Object.getOwnPropertyNames(x); // ['0']Object.getOwnPropertySymbols(x); // [Symbol(size)] Symbol.for()，Symbol.keyFor()有时，我们希望重新使用同一个Symbol值，Symbol.for方法可以做到这一点。 它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol 值。 1234var s1 = Symbol.for('foo');var s2 = Symbol.for('foo');s1 === s2 // true Symbol.for()和Symbol()这两种写法，都会生成新的Symbol。它们的区别 是，前者会被登记在全局环境中供搜索，后者不会。Symbol.for()不会每次调 用就返回一个新的 Symbol 类型的值，而是会先检查给定的 key 是否已经存在， 如果不存在才会新建一个值。比如，如果你调用Symbol.for(&quot;cat&quot;)30次，每次 都会返回同一个 Symbol 值，但是调用Symbol(&quot;cat&quot;)30次，会返回30个不同的 Symbol值。 Symbol.keyFor方法返回一个已登记的 Symbol 类型值的key。 12345var s1 = Symbol.for('foo');Symbol.keyFor(s1); // 'foo'var s2 = Symbol('foo');Symbol.keyFor(s2); // undefined 需要注意的是，Symbol.for为Symbol值登记的名字，是全局环境的，可以在不 同的 iframe 或 service worker 中取到同一个值。 实例：模块的Singleton模式Singleton模式指的是调用一个类，任何时候返回的都是同一个实例。 123456789101112// mod.jsconst FOO_KEY = Symbol.for('foo');function A() &#123; this.foo = 'hello';&#125;if (!global[FOO_KEY]) &#123; global[FOO_KEY] = new A();&#125;module.exports = global[FOO_KEY]; 内置的Symbol值Symbol.hasInstance 对象的Symbol.hasInstance属性，指向一个内部方法。当其他对象使用 instanceof运算符，判断是否为该对象的实例时，会调用这个方法。比 如，foo instanceof Foo在语言内部，实际调用的是 Foo[Symbol.hasInstance](foo)。 1234567class MyClass &#123; [Symbol.hasInstance](foo) &#123; return foo instanceof Array; &#125;&#125;[1, 2, 3] instanceof new MyClass() // true Symbol.isConcatSpreadable对象的Symbol.isConcatSpreadable属性等于一个布尔值，表示该对象用于Array.prototype.concat()时，是否可以展开。 1234567let arr1 = ['c', 'd'];['a', 'b'].concat(arr1, 'e'); // ['a', 'b', 'c', 'd', 'e']arr1[Symbol.isConcatSpreadable]; // undefinedlet arr2 = ['c', 'd'];arr2[Symbol.isConcatSpreadable] = false;['a', 'b'].concat(arr2, 'e'); // ['a', 'b', ['c','d'], 'e'] 上面代码说明，数组的默认行为是可以展开，Symbol.isConcatSpreadable默认等于undefined。该属性等于true时，也有展开的效果。 类似数组的对象正好相反，默认不展开。它的Symbol.isConcatSpreadable属性设为true，才可以展开。 12345let obj = &#123;length: 2, 0: 'c', 1: 'd'&#125;;['a', 'b'].concat(obj, 'e'); // ['a', 'b', obj, 'e']obj[Symbol.isConcatSpreadable] = true;['a', 'b'].concat(obj, 'e'); // ['a', 'b', 'c', 'd', 'e'] Symbol.species对象的Symbol.species属性，指向当前对象的构造函数。创造实例时，默认会 调用这个方法，即使用这个属性返回的函数当作构造函数，来创造新的实例对象。 1234class MyArray extends Array&#123; // 覆盖父类Array的构造函数 static get [Symbol.species]() &#123;return Array;&#125;&#125; 上面代码中，子类MyArray继承了父类Array。创建MyArray的实例对象时， 本来会调用它自己的构造函数（本例中被省略了），但是由于定义了Symbol.species属性，所以会使用这个属性返回的的函数，创建MyArray的实例。这个例子也说明，定义Symbol.species属性要采用get读取器。 123456789class MyArray extends Array&#123; static get [Symbol.species]() &#123;return Array;&#125;&#125;var a = new MyArray(1, 2, 3);var mapped = a.map(x =&gt; x * x);mapped instanceof MyArray // falsemapped instanceof Array // true 上面代码中，由于构造函数被替换成了Array。所以，mapped对象不是MyArray的实例，而是Array的实例。 Symbol.match对象的Symbol.match属性，指向一个函数。当执行str.match(myObject)时，如果该属性存在，会调用它，返回该方法的返回值。 Symbol.replace对象的Symbol.replace属性，指向一个方法，当该对象被String.prototype.replace方法调用时，会返回该方法的返回值。 12345678910String.prototype.replace(searchValue, replaceValue);// 等同于searchValue[Symbol.replace](this, replaceValue);const x = &#123;&#125;;x[Symbol.replace] = (...s) =&gt; console.log(s);'hello'.replace(x, 'world'); // ["Hello", "World"] Symbol.replace方法会收到两个参数，第一个参数是replace方法正在作用的对象，上面例子是Hello，第二个参数是替换后的值，上面例子是World。 Symbol.search对象的Symbol.search属性，指向一个方法，当该对象被String.prototype.search方法调用时，会返回该方法的返回值。 12345678910class MySearch &#123; constructor(value) &#123; this.value = value; &#125; [Symbol.search](string) &#123; return string.indexOf(this.value); &#125;&#125;'foobar'.search(new MySearch('foo')); // 0 Symbol.split 对象的Symbol.split属性，指向一个方法，当该对象被String.prototype.split 方法调用时，会返回该方法的返回值。 12345678910111213141516171819class MySplitter &#123; constructor(value) &#123; this.value = value; &#125; [Symbol.split](string) &#123; var index = string.indexOf(this.value); if (index === -1) &#123; return string; &#125; return [ string.substr(0, index), string.substr(index + this.value.length) ]; &#125;&#125;'foobar'.split(new MySplitter('foo')); // ['', 'bar']'foobar'.split(new MySplitter('bar')); // ['foo', '']'foobar'.split(new MySplitter('baz')); // 'foobar' 使用Symbol.split方法，重新定义了字符串对象的split方法的行为。 Symbol.iterator对象的Symbol.iterator属性，指向该对象的默认遍历器方法。 对象进行for…of循环时，会调用Symbol.iterator方法，返回该对象的默认遍历器。 12345678910111213141516171819class Collection &#123; *[Symbol.iterator]() &#123; let i = 0; while (this[i] !== undefined) &#123; yield this[i]; ++ i; &#125; &#125;&#125;let myCollection = new Collection();myCollection[0] = 1;myCollection[1] = 2;for (let value of myCollection) &#123; console.log(value);&#125;// 1// 2 Symbol.toPrimitive对象的Symbol.toPrimitive属性，指向一个方法。该对象被转为原始类型的值 时，会调用这个方法，返回该对象对应的原始类型值。 Symbol.toPrimitive被调用时，会接受一个字符串参数，表示当前运算的模式，一共有三种模式: Number: 该场合需要转成数值 String: 该场合需要转成字符串 Default: 该场合可以转成数值，也可以转成字符串 12345678910111213141516171819let obj = &#123; [Symbol.toPrimitive](hint) &#123; switch (hint) &#123; case 'number': return 123; case 'string': return 'str'; case 'default': return 'default'; default: throw new Error(); &#125; &#125;&#125;;2 * obj // 2463 + obj // '3default'obj == 'default' // trueString(obj) // 'str' Symbol.toStringTag 对象的Symbol.toStringTag属性，指向一个方法。在该对象上面调用Object.prototype.toString方法时，如果这个属性存在，它的返回值会出现在toString方法返回的字符串之中，表示对象的类型。也就是说，这个属性可 以用来定制[object Object]或[object Array]中 object 后面的那个字符串。 12345678class Collection &#123; get [Symbol.toStringTag]() &#123; return 'xxx'; &#125;&#125;var x = new Collection();Object.prototype.toString.call(x); // "[object xxx]" Symbol.unscopables对象的Symbol.unscopables属性，指向一个对象。该对象指定了使用with关键字时，哪些属性会被with环境排除。 Set和Map数据结构Set基本用法ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重 复的值。 Set 本身是一个构造函数，用来生成 Set 数据结构。 12345678const s = new Set();[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));for (let i of s) &#123; console.log(i);&#125;// 2 3 5 4 上面代码通过add方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。 Set 函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。 Set 函数可以用来去除数组重复成员： 12345const items = new Set([1, 2, 3, 4, 5, 5, 5, 5, 5, 5]);items.size // 5// 去除数组的重复成员[...new Set(array)] 向Set加入值的时候，不会发生类型转换，所以5和&quot;5&quot;是两个不同的值。Set内 部判断两个值是否不同，使用的算法叫做“Same-value equality”，它类似于精确相 等运算符（===），主要的区别是NaN等于自身，而精确相等运算符认为NaN不等于自身。 在Set 函数中，两个对象总是不相等的。 Set实例的属性和方法Set 结构的实例有以下属性： Set.prototype.constructor：构造函数，默认就是Set函数 Set.prototype.size：返回Set实例的成员总数 Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成 员）。下面先介绍四个操作方法： add(value)：添加某个值，返回Set结构本身。 delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。 has(value)：返回一个布尔值，表示该值是否为 Set 的成员。 clear()：清除所有成员，没有返回值。 上面这些属性和方法的实例如下: 1234567891011s.add(1).add(2).add(2);// 注意2被加入了两次s.size; // 2s.has(1); // trues.has(2); // trues.has(3); // falses.delete(2);s.has(2); // false Array.from方法可以将 Set 结构转为数组: 12const items = new Set([1, 2, 3, 4, 5]);const array = Array.from(items); 这就提供了去除数组重复成员的另一种方法： 12345function dedupe() &#123; return Array.from(new Set(array));&#125;dedupe([1, 2, 1, 3]); // [1, 2, 3] 遍历操作Set 结构的实例有四个遍历方法，可以用于遍历成员： keys()：返回键名的遍历器 values()：返回键值的遍历器 entries()：返回键值对的遍历器 forEach()：使用回调函数遍历每个成员 需要特别指出的是， Set 的遍历顺序就是插入顺序。这个特性有时非常有用，比 如使用Set保存一个回调函数列表，调用时就能保证按照添加顺序调用。 keys(), values(), entries() keys方法、values方法、entries方法返回的都是遍历器对象。由于 Set 结构没有键名，只有键值（或者说键名和键值 是同一个值），所以keys方法和 values方法的行为完全一致。 12345678910111213141516171819202122let set = new Set(['red', 'green', 'blue']);for (let item of set.keys()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.values()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.entries()) &#123; console.log(item);&#125;// ['red', 'red']// ['green', 'green']// ['blue', 'blue'] 上面代码中，entries方法返回的遍历器，同时包括键名和键值，所以每次输出 一个数组，它的两个成员完全相等。 Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的 values 方法。这意味着，可以省略values方法，直接用for…of循环遍历 Set。 forEach()Set结构的实例的forEach方法，用于对每个成员执行某种操作，没有返回值。另外， forEach 方法还可以有第二 个参数，表示绑定的 this 对象。 遍历的应用扩展运算符…内部是用for...of循环，所以也可以用于Set结构： 123let set = new Set(['red', 'green', 'blue']);let arr = [...set];// ['red', 'green', 'blue'] 扩展运算符和 Set 结构相结合，就可以去除数组的重复成员: 123let arr = [3, 5, 2, 2, 5, 5];let unique = [...new Set(arr)];// [3, 5, 2] 数组的map和filter方法也可以用于Set： 1234567let set = new Set([1, 2, 3]);set = new Set([...set].map(x =&gt; x * 2));// 返回set结构： &#123;2, 4, 6&#125;let set = new Set([1, 2, 3, 4, 5]);set = new Set([...set].filter(x =&gt; (x % 2) == 0));// 返回set结构： &#123;2, 4&#125; 因此使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集 （Difference）: 1234567891011121314let a = new Set([1, 2, 3]);let b = new Set([4, 3, 2]);// 并集let union = new Set([...a, ...b]);// Set &#123;1, 2, 3, 4&#125;// 交集let intersect = new Set([...a].filter(x =&gt; b.has(x)));// Set &#123;2, 3&#125;// 差集let different = new Set([...a].filter(x =&gt; !b.has(x)));// Set &#123;1&#125; 如果想在遍历操作中，同步改变原来的 Set 结构，目前没有直接的方法，但有两种 变通方法。一种是利用原 Set 结构映射出一个新的结构，然后赋值给原来的 Set 结 构；另一种是利用Array.from方法: 123456789// 方法一let set = new Set([1, 2, 3]);set = new Set([...set].map(val =&gt; val * 2));// set的值是2, 4, 6// 方法二let set = new Set([1, 2, 3]);set = new Set(Array.from(set, val =&gt; val * 2));// set的值是2, 4, 6 WeakSet含义WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区 别。 首先，WeakSet 的成员只能是对象，而不能是其他类型的值。 其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象 的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回 收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。 这是因为垃圾回收机制依赖引用计数，如果一个值的引用次数不为 0 ，垃圾回收 机制就不会释放这块内存。结束使用该值之后，有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄漏。WeakSet 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。 由于上面这个特点，WeakSet 的成员是不适合引用的，因为它会随时消失。另外， 由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 WeakSet 不可遍历。 语法WeakSet 是一个构造函数，可以使用new命令，创建WeakSet数据结构： 1const ws = new WeakSet(); 作为构造函数，WeakSet 可以接受一个数组或类似数组的对象作为参数。（实际 上，任何具有 Iterable 接口的对象，都可以作为 WeakSet 的参数。）该数组的所 有成员，都会自动成为 WeakSet 实例对象的成员。这意味着，数组的成员只能是对象。 WeakSet 结构有以下三个方法: WeakSet.prototype.add(value)：向 WeakSet 实例添加一个新成员。 WeakSet.prototype.delete(value)：清除 WeakSet 实例的指定成员。 WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。 WeakSet没有size属性，没有办法遍历它的成员。 WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。 WeakSet 的另一个例子： 1234567891011const foos = new WeakSet();class Foo &#123; constructor() &#123; foos.add(this); &#125; method() &#123; if (!foo.has(this)) &#123; throw new TypeError('Foo.prototype.method 只能在Foo的实例上调用!'); &#125; &#125;&#125; Foo的实例方法，只能在Foo的实例上调用。这里使用WeakSet 的好处是，foos对实例的引用，不会被计入内存回收机制，所以删除实例的时 候，不用考虑foos，也不会出现内存泄漏。 Map含义和基本用法JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统 上只能用字符串当作键。这给它的使用带来了很大的限制。 为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集 合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也 就是说，Object 结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。 123const map = new Map();map.set(1, 'aaa').set(1, 'bbb');map.get(1); // 'bbb' 如果读取一个未知的键，则返回undefined。 注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小 心。同理，同样的值的两个实例，在 Map 结构中被视为两个键。 Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两 个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果 使用对象作为键名，就不用担心自己的属性与原作者的属性同名。 如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严 格相等，Map 将其视为一个键，比如0和-0就是一个键，布尔值true和字符 串true则是两个不同的键。另外，undefined和null也是两个不同的键。虽然NaN不严格相等于自身，但 Map 将其视为同一个键。 Map是一组键值对的结构，具有极快的查找速度。举个例子，假设要根据同学的名字查找对应的成绩，如果用Array实现，给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，Array越长，耗时越长。如果用Map实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。 实例的属性和操作方法 size属性：返回 Map 结构的成员总数 set(key, value)：设置键名key对应的键值为 value ，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。set返回的是当前的Map对象，因此可以采用链式写法 get(key)：读取key对应的键值，如果找不到key，返回undefined has(key): 返回一个布尔值，表示某个键是否在当前 Map 对象之中 delete(key)：法删除某个键，返回true。如果删除失败，返回false clear()：清除所有成员，没有返回值 遍历方法Map 结构原生提供三个遍历器生成函数和一个遍历方法： keys()：：返回键名的遍历器 values()：返回键值的遍历器。 entries() ：返回所有成员的遍历器。 forEach() ：遍历 Map 的所有成员。 需要特别注意的是，Map 的遍历顺序就是插入顺序。 12345678910111213141516171819202122const map = new Map([ ['F', 'no'], ['T', 'yes'],]);for (let key of map.keys()) &#123; console.log(key);&#125;// 'F'// 'T'for (let value of map.values()) &#123; console.log(value);&#125;// 'no'// 'yes'for (let item of map.entries()) &#123; console.log(item[0], item[1]);&#125;// 'F' 'no'// 'T' 'yes' Map 结构的默认遍历器接口 （Symbol.iterator属性），就是entries方法。 Map 结构转为数组结构，比较快速的方法是使用扩展运算符...： 1234567891011121314151617const map = new Map([ [1, 'one'], [2, 'two'], [3, 'three'],]);[...map.keys()]// [1, 2, 3][...map.values()]// ['one', 'two', 'three'][...map.entries()]// [[1,'one'], [2, 'two'], [3, 'three']][...map]// [[1,'one'], [2, 'two'], [3, 'three']] 结合数组的map方法、filter方法，可以实现 Map 的遍历和过滤（Map 本身没 map和filter方法）。 1234567891011121314const map0 = new Map() .set(1, 'a') .set(2, 'b') .set(3, 'c');const map1 = new Map( [...map0].filter(([k, v]) =&gt; k &lt; 3));// 产生Map结构 &#123;1 =&gt; 'a', 2 =&gt; 'b'&#125;const map2 = new Map( [...map0].map(([k, v]) =&gt; [k * 2, '_' + v]));// 产生Map结构 &#123;2 =&gt; '_a', 4 =&gt; '_b', 6 =&gt; '_c'&#125; 此外，Map 还有一个 forEach方法，与数组的forEach方法类似，也可以实现遍历。该方法还可以接受第二个参数，用来绑定this。 与其他数据结构的互相转换 Map转为数组 Map 转为数组最方便的方法，就是使用扩展运算符... 12345const myMap = new Map() .set(true, 7) .set(&#123;foo: 3&#125;, ['abc']);[...myMap]// [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ 'abc' ] ] ] 数组转为Map 将数组传入Map构造函数，就可以转为Map Map转为对象 如果所有 Map 的键都是字符串，它可以转为对象： 12345678910111213function strMapToObj(strMap) &#123; let obj = Object.create(null); for (let [k, v] of strMap) &#123; obj[k] = v; &#125; return obj;&#125;const myMap = new Map() .set('yes', true) .set('no', false);strMapToObj(myMap);// &#123; yes: true, no: false &#125; 对象转为Map 12345678910function objToStrMap(obj) &#123; let strMap = new Map(); for (let k of Object.keys(obj)) &#123; strMap.set(k, obj[k]); &#125; return strMap;&#125;objToStrMap(&#123;yes: true, no: false&#125;);// Map &#123;"yes" =&gt; true, "no" =&gt; false&#125; Map转为JSON Map 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可 以选择转为对象 JSON。 1234567function strMapToJson(strMap) &#123; return JSON.stringify(strMapToObj(strMap));&#125;let myMap = new Map().set('yes', true).set('no', false);strMapToJson(myMap);// '&#123;"yes":true,"no":false&#125;' 另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。 123456function mapToArrayJson(map) &#123; return JSON.stringify([...map]);&#125;let myMap = new Map().set(true, 7).set(&#123;foo: 3&#125;, ['abc']);mapToArrayJson(myMap);// '[[true,7],[&#123;"foo":3&#125;,["abc"]]]' JSON转为Map JSON 转为 Map，正常情况下，所有键名都是字符串： 123456function jsonToStrMap(jsonStr) &#123; return objToStrMap(JSON.parse(jsonStr));&#125;jsonToStrMap('&#123;"yes": true, "no": false&#125;');// Map &#123;'yes' =&gt; true, 'no' =&gt; false&#125; 但是，有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一 个有两个成员的数组。这时，它可以一一对应地转为Map。这往往是数组转为 JSON 的逆操作。 WeakMap含义WeakMap结构与Map结构类似，也是用于生成键值对的集合。 1234567891011// WeakMap 可以使用 set 方法添加成员const wm1 = new WeakMap();const key = &#123;foo: 1&#125;;wm1.set(key, 2);wm1.get(key); // 2// WeakMap 也可以接受一个数组，作为构造函数的参数const k1 = [1, 2, 3];const k2 = [4, 5, 6];const wm2 = new WeakMap([[k1, 'foo'], [k2, 'bar']]);wm2.get(k2); // 'bar' WeakMap和Map的区别有两点: WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名 WeakMap的键名所指向的对象，不计入垃圾回收机制 WeakMap 的键名所引用的对象都是弱引用， 即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清 除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。 基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。一个典型应用场景是，在网页的 DOM 元素上添加数据，就可以使 用 WeakMap 结构。当该 DOM 元素被清除，其所对应的 WeakMap 记录就会自动被移除。 总之， WeakMap 的专用场合就是，它的键所对应的对象，可能会在将来消 失。 WeakMap 结构有助于防止内存泄漏。 注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。 WeakMap的语法WeakMap 与 Map 在 API 上的区别主要是两个，一是没有遍历操作（即没有key()、values()和entries()方法），也没有size属性。因为没有办法列出所有键名，某个键名是否存在完全不可预测，跟垃圾回收机制是否运行相 关。这一刻可以取到键名，下一刻垃圾回收机制突然运行了，这个键名就没了，为 了防止出现不确定性，就统一规定不能取到键名。二是无法清空，即不支持clear方法。因此，WeakMap只有四个方法可用：get()、set()、has()、delete()。 WeakMap的用途WeakMap 应用的典型场合就是 DOM 节点作为键名。 123456789let myElement = document.getElementById('logo');let myWeakMap = new WeakMap();myWeakMap.set(myElement, &#123;timeClicked: 0&#125;);myElement.addEventListener('click', function () &#123; let logoData = myWeakMap.get(myElement); logoData.timeClicked++;&#125;, false); 上面代码中，myElement是一个 DOM 节点，每当发生click事件，就更新一 下状态。我们将这个状态作为键值放在 WeakMap 里，对应的键名就是myElement。一旦这个 DOM 节点删除，该状态就会自动消失，不存在内存泄漏风险。 WeakMap 的另一个用处是部署私有属性。 123456789101112131415161718192021222324const _counter = new WeakMap();const _action = new WeakMap();class Countdown &#123; constructor(counter, action) &#123; _counter.set(this, counter); _action.set(this, action); &#125; dec() &#123; let counter = _counter.get(this); if (counter &lt; 1) return; counter--; _counter.set(this, counter); if (counter === 0) &#123; _action.get(this); &#125; &#125;&#125;const c = new Countdown(2, () =&gt; console.log('DONE'));c.dec();c.dec();//DONE 上面代码中，Countdown类的两个内部属性_counter和_action，是实例的弱引用，所以如果删除实例，它们也就随之消失，不会造成内存泄漏。 Proxy概述Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一 种“元编程”（meta programming），即对编程语言进行编程。 Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必 须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理 器”。 12345678910var obj = new Proxy(&#123;&#125;, &#123; get: function (target, key, receiver) &#123; console.log(`getting $&#123;key&#125;`); return Reflect.get(target, key, receiver); &#125;, set: function (target, key, value, receiver) &#123; console.log(`setting $&#123;key&#125;`); return Reflect.set(target, key, value, receiver); &#125;&#125;); 上面代码对一个空对象架设了一层拦截，重定义了属性的读取（get）和设置 （set）行为。这里暂时先不解释具体的语法，只看运行结果。对设置了拦截行 为的对象obj，去读写它的属性，就会得到下面的结果。 1234567obj.count = 1;// setting count++obj.count;// getting count// setting count// 2 Proxy 对象的所有用法，都是var proxy = new Proxy(target, handler);这种形式，不同的只是handler参数的写法。target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。 要使得 Proxy 起作用，必须针对 Proxy 实例进行操作。 一个技巧是将 Proxy 对象，设置到object.proxy属性，从而可以在object对象上调用： 1var object = &#123; proxy: new Proxy(target, handler) &#125;; Proxy实例也可以作为其他对象的原型对象。 同一个拦截器函数，可以设置拦截多个操作。 12345678910111213141516171819202122232425var handler = &#123; get: function (target, name) &#123; if (name === 'prototype') &#123; return Object.prototype; &#125; return 'hello, ' + name; &#125;, apply: function (target, thisBindding, args) &#123; return args[0]; &#125;, construct: function (target, args) &#123; return &#123;value: args[1]&#125;; &#125;&#125;;var fproxy = new Proxy(function (x, y) &#123; return x + y;&#125;, handler);fproxy(1, 2); // 1new fproxy(1, 2); // &#123;value: 2&#125;fproxy.prototype === Object.prototype; // truefproxy.foo; // 'hello, foo' 下面是 Proxy 支持的拦截操作一览。 对于可以设置、但没有设置拦截的操作，则直接落在目标对象上，按照原先的方式 产生结果。 （1）get(target, propKey, receiver) 拦截对象属性的读取，比如proxy.foo和proxy[&#39;foo&#39;]。 最后一个参数receiver是一个对象，可选，参见下面 Reflect.get 的部分。 （2）set(target, propKey, value, receiver) 拦截对象属性的设置，比如proxy.foo = v或proxy[&#39;foo&#39;] = v，返回一个布尔值。 （3）has(target, propKey) 拦截propKey in proxy的操作，返回一个布尔值。 （4）deleteProperty(target, propKey) 拦截delete proxy[propKey]的操作，返回一个布尔值。 （5）ownKeys(target) 拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历 属性。 （6）getOwnPropertyDescriptor(target, propKey) 拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。 （7）defineProperty(target, propKey, propDesc) 拦截Object.defineProperty(proxy, propKey,propDesc)、Object.defineProperties(proxy, propDescs)，返回一个布尔值。 （8）preventExtensions(target) 拦截Object.preventExtensions(proxy)，返回一个布尔值。 （9）getPrototypeOf(target) 拦截Object.getPrototypeOf(proxy)，返回一个对象。 （10）isExtensible(target) 拦截Object.isExtensible(proxy)，返回一个布尔值。 （11）setPrototypeOf(target, proto) 拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。 如果目标对象是函数，那么还有两种额外操作可以拦截。 （12）apply(target, object, args) 拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object,...args)、proxy.apply(...)。 （13）construct(target, args) 拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(...args)。 Proxy实例的方法get()get方法用于拦截某个属性的读取操作。 12345678910111213141516var person = &#123; name: '张三'&#125;;var proxy = new Proxy(person, &#123; get: function (target, property) &#123; if (property in target) &#123; return target[property]; &#125; else &#123; throw new ReferenceError(`Property " $&#123;Property&#125; " do not exist.`); &#125; &#125;&#125;);proxy.name; // '张三'proxy.age; // 抛出一个错误 get方法可以继承。 123456789let proto = new Proxy(&#123;&#125;, &#123; get(target, propertyKey, receiver) &#123; console.log('GET' + propertyKey); return target[propertyKey]; &#125;&#125;);let obj = Object.create(proto);obj.xxx; // 'GET xxx' 1234567891011121314151617181920function createArray(...elements) &#123; let handler = &#123; get(target, propKey, receiver) &#123; let index = Number(propKey); if (index &lt; 0) &#123; propKey = String(target.length + index); &#125; return Reflect.get(target, propKey, receiver); &#125; &#125;; let target = []; target.push(...elements); return new Proxy(target, handler);&#125;let arr = createArray('a', 'b', 'c');arr[-1]; // c// 数组的位置参数是 -1 ，就会输出数组的倒数最后一个成员 利用 Proxy，可以将读取属性的操作（get），转变为执行某个函数，从而实现属性的链式操作。 123456789101112131415161718192021222324var pipe = (function () &#123; return function (value) &#123; var funcStack = []; var oprpxy = new Proxy(&#123;&#125;, &#123; get: function (pipeObject, fnName) &#123; if (fnName === 'get') &#123; return funcStack.reduce(function (val, fn) &#123; return fn(val); &#125;, value); &#125; funcStack.push(window[fnName]); return oprpxy; &#125; &#125;); return oprpxy; &#125;&#125;());var double = n =&gt; n * 2;var pow = n =&gt; n * n;var reverseInt = n =&gt; n.toString().split('').reverse().join('') | 0;pipe(3).double.pow.reverseInt.get; // 63 下面的例子则是利用get拦截，实现一个生成各种DOM节点的通用函数dom： 123456789101112131415161718192021222324252627282930const dom = new Proxy(&#123;&#125;, &#123; get(target, property) &#123; return function (attrs = &#123;&#125;, ...children) &#123; const el = document.createElement(property); for (let prop of Object.keys(attrs)) &#123; el.setAttribute(prop, attrs[prop]); &#125; for (let child of children) &#123; if (typeof child === 'string') &#123; child = document.createTextNode(child); &#125; el.appendChild(child); &#125; return el; &#125; &#125;&#125;);const el = dom.div(&#123;&#125;, 'hello, my name is ', dom.a(&#123;href: '//example.com'&#125;, 'Mark'), '. I like: ', dom.ul(&#123;&#125;, dom.li(&#123;&#125;, 'The web'), dom.li(&#123;&#125;, 'Food'), dom.li(&#123;&#125;, '...actually that\'s it') ));document.body.appendChild(el); 如果一个属性不可配置（configurable）和不可写（writable），则该属性不能被代 理，通过 Proxy 对象访问该属性会报错。 set()set方法用来拦截某个属性的赋值操作。 假定Person对象有一个age属性，该属性应该是一个不大于200的整数，那么可以使用Proxy保证age的属性值符合要求。 12345678910111213141516171819202122let validator = &#123; set: function (obj, prop, value) &#123; if (prop === 'age') &#123; if (!Number.isInteger(value)) &#123; throw new TypeError('the age is not an integer'); &#125; if (value &gt; 200) &#123; throw new RangeError('The age seems invalid'); &#125; &#125; // 对于age以外的属性，直接保存 obj[prop] = value; &#125;&#125;;let person = new Proxy(&#123;&#125;, validator);person.age = 100;person.age; // 100person.age = 'young'; // 报错person.age = 300; // 报错 上面代码中，由于设置了存值函数set，任何不符合要求的age属性赋值，都会抛出一个错误，这是数据验证的一种实现方法。利用set方法，还可以数据绑定，即每当对象发生变化时，会自动更新 DOM。 有时，我们会在对象上面设置内部属性，属性名的第一个字符使用下划线开头，表示这些属性不应该被外部使用。结合get和set方法，就可以做到防止这些内部 属性被外部读写。 apply()apply方法拦截函数的调用、call和apply操作。 apply方法可以接受三个参数，分别是目标对象、目标对象的上下文对象this和目标对象的参数数组。 12345678910111213var target = function () &#123; return 'I am the target';&#125;;var handler = &#123; apply: function () &#123; return 'I am the proxy'; &#125;&#125;;var p = new Proxy(target, handler);p();// "I am the proxy" 上面代码中，变量p是 Proxy 的实例，当它作为函数调用时（p()），就会被apply方法拦截，返回一个字符串。 123456789101112var twice = &#123; apply(target, ctx, args) &#123; return Reflect.apply(...arguments) * 2; &#125;&#125;;function sum(left, right) &#123; return left + right;&#125;var proxy = new Proxy(sum, twice);proxy(1, 2); // 6proxy.call(null, 5, 6); // 22proxy.call(null, [7, 8]); // 30 上面代码中，每当执行proxy函数（直接调用或call和apply调用），就会被apply方法拦截。 另外，直接调用Reflect.apply方法，也会被拦截。 has()has 方法用来拦截HasProperty操作，即判断对象是否具有某个属性时，这个 方法会生效。典型的操作就是in运算符。 下面的例子使用has方法隐藏某些属性，不被in运算符发现。 123456789101112var handler = &#123; has(target, key) &#123; if (key[0] === '_') &#123; return false; &#125; return key in target; &#125;&#125;;var target = &#123;_proto: 'foo', prop: 'foo'&#125;;var proxy = new Proxy(target, handler);'_prop' in proxy; // false 如果原对象不可配置或者禁止扩展，这时has拦截会报错。 值得注意的是，has方法拦截的是HasProperty操作，而不是HasOwnProperty操作，即has方法不判断一个属性是对象自身的属性，还是继承的属性。 另外，虽然for...in循环也用到了in运算符，但是has拦截对for...in循环不生效 。 construct()construct方法用于拦截new命令，下面是拦截对象的写法： 12345var handler = &#123; construct(target, args, newTarget) &#123; return new target(...args); &#125;&#125;; construct方法可以接受两个参数： target : 目标对象 args：构建函数的参数对象 12345678910var p = new Proxy(function () &#123;&#125;, &#123; construct: function (target, args) &#123; console.log('called: ' + args.join(', ')); return &#123;value: args[0] * 10&#125;; &#125;&#125;);(new p(1)).value;// 'called: 1'// 10 construct方法返回的必须是一个对象，否则会报错。 deleteProperty()deleteProperty方法用于拦截delete操作，如果这个方法抛出错误或者返回false，当前属性就无法被delete命令删除。 1234567891011121314151617var handler = &#123; deleteProperty (target, key) &#123; invariant(key, 'delete'); return true; &#125;&#125;;function invariant(key, action) &#123; if (key[0] === '_') &#123; throw new Error(`Invalid attempt to $&#123;action&#125; private "$&#123;key&#125;" property`); &#125;&#125;var target = &#123;_prop: 'foo'&#125;;var proxy = new Proxy(target, handler);delete proxy._prop;// Error: Invalid attempt to delete private "_prop" property 注意，目标对象自身的不可配置（configurable）的属性，不能被deleteProperty方法删除，否则报错。 defineProperty()defineProperty()方法拦截了Object.defineProperty操作。 注意，如果目标对象不可扩展（extensible），则defineProperty不能增加目标 对象上不存在的属性，否则会报错。另外，如果目标对象的某个属性不可写 （writable）或不可配置（configurable），则defineProperty方法不得改变这 两个设置。 getOwnPropertyDescriptor()getOwnPropertyDescriptor()方法拦截Object.getOwnPropertyDescriptor()，返回一个属性描述对象或undefined。 getPrototypeOf()getPrototypeOf()方法主要用来拦截获取对象原型。具体来说，拦截下面这些操作。 Object.prototype.__proto__ Object.prototype.isPrototypeOf() Object.getPrototypeOf() Reflect.getPrototypeOf() instanceof 注意，getPrototypeOf方法的返回值必须是对象或者null，否则报错。另 外，如果目标对象不可扩展（extensible），getPrototypeOf方法必须返回目标 对象的原型对象。 isExtensible()isExtensible()方法拦截Object.isExtensible操作。 注意，该方法只能返回布尔值，否则返回值会被自动转为布尔值。 这个方法有一个强限制，它的返回值必须与目标对象的isExtensible属性保持一致，否则就会抛出错误。 ownKeys()ownKeys()方法用来拦截对象自身属性的读取操作。具体来说，拦截以下操作： Object.getOwnPropertyNames() Object.getOwnPropertySymbols() Object.keys() 1234567891011121314151617let target = &#123; _bar: 'foo', _prop: 'bar', prop: 'baz'&#125;;let handler = &#123; ownKeys(target) &#123; return Reflect.ownKeys(target).filter(key =&gt; key[0] !== '_'); &#125;&#125;;let proxy = new Proxy(target, handler);for (let key of Object.keys(proxy)) &#123; console.log(target[key]);&#125;// 'baz' 注意，使用Object.keys方法时，有三类属性会被ownKeys方法自动过滤，不会返回： 目标对象上不存在的属性 属性名为 Symbol 值 不可遍历（enumerable）的属性 ownKeys方法还可以拦截Object.getOwnPropertyNames()。 ownKeys方法返回的数组成员，只能是字符串或 Symbol 值。如果有其他类型的 值，或者返回的根本不是数组，就会报错。 如果目标对象自身包含不可配置的属性，则该属性必须被 ownKeys方法返回，否则报错。 另外，如果目标对象是不可扩展的（non-extensition），这时ownKeys方法返回的数组之中，必须包含原对象的所有属性，且不能包含多余的属性，否则报错。 preventExtensions()preventExtensions()方法拦截Object.preventExtensions()。该方法必须返回一个布尔值，否则会被自动转为布尔值。 这个方法有一个限制，只有目标对象不可扩展时（即Object.isExtensible(proxy)为false），preventExtensions才能返回true，否则会报错。 为了防止出现这个问题，通常要在proxy.preventExtensions方法里面，调用一次Object.preventExtensions。 1234567891011var p = new Proxy(&#123;&#125;, &#123; preventExtensions: function (target) &#123; console.log('called'); Object.preventExtensions(target); return true; &#125;&#125;);Object.preventExtensions(p);// 'called'// true setPrototypeOf()setPrototypeOf()方法主要用来拦截Object.setPrototypeOf方法。 注意，该方法只能返回布尔值，否则会被自动转为布尔值。另外，如果目标对象不可扩展（extensible），setPrototypeOf方法不得改变目标对象的原型。 Proxy.revocable()Proxy.revocable()方法返回一个可取消的 Proxy 实例。 12345678910let target = &#123;&#125;;let handler = &#123;&#125;;let &#123;proxy, revoke&#125; = Proxy.revocable(target, handler);proxy.foo = 123;proxy.foo // 123revoke();proxy.foo // TypeError: Revoked Proxy.revocable()方法返回一个对象，该对象的proxy属性是Proxy实 例，revoke属性是一个函数，可以取消Proxy实例。上面代码中，当执行revoke函数之后，再访问Proxy实例，就会抛出一个错误。 Proxy.revocable() 的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。 this问题虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的this关键字会指向 Proxy 代理。 1234567891011const target = &#123; m: function () &#123; console.log(this === proxy); &#125;&#125;;const handler = &#123;&#125;;const proxy = new Proxy(target, handler);target.m(); // falseproxy.m(); // true 此外，有些原生对象的内部属性（比如Date对象的getDate方法），只有通过正确的this才能拿到，所以Proxy也无法代理这些原生对象的属性。 实例：Web服务的客户端Proxy 对象可以拦截目标对象的任意属性，这使得它很合适用来写 Web 服务的客 户端。 123456const service = createWebService('http://example.com/data');service.employees().then(json =&gt; &#123; const employees = JSON.parse(json); // ...&#125;); 上面代码新建了一个 Web 服务的接口，这个接口返回各种数据。Proxy 可以拦截 这个对象的任意属性，所以不用为每一种数据写一个适配方法，只要写一个 Proxy 拦截就可以了。 1234567function createWebService(baseUrl) &#123; return new Proxy(&#123;&#125;, &#123; get(target, propKey, receiver) &#123; return () =&gt; httpGet(baseUrl + '/' + propKey); &#125; &#125;);&#125; Reflect概述Reflect对象的设计目的有这样几个： 将 Object 对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从 Reflect 对象上可以拿到语言内部的方法。 修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。 让object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。 Reflect对象的方法和Proxy对象的方法一一对应，只要是Proxy对象 的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说， 不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。 123456789Proxy(target, &#123; set: function (target, name, value, receiver) &#123; var success = Reflect.set(target, name, value, receiver); if (success) &#123; log('property ' + name + ' on ' + target + ' set to ' + value); &#125; return success; &#125;&#125;); 上面代码中，proxy方法拦截target对象的属性赋值行为。它采用Reflect.set方法将值赋值给对象的属性，确保完成原有的行为，然后再部署额外的功能。 静态方法Reflect对象共有13个静态方法： Reflect.apply(target,thisArg,args) Reflect.construct(target,args) Reflect.get(target,name,receiver) Reflect.set(target,name,value,receiver) Reflect.defineProperty(target,name,desc) Reflect.deleteProperty(target,name) Reflect.has(target,name) Reflect.ownKeys(target) Reflect.isExtensible(target) Reflect.preventExtensions(target) Reflect.getOwnPropertyDescriptor(target, name) Reflect.getPrototypeOf(target) Reflect.setPrototypeOf(target, prototype) Reflect.get(target,name,receiver)Reflect.get方法查找并返回target对象的name属性，如果没有该属性，则返回undefined。 1234567891011var myObject = &#123; foo: 1, bar: 2, get baz() &#123; return this.foo + this.bar; &#125;&#125;;Reflect.get(myObject, 'foo'); // 1Reflect.get(myObject, 'bar'); // 2Reflect.get(myObject, 'baz'); // 3 如果name属性部署了读取函数（getter），则读取函数的this绑定receiver。 1234567891011121314var myObject = &#123; foo: 1, bar: 2, get baz() &#123; return this.foo + this.bar; &#125;&#125;;var myReceiverObject = &#123; foo: 4, bar: 4&#125;;Reflect.get(myObject, 'baz', myReceiverObject); // 8 如果第一个参数不是对象，Reflect.get方法会报错。 Reflect.set(target, name, value, receiver)Reflect.set方法设置target对象的name属性等于value。 如果name属性设置了赋值函数，则赋值函数的this绑定receiver。 如果第一个参数不是对象，Reflect.set会报错。 Reflect.set会触发Proxy.defineProperty拦截。 Reflect.has(obj, name)Reflect.has方法对应name in obj中的in运算符。 如果第一个参数不是对象，Reflect.has和in运算符都会报错。 Reflect.deleteProperty(obj, name)Reflect.deleteProperty方法等同于delete obj[name]，用于删除对象的属性。 该方法返回一个布尔值。如果删除成功，或者被删除的属性不存在，返回true；删除失败，被删除的属性依然存在，返回false。 Reflect.construct(target, args)Reflect.construct方法等同于new target(...args)，这提供了一种不使用new，来调用构造函数的方法。 Reflect.getPrototyprOf(obj) Reflect.getPrototyprOf方法用于读取对象的_proto_属性，对应Object.getPrototypeOf(obj)。 Reflect.getPrototypeOf和Object.getPrototypeOf的一个区别是，如果参数不是对象，Object.getPrototypeOf会将这个参数转为对象，然后再运行，而Reflect.getPrototypeOf会报错。 Reflect.setPrototypeOf(obj, newProto)Reflect.setPrototypeOf方法用于设置对象的_proto_属性，返回第一个参数对象，对应Object.setPrototypeOf(obj, newProto)。 如果第一个参数不是对象，Object.setPrototypeOf会返回第一个参数本身，而Reflect.setPrototypeOf会报错。 如果第一个参数是undefined或null，Object.setPrototypeOf和Reflect.setPrototypeOf都会报错。 Reflect.apply(func, thisArg, args)Reflect.apply方法等同于Function.prototype.apply.call(func,thisArg, args)，用于绑定this对象后执行给定函数。 一般来说，如果要绑定一个函数的this对象，可以这样写fn.apply(obj, args)，但是如果函数定义了自己的apply方法，就只能写成Function.prototype.apply.call(fn, obj, args)，采用Reflect对象可以简化这种操作。 Reflect.defineProperty(target, propertyKey, attributes)Reflect.defineProperty方法基本等同于Object.defineProperty，用来为对象定义属性。未来，后者会被逐渐废除，请从现在开始就使用Reflect.defineProperty代替它。 Reflect.defineProperty的第一个参数不是对象，就会抛出错误。 Reflect.getOwnPropertyDescriptor(target, propertyKey)Reflect.getOwnPropertyDescriptor基本同于Object.getOwnPropertyDescriptor，用于得到指定属性的描述对象，将来会替代掉后者。 Reflect.getOwnPropertyDescriptor和Object.getOwnPropertyDescriptor的一个区别是，如果第一个参数不是对象，Object.getOwnPropertyDescriptor(1, &#39;foo&#39;)不报错，返回undefined，而Reflect.getOwnPropertyDescriptor(1, &#39;foo&#39;)会抛出错 误，表示参数非法。 Reflect.isExtensible(target)Reflect.isExtensible方法对应Object.isExtensible，返回一个布尔值，表示当前对象是否可扩展。 如果参数不是对象，Object.isExtensible会返回false，因为非对象本来就是不可扩展的，而Reflect.isExtensible会报错。 Reflect.preventExtensions(target)Reflect.preventExtensions对应Object.preventExtensions方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功。 如果参数不是对象，Object.preventExtensions在 ES5 环境报错，在 ES6 环 境返回传入的参数，而Reflect.preventExtensions会报错。 Reflect.ownKeys(target)Reflect.ownKeys方法用于返回对象的所有属性，基本等同于Object.getOwnPropertyNames与Object.getOwnPropertySymbols之和。 实例：使用Proxy实现观察者模式观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行。 下面，使用 Proxy 写一个观察者模式的最简单实现，即实现observable和observe这两个函数。思路是observable函数返回一个原 始对象的 Proxy 代理，拦截赋值操作，触发充当观察者的各个函数。 12345678910const queuedObservers = new Set();const observe = fn =&gt; queuedObservers.add(fn);const observable = obj =&gt; new Proxy(obj, &#123;set&#125;);function set(target, key, value, receiver) &#123; const result = Reflect.set(target, key, value, receiver); queuedObservers.forEach(observe =&gt; observe()); return result;&#125; 上面代码中，先定义了一个Set集合，所有观察者函数都放进这个集合。然后，observable函数返回原始对象的代理，拦截赋值操作。拦截函数set之中，会自动执行所有观察者。 Promise对象Promise的含义所谓 Promise ，简单说就是一个容器，里面保存着某个未来才会结束的事件（通 常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异 步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行 处理。 Promise对象有以下两个特点: 对象的状态不受外界影响。 Promise 对象代表一个异步操作，有三种状 态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个 状态。这也是 Promise 这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 一旦状态改变，就不会再变，任何时候都可以得到这个结果。 Promise 对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为resolved（已定型）。如果改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全 不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 注意，为了行文方便，本章后面的resolved统一只指fulfilled状态，不包含rejected状态。 有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层 嵌套的回调函数。此外， Promise 对象提供统一的接口，使得控制异步操作更加容易。 Promise也有一些缺点。首先，无法取消 Promise ，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数， Promise 内部抛出的错误，不会反应到外部。第三，当处于 pending 状态时，无法得知目前进展到哪一个阶段。 如果某些事件不断地反复发生，一般来说，使用 Stream 模式是比部署Promise更好的选择。 基本用法ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。 123456789var promise = new Promise(function (resolve, reject) &#123; // ... some code if (/*异步操作成功*/) &#123; resolve(value); // value作为参数传递给then回调中的resolved函数 &#125; else &#123; reject(error); // error作为参数传递给then回调中的rejected函数 &#125;&#125;); Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。 resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从pending变为resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失 败”（即从pending变为rejected），在异步操作失败时调用，并将异步操作报出的 错误，作为参数传递出去。 Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。 12345promise.then(function (value) &#123; // success&#125;, function (error) &#123; // failure&#125;); then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。 123456789function timeout(ms) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, ms, 'done'); &#125;);&#125;timeout(100).then((value) =&gt; &#123; console.log(value);&#125;); 上面代码中，timeout方法返回一个Promise实例，表示一段时间以后才会发生的结果。过了指定的时间（ms参数）以后，Promise实例的状态变为resolved，就会触发then方法绑定的回调函数。 Promise 新建后就会立即执行。 1234567891011121314let promise = new Promise(function (resolve, reject) &#123; console.log('promise'); resolve();&#125;);promise.then(function () &#123; console.log('resolved');&#125;);console.log('hi');// promise// hi// resolved 上面代码中，Promise 新建后立即执行，所以首先输出的是Promise。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。 1234567891011121314151617181920212223242526272829var getJSON = function (url) &#123; var promise = new Promise(function (resolve, reject) &#123; var client = new XMLHttpRequest(); client.open('GET', url); client.onreadystatechange = handler; client.responseType = 'json'; client.setRequestHeader('Accept', 'application/json'); client.send(); function handler() &#123; if (this.readyState !== 4) &#123; return; &#125; if (this.status === 200) &#123; resolve(this.response); &#125; else &#123; reject(new Error(this.statusText)); &#125; &#125; &#125;); return promise;&#125;;getJSON('/post.json').then(function (json) &#123; console.log('contents: ' + json);&#125;, function (error) &#123; console.log('出错误了', error);&#125;); 如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。reject函数的参数通常是Error对象的实例，表示抛出的错误；resolve函数的参数除了正常的值以外，还可能是另一个Promise实例，比如： 12345678var p1 = new Promise(function (resolve, reject) &#123; // ...&#125;);var p2 = new Promise(function (resolve, reject) &#123; // ... resolve(p1);&#125;); 注意，这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状 态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立即执行。 123456789101112var p1 = new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; reject(new Error('fail')), 3000)&#125;);var p2 = new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; resolve(p1), 1000)&#125;);p2 .then(result =&gt; console.log(result)) // 这个then是针对p1的 .catch(error =&gt; console.log(error));// Error: fail 上面代码中，p1是一个Promise，3秒之后变为rejected。p2的状态在1秒之 后改变，resolve方法返回的是p1。由于p2返回的是另一个 Promise，导 致p2自己的状态无效了，由p1的状态决定p2的状态。所以，后面的then语句都变成针对后者（p1）。又过了2秒，p1变为rejected，导致触发catch方法指定的回调函数。 注意，调用resolve或reject并不会终结 Promise 的参数函数的执行。这是因为立即resolved的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。 一般来说，调用resolve或reject以后，Promise 的使命就完成了，后继操作 应该放到then 方法里面，而不应该直接写在resolve或reject的后面。所以，最好在它们前面加上return 语句，这样就不会有意外。 123456new Promise(((resolve, reject) =&gt; &#123; return resolve(1); // 后面语句不会执行 console.log(2);&#125;)); Promise.prototype.then()Promise实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是resolved状态的回调函数，第二 个参数（可选）是rejected状态的回调函数。 then方法返回的是一个新的Promise实例。因此可以采用链式写法。 12345getJSON('/post.json').then(function (json) &#123; return json.post;&#125;).then(function (post) &#123; // ...&#125;); 上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以 后，会将返回结果作为参数，传入第二个回调函数。 采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函 数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。 Promise.prototype.catch()Promise.prototype.catch()方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。 then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。 下面三种写法是等价的： 12345678910111213141516171819202122232425262728var promise = new Promise(function (resolve, reject) &#123; throw new Error('test');&#125;);promise.catch(function (error) &#123; console.log(error);&#125;);/***********分割线****************/var promise = new Promise(function (resolve, reject) &#123; try &#123; throw new Error('test'); &#125; catch (e) &#123; reject(e); &#125;&#125;);promise.catch(function (error) &#123; console.log(error);&#125;);/***********分割线****************/var promise = new Promise(function (resolve, reject) &#123; reject(new Error('test'));&#125;);promise.catch(function (error) &#123; console.log(error);&#125;); 如果Promise状态已经变成resolved，再抛出错误是无效的。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了。 Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。 1234567getJSON('/post/1.json').then(function (post) &#123; return getJSON(post.commentURL);&#125;).then(function (comments) &#123; // some code&#125;).catch(function (error) &#123; // 处理前面三个Promise产生的错误&#125;); 一般来说，不要在then方法里面定义Reject状态的回调函数（即then的第二个参数），总是使⽤catch方法： 12345678910111213141516// badpromise .then(function (data) &#123; // success &#125;, function (err) &#123; // error &#125;);// goodpromise .then(function (data) &#123; // success &#125;) .catch(function (err) &#123; // error &#125;); 上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面then方法执行中的错误，也更接近同步的写法（try/catch）。因此，建议总是使用catch方法，而不使用 then 方法的第二个参数。 跟传统的try/catch代码块不同的是，如果没有使用catch方法指定错误处理 的回调函数，Promise对象抛出的错误不会传递到外层代码，即不会有任何反应。 12345678910var someAsyncThing = function () &#123; return new Promise(function (resolve, reject) &#123; // 下面一行会报错，因为x没有声明 resolve(x + 2); &#125;);&#125;;someAsyncThing().then(function () &#123; console.log('everything is great');&#125;); 上面代码中，someAsyncThing函数产生的 Promise 对象会报错，但是由于没有指定catch方法，这个错误不会被捕获，也不会传递到外层代码。正常情况下， 运行后不会有任何输出，但是浏览器此时会打印出错误“ReferenceError: x is not defined”，不过不会终止脚本执行，如果这个脚本放在服务器执行，退出码就是0（即表示执行成功）。 1234567891011var promise = new Promise(function (resolve, reject) &#123; resolve('ok'); setTimeout(function () &#123; throw new Error('test'); &#125;, 0);&#125;);promise.then(function (value) &#123; console.log(value);&#125;);// ok// Uncaught Error: test 上面代码中，Promise 指定在下一轮“事件循环”再抛出错误。到了那个时候， Promise 的运行已经结束了，所以这个错误是在 Promise 函数体外抛出的，会冒泡到最外层，成了未捕获的错误。 Node有一个unhandledRejection事件，专门监听未捕获的reject错误。 123process.on('unhandledRejection', function (err, p) &#123; console.log(err.stack);&#125;); unhandledRejection事件的监听函数有两个参数，第一个是错误对象，第二个是报错的 Promise 实例，它可以用来了解发生错误的环境信息。 catch方法返回的还是一个 Promise 对象，因此后面还可以接着调用then方法： 12345678910111213141516var someAsyncThing = function () &#123; return new Promise(function (resolve, reject) &#123; // 下面一行会报错，因为x没有声明 resolve(x + 2); &#125;);&#125;;someAsyncThing() .catch(function (error) &#123; console.log(error); &#125;) .then(function () &#123; console.log('carry on'); &#125;);// [ReferenceError: x is not defined]// carry on 上面代码运行完catch方法指定的回调函数，会接着运行后面那个then方法指定的回调函数。如果没有报错，则会跳过catch方法。 catch方法之中，还能再抛出错误。 Promise.all()Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。 1var p = Promise.all([p1, p2, p3]); 上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参 数转为 Promise 实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。） p的状态由p1、p2、p3决定，分成两种情况： 只有p1 、p2、p3的状态都变成fulfilled，p的状态才会变fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。 只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 1234567891011121314151617181920212223242526// 生成一个Promise对象的数组var promises = [2, 3, 5, 7, 11, 13].map(function (id) &#123; return getJSON('/post/' + id + '.json');&#125;);Promise.all(promises).then(function (posts) &#123; // ...&#125;).catch(function (reason) &#123; // ...&#125;);/************************/const databasePromise = connectDatabase();const booksPromise = databasePromise .then(findAllBooks);const userPromise = databasePromise .then(getCurrentUser);Promise.all([ booksPromise, userPromise]).then(([books, user]) =&gt; pickTopRecommentations(books, user)); 注意，如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦 被rejected，并不会触发Promise.all()的catch方法。 Promise.race()Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。 1var p = Promise.race([p1, p2, p3]); 上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就 着改变。那个率先改变的Promise实例的返回值，就传递给p的回调函数。 promise.race方法的参数与promise.all方法一样，如果不是 Promise 实例，就会先调用Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。 12345678const p = Promise.race([ fetch('/resource-that-may-take-a-while'), new Promise((function (resolve, reject) &#123; setTimeout(() =&gt; reject(new Error('request timeout')), 5000); &#125;))]);p.then(response =&gt; console.log(response));p.then(error =&gt; console.log(error)); 上面例子中，如果指定时间内没有获得结果，就将Promise的状态变 为reject，否则变为resolve。 Promise.resolve()有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用。 1var jsPromise = Promise.resolve($.ajax('/whatever.json')); Promise.resolve等价于下面的写法： 123Promise.resolve('foo');// 等价于new Promise(resolve =&gt; resolve('foo')); Promise.resolve方法的参数分成四种情况: 参数是一个Promise实例 如果参数是Promise实例，那么Promise.resolve将不做任何修改、原封不动地 返回这个实例。 参数是一个 thenable对象 thenable对象指的是具有then方法的对象，比如下面这个对象。 12345678910let thenable = &#123; then: function (resolve, reject) &#123; resolve(42); &#125;&#125;;let p1 = Promise.resolve(thenable);p1.then(function (value) &#123; console.log(value); // 42&#125;); Promise.resolve方法会将这个对象转为Promise对象，然后就立即执行thenable对象的then方法。 参数不是具有then方法的对象，或根本就不是对象 如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的Promise对象，状态为resolved。 123456var p = Promise.resolve('hello');p.then(function (s) &#123; console.log(s);&#125;);// hello 不带有任何参数 Promise.resolve方法允许调用时不带参数，直接返回一个resolved状态的Promise对象。 所以，如果希望得到一个Promise对象，比较方便的方法就是直接调Promise.resolve方法。 12345var p = Promise.resolve();p.then(function () &#123; // ...&#125;); 需要注意的是，立即resolve的Promise对象，是在本轮“事件循环”（event loop）的结束时，而不是在下一轮“事件循环”的开始时。 123456789101112setTimeout(function () &#123; console.log('three');&#125;, 0);Promise.resolve().then(function () &#123; console.log('two');&#125;);console.log('one');// one// two// three 上面代码中，setTimeout(fn, 0)在下一轮“事件循环”开始时执 行，Promise.resolve()在本轮“事件循环”结束时执行，console.log(&#39;one&#39;)则是立即执行，因此最先输出。 Promise.reject()Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。 12345678var p = Promise.reject('出错了');// 等同于var p = new Promise(((resolve, reject) =&gt; reject('出错误了')));p.then(null, function (s) &#123; console.log(s);&#125;);// 出错了 注意，Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。这一点与Promise.resolve方法不一致。 1234567891011const thenable = &#123; then(resolve, reject) &#123; reject('出错了'); &#125;&#125;;Promise.reject(thenable).catch(e =&gt; &#123; console.log(e === thenable);&#125;);// true 上面代码中，Promise.reject方法的参数是一个thenable对象，执行以后， 后面catch方法的参数不是reject抛出的“出错了”这个字符串，而是thenable对象。 两个有用的附加方法ES6的Promise API提供的方法不是很多，有些有用的方法可以自己部署。下面介 绍如何部署两个不在ES6之中、但很有用的方法。 done()Promise对象的回调链，不管以then方法或catch方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为Promise内部的错误不会冒泡到全局）。 因此，我们可以提供一个done方法，总是处于回调链的尾端，保证抛出任何可能 出现的错误。 1234567Promise.prototype.done = function (onFulfilled, onRejected) &#123; this.then(onFulfilled, onRejected) .catch(function (reason) &#123; // 抛出一个全局错误 setTimeout(() =&gt; &#123;throw reason&#125;, 0); &#125;);&#125;; finally() finally()方法用于指定不管Promise对象最后状态如何，都会执行的操作。它与done方法的最大区别，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。 1234567Promise.prototype.finally = function (callback) &#123; let p = this.constructor; return this.then( value =&gt; p.resolve(callback()).then(() =&gt; value), reason =&gt; p.resolve(callback()).then(() =&gt; &#123;throw reason&#125;) );&#125;; 应用加载图片12345678const preloadImage = function (path) &#123; return new Promise(function (resolve, reject) &#123; var image = new Image(); image.onload = resolve; image.onerror = reject; image.src = path; &#125;);&#125;; Generator函数与Promise的结合使用Generator函数管理流程，遇到异步操作的时候，通常返回一个Promise对象。 1234567891011121314151617181920212223242526272829303132function getFoo() &#123; return new Promise(function (resolve, reject) &#123; resolve('foo'); &#125;);&#125;var g = function* () &#123; try &#123; var foo = yield getFoo(); console.log(foo); &#125; catch (e) &#123; console.log(e); &#125;&#125;;function run(generator) &#123; var it = generator(); function go(result) &#123; if (result.done) return result.value; return result.value.then(function (value) &#123; return go(it.next(value)); &#125;, function (error) &#123; return go(it.throw(error)); &#125;); &#125; go(it.next());&#125;run(g); 上面代码的Generator函数g之中，有一个异步操作getFoo，它返回的就是一 个Promise对象。函数run用来处理这个Promise对象，并调用下一个next方法。 Promise.try()实际开发中，经常遇到一种情况：不知道或者不想区分，函数 f 是同步函数还是 异步操作，但是想用 Promise 来处理它。因为这样就可以不管f是否包含异步操 作，都用then方法指定下一步流程，用catch方法处理 f 抛出的错误。一般就会采用下面的写法: 1Promise.resolve().then(f); 上面的写法有一个缺点，就是如果f是同步函数，那么它会在本轮事件循环的末尾执行。 12345const f = () =&gt; console.log('now');Promise.resolve().then(f);console.log('next');// next// now 那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有 统一的 API 呢？回答是可以的，并且还有两种写法。第一种写法是用async函数来写。 12345const f = () =&gt; console.log('now');(async () =&gt; f())();console.log('next');// now// next 上面代码中，第二行是一个立即执行的匿名函数，会立即执行里面的async函 数，因此如果f是同步的，就会得到同步的结果；如果f是异步的，就可以用then指定下一步，就像下面的写法。 12(async () =&gt; f())().then(...); 需要注意的是，async () =&gt; f()会吃掉f()抛出的错误。所以，如果想捕获错误，要使用promise.catch方法。 123(async () =&gt; f())().then(...).catch(...); 第二种写法是使用new Promise()： 123456789const f = () =&gt; console.log('now');( () =&gt; new Promise( resolve =&gt; resolve(f()) ))();console.log('next');// now// next 上面代码也是使用立即执行的匿名函数，执行new Promise()。这种情况下，同步函数也是同步执行的。 鉴于这是一个很常见的需求，所以现在有一个提案，提供Promise.try方法代替上面的写法。 12345const f = () =&gt; console.log('now');Promise.try(f);console.log('next');// now// next 由于Promise.try为所有操作提供了统一的处理机制，所以如果想用then方法 管理流程，最好都用Promise.try包装一下。这样有许多好处，其中一点就是可以更好地管理异常。 123Promise.try(database.user.get(&#123;id: userId&#125;)) .then(...) .catch(...) Iterator 和 for…of 循环Iterator的概念JavaScript 原有的表示“集合”的数据结构，主要是数组（Array）和对象（Object），ES6 又添加了Map和Set。这样就有了四种数据集合，用户还 可以组合使用它们，定义自己的数据结构，比如数组的成员是 Map ， Map 的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。 遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供 统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作（即依 次处理该数据结构的所有成员）。 Iterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接 口；二是使得数据结构的成员能够按某种次序排列；三是ES6创造了一种新的遍历 命令for…of循环，Iterator接口主要供for…of消费。 Iterator 的遍历过程是这样的: 创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象 本质上，就是一个指针对象。 第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。 第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。 不断调用指针对象的next方法，直到它指向数据结构的结束位置。 每一次调用 next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。 1234567891011121314151617var it = makeIterator(['a', 'b']);it.next(); // &#123; value: "a", done: false &#125;it.next(); // &#123; value: "b", done: false &#125;it.next(); // &#123; value: undefined, done: true &#125;// 一个遍历器生成函数，作用就是返回一个遍历器对象function makeIterator(array) &#123; var nextIndex = 0; return &#123; next: function () &#123; return nextIndex &lt; array.length ? &#123;value: array[nextIndex++], done: false&#125; : &#123;value: undefined, done: true&#125;; &#125; &#125;;&#125; 对于遍历器对象来说，done: false和value: undefined属性都是可以省略 的，因此上面的makeIterator函数可以简写成下面的形式: 12345678910function makeIterator(array) &#123; var nextIndex = 0; return &#123; next: function () &#123; return nextIndex &lt; array.length ? &#123;value: array[nextIndex++]&#125; : &#123;done: true&#125;; &#125; &#125;;&#125; 由于 Iterator 只是把接口规格加到数据结构之上，所以，遍历器与它所遍历的那个数据结构，实际上是分开的，完全可以写出没有对应数据结构的遍历器对象，或者 说用遍历器对象模拟出数据结构。下面是一个无限运行的遍历器对象的例子: 12345678910111213141516var it = idMaker();it.next().value; // 0it.next().value; // 1it.next().value; // 2// ...function idMaker() &#123; var index = 0; return &#123; next: function () &#123; return &#123;value: index++, done: false&#125;; &#125; &#125;;&#125; 如果使用 TypeScript 的写法，遍历器接口（Iterable）、指针对象（Iterator） 和 next 方法返回值的规格可以描述如下： 123456789101112interface Iterable &#123; [Symbol.iterator]() : Iterator,&#125;interface Iterator &#123; next(value?: any) : IterationResult,&#125;interface IterationResult &#123; value: any, done: boolean,&#125; 默认Iterator接口Iterator 接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即for…of循环。当使用for…of循环遍历某种数据结构时， 该循环会自动去寻找 Iterator 接口。 一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是”可遍历 的“（iterable）。 ES6 规定，默认的 Iterator 接口部署在数据结构的Symbol.iterator属性，或者 说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历 的”（iterable）。Symbol.iterator属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。至于属性名Symbol.iterator，它是一个表达式，返回Symbol对象的iterator属 性，这是一个预定义好的、类型为 Symbol 的特殊值，所以要放在方括号内（参见 Symbol 一章）。 123456789101112const obj = &#123; [Symbol.iterator] : function () &#123; return &#123; next: function () &#123; return &#123; value: 1, done: true &#125;; &#125; &#125;; &#125;&#125;; ES6 的有些数据结构原生具备 Iterator 接口（比如数组），即不用任何处理，就可以被for…of循环遍历。原因在于，这些数据结构原生部署了Symbol.iterator属性，另外一些数据结构没有（比如对象）。 凡是部署了Symbol.iterator属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。 原生具备 Iterator 接口的数据结构如下: Array Map Set String TypedArray 函数的arguments对象 NodeList对象 123456let arr = ['a', 'b', 'c'];let iter = arr[Symbol.iterator]();iter.next(); // &#123; value: 'a', done: false &#125;iter.next(); // &#123; value: 'b', done: false &#125;iter.next(); // &#123; value: undefined, done: true &#125; 对于原生部署 Iterator 接口的数据结构，不用自己写遍历器生成函数，for…of循环会自动遍历它们。除此之外，其他数据结构（主要是对象）的 Iterator 接口，都需要自己在Symbol.iterator属性上面部署，这样才会被for…of循环遍历。 对象（Object）之所以没有默认部署 Iterator 接口，是因为对象的哪个属性先遍 历，哪个属性后遍历是不确定的，需要开发者手动指定。本质上，遍历器是一种线 性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转 换。不过，严格地说，对象部署遍历器接口并不是很必要，因为这时对象实际上被 当作 Map 结构使用，ES5 没有 Map 结构，而 ES6 原生提供了。 一个对象如果要具备可被for…of循环调用的 Iterator 接口，就必须在Symbol.iterator的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）。 12345678910111213141516171819202122232425class RangeIterator &#123; constructor(start, stop) &#123; this.value = start; this.stop = stop; &#125; [Symbol.iterator]() &#123;return this;&#125; next() &#123; var value = this.value; if (value &lt; this.stop) &#123; this.value++; return &#123;done: false, value: value&#125;; &#125; return &#123;done: true, value: undefined&#125;; &#125;&#125;function range(start, stop) &#123; return new RangeIterator(start, stop);&#125;for (var value of range(0, 3)) &#123; console.log(value); // 0, 1, 2&#125; 对于类似数组的对象（存在数值键名和length属性），部署Iterator接口，有个简便方法，就是Symbol.iterator方法直接引用数组的 Iterator 接口。 12345NodeList.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];// 或者NodeList.prototype[Symbol.iterator] = [][Symbol.iterator];[...document.querySelectorAll('div')] // 可以执行了 注意，普通对象部署数组的Symbol.iterator方法，并无效果。 1234567891011121314151617181920212223let iterable = &#123; 0: 'a', 1: 'b', 2: 'c', length: 3, [Symbol.iterator]: Array.prototype[Symbol.iterator]&#125;;let iterable1 = &#123; a: 'a', b: 'b', c: 'c', length: 3, [Symbol.iterator]: Array.prototype[Symbol.iterator]&#125;;for (let item of iterable) &#123; console.log(item); // 'a', 'b', 'c'&#125;for (let item of iterable1) &#123; console.log(item); // undefined, undefined, undefined&#125; 如果Symbol.iterator方法对应的不是遍历器生成函数（即会返回一个遍历器对象），解释引擎将会报错。 有了遍历器接口，数据结构就可以用for...of循环遍历，也可以使用while循环遍历。 1234567var $iterator = ITERABLE[Symbol.iterator]();var $result = $iterator.next();while (!$result.done) &#123; var x = $result.value; // ... $result = $iterator.next();&#125; 调用Iterator接口的场合 解构赋值 对数组和 Set 结构进行解构赋值时，会默认调用Symbol.iterator方法: 1234567let set = new Set().add('a').add('b').add('c');let [x, y] = set;// x = 'a'; y = 'b'let [first, ...rest] = set;// first='a'; rest=['b','c']; 扩展运算符 扩展运算符（…）也会调用默认的 Iterator 接口: 12var str = 'hello';[...str] // ['h','e','l','l','o'] yield* yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。 1234567891011121314let generator = function* () &#123; yield 1; yield* [2, 3, 4]; yield 5;&#125;;var iterator = generator();iterator.next(); // &#123; value: 1, done: false &#125;iterator.next(); // &#123; value: 2, done: false &#125;iterator.next(); // &#123; value: 3, done: false &#125;iterator.next(); // &#123; value: 4, done: false &#125;iterator.next(); // &#123; value: 5, done: false &#125;iterator.next(); // &#123; value: undefined, done: true &#125; 其他场合 由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调 用了遍历器接口。下面是一些例子： for…of Array.from() Map(), Set(), WeakMap(), WeakSet()（比如new Map([[&#39;a&#39;,1],[&#39;b&#39;,2]])） Promise.all() Promise.race() 字符串的Iterator接口字符串是一个类似数组的对象，也原生具有 Iterator 接口。 可以覆盖原生的Symbol.iterator方法，达到修改遍历器行为的目的： 1234567891011121314151617181920var str = new String('hi');[...str] // ['h', 'i']str[Symbol.iterator] = function () &#123; return &#123; next: function () &#123; if (this._first) &#123; this._first = false; return &#123;value: 'bye', done: false&#125;; &#125; else &#123; return &#123;done: true&#125;; &#125; &#125;, _first: true &#125;;&#125;;[...str] // ['bye']str // 'hi' Iterator接口与Generator函数Symbol.iterator方法的最简单实现，还是使用下一章要介绍的Generator函数： 1234567891011121314151617181920212223var myIterable = &#123;&#125;;myIterable[Symbol.iterator] = function* () &#123; yield 1; yield 2; yield 3;&#125;;[...myIterable] // [1, 2, 3]// 或者采用下面的简洁写法let obj = &#123; * [Symbol.iterator]() &#123; yield 'hello'; yield 'world'; &#125;&#125;;for (let x of obj) &#123; console.log(x);&#125;// hello// world 遍历器对象的return()，throw()遍历器对象除了具有next方法，还可以具有return方法和throw方法。如果 你自己写遍历器对象生成函数，那么next方法是必须部署的，return方法和throw方法是否部署是可选的。 return方法的使用场合是，如果for...of循环提前退出（通常是因为出错，或者有break语句或continue语句），就会调用return方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署return方法。 123456789101112131415161718192021222324252627282930function realinesSync(file) &#123; return &#123; next() &#123; return &#123;done: false&#125;; &#125;, return() &#123; file.close(); return &#123;done: true&#125;; &#125;, &#125;;&#125;// 下面的三种情况，都会触发执行return// 情况一for (let line of realinesSync(fileName)) &#123; console.log(line); break;&#125;// 情况二for (let line of realinesSync(fileName)) &#123; console.log(line); continue;&#125;// 情况三for (let line of realinesSync(fileName)) &#123; console.log(line); throw new Error();&#125; return方法必须返回一个对象，这是 Generator 规格决定的。 throw方法主要是配合 Generator 函数使用，一般的遍历器对象用不到这个方法。 for…of循环for…of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList对象）、Generator对象以及字符串。 数组数组原生具备iterator接口（即默认部署了Symbol.iterator属性），for…of循环本质上就是调用这个接口产生的遍历器。 for…of循环可以代替数组实例的forEach方法。 JavaScript 原有的for…in循环，只能获得对象的键名，不能直接获取键值。 ES6 提供for...of循环，允许遍历获得键值。如果要通过for…of循环，获取数组的索引，可以借助数组实例的entries方法和keys方法。 for…of循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。 Set和Map结构Set 和 Map 结构也原生具有 Iterator 接口，可以直接使用for...of循环。 遍历的顺序是按照各个成员被添加进数据结构的顺序。Set 结构遍历时，返 回的是一个值，而 Map 结构遍历时，返回的是一个数组，该数组的两个成员分别 为当前 Map 成员的键名和键值。 计算生成的数据结构有些数据结构是在现有数据结构的基础上，计算生成的。比如，ES6的数组、Set、 Map 都部署了以下三个方法，调用后都返回遍历器对象。 entries()返回一个遍历器对象，用来遍历 [键名, 键值] 组成的数组。对 于数组，键名就是索引值；对于 Set，键名与键值相同。Map 结构的 Iterator 接口，默认就是调用entries方法。 keys()返回一个遍历器对象，用来遍历所有的键名。 values()返回一个遍历器对象，用来遍历所有的键值。 这三个方法调用后生成的遍历器对象，所遍历的都是计算生成的数据结构。 类似数组的对象对于字符串来说， for...of循环还有一个特点，就是会正确识别32位 UTF-16 字符。 并不是所有类似数组的对象都具有 Iterator 接口，一个简便的解决方法，就是使用Array.from方法将其转为数组: 123456789101112131415let arrayLike = &#123; length: 2, 0: 'a', 1: 'b'&#125;;// 报错for (let x of arrayLike) &#123; console.log(x);&#125;// 正确for (let x of Array.from(arrayLike)) &#123; console.log(x);&#125; 对象对于普通的对象，for…of结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用。但是，这样情况下，for…in循环依然可以用来遍历键名。 一种解决方法是，使用Object.keys方法将对象的键名生成一个数组，然后遍历这个数组： 123for (var key of Object.keys(someObject)) &#123; console.log(key + ': ' + someObject[key]);&#125; 另一个方法是使用 Generator 函数将对象重新包装一下: 123456789101112function* entries(obj) &#123; for (let key of object.keys(obj)) &#123; yield [key, obj[key]]; &#125;&#125;for (let [key, value] of entries(obj)) &#123; console.log(key, '-&gt;', value);&#125;// a -&gt; 1// b -&gt; 2// c -&gt; 3 与其他遍历语法的比较forEach无法中途跳出，break命令或return命令都不能奏效。 for…in循环有几个缺点： 数组的键名是数字，但是 for...in循环是以字符串作为键名“0”、“1”、“2”等等 for...in循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键 某些情况下，for...in循环会以任意顺序遍历键名 for...in循环主要是为遍历对象而设计的，不适用于遍历数组。 Generator函数的语法简介基本概念Generator 函数有多种理解角度。从语法上，首先可以把它理解成，Generator 函 数是一个状态机，封装了多个内部状态。 执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态 机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。 形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。 1234567function* helloWorldGenerator() &#123; yield 'hello'; yield 'world'; return 'ending';&#125;var hw = helloWorldGenerator(); 上面代码定义了一个 Generator 函数helloWorldGenerator，它内部有两个yield表达式（ hello和world），即该函数有三个状态：hello，world 和return语句（结束执行）。 然后，Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆 括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象。 下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是 说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield 表达式（或return语句）为止。换言之，Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法 可以恢复执行。 1234567891011hw.next();// &#123; value: 'hello', done: false &#125;hw.next();// &#123; value: 'world', done: false &#125;hw.next();// &#123; value: 'ending', done: true &#125;hw.next();// &#123; value: undefined, done: true &#125; yield表达式由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部 状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。 遍历器对象的next方法的运行逻辑如下: 遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值 下一次调用 next方法时，再继续往下执行，直到遇到下一个yield表达式 如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值 如果该函数没有return语句，则返回的对象的value属性值为undefined 需要注意的是，yield表达式后面的表达式，只有当调用next方法、内部指针 指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。 yield表达式与return语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值。区别在于每次遇到yield，函数暂停执行，下一次再从该位置继续向后执行，而return语句不具备位置记忆的功能。一个函数里面，只能执行一次（或者说一个）return语句，但是可以执行多次（或 者说多个）yield表达式。正常函数只能返回一个值，因为只能执行一次return；Generator 函数可以返回一系列的值，因为可以有任意多个yield。从另一个角度看，也可以说 Generator 生成了一系列的值，这也就是 它的名称的来历（英语中，generator 这个词是“生成器”的意思）。 Generator 函数可以不用yield表达式，这时就变成了一个单纯的暂缓执行函数。 123456789function* f() &#123; console.log('执行了');&#125;var generator = f();setTimeout(function () &#123; generator.next();&#125;, 20000); yield表达式只能用在 Generator 函数里面，用在其他地方都会报错。 123456789101112131415var arr = [1, [[2, 3], 4], [5, 6]];var flat = function* (a) &#123; a.forEach(function (item) &#123; if (typeof item !== 'number') &#123; yield* flat(item); &#125; else &#123; yield item; &#125; &#125;);&#125;;for (var f of flat(arr)) &#123; console.log(f);&#125; 上面代码也会产生句法错误，因为forEach方法的参数是一个普通函数，但是在 里面使用了yield表达式。一种修改方法是改用for循环: 1234567891011121314151617var arr = [1, [[2, 3], 4], [5, 6]];var flat = function* (a) &#123; var length = a.length; for (var i = 0; i &lt; length; i++) &#123; var item = a[i]; if (typeof item !== 'number') &#123; yield* flat(item); &#125; else &#123; yield item; &#125; &#125;&#125;;for (var f of flat(arr)) &#123; console.log(f);&#125; yield表达式如果用在另一个表达式之中，必须放在圆括号里面: 1234567function* demo() &#123; console.log('Hello' + yield); // SyntaxError console.log('Hello' + yield 123); // SyntaxError console.log('Hello' + (yield)); // OK console.log('Hello' + (yield 123)); // OK&#125; yield表达式用作函数参数或放在赋值表达式的右边，可以不加括号。 与Iterator接口的关系由于 Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象 的 Symbol.iterator 属性，从而使得该对象具有 Iterator 接口。 12345678var myIterable = &#123;&#125;;myIterable[Symbol.iterator] = function* () &#123; yield 1; yield 2; yield 3;&#125;;[...myIterable] // [1, 2, 3] Generator 函数执行后，返回一个遍历器对象。该对象本身也具 有 Symbol.iterator 属性，执行后返回自身。 next方法的参数yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。 123456789101112function* f() &#123; for (var i = 0; true; i++) &#123; var reset = yield i; if (reset) &#123; i = -1; &#125; &#125;&#125;var g = f();g.next(); // &#123; value: 0, done: false &#125;g.next(); // &#123; value: 1, done: false &#125;g.next(true); // &#123; value: 0, done: false &#125; 上面代码先定义了一个可以无限运行的 Generator 函数f，如果next方法没有参数，每次运行到 yield 表达式，变量reset的值总是undefined。当next方法带一个参数true时，变量reset就被重置为这个参数（即true），因此i会等于-1，下一轮循环就会从-1开始递增。 这个功能有很重要的语法意义。Generator 函数从暂停状态到恢复运行，它的上下 文状态（context）是不变的。通过next方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值。也就是说，可以在 Generator 函数运 行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。 注意，由于next方法的参数表示上一个yield表达式的返回值，所以在第一次使用next方法时，传递参数是无效的。V8 引擎直接忽略第一次使用next方法 时的参数，只有从第二次使用next方法开始，参数才是有效的。从语义上讲，第 一个next方法用来启动遍历器对象，所以不用带有参数。 1234567891011121314function* dataConsumer() &#123; console.log('start'); console.log(`1.$&#123;yield&#125;`); console.log(`2.$&#123;yield&#125;`); return 'result';&#125;let genObj = dataConsumer();genObj.next();// startgenObj.next('a');// 1.2genObj.next('b');// 2.b 如果想要第一次调用next方法时，就能够输入值，可以在 Generator 函数外面再包一层： 123456789101112131415function wrapper(generatorFunction) &#123; return function (...args) &#123; let generatorObject = generatorFunction(...args); generatorObject.next(); return generatorObject; &#125;;&#125;const wrapped = wrapper(function* () &#123; console.log(`first input: $&#123;yield&#125;`); return 'DONE';&#125;);wrapper().next('hello');// first input: hello for…of 循环for…of循环可以自动遍历 Generator 函数时生成的Iterator对象，且此时不再需要调用next方法: 12345678910111213function* foo() &#123; yield 1; yield 2; yield 3; yield 4; yield 5; return 6;&#125;for (let v of foo()) &#123; console.log(v);&#125;// 1 2 3 4 5 123456789101112function* fibonacci() &#123; let [prev, curr] = [0, 1]; for(;;) &#123; [prev, curr] = [curr, prev + curr]; yield curr; &#125;&#125;for (let n of fibonacci()) &#123; if (n &gt; 1000) break; console.log(n);&#125; 利用for…of循环，可以写出遍历任意对象（object）的方法。原生的 JavaScript 对象没有遍历接口，无法使用for…of循环，通过 Generator 函数为 它加上这个接口，就可以用了。 12345678910111213function* objectEntries(obj) &#123; let propKeys = Reflect.ownKeys(obj); for (let propKey of propKeys) &#123; yield [propKey, obj[propKey]]; &#125;&#125;let jane = &#123; first: 'jane', last: 'doe' &#125;;for (let [key, value] of objectEntries(jane)) &#123; console.log(`$&#123;key&#125;: $&#123;value&#125;`);&#125; 加上遍历器接口的另一种写法是，将 Generator 函数加到对象的Symbol.iterator属性上面： 123456789101112131415function* objectEntries(obj) &#123; let propKeys = Reflect.ownKeys(obj); for (let propKey of propKeys) &#123; yield [propKey, obj[propKey]]; &#125;&#125;let jane = &#123; first: 'jane', last: 'doe' &#125;;jane[Symbol.iterator] = objectEntries;for (let [key, value] of objectEntries(jane)) &#123; console.log(`$&#123;key&#125;: $&#123;value&#125;`);&#125; 除了for…of循环以外，扩展运算符（…）、解构赋值和Array.from方法 内部调用的，都是遍历器接口。这意味着，它们都可以将 Generator 函数返回的 Iterator 对象，作为参数。 123456789101112131415161718192021222324function* number() &#123; yield 1; yield 2; return 3; yield 4;&#125;// 扩展运算符[...number()] // [1, 2]// Array.from方法Array.from(number()); // [1, 2]// 解构赋值let [x, y] = number();x // 1y // 2// for...of 循环for (let n of number()) &#123; console.log(n);&#125;// 1// 2 Generator.prototype.throw()Generator 函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。 12345678910111213141516171819var g = function* () &#123; try &#123; yield; &#125; catch (e) &#123; console.log('内部捕获', e); &#125;&#125;;var i = g();i.next();try &#123; i.throw('a'); i.throw('b');&#125; catch (e) &#123; console.log('外部捕获', e);&#125;// 内部捕获 a// 外部捕获 b throw方法可以接受一个参数，该参数会被catch语句接收，建议抛出Error对象的实例。 如果 Generator 函数内部没有部署try…catch代码块，那么throw方法抛出的错误，将被外部try…catch代码块捕获。 throw方法被捕获以后，会附带执行下一条yield表达式。也就是说，会附带执行一次next方法。 throw命令与g.throw方法是无关的，两者互不影响。 123456789101112131415var gen = function* gen () &#123; yield console.log('hello'); yield console.log('world');&#125;;var g = gen();g.next();try &#123; throw new Error()&#125; catch (e) &#123; g.next();&#125;// hello// world 这种函数体内捕获错误的机制，大大方便了对错误的处理。多个yield表达式， 可以只用一个 try…catch 代码块来捕获错误。如果使用回调函数的写法，想要 捕获多个错误，就不得不为每个函数内部写一个错误处理语句，现在只在Generator 函数内部写一次catch语句就可以了。 Generator 函数体外抛出的错误，可以在函数体内捕获；反过来，Generator 函数 体内抛出的错误，也可以被函数体外的catch捕获。 一旦 Generator 执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了。 如果此后还调用next方法，将返回一个value属性等于undefined、done属性等于true的对象，即 JavaScript 引擎认为这个Generator 已经运行结束了。 Generator.prototype.return()Generator 函数返回的遍历器对象，还有一个return 方法，可以返回给定的值，并且终结遍历 Generator 函数。 1234567891011function* gen() &#123; yield 1; yield 2; yield 3;&#125;var g = gen();g.next(); // &#123; value: 1, done: false &#125;g.return('foo'); // &#123; value: "foo", done: true &#125;g.next(); // &#123; value: undefined, done: true &#125; 如果return方法调用时，不提供参数，则返回值的value属性为undefined。 12345678910function* gen() &#123; yield 1; yield 2; yield 3;&#125;var g = gen();g.next(); // &#123; value: 1, done: false &#125;g.return(); // &#123; value: undefined, done: true &#125; 如果 Generator 函数内部有try...finally代码块，那么return方法会推迟到finally代码块执行完再执行。 123456789101112131415161718function* numbers() &#123; yield 1; try &#123; yield 2; yield 3; &#125; finally &#123; yield 4; yield 5; &#125; yield 6;&#125;var g = number();g.next(); // &#123; value: 1, done: false &#125;g.next(); // &#123; value: 2, done: false &#125;g.return(7); // &#123; value: 4, done: false &#125;g.next(); // &#123; value: 5, done: false &#125;g.next(); // &#123; value: 7, done: true &#125; next()、throw()、return() 的共同点next() 、 throw() 、 return() 这三个方法本质上是同 一件事，可以放在一起理解。它们的作用都是让 Generator 函数恢复执行，并且使用不同的语句替换yield表达式。 next()是将yield表达式替换成一个值。 throw()是将yield表达式替换成一个throw语句。 return() 是将表达式替换成一个return语句。 yield*表达式如果在 Generator 函数内部，调用另一个 Generator 函数，默认情况下是没有效果的。 这个就需要用到yield* 表达式，用来在一个 Generator 函数里面执行另一个 Generator 函数。 1234567891011121314151617181920212223242526272829303132333435function* foo() &#123; yield 'a'; yield 'b';&#125;function* bar() &#123; yield 'x'; yield* foo(); yield 'y';&#125;// 等同于function* bar() &#123; yield 'x'; yield 'a'; yield 'b'; yield 'y';&#125;// 等同于function* bar() &#123; yield 'x'; for (let v of foo()) &#123; yield v; &#125; yield 'y';&#125;for (let v of bar()) &#123; console.log(v);&#125;// 'x';// 'a';// 'b';// 'y'; 从语法角度看，如果yield*表达式后面跟的是一个遍历器对象，需要在yield表达式后面加上星号，表明它返回的是一个遍历器对象。这被称yield*表达式。 yield*后面的 Generator 函数（没有 return 语句时），等同于在 Generator 函数内部，部署一个for…of循环。 如果yield*后面跟着一个数组，由于数组原生支持遍历器，因此就会遍历数组成员。 12345function* gen() &#123; yield* ['a', 'b', 'c'];&#125;gen().next(); // &#123; value:"a", done:false &#125; 实际上，任何数据结构只要有 Iterator 接口，就可以被yield*遍历。 1234567let read = (function* () &#123; yield 'hello'; yield* 'hello';&#125;)();read.next().value; // 'hello'read.next().value; // 'h' 如果被代理的 Generator 函数有return语句，那么就可以向代理它的 Generator 函数返回数据。 1234567891011121314151617181920212223242526function* foo() &#123; yield 2; yield 3; return 'foo';&#125;function* bar() &#123; yield 1; var v = yield* foo(); console.log('v: ' + v); yield 4;&#125;var it = bar();it.next();// &#123;value: 1, done: false&#125;it.next();// &#123;value: 2, done: false&#125;it.next();// &#123;value: 3, done: false&#125;it.next();// "v: foo"// &#123;value: 4, done: false&#125;it.next();// &#123;value: undefined, done: true&#125; yield*命令可以很方便地取出嵌套数组的所有成员。 1234567891011121314151617181920function* iterTree(tree) &#123; if (Array.isArray(tree)) &#123; for (let i = 0; i &lt; tree.length; i++) &#123; yield* iterTree(tree[i]); &#125; &#125; else &#123; yield tree; &#125;&#125;const tree = ['a', ['b', 'c'], ['d', 'e']];for (let x of iterTree(tree)) &#123; console.log(x);&#125;// a// b// c// d// e 1234567891011121314151617181920212223242526272829303132333435// 下面是二叉树的构造函数// 三个参数分别是左树、当前节点和右树function Tree(left, label, right) &#123; this.left = left; this.label = label; this.right = right;&#125;// 下面中序（inorder）遍历函数// 由于返回的是一个遍历器，所以要用generator函数// 函数体内采用递归算法，所以左树和右树要用yield*遍历function* inorder(t) &#123; if (t) &#123; yield* inorder(t.left); yield t.label; yield* inorder(t.right); &#125;&#125;// 下面生成二叉树function make(array) &#123; // 判断是否为叶节点 if (array.length == 1) return new Tree(null, array[0], null); return new Tree(make(array[0]), array[1], make(array[2]));&#125;let tree = make([[['a'], 'b', ['c']], 'd', [['e'], 'f', ['g']]]);// 遍历二叉树var result = [];for (let node of inorder(tree)) &#123; result.push(node);&#125;result// ['a', 'b', 'c', 'd', 'e', 'f', 'g'] 作为对象属性的Generator函数如果一个对象的属性是 Generator 函数，可以简写成下面的形式： 12345let obj = &#123; * myGeneratorMethod() &#123; // ... &#125;&#125;; Generator函数的thisGenerator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，也继承了 Generator 函数的prototype对象上的方法。 12345678910function* g() &#123;&#125;g.prototype.hello = function () &#123; return 'hi';&#125;;let obj = g();obj instanceof g // trueobj.hello() // hi 上面代码表明，Generator 函数g返回的遍历器obj，是g的实例，而且继承 了g.prototype 。但是，如果把g当作普通的构造函数，并不会生效，因为g返回的总是遍历器对象，而不是this对象。 123456function* g() &#123; this.a = 11;&#125;let obj = g();obj.a // undefined Generator函数也不能跟new命令一起用，会报错。 那么，有没有办法让 Generator 函数返回一个正常的对象实例，既可以用next方法，又可以获得正常的this？ 下面是一个变通方法。首先，生成一个空对象，使用call方法绑定 Generator 函数内部的this。这样，构造函数调用以后，这个空对象就是 Generator 函数的实例对象了。 1234567891011121314function* F() &#123; this.a = 1; yield this.b = 2; yield this.c = 3;&#125;var obj = &#123;&#125;;var f = F.call(obj);f.next(); // Object &#123;value: 2, done: false&#125;f.next(); // Object &#123;value: 3, done: false&#125;f.next(); // Object &#123;value: undefined, done: true&#125;obj.a // 1obj.b // 2obj.c // 3 上面代码中，执行的是遍历器对象f，但是生成的对象实例是obj，有没有办法将这两个对象统一呢？ 一个办法就是将obj换成F.prototype: 1234567891011121314function* F() &#123; this.a = 1; yield this.b = 2; yield this.c = 3;&#125;var f = F.call(F.prototype);f.next(); // Object &#123;value: 2, done: false&#125;f.next(); // Object &#123;value: 3, done: false&#125;f.next(); // Object &#123;value: undefined, done: true&#125;f.a // 1f.b // 2f.c // 3 再将F改成构造函数，就可以对它执行new命令了： 123456789101112131415161718function* gen() &#123; this.a = 1; yield this.b = 2; yield this.c = 3;&#125;function F() &#123; return gen.call(gen.prototype);&#125;var f = new F();f.next(); // Object &#123;value: 2, done: false&#125;f.next(); // Object &#123;value: 3, done: false&#125;f.next(); // Object &#123;value: undefined, done: true&#125;f.a // 1f.b // 2f.c // 3 含义Generator与状态机Generator 是实现状态机的最佳结构。比如，下面的clock函数就是一个状态机。 123456789var ticking = true;var clock = function () &#123; if (ticking) &#123; console.log('Tick'); &#125; else &#123; console.log('Tock'); &#125; ticking = !ticking;&#125;; 上面代码的clock函数一共有两种状态（Tick和Tock），每运行一次，就改 变一次状态。这个函数如果用 Generator 实现，就是下面这样: 12345678var clock = function* () &#123; while (true) &#123; console.log('tick'); yield; console.log('tock'); yield; &#125;&#125;; 上面的 Generator 实现与 ES5 实现对比，可以看到少了用来保存状态的外部变 量ticking，这样就更简洁，更安全（状态不会被非法篡改）、更符合函数式编 程的思想，在写法上也更优雅。Generator 之所以可以不用外部变量保存状态，是 因为它本身就包含了一个状态信息，即目前是否处于暂停态。 Generator与协程协程（coroutine）是一种程序运行的方式，可以理解成“协作的线程”或“协作的函数”。协程既可以用单线程实现，也可以用多线程实现。前者是一种特殊的子例程， 后者是一种特殊的线程。 协程与子例程的差异 传统的“子例程”（subroutine）采用堆栈式“后进先出”的执行方式，只有当调用的子 函数完全执行完毕，才会结束执行父函数。协程与其不同，多个线程（单线程情况 下，即多个函数）可以并行执行，但是只有一个线程（或函数）处于正在运行的状 态，其他线程（或函数）都处于暂停态（suspended），线程（或函数）之间可以 交换执行权。也就是说，一个线程（或函数）执行到一半，可以暂停执行，将执行 权交给另一个线程（或函数），等到稍后收回执行权的时候，再恢复执行。这种可以并行执行、交换执行权的线程（或函数），就称为协程。 从实现上看，在内存中，子例程只使用一个栈（stack），而协程是同时存在多个 栈，但只有一个栈是在运行状态，也就是说，协程是以多占用内存为代价，实现多任务的并行。 协程与普通线程的差异 不难看出，协程适合用于多任务运行的环境。在这个意义上，它与普通的线程很相似，都有自己的执行上下文、可以分享全局变量。它们的不同之处在于，同一时间 可以有多个线程处于运行状态，但是运行的协程只能有一个，其他协程都处于暂停 状态。此外，普通的线程是抢先式的，到底哪个线程优先得到资源，必须由运行环 境决定，但是协程是合作式的，执行权由协程自己分配。 由于 JavaScript 是单线程语言，只能保持一个调用栈。引入协程以后，每个任务可以保持自己的调用栈。这样做的最大好处，就是抛出错误的时候，可以找到原始的调用栈。不至于像异步操作的回调函数那样，一旦出错，原始的调用栈早就结束。 Generator 函数是 ES6 对协程的实现，但属于不完全实现。Generator 函数被称 为“半协程”（semi-coroutine），意思是只有 Generator 函数的调用者，才能将程序 的执行权还给 Generator 函数。如果是完全执行的协程，任何函数都可以让暂停的协程继续执行。 如果将 Generator 函数当作协程，完全可以将多个需要互相协作的任务写成 Generator 函数，它们之间使用 yield 表示式交换控制权。 应用异步操作的同步化表达Generator 函数的暂停执行的效果，意味着可以把异步操作写在yield表达式里 面，等到调用next方法时再往后执行。这实际上等同于不需要写回调函数了，因 为异步操作的后续操作可以放在yield表达式下面，反正要等到调用next方法 时再执行。所以，Generator 函数的一个重要实际意义就是用来处理异步操作，改写回调函数。 1234567891011function* loadUI() &#123; showLoadingScreen(); yield loadUIDataAsynchronously(); hideLoadingScreen();&#125;var loader = loadUI();// 加载UIloader.next();// 卸载UIloader.next(); 上面代码中，第一次调用loadUI函数时，该函数不会执行，仅返回一个遍历器。 下一次对该遍历器调用next方法，则会显示Loading界面 （showLoadingScreen），并且异步加载数据（loadUIDataAsynchronously）。等到数据加载完成，再一次使用next方法，则会隐藏Loading界面。可以看到，这种写法的好处是所有loading界面的逻辑，都被封装在一个函数，按部就班非常清晰。 Ajax 是典型的异步操作，通过 Generator 函数部署 Ajax 操作，可以用同步的方式表达: 1234567891011121314function* main() &#123; var result = yield result('http://some.url'); var resp = JSON.parse(result); console.log(resp.value);&#125;function request(url) &#123; makeAjaxCall(url, function (response) &#123; it.next(response); &#125;);&#125;var it = main();it.next(); 上面代码的main函数，就是通过 Ajax 操作获取数据。可以看到，除了多了一 个yield，它几乎与同步操作的写法完全一样。注意，makeAjaxCal 函数中的next方法，必须加上response参数，因为yield表达式，本身是没有值的，总是等于undefined。 下面是另一个例子，通过 Generator 函数逐行读取文本文件。 12345678910function* numbers() &#123; let file = new FileReader('number.txt'); try &#123; while (!file.eof) &#123; yield parseInt(file.readLine(), 10); &#125; &#125; finally &#123; file.close(); &#125;&#125; 控制流管理如果有一个多步操作非常耗时，采用回调函数，可能会写成下面这样: 123456789step1(function (value1) &#123; step2(value1, function (value2) &#123; step3(value2, function (value3) &#123; step(value3, function (value4) &#123; // Do something with value4 &#125;); &#125;); &#125;);&#125;); 采用 Promise 改写上面的代码： 12345678910Promise.resolve(step1) .then(step2) .then(step3) .then(step4) .then(function (value4) &#123; // Do something with value4 &#125;, function (error) &#123; // Handle error &#125;) .done(); 上面代码已经把回调函数，改成了直线执行的形式，但是加入了大量 Promise 的语 法。Generator 函数可以进一步改善代码运行流程: 1234567891011function* longRunningTask() &#123; try &#123; var value2 = yield step1(value1); var value3 = yield step1(value2); var value4 = yield step1(value3); var value5 = yield step1(value4); // Do something with value4 &#125; catch (e) &#123; // Handle error &#125;&#125; 然后，使用一个函数，按次序自动执行所有步骤： 12345678910scheduler(longRunningTask(initialValue));function scheduler(task) &#123; var taskObj = task.next(task.value); // 如果Generator函数未结束，就继续调用 if (!taskObj.done) &#123; task.value = taskObj.value; scheduler(task); &#125;&#125; 注意，上面这种做法，只适合同步操作，即所有的 task 都必须是同步的，不能有 异步操作。因为这里的代码一得到返回值，就继续往下执行，没有判断异步操作何 时完成。如果要控制异步的操作流程，详见后面的《异步操作》一章。 下面，利用for...of循环会自动依次执行yield命令的特性，提供一种更一般的控制流管理的方法: 12345678let steps = [step1Func, step2Func, step3Func];function* iterateSteps(steps) &#123; for (var i = 0; i &lt; steps.length; i++) &#123; var step = steps[i]; yield step(); &#125;&#125; 部署Iterator接口利用 Generator 函数，可以在任意对象上部署 Iterator 接口： 123456789101112131415function* iterEntries() &#123; let keys = Object.keys(obj); for (let i = 0; i &lt; keys.length; i++) &#123; let key = keys[i]; yield [key, obj[key]]; &#125;&#125;let myobj = &#123; foo: 3, bar: 7 &#125;;for (let [key, value] of iterEntries(myobj)) &#123; console.log(key, value);&#125;// foo 3// bar 7 上述代码中，myObj是一个普通对象，通过iterEntries函数，就有了 Iterator 接口。也就是说，可以在任意对象上部署next方法。 作为数据结构Generator 可以看作是数据结构，更确切地说，可以看作是一个数组结构，因为 Generator 函数可以返回一系列的值，这意味着它可以对任意表达式，提供类似数组的接口。 12345function* doStuff() &#123; yield fs.redFile.bind(null, 'hello.txt'); yield fs.redFile.bind(null, 'world.txt'); yield fs.redFile.bind(null, 'and-such.txt');&#125; 上面代码就是依次返回三个函数，但是由于使用了 Generator 函数，导致可以像处理数组那样，处理这三个返回的函数。 123for (task of doStuff()) &#123; // task是一个函数，可以像回调函数那样使用它&#125; Generator 使得数据或者操作，具备了类似数组的接口。 Generator函数的异步应用传统方法ES6 诞生以前，异步编程的方法，大概有下面四种： 回调函数 事件监听 发布/订阅 Promise 对象 基本概念异步所谓”异步”，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成 两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。 比如，有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要 求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务 的第二段（处理文件）。这种不连续的执行，就叫做异步。 相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务，所以操作 系统从硬盘读取文件的这段时间，程序只能干等着。 回调函数JavaScript 语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函 数。回调函数的英语名字 callback ，直译过来就是”重新调用”。 1234fs.readFile('/etc/passwd', 'utf-8', function (err, data) &#123; if (err) throw err; console.log(data);&#125;); 一个有趣的问题是，为什么 Node 约定，回调函数的第一个参数，必须是错误对象err（如果没有错误，该参数就是null）？ 原因是执行分成两段，第一段执行完以后，任务所在的上下文环境就已经结束了。 在这以后抛出的错误，原来的上下文环境已经无法捕捉，只能当作参数，传入第二 段。 PromisePromise 对象就是为了解决回调地狱而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用。 Promise 的最大问题是代码冗余，原来的任务被 Promise 包装了一下，不管什么操 作，一眼看去都是一堆then，原来的语义变得很不清楚。 Generator函数协程传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有 一种叫做”协程”（coroutine），意思是多个线程互相协作，完成异步任务。 协程有点像函数，又有点像线程。它的运行流程大致如下: 第一步，协程A开始执行。 第二步，协程A执行到一半，进入暂停，执行权转移到协程B 第三步，（一段时间后）协程B交还执行权。 第四步，协程A恢复执行。 12345function* asyncJob() &#123; // ... 其他代码 var f = yield readFile(fileA); // ... 其他代码&#125; 上面代码的函数asyncJob是一个协程，它的奥妙就在其中的yield命令。它表示执行到此处，执行权将交给其他协程。也就是说，yield命令是异步两个阶段 的分界线。 协程遇到yield命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。 它的最大优点，就是代码的写法非常像同步操作，如果去除yield命令，简直一 模一样。 协程的Generator函数实现Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂 停执行）。 整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操 作需要暂停的地方，都用yield语句注明。Generator 函数的执行方法如下: 12345678function* gen(x) &#123; var y = yield x + 2; return y;&#125;var g = gen(1);g.next(); // &#123; value: 3, done: false &#125;g.next(); // &#123; value: undefined, done: true &#125; 换言之，next方法的作用是分阶段执行 Generator 函数。每次调用next方法，会返回一个对象，表示当前阶段的信息（value属性和done属性）。value属性是yield语句后面表达式的值，表示当前阶段的值；done属性是一个布尔值，表示 Generator 函数是否执行完毕，即是否还有下一个阶段。 Generator函数的数据交换和错误处理Generator 函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。除 此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：函数体内外的 数据交换和错误处理机制。 next返回值的value属性，是 Generator 函数向外输出数据；next方法还可以接受参数，向 Generator 函数体内输入数据。 12345678function* gen(x) &#123; var y = yield x + 2; return y;&#125;var g = gen(1);g.next(); // &#123; value: 3, done: false &#125;g.next(2); // &#123; value: 2, done: true &#125; Generator 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误： 12345678910111213function* gen(x) &#123; try &#123; var y = yield x + 2; &#125; catch (e) &#123; console.log(e); &#125; return y;&#125;var g = gen(1);g.next();g.throw('出错了');// 出错了 上面代码的最后一行，Generator 函数体外，使用指针对象的throw方法抛出的 错误，可以被函数体内的try…catch代码块捕获。这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的。 异步任务的封装123456789101112131415var fetch = require('node-fetch');function* gen() &#123; var url = 'https://api.github.com/users/github'; var result = yield fetch(url); console.log(result.bio);&#125;var g = gen();var result = g.next();result.value.then(function (data) &#123; return data.json();&#125;).then(function (data) &#123; g.next(data);&#125;); 上面代码中，首先执行 Generator 函数，获取遍历器对象，然后使用next方法 （第二行），执行异步任务的第一阶段。由于 Fetch 模块返回的是一个 Promise 对象，因此要用then方法调用下一个next方法。 Thunk函数Thunk 函数是自动执行 Generator 函数的一种方法。 参数的求值策略1234567var x = 1;function f(m) &#123; return m * 2;&#125;f(x + 5) 上面代码先定义函数 f，然后向它传入表达式x + 5。。请问，这个表达式应该何时求值？ 一种意见是”传值调用”（call by value），即在进入函数体之前，就计算x+5的值（等于6），再将这个值传入函数f。C语言就采用这种策略。 另一种意见是“传名调用”（call by name），即直接将表达式x+5传入函数体， 只在用到它的时候求值。Haskell 语言采用这种策略。 传值调用比较简单，但是对参数求值的时候，实际上还没用到这 个参数，有可能造成性能损失。 Thunk函数的含义编译器的“传名调用”实现，往往是将参数放到一个临时函数之中，再将这个临时函 数传入函数体。这个临时函数就叫做 Thunk 函数。 123456789101112131415function f(m) &#123; return m * 2;&#125;f(x + 5);// 等同于var thunk = function () &#123; return x + 5;&#125;;function f(thunk) &#123; return thunk() * 2;&#125; 上面代码中，函数f的参数x+5被一个函数替换了。凡是用到原参数的地方，对Thunk函数求值即可。 这就是 Thunk 函数的定义，它是“传名调用”的一种实现策略，用来替换某个表达式。 JavaScript语言的Thunk函数JavaScript 语言是传值调用，它的Thunk函数含义有所不同。在 JavaScript 语言 中，Thunk 函数替换的不是表达式，而是多参数函数，将其替换成一个只接受回调函数作为参数的单参数函数。 123456789101112// 正常版本的readFile（多参数版本）fs.readFile(fileName, callback);// Thunk版本的readFile（单参数版本）var Thunk = function (fileName) &#123; return function (callback) &#123; return fs.readFile(fileName, callback); &#125;;&#125;;var readFileThunk = Thunk(fileName);readFileThunk(callback); 任何函数，只要参数有回调函数，就能写成 Thunk 函数的形式。下面是一个简单的 Thunk 函数转换器。 1234567891011121314151617181920212223242526// ES5版本var Thunk = function (fn) &#123; return function () &#123; var args = array.prototype.slice.call(arguments); return function (callback) &#123; args.push(callback); return fn.apply(this, args); &#125; &#125;;&#125;;// ES6版本const Thunk = function (fn) &#123; return function (...args) &#123; return function (callback) &#123; return fn.call(this, ...args, callback); &#125; &#125;;&#125;;function f(a, cb) &#123; cb(a);&#125;const ft = Thunk(f);ft(1)(console.log); // 1 Thunkify模块生产环境的转换器，建议使用 Thunkify 模块: 1$ npm install thunkify 1234567var thunkify = require('thunkify');var fs = require('fs');var read = thunkify(fs.readFile);read('package.json')(function (err, str) &#123; // ...&#125;); Thunkify 的源码与上一节那个简单的转换器非常像： 1234567891011121314151617181920212223242526function thunkify(fn) &#123; return function () &#123; var args = new array(arguments.length); var ctx = this; for (var i = 0; i &lt; args.length; ++i) &#123; args[i] = arguments[i]; &#125; return function (done) &#123; var called; args.push(function () &#123; if (called) return; called = true; done.apply(null, arguments); &#125;); try &#123; fn.apply(ctx, args); &#125; catch (e) &#123; done(e); &#125; &#125; &#125;&#125; 它的源码主要多了一个检查机制，变量 called 确保回调函数只运行一次。这样的 设计与下文的 Generator 函数相关。 12345678910function f(a, b, callback) &#123; var sum = a + b; callback(sum); callback(sum);&#125;var ft = thunkify(f);var print = console.log.bind(console);ft(1, 2)(print);// 3 Generator函数的流程管理Thunk 函数现在可以用于 Generator 函数的自动流程管理。 1234567891011function* gen() &#123; // ...&#125;var g = gen();var res = g.next();while (!res.done) &#123; console.log(res.value); res = g.next();&#125; 上面代码中，Generator 函数gen会自动执行完所有步骤。 但是，这不适合异步操作。如果必须保证前一步执行完，才能执行后一步，上面的自动执行就不可行。这时，Thunk 函数就能派上用处。以读取文件为例。下面的 Generator 函数封装了两个异步操作。 12345678910var fs = require('fs');var thunkify = require('thunkify');var readFileTunk = thunkify(fs.readFile);var gen = function* () &#123; var r1 = yield readFileThunk('/etc/fstab'); console.log(r1.toString()); var r2 = yield readFileThunk('/etc/shells'); console.log(r2.toString());&#125;; 上面代码中，yield命令用于将程序的执行权移出 Generator 函数，那么就需要 一种方法，将执行权再交还给 Generator 函数。 这种方法就是 Thunk 函数，因为它可以在回调函数里，将执行权交还给 Generator 函数。为了便于理解，我们先看如何手动执行上面这个 Generator 函数。 1234567891011var g = gen();var r1 = g.next();r1.value(function (err, data) &#123; if (err) throw err; var r2 = g.next(data); r2.value(function (err, data) &#123; if (err) throw err; g.next(data); &#125;);&#125;); 上面代码中，变量g是 Generator 函数的内部指针，表示目前执行到哪一 步。next方法负责将指针移动到下一步，并返回该步的信息（value属性和done属性）。 仔细查看上面的代码，可以发现 Generator 函数的执行过程，其实是将同一个回调函数，反复传入next方法的value属性。这使得我们可以用递归来自动完成这 个过程。 Thunk函数的自动流程管理Thunk 函数真正的威力，在于可以自动执行 Generator 函数。下面就是一个基于 Thunk 函数的 Generator 执行器。 1234567891011121314151617function run(fn) &#123; var gen = fn(); function next(err, data) &#123; var result = gen.next(data); if (result.done) return; result.value(next); &#125; next();&#125;function* g() &#123; // ...&#125;run(g); 上面代码的run函数，就是一个 Generator 函数的自动执行器。内部的next函数就是 Thunk 的回调函数。next函数先将指针移到 Generator 函数的下一步 （gen.next方法），然后判断 Generator 函数是否结束（result.done属 性），如果没结束，就将next函数再传入 Thunk 函数（result.value属性），否则就直接退出。 有了这个执行器，执行 Generator 函数方便多了。不管内部有多少个异步操作，直接把 Generator 函数传入run函数即可。当然，前提是每一个异步操作，都要是 Thunk 函数，也就是说，跟在yield命令后面的必须是 Thunk 函数。 12345678var g = function* () &#123; var f1 = yield readFileTunk('fileA'); var f2 = yield readFileTunk('fileB'); // ... var fn = yield readFileTunk('fileN');&#125;;run(g); Thunk 函数并不是 Generator 函数自动执行的唯一方案。因为自动执行的关键是， 必须有一种机制，自动控制 Generator 函数的流程，接收和交还程序的执行权。回 调函数可以做到这一点，Promise 对象也可以做到这一点。 co模块基本用法co 模块是著名程序员 TJ Holowaychuk 于2013年6月发布的一个小工具，用于 Generator 函数的自动执行。 下面是一个 Generator 函数，用于依次读取两个文件: 123456var gen = function* () &#123; var f1 = yield readFile('/etc/fstab'); var f2 = yield readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString());&#125;; co 模块可以让你不用编写 Generator 函数的执行器： 12var co = require('co');co(gen); 上面代码中，Generator 函数只要传入co函数，就会自动执行。 co函数返回一个 Promise 对象，因此可以用then方法添加回调函数。 123co(gen).then(function () &#123; console.log('Generator函数执行完成');&#125;); co模块的原理为什么 co 可以自动执行 Generator 函数？ 前面说过，Generator 就是一个异步操作的容器。它的自动执行需要一种机制，当 异步操作有了结果，能够自动交回执行权。 两种方法可以做到这一点。 回调函数。将异步操作包装成 Thunk 函数，在回调函数里面交回执行权。 Promise 对象。将异步操作包装成 Promise 对象，用 then 方法交回执行权。 co 模块其实就是将两种自动执行器（Thunk 函数和 Promise 对象），包装成一个 模块。使用 co 的前提条件是，Generator 函数的 yield 命令后面，只能是 Thunk 函数或 Promise 对象。如果数组或对象的成员，全部都是 Promise 对象，也可以 使用 co，详见后文的例子。（co v4.0版以后， yield 命令后面只能是 Promise 对象，不再支持 Thunk 函数。） 基于Promise对象的自动执行手动执行其实就是用 then方法，层层添加回调函数。理解了这一点，就可以写出一个自动执行器。 123456789101112131415function run(gen) &#123; var g = gen(); function next(data) &#123; var result = g.next(data); if (result.done) return result.value; result.value.then(function (data) &#123; next(data); &#125;); &#125; next();&#125;run(gen); co模块的源码首先，co 函数接受 Generator 函数作为参数，返回一个 Promise 对象: 1234567function co(gen) &#123; var ctx = this; return new Promise(function (resolve, reject) &#123; &#125;)&#125; 在返回的 Promise 对象里面，co 先检查参数gen是否为 Generator 函数。如果是，就执行该函数，得到一个内部指针对象；如果不是就返回，并将 Promise 对象的状态改为resolved。 12345678function co(gen) &#123; var ctx = this; return new Promise(function (resolve, reject) &#123; if (typeof gen === 'function') gen = gen.call(ctx); if (!gen || typeof gen.next !== 'function') return resolve(gen); &#125;);&#125; 接着，co 将 Generator 函数的内部指针对象的next方法，包装成onFulfilled函数。这主要是为了能够捕捉抛出的错误。 12345678910111213141516171819function co(gen) &#123; var ctx = this; return new Promise(function (resolve, reject) &#123; if (typeof gen === 'function') gen = gen.call(ctx); if (!gen || typeof gen.next !== 'function') return resolve(gen); onFulfilled(); function onFulfilled(res) &#123; var ret; try &#123; ret = gen.next(res); &#125; catch (e) &#123; return reject(e); &#125; next(ret); &#125; &#125;);&#125; 最后，就是关键的next函数，它会反复调用自身。 12345678910111213function next(ret) &#123; if (ret.done) return resolve(ret.value); var value = toPromise.call(ctx, ret.value); if (value &amp;&amp; isPromise(value)) return value.then(onFulfilled, onRejected); return onRejected( new TypeError( 'You may only yield a function, promise, generator, array,or object, ' + 'but the following object was passed: "' + String(ret.value) + '"' ) );&#125; 上面代码中，next函数的内部代码，一共只有四行命令。 第一行，检查当前是否为 Generator 函数的最后一步，如果是就返回。 第二行，确保每一步的返回值，是 Promise 对象。 第三行，使用then方法，为返回值加上回调函数，然后通过onFulfilled函数 再次调用next函数。 第四行，在参数不符合要求的情况下（参数非 Thunk 函数和 Promise 对象），将 Promise 对象的状态改为rejected，从而终止执行。 处理并发的异步操作co 支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下 一步。 这时，要把并发的操作都放在数组或对象里面，跟在yield语句后面。 1234567891011121314151617// 数组的写法co(function* () &#123; var res = yield [ Promise.resolve(1), Promise.resolve(2) ]; console.log(res);&#125;).catch(onerror);// 对象的写法co(function* () &#123; var res = yield &#123; 1: Promise.resolve(1), 2: Promise.resolve(2) &#125;; console.log(res);&#125;).catch(onerror); 实例 ：处理StreamNode 提供 Stream 模式读写数据，特点是一次只处理数据的一部分，数据分成一 块块依次处理，就好像“数据流”一样。这对于处理大规模数据非常有利。Stream 模 式使用 EventEmitter API，会释放三个事件。 data事件：下一块数据块已经准备好了。 end事件：整个“数据流”处理“完了。 error事件：发生错误。 使用Promise.race() 函数，可以判断这三个事件之中哪一个最先发生，只有当data事件最先发生时，才进入下一个数据块的处理。从而，我们可以通过一 个while 循环，完成所有数据的读取。 1234567891011121314151617181920212223const co = require('co');const fs = require('fs');const stream = fs.createReadStream('./les_miserables.txt');let valjeanCount = 0;co(function* () &#123; while (true) &#123; const res = yield Promise.race([ new Promise(resolve =&gt; stream.once('data', resolve)), new Promise(resolve =&gt; stream.once('end', resolve)), new Promise((resolve, reject) =&gt; stream.once('error', reject)) ]); if (!res) &#123; break; &#125; stream.removeAllListeners('data'); stream.removeAllListeners('end'); stream.removeAllListeners('error'); valjeanCount += (res.toString().match(/valjean/ig) || []).length; &#125; console.log('count:', valjeanCount); // count: 1120&#125;); async函数含义ES2017 标准引入了 async 函数，使得异步操作变得更加方便。 async 函数是什么？一句话，它就是 Generator 函数的语法糖。 前文有一个 Generator 函数，依次读取两个文件。 1234567891011121314151617var fs = request('fs');var readFile = function (fileName) &#123; return new Promise(function (resolve, reject) &#123; fs.readFile(fileName, function (error, data) &#123; if (error) return reject(error); resolve(data); &#125;); &#125;);&#125;;var gen = function* () &#123; var f1 = yield readFile('/etc/fstab'); var f2 = yield readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString());&#125;; 写成async函数，就是下面这样: 123456var asyncReadFile = async function () &#123; var f1 = await readFile('/etc/fstab'); var f2 = await readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString());&#125;; 一比较就会发现，async函数就是将 Generator 函数的星号（ *）替换成async，将yield替换成await，仅此而已。 async函数对 Generator 函数的改进，体现在以下四点: 内置执行器 Generator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。 1asyncReadFile(); 上面的代码调用了 asyncReadFile 函数，然后它就会自动执行，输出最后结果。 这完全不像 Generator 函数，需要调用 next 方法，或者用 co 模块，才能真正执 行，得到最后结果。 更好的语义 async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。 更广的适用性 co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。 返回值是 Promise async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。 进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对 象，而await命令就是内部then命令的语法糖。 基本用法async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。 123456789async function getStockPriceByName(name) &#123; var symbol = await getStockPriceSymbol(name); var stockPrice = await getStockPrice(symbol); return stockPrice;&#125;getStockPriceByName('goog').then(function (result) &#123; console.log(result);&#125;); 上面代码是一个获取股票报价的函数，函数前面的async关键字，表明该函数内 部有异步操作。调用该函数时，会立即返回一个 Promise 对象。 下面是另一个例子，指定多少毫秒后输出一个值。 123456789101112function timeout(ms) &#123; return new Promise(resolve =&gt; &#123; setTimeout(resolve, ms); &#125;);&#125;async function asyncPrint(value, ms) &#123; await timeout(ms); console.log(value);&#125;asyncPrint('hello world', 50); 由于 async 函数返回的是 Promise 对象，可以作为await命令的参数。所以，上面的例子也可以写成下面的形式: 123456789101112async function timeout(ms) &#123; await new Promise(resolve =&gt; &#123; setTimeout(resolve, ms); &#125;);&#125;async function asyncPrint(value, ms) &#123; await timeout(ms); console.log(value);&#125;asyncPrint('hello world', 50); async 函数有多种使用形式： 123456789101112131415161718192021222324252627// 函数声明async function foo() &#123;&#125;// 函数表达式const foo = async function () &#123;&#125;;// 对象的方法let obj = &#123; async foo() &#123;&#125; &#125;;obj.foo().then();// class的方法class Storage &#123; constructor() &#123; this.cachePromise = caches.open('avatars'); &#125; async getAvatar(name) &#123; const cache = await this.cachePromise; return cache.match(`/avatars/$&#123;name&#125;.jpg`); &#125;&#125;const storage = new Storage();storage.getAvatar('jake').then();// 箭头函数const foo = async () =&gt; &#123;&#125;; 语法返回Promise对象async函数返回一个 Promise 对象。 async函数内部return语句返回的值，会成为then方法回调函数的参数: 123456async function f() &#123; return 'hello world';&#125;f().then(v =&gt; console.log(v));// 'hello world' async函数内部抛出错误，会导致返回的 Promise 对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到。 123456789async function f() &#123; throw new Error('出错了');&#125;f().then( v =&gt; console.log(v), e =&gt; console.log(e));// Error: 出错了 Promise对象的状态变化async函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。 也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。 1234567async function getTitle(url) &#123; let response = await fetch(url); let html = await response.text(); return html.match(/&lt;title&gt;([\s\S]+)&lt;\/title&gt;/i)[1];&#125;getTitle('https://tc39.github.io/ecma262/').then(console.log);// "ECMAScript 2017 Language Specification" await命令正常情况下，await命令后面是一个 Promise 对象。如果不是，会被转成一个立即resolve的 Promise 对象。 123456async function f() &#123; return await 123;&#125;f().then(v =&gt; console.log(v));// 123 await命令后面的 Promise 对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到。 12345678async function* f() &#123; await Promise.reject('出错了');&#125;f().then(v =&gt; console.log(v)).catch(e =&gt; console.log(e));// 出错了 只要一个await语句后面的 Promise 变为reject，那么整个 async函数都会中断执行。 1234async function f() &#123; await Promise.reject('出错了'); await Promise.resolve('hello world'); // 不会执行&#125; 有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以 将第一个await放在try…catch结构里面，这样不管这个异步操作是否成 功，第二个await都会执行。 1234567891011async function f() &#123; try &#123; await Promise.reject('出错了'); &#125; catch (e) &#123; &#125; return await Promise.resolve('hello world');&#125;f().then(v =&gt; console.log(v));// hello world 另一种方法是await后面的Promise对象再跟一个catch方法，处理前面可能出现的错误。 123456789async function f() &#123; await Promise.reject('出错了') .catch(e =&gt; console.log(e)); return await Promise.resolve('hello world');&#125;f().then(v =&gt; console.log(v));// 出错了// hello world 错误处理如果await后面的异步操作出错，那么等同于async函数返回的Promise对象被reject。 12345678910async function f() &#123; await new Promise(function (resolve, reject) &#123; throw new Error('出错了'); &#125;);&#125;f() .then(v =&gt; console.log(v)) .catch(e =&gt; console.log(e));// Error：出错了 上面代码中，async函数f执行后，await后面的 Promise 对象会抛出一个错误对象，导致catch方法的回调函数被调用，它的参数就是抛出的错误对象。具体的执行机制，可以参考后文的“async 函数的实现原理”。 防止出错的方法，也是将其放在try...catch代码块之中。 123456789async function f() &#123; try &#123; await new Promise(function (resolve, reject) &#123; throw new Error('出错了'); &#125;); &#125; catch (e) &#123; return await('hello world'); &#125;&#125; 如果有多个await命令，可以统一放在try...catch结构中。 1234567891011async function main() &#123; try &#123; var val1 = await firstStep(); var val2 = await secondStep(val1); var val3 = await thirdStep(val1, val2); console.log('final: ', val3); &#125; catch (e) &#123; console.log(e); &#125;&#125; 下面的例子使用try...catch结构，实现多次重复尝试。 1234567891011121314151617const superagent = require('superagent');const NUM_RETRIES = 3;async function test() &#123; let i; for (i = 0; i &lt; NUM_RETRIES; ++i) &#123; try &#123; await superagent.get('http://google.com/this-throws-an-error'); break; &#125; catch (e) &#123; &#125; &#125; console.log(i); // 3&#125;test(); 使用注意点第一点，前面已经说过，await命令后面的 Promise 对象，运行结果可能是rejected，所以最好把await命令放在try…catch代码块中。 123456789101112131415async function myFunction() &#123; try &#123; await sometingThatReturnsAPromise(); &#125; catch (e) &#123; console.log(e); &#125;&#125;// 另一种写法async function myFunction() &#123; await sometingThatReturnsAPromise() .catch(function (err) &#123; console.log(err); &#125;);&#125; 第二点，多个await 命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。 12let foo = await getFoo();let bar = await getBar(); 上面代码中，getFoo和getBar是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有getFoo完成以后，才会执行getBar， 完全可以让它们同时触发： 12345678// 写法一let [foo, bar] = await Promise.all([getFoo(), getBar()]);// 写法二let fooPromise = getFoo();let barPromise = getBar();let foo = await fooPromise;let bar = await barPromise; 上面两种写法， getFoo和getBar都是同时触发，这样就会缩短程序的执行时间。 第三点，await 命令只能用在async函数之中，，如果用在普通函数，就会报错： 12345678async function dbFuc(db) &#123; let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;]; // 报错 docs.forEach(function (doc) &#123; await db.post(doc); &#125;);&#125; 上面代码会报错，因为 await 用在普通函数之中了。但是，如果将forEach 方法的参数改成 async 函数，也有问题。 12345678function dbFuc(db) &#123; // 这里不需要async let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;]; // 可能得到错误结果 docs.forEach(async function (doc) &#123; await db.post(doc); &#125;);&#125; 上面代码可能不会正常工作，原因是这时三个db.post操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用for循环： 1234567async function dbFuc(db) &#123; let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;]; for (let doc of docs) &#123; await db.post(doc); &#125; &#125; 如果确实希望多个请求并发执行，可以使用Promise.all方法。当三个请求都会 resolved 时，下面两种写法效果相同: 1234567891011121314151617181920async function dbFuc(db) &#123; let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;]; let promises = docs.map((doc) =&gt; db.post(doc)); let results = await Promise.all(promises); console.log(results);&#125;// 或者使用下面的写法async function dbFuc(db) &#123; let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;]; let promises = doc.map((doc) =&gt; db.post(doc)); let results = []; for (let promise of promises) &#123; results.push(await promise); &#125; console.log(results);&#125; 目前，@std/esm模块加载器支持顶层await，即await命令可以不放在async 函数里面，直接使用: 123456789// async函数的写法const start = async () =&gt; &#123; const res = await fetch('google.com'); return res.text();&#125;;// 顶层await的写法,脚本必须使用@std/esm加载器const res = await fetch('google.com');console.log(await res.text()); async函数的实现原理async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里： 1234567891011async function fn(args) &#123; // ...&#125;// 等同于function fn(args) &#123; return spawn(function* () &#123; // ... &#125;);&#125; 所有的async函数都可以写成上面的第二种形式，其中的spawn函数就是自动执行器。 与其他异步处理方法的比较假定某个 DOM 元素上面，部署了一系列的动画，前一个动画结束，才能开始后一 个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返 回值。 首先是 Promise 的写法: 1234567891011121314151617181920212223function chainAnimationsPromise(elem, animations) &#123; // 变量ret用来保存上一个动画的返回值 var ret = null; // 新建一个空的Promise var p = Promise.resolve(); // 使用then方法，添加所有动画 for (var anim of animations) &#123; p = p.then(function (val) &#123; ret = val; return anim(elem); &#125;); &#125; // 返回一个部署了错误捕捉机制的Promise return p.catch(function (e) &#123; /*忽略错误，继续执行*/ &#125;).then(function () &#123; return ret; &#125;);&#125; 虽然 Promise 的写法比回调函数的写法大大改进，但是一眼看上去，代码完全都是 Promise 的 API（then、catch等等），操作本身的语义反而不容易看出来。 接着是 Generator 函数的写法: 12345678910111213function chainAnimationsPromise(elem, animations) &#123; return spawn(function* () &#123; var ret = null; try &#123; for (var anim of animations) &#123; ret = yield anim(elem); &#125; &#125; catch (e) &#123; /*忽略错误，继续执行*/ &#125; return ret; &#125;);&#125; 上面代码使用 Generator 函数遍历了每个动画，语义比 Promise 写法更清晰，用户定义的操作全部都出现在spawn函数的内部。这个写法的问题在于，必须有一个任务运行器，自动执行 Generator 函数，上面代码的spawn函数就是自动执行 器，它返回一个 Promise 对象，而且必须保证yield语句后面的表达式，必须返 回一个 Promise。 最后是 async 函数的写法： 1234567891011async function chainAnimationsPromise(elem, animations) &#123; var ret = null; try &#123; for (var anim of animations) &#123; ret = await anim(elem); &#125; &#125; catch (e) &#123; /*忽略错误，继续执行*/ &#125; return ret;&#125; 可以看到Async函数的实现最简洁，最符合语义，几乎没有语义不相关的代码。它将Generator写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码 量最少。如果使用Generator写法，自动执行器需要用户自己提供。 实例：按顺序完成异步操作实际开发中，经常遇到一组异步操作，需要按照顺序完成。比如，依次远程读取一 组 URL，然后按照读取的顺序输出结果。 123456async function logInOrder(urls) &#123; for (const url of urls) &#123; const response = await fetch(url); console.log(await response.text()); &#125;&#125; 上面代码的问题是所有远程操作都是继发。只有前一个URL返回结 果，才会去读取下一个URL，这样做效率很差，非常浪费时间。我们需要的是并发发出远程请求。 123456789101112async function logInOrder(urls) &#123; // 并发读取远程URL const textPromises = urls.map(async url =&gt; &#123; const response = await fetch(url); return response.text(); &#125;); // 按次序输出 for (const textPromise of textPromises) &#123; console.log(await textPromise); &#125; &#125; 上面代码中，虽然map方法的参数是async函数，但它是并发执行的，因为只有async函数内部是继发执行，外部不受影响。后面的for..of循环内部使用await，因此实现了按顺序输出。 异步遍历器《遍历器》一章说过，Iterator 接口是一种数据遍历的协议，只要调用遍历器对象的next方法，就会得到一个对象，表示当前遍历指针所在的那个位置的信息。next方法返回的对象的结构是{value, done}，其中value表示当前的数据的值，done是一个布尔值，表示遍历是否结束。 这里隐含着一个规定，next方法必须是同步的，只要调用就必须立刻返回值。也就是说，一旦执行next方法，就必须同步地得到value和done这两个属性。 如果遍历指针正好指向同步操作，当然没有问题，但对于异步操作，就不太合适了。目前的解决方法是，Generator 函数里面的异步操作，返回一个 Thunk 函数或 者 Promise 对象，即value属性是一个 Thunk 函数或者 Promise 对象，等待以后返回真正的值，而done属性则还是同步产生的。 目前，有一个提案，为异步操作提供原生的遍历器接口，即value和done这个属性都是异步产生，这称为”异步遍历器“（Async Iterator）。 异步遍历的接口异步遍历器的最大的语法特点，就是调用遍历器的next方法，返回的是一个 Promise 对象。 12345asyncIterator .next() .then( (&#123;value, done&#125;) =&gt; /*...*/ ); 上面代码中， asyncIterator 是一个异步遍历器，调用next方法以后，返回一 个 Promise 对象。因此，可以使用then方法指定，这个 Promise 对象的状态变为resolve以后的回调函数。回调函数的参数，则是一个具有value和done两个属性的对象，这个跟同步遍历器是一样的。 我们知道，一个对象的同步遍历器的接口，部署在Symbol.iterator属性上面。 同样地，对象的异步遍历器接口，部署在Symbol.asyncIterator属性上面。不 管是什么样的对象，只要它的Symbol.asyncIterator属性有值，就表示应该对 它进行异步遍历。 1234567891011121314151617const asyncIterable = createAsyncIterable(['a', 'b']);const asyncIterator = asyncIterable[Symbol.asyncIterator]();asyncIterator .next() .then(iterResult1 =&gt; &#123; console.log(iterResult1); // &#123; value: 'a', done: false &#125; return asyncIterator.next(); &#125;) .then(iterResult2 =&gt; &#123; console.log(iterResult2); return asyncIterator.next(); // &#123; value: 'b', done: false &#125; &#125;) .then(iterResult3 =&gt; &#123; console.log(iterResult3); return asyncIterator.next(); // &#123; value: undefined, done: true &#125; &#125;); 由于异步遍历器的next方法，返回的是一个 Promise 对象。因此，可以把它放在await命令后面。 12345678910async function f() &#123; const asyncIterable = createAsyncIterable(['a', 'b']); const asyncIterator = asyncIterable[Symbol.asyncIterator](); console.log(await asyncIterator.next()); // &#123; value: 'a', done: false &#125; console.log(await asyncIterator.next()); // &#123; value: 'b', done: false &#125; console.log(await asyncIterator.next()); // &#123; value: undefined, done: true &#125;&#125; 注意，异步遍历器的 next 方法是可以连续调用的，不必等到上一步产生的 Promise对象 resolve以后再调用。这种情况下，next方法会累积起来，自动按照每一步的顺序运行下去。下面是一个例子，把所有的next方法放在Promise.all方法里面。 123456const asyncGenObj = createAsyncIterable(['a', 'b']);const [&#123;value: v1&#125;, &#123;value: v2&#125;] = await Promise.all([ asyncGenObj.next(), asyncGenObj.next()]);console.log(v1, v2); // a b 另一种用法是一次性调用所有的next方法，然后await最后一步操作： 1234const writer = openFile('someFile.txt');writer.next('hello');writer.next('world');await writer.return(); for await…of前面介绍过，for…of循环用于遍历同步的 Iterator 接口。新引入的for await…of循环，则是用于遍历异步的 Iterator 接口。 1234567async function f() &#123; for await (const x of createAsyncIterable(['a', 'b'])) &#123; console.log(x); &#125;&#125;// a// b 上面代码中，createAsyncIterable()返回一个异步遍历器，for…of循环 自动调用这个遍历器的next方法，会得到一个Promise对象。await用来处理这个Promise对象，一旦resolve ，就把得到的值（x）传入for…of的循环体。 for await...of循环的一个用途，是部署了 asyncIterable 操作的异步接口，可 以直接放入这个循环。 1234567let body = '';async function f() &#123; for await (const data of req) body += data; const parsed = JSON.parse(body); console.log('got', parsed);&#125; 如果next方法返回的 Promise 对象被reject，for await...of就会报错，要用try…catch 捕捉。 123456789async function () &#123; try &#123; for await (const x of createRejectingIterable()) &#123; console.log(x); &#125; &#125; catch (e) &#123; console.error(e); &#125;&#125; 注意，for await...of循环也可以用于同步遍历器: 1234567(async function() &#123; for await (const x of ['a', 'b']) &#123; console.log(x); &#125;&#125;)();// a// b 异步Generator函数就像 Generator 函数返回一个同步遍历器对象一样，异步 Generator 函数的作用， 是返回一个异步遍历器对象。 在语法上，异步 Generator 函数就是async函数与 Generator 函数的结合。 123456async function* gen() &#123; yield 'hello';&#125;const genObj = gen();genObj.next().then(x =&gt; console.log(x));// &#123; value: 'hello', done: false &#125; 上面代码中，gen是一个异步 Generator 函数，执行后返回一个异步 Iterator 对 象。对该对象调用next方法，返回一个 Promise 对象。 异步遍历器的设计目的之一，就是 Generator 函数处理同步操作和异步操作时，能 够使用同一套接口。 12345678910111213141516171819// 同步Generator函数function* map(iterable, func) &#123; const iter = iterable[Symbol.iterator](); while (true) &#123; const &#123;value, done&#125; = iter.next(); if (done) break; yield func(value); &#125;&#125;// 异步Generator函数async function* map(iterable, func) &#123; const iter = iterable[Symbol.asyncIterator](); while (true) &#123; const &#123;value, done&#125; = await iter.next(); if (done) break; yield func(value); &#125;&#125; 下面是另一个异步 Generator 函数的例子： 1234567891011async function* readLines(path) &#123; let file = await fileOpen(path); try &#123; while (!file.EOF) &#123; yield await file.ReadLine(); &#125; &#125; finally &#123; await file.close(); &#125;&#125; 上面代码中，异步操作前面使用await关键字标明，即await后面的操作，应该返回 Promise 对象。凡是使用yield关键字的地方，就是next方法的停下来 的地方，它后面的表达式的值（即await file.readLine() 的值），会作为next()返回对象的value属性，这一点是与同步 Generator 函数一致的。 异步 Generator 函数内部，能够同时使用await和yield命令。可以这样理 解，await命令用于将外部操作产生的值输入函数内部，yield命令用于将函数内部的值输出。 12345(async function() &#123; for await (const line of readLines(filePath)) &#123; console.log(line); &#125;&#125;)(); 异步 Generator 函数可以与for await...of循环结合起来使用: 12345async function* prefixLines(asyncIterable) &#123; for await (const line of asyncIterable) &#123; yield '&gt; ' + line; &#125;&#125; 异步 Generator 函数的返回值是一个异步 Iterator，即每次调用它的next方法， 会返回一个 Promise 对象，也就是说，跟在yield命令后面的，应该是一个 Promise 对象。 1234567891011async function* asyncGenerator() &#123; console.log('start'); const result = await doSomethingAsync(); // (A) yield 'Result: ' + result; //(B) console.log('Done');&#125;const ag = asyncIterator();ag.next().then(&#123;value, done&#125; =&gt; &#123; // ...&#125;) 上面代码中，ag是asyncGenerator函数返回的异步 Iterator 对象。调用ag.next()以后，asyncGenerator函数内部的执行顺序如下： 打印出start await命令返回一个 Promise 对象，但是程序不会停在这里，继续往下执行 程序在 B 处暂停执行，yield命令立刻返回一个 Promise 对象，该对象就是ag.next()的返回值 A 处await命令后面的那个 Promise 对象 resolved，产生的值放入result变量 B 处的 Promise 对象 resolved，then方法指定的回调函数开始执行，该函数的参数是一个对象，value的值是表达式&#39;Result： &#39; + result 的值， done 属性的值是false 如果异步 Generator 函数抛出错误，会被 Promise 对象reject，然后抛出的错误被catch方法捕获。 1234567async function* asyncGenerator() &#123; throw new Error('problem!');&#125;asyncIterator() .next() .catch(err =&gt; console.log(err)); // Error: problem! 注意，普通的async函数返回的是一个 Promise 对象，而异步 Generator 函数返回的是一个异步 Iterator 对象。可以这样理解，async 函数和异步 Generator 函数，是封装异步操作的两种方法，都用来达到同一种目的。区别在于，前者自带执行器，后者通过for await…of执行，或者自己编写执行器。下面就是一个异 步 Generator 函数的执行器。 12345678910async function takeAsync(asyncIterable, count = Infinity) &#123; const result = []; const iterator = asyncIterable[Symbol.asyncIterator](); while (result.length &lt; count) &#123; const &#123;value, done&#125; = await iterator.next(); if (done) break; result.push(value); &#125; return result;&#125; 上面代码中，异步 Generator 函数产生的异步遍历器，会通过while循环自动执 行，每当await iterator.next()完成，就会进入下一轮循环。一旦done属性变为true，就会跳出循环，异步遍历器执行结束。 12345678910111213async function f() &#123; async function* gen() &#123; yield 'a'; yield 'b'; yield 'c'; &#125; return await takeAsync(gen());&#125;f().then(function(result) &#123; console.log(result); // ['a', 'b', 'c']&#125;); 异步 Generator 函数出现以后，JavaScript 就有了四种函数形式：普通函数、 async 函数、Generator 函数和异步 Generator 函数。请注意区分每种函数的不同之处。基本上，如果是一系列按照顺序执行的异步操作（比如读取文件，然后写入 新内容，再存入硬盘），可以使用 async 函数；如果是一系列产生相同数据结构的异步操作（比如一行一行读取文件），可以使用异步 Generator 函数。 异步 Generator 函数也可以通过next方法的参数，接收外部传入的数据。 1234const write = openFile('someFile.txt');write.next('hello'); // 立即执行writer.next('world'); // 立即执行await writer.return(); // 等待写入结束 上面代码中，openFile是一个异步 Generator 函数。next方法的参数，向该函数内部的操作传入数据。每次next方法都是同步执行的，最后的 await 命令 用于等待整个写入操作结束。 最后，同步的数据结构，也可以使用异步 Generator 函数： 12345async function* createAsyncIterable(syncIterable) &#123; for (const elem of syncIterable) &#123; yield elem; &#125;&#125; yield*语句yield*语句也可以跟一个异步遍历器: 12345678910async function* gen1() &#123; yield 'a'; yield 'b'; return 2;&#125;async function* gen2() &#123; // result 最终会等于2 const result = yield* gen1();&#125; 与同步 Generator 函数一样，for await…of循环会展开yield*： 1234567(asyncGenObj function() &#123; for await (const x of gen2()) &#123; console.log(x); &#125;&#125;)();// a// b Class的基本语法简介ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。 基本上，ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。 1234567891011// 定义类class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125; 上面代码定义了一个“类”，可以看到里面有一个constructor方法，这就是构造 方法，而this关键字则代表实例对象。 Point 类除了构造方法，还定义了一个toString方法。注意，定义“类”的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以 了。另外，方法之间不需要逗号分隔，加了会报错。 类的数据类型就是函数，类本身就指向构造函数。 构造函数的 prototype 属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的 prototype 属性上面。在类的实例上面调用方法，其实就是调用原型上的方法。 由于类的方法都定义在 prototype 对象上面，所以类的新方法可以添加在 prototype 对象上面。Object.assign方法可以很方便地一次向类添加多个方法。 另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。 类的属性名，可以采用表达式： 1234567891011let methodName = 'getArea';class Square &#123; constructor(length) &#123; // ... &#125; [methodName]() &#123; // ... &#125;&#125; 严格模式类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。 考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式。 constructor方法constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。 constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。 12345678class Foo &#123; constructor() &#123; return objectEntries.create(null); &#125;&#125;new Foo() instanceof Foo// false 类必须使用new调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。 类的实例对象生成类的实例对象的写法，与 ES5 完全一样，也是使用new命令。前面说过，如果忘记加上new，像函数那样调用Class ，将会报错。 与 ES5 一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。 1234567891011121314151617181920// 定义类class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125;var point = new Point(2, 3);point.toString(); // (2, 3)point.hasOwnProperty('x'); // truepoint.hasOwnProperty('y'); // truepoint.hasOwnProperty('toString'); // falsepoint._proto_.hasOwnProperty('toString'); // true 上面代码中，x和y都是实例对象point自身的属性（因为定义在this变量 上），所以hasOwnProperty 方法返回 true ，而 toString 是原型对象的属性 （因为定义在 Point 类上），所以 hasOwnProperty 方法返回 false 。这些都与 ES5 的行为保持一致。 与 ES5 一样，类的所有实例共享一个原型对象。 12345var p1 = new Point(2, 3);var p2 = new Point(3, 3);p1._proto_ === p2._proto_// true 这也意味着，可以通过实例的_proto_属性为“类”添加方法。 _proto_并不是语言本身的特性，这是各大厂商具体实现时添加的私有属 性，虽然目前很多现代浏览器的JS引擎中都提供了这个私有属性，但依旧不建 议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用Object.getPrototypeOf方法来获取实例对象的原型，然后再来为原型添加方法/属性。 123456789101112var p1 = new Point(2, 3);var p2 = new Point(3, 2);p1._proto_.printName = function () &#123; return 'Oops'&#125;;p1.printName(); // Oopsp2.printName(); // Oopsvar p3 = new Point(4, 2);p3.printName(); // Oops Class表达式与函数一样，类也可以使用表达式的形式定义： 12345const MyClass = class Me&#123; getClassName() &#123; return Me.name; &#125;&#125;; 上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是MyClass而不是Me，Me 只在 Class 的内部代码可用，指代当前类。 123let inst = new MyClass();inst.getClassName(); // MeMe.name // // ReferenceError: Me is not defined 如果类的内部没用到的话，可以省略Me，也就是可以写成下面的形式: 123const MyClass = class &#123; /* ... */&#125;; 采用 Class 表达式，可以写出立即执行的 Class： 1234567891011let person = new class &#123; constructor(name) &#123; this.name = name; &#125; sayName() &#123; console.log(this.name); &#125;&#125;('张三');person.sayName(); // 张三 不存在变量提升类不存在变量提升（hoist），这一点与 ES5 完全不同。 ES6 不会把类的声 明提升到代码头部。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。 私有方法私有方法是常见需求，但 ES6 不提供，只能通过变通方法模拟实现。 一种做法是在命名上加以区别： 1234567891011121314class Widget &#123; // 公有方法 foo(baz) &#123; this._baz(baz); &#125; // 私有方法 _baz(baz) &#123; return this.snaf = baz; &#125; // ...&#125; 这种命名是不保险的，在类的外部，还是可以调用到这个方法。 另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的。 1234567891011class Widget &#123; foo (baz) &#123; bar.call(this, baz); &#125; // ...&#125;function bar(baz) &#123; return this.snaf = baz;&#125; 还有一种方法是利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值。 1234567891011121314export default class myClass&#123; // 公有方法 foo(baz) &#123; this[bar](baz); &#125; // 私有方法 [bar](baz) &#123; return this[snaf] = baz; &#125; // ...&#125; 上面代码中，bar 和 snaf 都是 Symbol值，导致第三方无法获取到它们，因此达到了私有方法和私有属性的效果。 私有属性与私有方法一样，ES6 不支持私有属性。目前，有一个提案，为class加了私有属性。方法是在属性名之前，使用#表示。 1234567891011class Point &#123; #x; constructor(x = 0) &#123; #x = +x; // 写成 this.#x 亦可 &#125; get x() &#123; return #x &#125; set x(value) &#123; #x = +value &#125;&#125; 上面代码中，#x就表示私有属性x，在Point类之外是读取不到这个属性的。还可以看到，私有属性与实例的属性是可以同名的（比如，#x 与 get x() ）。 私有属性可以指定初始值，在构造函数执行时进行初始化： 123456class Point &#123; #x = 0; constructor() &#123; #x; // 0 &#125;&#125; 之所以要引入一个新的前缀#表示私有属性，而没有采用private关键字，是因为 JavaScript 是一门动态语言，使用独立的符号似乎是唯一的可靠方法，能够准 确地区分一种属性是否为私有属性。另外，Ruby 语言使用@表示私有属性，ES6 没有用这个符号而使用# ，是因为@已经被留给了 Decorator。 该提案只规定了私有属性的写法。但是，很自然地，它也可以用来写私有方法。 this的指向类的方法内部如果含有this ，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。 12345678910111213class Logger &#123; printName(name = 'there') &#123; this.print(`hello $&#123;name&#125;`); &#125; print(text) &#123; console.log(text); &#125;&#125;const logger = new Logger();const &#123; printName &#125; = logger;printName(); // TypeError: Cannot read property 'print' of undefined 上面代码中，printName方法中的this，默认指向 Logger 类的实例。但是， 如果将这个方法提取出来单独使用，this会指向该方法运行时所在的环境。 一个比较简单的解决方法是，在构造方法中绑定this，这样就不会找不到print方法了。 1234567class Logger &#123; constructor() &#123; this.printName = this.printName.bind(this); &#125; // ...&#125; 另一种解决方法是使用箭头函数。 123456789class Logger &#123; constructor() &#123; this.printName = (name = 'there') =&gt; &#123; this.print(`hello $&#123;name&#125;`); &#125;; &#125; // ...&#125; 还有一种解决方法是使用Proxy，获取方法的时候，自动绑定this。 12345678910111213141516171819function selfish(target) &#123; const cache = new WeakMap(); const handler = &#123; get (target, key) &#123; const value = Reflect.get(target, key); if (typeof value !== 'function') &#123; return value; &#125; if (!cache.has(value)) &#123; cache.set(value, value.bind(target)); &#125; return cache.get(value); &#125; &#125;; const proxy = new Proxy(target, handler); return proxy;&#125;const logger = selfish(new Logger()); name属性由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被 Class 继承，包括name属性。 name属性总是返回紧跟在class关键字后面的类名。 Class的取值函数（getter）和存值函数（setter）与 ES5 一样，在“类”的内部可以使用get 和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。 12345678910111213141516171819class MyClass &#123; constructor() &#123; // ... &#125; get prop() &#123; return 'getter'; &#125; set prop(value) &#123; console.log('setter: ' + value); &#125;&#125;let inst = new MyClass();inst.prop = 123;// setter: 123inst.prop// 'getter' 存值函数和取值函数是设置在属性的 Descriptor 对象上的。 1234567891011121314151617181920class CustomHTMLElement &#123; constructor(element) &#123; this.element = element; &#125; get html() &#123; return this.element.innerHTML; &#125; set html(value) &#123; this.element.innerHTML = value; &#125;&#125;var descriptor = Object.getOwnPropertyDescriptor( CustomHTMLElement.prototype, 'html');'get' in descriptor // true'set' in descriptor // true Class的Generator方法如果某个方法之前加上星号（*），就表示该方法是一个 Generator 函数。 1234567891011121314151617class Foo &#123; constructor(...args) &#123; this.args = args; &#125; * [Symbol.iterator]() &#123; for (let arg of this.args) &#123; yield arg; &#125; &#125;&#125;for (let x of new Foo('hello', 'world')) &#123; console.log(x);&#125;// hello// world 上面代码中，Foo类的Symbol.iterator方法前有一个星号，表示该方法是一 个 Generator 函数。Symbol.iterator方法返回一个Foo类的默认遍历器，for…of循环会自动调用这个遍历器。 Class的静态方法类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法 前，加上static 关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。 1234567891011class Foo &#123; static classMethod() &#123; return 'hello'; &#125;&#125;Foo.classMethod(); // hellovar foo = new Foo();foo.classMethod();// TypeError: foo.classMethod is not a function 注意，如果静态方法包含this关键字，这个this指的是类，而不是实例。 12345678910111213class Foo &#123; static bar () &#123; this.baz(); &#125; static baz () &#123; console.log('hello'); &#125; baz () &#123; console.log('world'); &#125;&#125;Foo.bar(); // hello 从这个例子还可以看出，静态方法可以与非静态方法重名。 父类的静态方法，可以被子类继承。 1234567891011class Foo &#123; static classMethod() &#123; return 'hello'; &#125;&#125;class Bar extends Foo&#123;&#125;Bar.classMethod(); // hello 上面代码中，父类Foo有一个静态方法，子类Bar可以调用这个方法。 静态方法也是可以从super对象上调用的。 12345678910111213class Foo &#123; static classMethod() &#123; return 'hello'; &#125;&#125;class Bar extends Foo&#123; static classMethod() &#123; return super.classMethod() + ', too'; &#125;&#125;Bar.classMethod(); // hello, too Class的静态属性和实例属性静态属性指的是 Class 本身的属性，即Class.propName ，而不是定义在实例对象（this）上的属性。 123456class Foo &#123;&#125;Foo.prop = 1;Foo.prop // 1 目前，只有这种写法可行，因为 ES6 明确规定，Class 内部只有静态方法，没有静 态属性。 目前有一个静态属性的提案，对实例属性和静态属性都规定了新的写法。 类的实例属性 类的实例属性可以用等式，写入类的定义之中。 1234567class MyClass &#123; myProp = 42; constructor() &#123; console.log(this.prop); // 42 &#125;&#125; 上面代码中， myProp就是MyClass的实例属性。在MyClass的实例上，可以读取这个属性。 以前，我们定义实例属性，只能写在类的constructor方法里面。 12345678class ReactCounter extends React.component&#123; constructor(props) &#123; super(props); this.state = &#123; count: 0 &#125;; &#125;&#125; 上面代码中，构造方法constructor里面，定义了this.state属性。 有了新的写法以后，可以不在constructor方法里面定义。 12345class ReactCounter extends React.Component&#123; state = &#123; count: 0 &#125;;&#125; 类的静态属性 类的静态属性只要在上面的实例属性写法前面，加上static关键字就可以了。 1234567class MyClass &#123; static myStaticProp = 42; constructor() &#123; console.log(MyClass.myStaticProp); // 42 &#125;&#125; new.target属性 new是从构造函数生成实例的命令。ES6 为new 命令引入了一个new.target 属性，该属性一般用在构造函数之中，返回 new命令作用于的那个构造函数。如果构造函数不是通过new命令调用的，new.target 会返回 undefined ，因此这个属性可以用来确定构造函数是怎么调用的。 12345678910111213141516171819function Person(name) &#123; if (new.target !== undefined) &#123; this.name = name; &#125; else &#123; throw new Error('必须使用new生成实例'); &#125;&#125;// 另一种写法function Person(name) &#123; if (new.target === Person) &#123; this.name = name; &#125; else &#123; throw new Error('必须使用new生成实例'); &#125;&#125;var person = new Person('张三');var notAPerson = person.call(person, '张三'); // 报错 上面代码确保构造函数只能通过new命令调用。 Class 内部调用 new.target ，返回当前 Class。 需要注意的是，子类继承父类时，new.target会返回子类。利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。 1234567891011121314151617class Shape &#123; constructor() &#123; if (new.target === Shape) &#123; throw new Error('本类不能实例化'); &#125; &#125;&#125;class Rectangle extends Shape&#123; constructor(length, width) &#123; super(); // ... &#125;&#125;var x = new Shape(); // 报错var y = new Rectangle(3, 4); // 正确 Class的继承简介Class可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。 1234567class Point &#123;&#125;class ColorPoint extends Point&#123;&#125; 上面代码定义了一个ColorPoint 类，该类通过 extends 关键字，继承了 Point 类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全 一样，等于复制了一个 Point 类。下面，我们在 ColorPoint 内部加上代码。 12345678910class ColorPoint extends Point&#123; constructor(x, y, color) &#123; super(x, y); // 调用父类的constructor(x, y) this.color = color; &#125; toString() &#123; return this.color + ' ' + super.toString(); // 调用父类的toString() &#125;&#125; 上面代码中，constructor方法和toString方法之中，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。 子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的 this 对象，而是继承父类的 this 对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。 1234567891011class Point &#123; /* ... */&#125;class ColorPoint extends Point&#123; constructor() &#123; &#125;&#125;let cp = new ColorPoint(); // ReferenceError ES5的继承，实质是先创造子类的实例对象this ，然后再将父类的方法添加到 this 上面（ Parent.apply(this) ）。ES6 的继承机制完全不同，实质是先创造父类的实例对象this （所以必须先调用super方法），然后再用子类的构造函数修改 this 。 如果子类没有定义 constructor 方法，这个方法会被默认添加。也就是说，不管有没有显式定义，任何一个子类都有constructor 方法。 另一个需要注意的地方是，在子类的构造函数中，只有调用 super 之后，才可以使用 this 关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有 super 方法才能返回父类实例。 1234567891011121314class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125;&#125;class ColorPoint extends Point&#123; constructor(x, y, color) &#123; this.color = color; // ReferenceError super(x, y); this.color = color; // 正确 &#125;&#125; 1234let cp = new ColorPoint(25, 8, 'green');cp instanceof ColorPoint // truecp instanceof Point // true 实例对象cp同时是ColorPoint和Point两个类的实例，这与ES5的行为完全一致。 Object.getPrototypeOf()Object.getPrototypeOf()方法可以用来从子类上获取父类。 12Object.getPrototypeOf(ColorPoint) === Point// true 因此，可以使用这个方法判断，一个类是否继承了另一个类。 super关键字super这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。 第一种情况，super 作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次 super 函数。 123456789class A &#123;&#125;class B extends A&#123; constructor() &#123; super(); &#125;&#125; 注意， super 虽然代表了父类 A的构造函数，但是返回的是子类B 的实例，即super 内部的 this 指的是 B ，因此super() 在这里相当于A.prototype.constructor.call(this) 。 1234567891011121314class A &#123; constructor() &#123; console.log(new.target.name); // new.target 指向当前正在执行的函数 &#125;&#125;class B extends A &#123; constructor() &#123; super(); &#125;&#125;new A() // Anew B() // B 作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错。 123456789class A &#123;&#125;class B extends A &#123; m() &#123; super(); // 报错 &#125;&#125; 第二种情况， super 作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。 1234567891011121314class A &#123; p() &#123; return 2; &#125;&#125;class B extends A &#123; constructor() &#123; super(); console.log(super.p()); // 2 &#125;&#125;let b = new B(); 上面代码中，子类 B 当中的 super.p() ，就是将super 当作一个对象使用。这时， super 在普通方法之中，指向 A.prototype，所以super.p() 就相当于A.prototype.p()。 这里需要注意，由于 super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。如果属性定义在父类的原型对象上， super 就可以取到。 ES6 规定，通过super调用父类的方法时，super会绑定子类的this： 1234567891011121314151617181920212223class A &#123; constructor() &#123; this.x = 1; &#125; print() &#123; console.log(this.x); &#125;&#125;class B extends A &#123; constructor() &#123; super(); this.x = 2; &#125; m() &#123; super.print(); &#125;&#125;let b = new B();b.m(); // 2 上面代码中， super.print() 虽然调用的是 A.prototype.print()，但是 A.prototype.print() 会绑定子类 B 的 this ，导致输出的是 2，而不是1。。也就是说，实际上执行的是super.print.call(this)。 由于绑定子类的 this ，所以如果通过 super 对某个属性赋值，这时super就是 this ，赋值的属性会变成子类实例的属性: 1234567891011121314151617class A &#123; constructor() &#123; this.x = 1; &#125;&#125;class B extends A &#123; constructor() &#123; super(); this.x = 2; super.x = 3; console.log(super.x); // undefined console.log(this.x); // 3 &#125;&#125;let b = new B(); 如果super 作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象。 123456789101112131415161718192021222324class Parent &#123; static myMethod(msg) &#123; console.log('static', msg); &#125; myMethod(msg) &#123; console.log('instance', msg); &#125;&#125;class Child extends Parent&#123; static myMethod(msg) &#123; super.myMethod(msg); &#125; myMethod(msg) &#123; super.myMethod(msg); &#125;&#125;Child.myMethod(1); // static 1var child = new Child();child.myMethod(2); // instance 2 super在静态方法之中指向父类，在普通方法之中指向父类的原型对象。 注意，使用 super的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。 12345678910class A &#123;&#125;class B extends A&#123; constructor() &#123; super(); console.log(super); // 报错 &#125;&#125; 最后，由于对象总是继承其他对象的，所以可以在任意一个对象中，使用super关键字。 1234567var obj = &#123; toString() &#123; return 'MyObject: ' + super.toString(); &#125;&#125;;obj.toString(); // MyObject: [object Object] 类的prototype属性和__proto__属性在默认情况下。所有原型对象都会自动获得一个constructor（构造函数）属性。这个属性包含一个指向prototype属性所在函数的指针。比如，之前的例子中，Person.prototype.constructor指向Person。通过这个构造函数还可以继续为原型对象添加其他属性和方法。创建自定义的构造函数之后，其原型对象默认只会取得constructor属性；至于其他方法，则都是从Object继承而来。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。ECMA-262第五版中管这个指针叫[[prototype]]。虽然在脚本中没有标准的方式访问[[prototype]]，但Firefox、Safari和Chrome在每个对象上都支持一个属性_proto_；而在其他实现中，这个属性对脚本是完全不可见的。不过，最重要的是，这个连接存在于实例与构造函数的原型对象之间，而不是存在与实例与构造函数之间。 大多数浏览器的 ES5 实现之中，每一个对象都有 __proto__ 属性，指向对应的构造函数的 prototype 属性。Class 作为构造函数的语法糖，同时有 prototype 属性和 __proto__ 属性，因此同时存在两条继承链。 子类的__proto__属性，表示构造函数的继承，总是指向父类。 子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。 12345678910class A &#123;&#125;class B extends A &#123;&#125;B._proto_ === A // trueB.prototype._protp_ === A.prototype // true 这样的结果是因为，类的继承是按照下面的模式实现的： 123456789101112131415class A &#123;&#125;class B &#123;&#125;// B 的实例继承 A 的实例Object.setPrototypeOf(B.prototype, A.prototype);// B 的实例继承 A 的静态属性Object.setPrototypeOf(B, A);const b = new B(); 《对象的扩展》一章给出过Object.setPrototypeOf方法的实现： 1234Object.setPrototypeOf = function (obj, proto) &#123; obj._proto_ = proto; return obj;&#125;; 因此，就得到了上面的结果： 1234567Object.setPrototypeOf(B.prototype, A.prototype);// 等同于B.prototype._proto_ = A.prototype;Object.setPrototypeOf(B, A);// 等同于B._proto_ = A; 这两条继承链，可以这样理解：作为一个对象，子类（ B ）的原型（ __proto__ 属性）是父类（A ）；作为一个构造函数，子类（ B ）的原型对象（ prototype 属性）是父类的原型对象（ prototype 属性）的实例。 extends的继承目标extends关键字后面可以跟多种类型的值。 123class B extends A &#123;&#125; 上面代码的A，只要是一个有prototype属性的函数，就能被B继承。由于函数都有prototype属性（除了Function.prototype函数），因此A可以是任意函数。 下面，讨论三种特殊情况。 第一种特殊情况，子类继承Object类。 123456class A extends Object &#123;&#125;A._proto_ === Object // trueA.prototype._proto_ === Object.prototype // true 这种情况下， A其实就是构造函数object的复制，A的实例就是object的实例。 第二种特殊情况，不存在任何继承。 123456class A &#123;&#125;A._proto_ === Function.prototype // trueA.prototype._proto_ === Object.prototype // true 这种情况下， A 作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承Function.prototype 。但是， A 调用后返回一个空对象（即 Object 实例），所以 A.prototype.__proto__ 指向构造函数 ( object ) 的prototype属性。 第三种特殊情况，子类继承null。 123456class A extends null&#123;&#125;A._proto_ === Function.prototype // trueA.prototype._proto_ === undefined // true 这种情况与第二种情况非常像。 A 也是一个普通函数，所以直接继承 Function.prototype 。但是， A 调用后返回的对象不继承任何方法，所以它的 __proto__ 指向 Function.prototype ，即实质上执行了下面的代码: 12345class C extends null&#123; constructor() &#123; return Object.create(null); &#125;&#125; 实例的__proto__属性子类实例的__proto__属性的__proto__属性，指向父类实例的__proto__属性。也就是说，子类的原型的原型，是父类的原型。 12345var p1 = new Point(2, 3);var p2 = new ColorPoint(2, 3, 'red');p2._proto_ === p1._proto_ // falsep2._proto_._proto_ === p1._proto_ // true 因此，通过子类实例的_proto_._proto_属性，可以修改父类实例的行为。 原生构造函数的继承原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript 的 原生构造函数大致有下面这些: Boolean() Number() String() Array() Date() Function() RegExp() Error() Object() 以前，这些原生构造函数是无法继承的。之所以会发生这种情况，是因为子类无法获得原生构造函数的内部属性。原生构造函数会忽略 apply 方 法传入的 this ，也就是说，原生构造函数的 this 无法绑定，导致拿不到内部 属性。 ES5 是先新建子类的实例对象this ，再将父类的属性添加到子类上，由于父类的 内部属性无法获取，导致无法继承原生的构造函数。比如， Array 构造函数有一 个内部属性[[DefineOwnProperty]] ，用来定义新属性时，更新 length 属 性，这个内部属性无法在子类获取，导致子类的 length 属性行为不正常。 ES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象 this ，然后再用子类的构造函数修饰 this ，使得父类的所有行为都可以继承： 123456789101112class MyArray extends Array &#123; constructor(...args) &#123; super(...args); &#125;&#125;var arr = new MyArray();arr[0] = 12;arr.length // 1arr.length = 0;arr[0] // undefined 上面这个例子也说明， extends 关键字不仅可以用来继承类，还可以用来继承原 生的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构。下面就 是定义了一个带版本功能的数组： 12345678910111213141516171819202122232425262728293031class VersionedArray extends Array &#123; constructor() &#123; super(); this.history = [[]]; &#125; commit() &#123; this.history.push(this.slice()); &#125; revert() &#123; this.splice(0, this.length, ...this.history[this.history.length - 1]); &#125;&#125;var x = new VersionedArray();x.push(1);x.push(2);x // [1, 2]x.history // [[]]x.commit();x.history // [[], [1, 2]]x.push(3);x // [1, 2, 3]x.history // [[], [1, 2]]x.revert();x // [1, 2] 下面是一个自定义Error子类的例子，可以用来定制报错时的行为： 1234567891011121314151617181920212223class ExtendableError extends Error &#123; constructor(message) &#123; super(); this.message = message; this.stack = (new Error()).stack; this.name = this.constructor.name; &#125;&#125;class MyError extends ExtendableError &#123; constructor(m) &#123; super(m); &#125;&#125;var myerror = new MyError('11');myerror.message // 11myerror instanceof Error // truemyerror.name // MyErrormyerror.stack// Error// at MyError.ExtendableError// ... 注意，继承Object的子类，有一个行为差异。 12345678class NewObj extends Object &#123; constructor() &#123; super(...arguments); &#125;&#125;var o = new NewObj(&#123;attr: true&#125;);o.attr === true // false 上面代码中， NewObj 继承了 Object ，但是无法通过 super 方法向父类 Object 传参。这是因为 ES6 改变了 Object 构造函数的行为，一旦发现 Object 方法不是通过 new Object() 这种形式调用，ES6 规定 Object构造函数会忽略参数。 Mixin模式的实现Mixin 模式指的是，将多个类的接口“混入”（mix in）另一个类。它在 ES6 的实现如下： 123456789101112131415161718192021function mix(...mixins) &#123; class Mix &#123;&#125; for (let mixin of mixins) &#123; copyProperties(Mix, mixin); copyProperties(Mix.prototype, mixin.prototype); &#125; return Mix;&#125;function copyProperties (target, source) &#123; for (let key of Reflect.ownKeys(source)) &#123; if (key !== 'constructor' &amp;&amp; key !== 'prototype' &amp;&amp; key !== 'name' ) &#123; let desc = Object.getOwnPropertyDescriptor(source, key); Object.defineProperty(target, key, desc); &#125; &#125;&#125; 上面代码的mix 函数，可以将多个对象合成为一个类。使用的时候，只要继承这个类即可。 123class DistributedEdit extends mix(loggable, Serializable) &#123; // ...&#125; 修饰器类的修饰许多面向对象的语言都有修饰器（Decorator）函数，用来修改类的行为。目前，有 一个提案将这项功能，引入了 ECMAScript。 12345678910@testableclass MyTestableClass &#123; // ...&#125;function testable(target) &#123; target.isTestable = true;&#125;MyTestableClass.isTestable // true 上面代码中， @testable 就是一个修饰器。它修改了 MyTestableClass这个类的行为，为它加上了静态属性 isTestable 。 testable 函数的参数target是MyTestableClass类本身。 基本上，修饰器的行为就是下面这样： 1234567891011@decoratorclass A &#123;&#125;// 等同于class A &#123;&#125;A = decorator(A) || A; 也就是说，修饰器是一个对类进行处理的函数。修饰器函数的第一个参数，就是所 要修饰的目标类。 如果觉得一个参数不够用，可以在修饰器外面再封装一层函数： 12345678910111213function testable(isTestable) &#123; return function (target) &#123; target.isTestable = isTestable; &#125;&#125;@testable(true)class MyTestableClass &#123;&#125;MyTestableClass.isTestable // true@testable(false)class MyClass &#123;&#125;MyClass.isTestable // false 上面代码中，修饰器 testable 可以接受参数，这就等于可以修改修饰器的行为。 注意，修饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味 着，修饰器能在编译阶段运行代码。也就是说，修饰器本质就是编译时执行的函数。 前面的例子是为类添加一个静态属性，如果想添加实例属性，可以通过目标类的 prototype 对象操作。 123456789function testable(target) &#123; target.prototype.isTestable = true;&#125;@testableclass MyTestableClass &#123;&#125;let obj = new MyTestableClass();obj.isTestable // true 123456789101112131415161718192021// mixins.jsexport function mixins(...list) &#123; return function (target) &#123; Object.assign(target.prototype, ...list); &#125;&#125;// main.jsimport &#123; minxins &#125; from './mixins'const Foo = &#123; foo() &#123; console.log('foo'); &#125;&#125;;@mixins(Foo)class MyClass &#123;&#125;let obj = new MyClass();obj.foo() // foo 方法的修饰修饰器不仅可以修饰类，还可以修饰类的属性。 123456class Person &#123; @readonly name() &#123; return `$&#123;this.first&#125; $&#123;this.last&#125;` &#125;&#125; 此时，修饰器函数一共可以接受三个参数，第一个参数是所要修饰的目标对象，即 类的实例（这不同于类的修饰，那种情况时 target 参数指的是类本身）；第二个 参数是所要修饰的属性名，第三个参数是该属性的描述对象。 123456789101112131415function readonly(target, name, descriptor) &#123; // descriptor对象原来的值如下 // &#123; // value: specifiedFunction, // enumerable: false, // configurable: true, // writable: true // &#125;; descriptor.writable = false; return descriptor;&#125;readonly(Person.prototype, 'name', decorator);// 类似于Object.defineProperty(Person.prototype, 'name', descriptor); 上面代码说明，修饰器（readonly）会修改属性的描述对象（descriptor），然后被 修改的描述对象再用来定义属性。 下面是另一个例子，修改属性描述对象的enumerable属性，使得该属性不可遍历。 1234567891011class Person &#123; @nonenumerable get kidCount() &#123; return this.children.length; &#125;&#125;function nonenumerable(target, name, descriptor) &#123; descriptor.enumerable = false; return descriptor;&#125; 如果同一个方法有多个修饰器，会像剥洋葱一样，先从外到内进入，然后由内向外执行。 1234567891011121314function dec(id) &#123; console.log('evaluated', id); return (target, property, descriptor) =&gt; console.log('executed', id);&#125;class Example &#123; @dec(1) @dec(2) method() &#123;&#125;&#125;// evaluated 1// evaluated 2// executed 2// executed 1 上面代码中，外层修饰器@dec(1)先进入，但是内层修饰器@dec(2)先执行。 除了注释，修饰器还能用来类型检查。所以，对于类来说，这项功能相当有用。从 长期来看，它将是 JavaScript 代码静态分析的重要工具。 为什么修饰器不能用于函数？修饰器只能用于类和类的方法，不能用于函数，因为存在函数提升。 12345678910var counter = 0;var add = function () &#123; counter++;&#125;;@addfunction foo() &#123; &#125; 上面的代码，意图是执行后 counter 等于1，但是实际上结果是 0。因为函数提升，使得实际执行的代码是下面这样: 12345678910111213@addfunction foo() &#123;&#125;var counter;var add;counter = 0;add = function () &#123; counter++;&#125;; 总之，由于存在函数提升，使得修饰器不能用于函数。类是不会提升的，所以就没 有这方面的问题。 另一方面，如果一定要修饰函数，可以采用高阶函数的形式直接执行。 1234567891011121314function doSomething(name) &#123; console.log('hello, ' + name);&#125;function loggingDecorator(wrapped) &#123; return function () &#123; console.log('starting'); const result = wrapped.apply(this, arguments); console.log('finished'); return result; &#125;&#125;const wrapped = loggingDecorator(doSomething); core-decorators.jscore-decorators.js是一个第三方模块，提供了几个常见的修饰器，通过它可以更好 地理解修饰器。 （1）@autobind autobind 修饰器使得方法中的 this 对象，绑定原始对象。 1234567891011121314import &#123; autobind &#125; from 'core-decorators';class Person &#123; @autobind getPerson() &#123; return this; &#125;&#125;let person = new Person();let getPerson = person.getPerson();getPerson() === person;// true （2）@readonly readonly 修饰器使得属性或方法不可写。 12345678910import &#123; readonly &#125; from 'core-decorators';class Meal &#123; @readonly entree = 'streak';&#125;var dinner = new Meal();dinner.entree = 'salmon';// Cannot assign to read only property 'entree' of [object Object] （3）@override override 修饰器检查子类的方法，是否正确覆盖了父类的同名方法，如果不正确会报错。 1234567891011import &#123; override &#125; from 'core-decorators';class Parent &#123; speak(first, second) &#123;&#125;&#125;class Child extends Parent&#123; @override speak() &#123;&#125; // SyntaxError: Child#speak() does not properly override Parent#speak(first, second)&#125; （4）@deprecate (别名@deprecated) deprecate或deprecated修饰器在控制台显示一条警告，表示该方法将废除。 （5）@suppressWarnings suppressWarnings修饰器抑制 deprecated 修饰器导致的console.warn() 调用。但是，异步代码发出的调用除外。 使用修饰器实现自动发布事件我们可以使用修饰器，使得对象的方法被调用时，自动发出一个事件。 123456789101112import &#123; postal &#125; from 'postal/lib/postal.lodash'export default function publish(topic, channel) &#123; return function (target, name, decriptor) &#123; const fn = decriptor.value; decriptor.value = function () &#123; let value = fn.apply(this, arguments); postal.channel() &#125;; &#125;;&#125; 上面代码定义了一个名为publish的修饰器，它通过改写 descriptor.value使得原方法被调用时，会自动发出一个事件。它使用的事件“发布/订阅”库 是Postal.js。 它的用法如下： 1234567891011121314import &#123; publish &#125; from 'path/to/decorators/publish'class FooComponent &#123; @publish('foo.some.message', 'component') someMethod() &#123; return &#123; my: 'data' &#125;; &#125; @publish('foo.some.other') anotherMethod() &#123; // ... &#125;&#125; 以后，只要调用someMethod或者anotherMethod，就会自动发出一个事件。 Mixin在修饰器的基础上，可以实现 Mixin 模式。所谓 Mixin 模式，就是对象继承的 一种替代方案，中文译为“混入”（mix in），意为在一个对象之中混入另外一个对象的方法。 12345678910111213141516171819202122232425262728293031323334const Foo = &#123; foo() &#123;console.log('foo')&#125;&#125;;class MyClass &#123;&#125;Object.assign(MyClass.prototype, Foo);let obj = new MyClass();obj.foo() // foo/************用修饰器改写***************/export function mixins(...list) &#123; return function (target) &#123; Object.assign(target.prototype, ...list); &#125;;&#125;const Foo = &#123; foo() &#123; console.log('foo'); &#125;&#125;;@mixins(Foo)class MyClass &#123; &#125;let obj = new MyClass();obj.foo() // foo 不过，上面的方法会改写 MyClass 类的prototype对象，如果不喜欢这一点，也可以通过类的继承实现 Mixin: 123class MyClass extends MyBaseClass&#123; /*....*/&#125; 上面代码中， MyClass 继承了 MyBaseClass 。如果我们想在 MyClass 里面“混 入”一个 foo 方法，一个办法是在MyClass 和 MyBaseClass 之间插入一个混入 类，这个类具有 foo 方法，并且继承了 MyBaseClass 的所有方法，然后MyClass再继承这个类。 12345let MyMixin = (superclass) =&gt; class extends superclass &#123; foo() &#123; console.log('foo from MyMixin'); &#125;&#125;; 上面代码中，MyMixin 是一个混入类生成器，接受 superclass作为参数，然后返回一个继承superclass 的子类，该子类包含一个 foo方法。 接着，目标类再去继承这个混入类，就达到了“混入”foo方法的目的。 123456class MyClass extends MyMixin(MyBaseClass)&#123; /*...*/&#125;let c = new MyClass();c.foo(); // foo from MyMixin 如果需要“混入”多个方法，就生成多个混入类。 TraitTrait 也是一种修饰器，效果与 Mixin 类似，但是提供更多功能，比如防止同名方法 的冲突、排除混入某些方法、为混入的方法起别名等等。 下面采用traits-decorator这个第三方模块作为例子。这个模块提供的trait 修饰器，不仅可以接受对象，还可以接受 ES6 类作为参数。 123456789101112131415161718import &#123; traits &#125; from 'traits-decorator';class TFoo &#123; foo() &#123; console.log('foo') &#125;&#125;const TBar = &#123; bar() &#123; console.log('bar') &#125;&#125;;@traits(TFoo, TBar)class MyClass &#123;&#125;let obj = new MyClass();obj.foo() // fooobj.bar() // bar Trait 不允许“混入”同名方法。 12345678910111213141516import &#123; traits &#125; from 'traits-decorator';class TFoo &#123; foo() &#123; console.log('foo') &#125;&#125;const TBar = &#123; bar() &#123; console.log('bar') &#125;, foo() &#123; console.log('foo') &#125;&#125;;@traits(TFoo, TBar)class MyClass &#123;&#125;// 报错// throw new Error('Method named: ' + methodName + ' is defined twice.');// Error: Method named: foo is defined twice. 一种解决方法是排除TBar的foo方法: 1234567891011121314151617import &#123; traits &#125; from 'traits-decorator';class TFoo &#123; foo() &#123; console.log('foo') &#125;&#125;const TBar = &#123; bar() &#123; console.log('bar') &#125;, foo() &#123; console.log('foo') &#125;&#125;;@traits(TFoo, TBar::excludes('foo'))class MyClass &#123;&#125;let obj = new MyClass();obj.foo() // fooobj.bar() // bar 上面代码使用绑定运算符（::）在 TBar上排除foo方法，混入时就不会报错了。 另一种方法是为TBar的foo方法起一个别名: 123456789101112131415161718import &#123; traits &#125; from 'traits-decorator';class TFoo &#123; foo() &#123; console.log('foo') &#125;&#125;const TBar = &#123; bar() &#123; console.log('bar') &#125;, foo() &#123; console.log('foo') &#125;&#125;;@traits(TFoo, TBar::alias(&#123;foo: 'aliasFoo'&#125;))class MyClass &#123;&#125;let obj = new MyClass();obj.foo() // fooobj.aliasFoo() // fooobj.bar() // bar alias和excludes方法，可以结合起来使用: 12@traits(TExample::excludes('foo', 'bar')::alias(&#123;baz:'exampleBaz'&#125;))class MyClass &#123;&#125; 上面代码排除了TExample的foo方法和bar方法，为baz方法起了别名exampleBaz。 as方法则为上面的代码提供了另一种写法: 12@traits(TExample::as(&#123;excludes: ['foo', 'bar'], alias: &#123;baz:'exampleBaz'&#125;&#125;))class MyClass &#123;&#125; Module的语法概述历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相 依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby的 require 、Python 的import ，甚至就连 CSS 都有 @import ，但是JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障 碍。 在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两 种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功 能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。 ES6 模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以 及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。 比如，CommonJS 模块就是对象，输入时必须查找对象属性。 12345678// CommonJS模块let &#123; start, exists, readFile &#125; = require('fs');// 等同于let _fs = require('fs');let start = _fs.start;let exists = _fs.exists;let readFile = _fs.readFile; 上面代码的实质是整体加载 fs 模块（即加载 fs 的所有方法），生成一个对象 （_fs ），然后再从这个对象上面读取3个方法。这种加载称为“运行时加载”，因 为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。 ES6 模块不是对象，而是通过 export命令显式指定输出的代码，再通过 import 命令输⼊入。 1import &#123; start, exists, readFile &#125; from 'fs'; 上面代码的实质是从 fs 模块加载3个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。 由于 ES6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠 静态分析实现的功能。 除了静态加载带来的各种好处，ES6 模块还有以下好处: 不再需要 UMD 模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目 前，通过各种工具库，其实已经做到了这一点。 将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者 navigator 对象的属性。 不再需要对象作为命名空间（比如 Math 对象），未来这些功能可以通过模块 提供。 严格模式ES6 的模块自动采用严格模式，不管你有没有在模块头部加上&quot;use strict&quot;;。 严格模式主要有以下限制: 变量必须声明后再使用 函数的参数不能有同名属性，否则报错 不能使用 with 语句 不能对只读属性赋值，否则报错 不能使用前缀0表示八进制数，否则报错 不能删除不可删除的属性，否则报错 不能删除变量 delete prop ，会报错，只能删除属性delete global[prop] eval不会在它的外层作用域引入变量 eval和 arguments 不能被重新赋值 arguments不会自动反映函数参数的变化 不能使用arguments.callee 不能使用arguments.caller 禁止 this 指向全局对象 不能使用fn.caller和fn.arguments获取函数调用的堆栈 增加了保留字（比如protected、static和interface export命令模块功能主要由两个命令构成： export 和 import 。export 命令用于规定模块的对外接口， import 命令用于输入其他模块提供的功能。 一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希 望外部能够读取模块内部的某个变量，就必须使用 export 关键字输出该变量。下 面是一个 JS 文件，里面使用 export 命令输出变量。 1234// profile.jsexport var firstName = 'Michael';export var lastName = 'Jackson';export var year = 1958; export的写法，除了像上面这样，还有另外一种： 123456// profile.jsvar firstName = 'Michael';var lastName = 'Jackson';var year = 1958;export &#123;firstName, lastName, year&#125;; 应该优先考虑使用这种写法。因 为这样就可以在脚本尾部，一眼看清楚输出了哪些变量。 export命令除了输出变量，还可以输出函数或类（class）。 123export function multiply(x, y) &#123; return x * y&#125;; 通常情况下， export输出的变量就是本来的名字，但是可以使用as关键字重命名。 12345678910111213function v1() &#123; /*...*/&#125;function v2() &#123; /*...*/&#125;export &#123; v1 as streamV1, v2 as streamV2, v2 as streamLatestVersion&#125;; 需要特别注意的是，export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。 123456// 报错export 1;// 报错var m = 1;export m; 上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出1，第二 种写法通过变量 m ，还是直接输出1。 1 只是一个值，不是接口。正确的写法是 下面这样。 12345678910// 写法一export var m = 1;// 写法二var m = 1;export &#123;m&#125;;// 写法三var n = 1;export &#123;n as m&#125;; 上面三种写法都是正确的，规定了对外的接口 m 。其他脚本可以通过这个接口， 取到值 1 。它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关 系。 function和class的输出，也必须遵守这样的写法。 12345678910// 报错function f() &#123;&#125;export f;// 正确export function f() &#123;&#125;;// 正确function f() &#123;&#125;export &#123;f&#125;; 另外， export 语句输出的接口，与其对应的值是动态绑定关系，即通过该接口， 可以取到模块内部实时的值。 12export var foo = 'bar';setTimeout(() =&gt; foo = 'baz', 500); 这一点与 CommonJS 规范完全不同。CommonJS 模块输出的是值的缓存，不存在 动态更新。 最后， export 命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果 处于块级作用域内，就会报错，下一节的 import 命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了ES6模块的设计初衷。 1234function foo() &#123; export default 'bar' // SyntaxError&#125;foo() import命令使用 export 命令定义了模块的对外接口以后，其他 JS 文件就可以通 过 import 命令加载这个模块。 123456// main.jsimport &#123;firstName, lastName, year&#125; from './profile';function setName(element) &#123; element.textContent = firstName + ' ' + lastName;&#125; 如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名。 1import &#123; lastName as surName &#125; from './profile'; import后面的 from 指定模块文件的位置，可以是相对路径，也可以是绝对路 径， .js 后缀可以省略。如果只是模块名，不带有路径，那么必须有配置文件， 告诉 JavaScript 引擎该模块的位置。 1import &#123;myMethod&#125; from 'util'; 上面代码中， util是模块文件名，由于不带有路径，必须通过配置，告诉引擎怎么取到这个模块。 有些 组件库中通过index文件导出模块，index文件中有模块的路径 import命令具有提升效果，会提升到整个模块的头部，首先执行。 123foo();import &#123; foo &#125; from 'my_module'; 上面的代码不会报错，因为 import 的执行早于 foo的调用。这种行为的本质 是， import 命令是编译阶段执行的，在代码运行之前。 由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得 到结果的语法结构。 最后， import语句会执行所加载的模块，因此可以有下面的写法。 1import 'lodash'; 上面代码仅仅执行lodash模块，但是不输入任何值。 如果多次重复执行同一句 import 语句，那么只会执行一次，而不会执行多次。 目前阶段，通过 Babel 转码，CommonJS 模块的 require 命令和 ES6 模块的 import 命令，可以写在同一个模块里面，但是最好不要这样做。因为 import 在静态解析阶段执行，所以它是一个模块之中最早执行的。下面的代码可能不会得到预期结果。 123require('core-js/modules/es6.symbol');require('core-js/modules/es6.promise');import React from 'React'; 模块的整体加载除了指定加载某个输出值，还可以使用整体加载，即用*指定一个对象，所有输出值都加载在这个对象上。 1234567891011121314// circle.jsexport function area (radius)&#123; return Math.PI * radius * radius;&#125;export function circumference (radius)&#123; return 2 * Math.PI * radius;&#125;// main.jsimport * as circle from './circle';console.log('圆面积：' + circle.area(4));console.log('圆周长：' + circle.circumference(14)); 注意，模块整体加载所在的那个对象，应该是可以静态分析的，所以不允许运行时改变。 export default 命令从前面的例子可以看出，使用import命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。 为了给用户方便，让他们不用阅读文档就能加载模块，就要用到export default命令，为模块指定默认输出： 123export default function () &#123; console.log(‘foo’);&#125; 其他模块加载该模块时，import命令可以为该匿名函数指定任意名字： 123// import-default.jsimport customName from './export-default';customName(); // foo 上面代码的 import 命令，可以用任意名称指向 export-default.js 输出的方 法，这时就不需要知道原模块输出的函数名。需要注意的是，这时 import 命令后面，不使用大括号。 export default命令用在非匿名函数前，也是可以的: 123456789101112// export-default.jsexport default function foo() &#123; console.log('foo');&#125;// 或者写成function foo() &#123; console.log('foo');&#125;export default foo; foo函数的函数名foo，在模块外部是无效的。加载的时候，视同匿名函数加载。 下面比较一下默认输出和正常输出: 12345678910111213// 第一组export default function crc32() &#123; // 输出 // ...&#125;import crc32 from 'crc32'; // 输入// 第二组export function crc32() &#123; // 输出 // ...&#125;import &#123;crc32&#125; from 'crc32'; // 输入 export default命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此export default命令只能使用一次。所以， import 命令后面才不用加大括号，因为只可能对应一个方法。 本质上， export default 就是输出一个叫做 default的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的: 123456789101112// modules.jsfunction add(x, y) &#123; return x * y;&#125;export &#123;add as default&#125;;// 等同于// export default add;// app.jsimport &#123; default as xxx &#125; from 'modules';// 等同于// import xxx from 'modules'; 正是因为export default 后命令其实只是输出一个叫做default的变量，所以它⾯面不不能跟变量量声明语句句。 123456789// 正确export var a = 1;// 正确var a = 1;export default a;// 错误export default var a = 1; export default a的含义是将变量a的值赋给变量default。所以，最后一种写法会报错。 同样地，因为 export default 本质是将该命令后面的值，赋给default 变量以后再默认，所以直接将一个值写在 export default 之后。 12345// 正确export default 42;// 错误export 42; 有了export default命令，输入模块时就非常直观了，以输入 lodash 模块为例： 1import _ from 'lodash' 如果想在一条import 语句中，同时输入默认方法和其他接口，可以写成下面这样: 1234567891011import _, &#123; each, each as forEach &#125; from 'lodash';export default function (obj) &#123; // ...&#125;export function each(obj, iterator, context) &#123; // ...&#125;export &#123; each as forEach &#125;; export default也可以用来输出类。 export 与 import 的复合写法如果在一个模块之中，先输入后输出同一个模块，import语句可以与 export 语句写在一起。 12345export &#123; foo, bar &#125; from 'my_module';// 等同于import &#123; foo, bar &#125; from 'my_module';export &#123; foo, bar &#125;; 模块的接口改名和整体输出，也可以采用这种写法: 12345// 接口改名export &#123; foo as myFoo &#125; from 'my_module';// 整体输出export * from 'my_module'; 默认接口的写法如下: 1export &#123; default &#125; from 'foo'; 具名接口改为默认接口的写法如下: 12345export &#123; es6 as default &#125; from './someModule';// 等同于import &#123; es6 &#125; from './someModule';export default es6; 同样地，默认接口也可以改名为具名接口: 1export &#123; default as es6 &#125; from './someModule'; 模块的继承假设有一个circleplus模块，继承了circle模块。 123456// circleplus.jsexport * from 'circle';export var e = 2.71828182846;export default function (x) &#123; return Math.exp(x);&#125; 上面代码中的 export * ，表示再输出 circle 模块的所有属性和方法。注意， export * 命令会忽略 circle 模块的 default 方法。然后，上面代码又输出了自定义的e变量和默认方法。 这时，也可以将circle的属性或方法，改名后再输出: 12// circleplus.jsexport &#123; area as circleArea &#125; from 'circle'; 加载上面模块的写法如下： 1234// main.jsimport * as math from 'circleplus';import exp from 'circleplus';console.log(exp(math.e)); import exp表示，将circleplus模块的默认方法加载为exp方法。 跨模块常量const 声明的常量只在当前代码块有效。如果想设置跨模块的常量（即跨多个文件），或者说一个值要被多个模块共享，可以 采用下面的写法。 1234567891011121314// constants.js 模块export const A = 1;export const B = 3;export const C = 4;// test1.js 模块import * as constants from './constants';console.log(constants.A); // 1console.log(constants.B); // 3// test2.js 模块import &#123;A, B&#125; from './constants';console.log(A); // 1console.log(B); // 3 如果要使用的常量非常多，可以建一个专门的 constants目录，将各种常量写在不同的文件里面，保存在该目录下。 123456789// constants/db.jsexport const db = &#123; url: 'http://my.couchdbserver.local:5984', admin_username: 'admin', admin_password: 'admin password'&#125;;// constants/user.jsexport const users = ['root', 'admin', 'staff', 'ceo', 'chief','moderator']; 然后，将这些文件输出的常量，合并在index.js里面。 123// constants/index.jsexport &#123;db&#125; from './db';export &#123;users&#125; from './users'; 使用的时候，直接加载index.js就可以了。 12// script.jsimport &#123;db, users&#125; from './index'; import()简介 import命令会被 JavaScript 引擎静态分析，先于模块内的其他模 块执行（叫做”连接“更合适）。所以，下面的代码会报错。 1234// 报错if (x === 2) &#123; import MyModual from './myModual';&#125; 上面代码中，引擎处理 import 语句是在编译时，这时不会去分析或执行 if 语句，所以 import 语句放在 if代码块之中毫无意义，因此会报句法错误，而不是执行时错误。也就是说， import 和 export 命令只能在模块的顶层，不能在代码块之中（比如，在 if代码块之中，或在函数之中）。 这样的设计，固然有利于编译器提高效率，但也导致无法在运行时加载模块。在语法上，条件加载就不可能实现。如果 import 命令要取代 Node 的 require 方法，这就形成了一个障碍。因为 require 是运行时加载模块， import 命令无法取代require的动态加载功能。 12const path = './' + firstName;const myModual = require(path); 因此，有一个提案，建议引入import()函数，完成动态加载。 1import(specifier) import函数的参数specifier，指定所要加载的模块的位置。 import命令能够接受什么参数，import()函数就能接受什么参数，两者区别主要是后者为动态加载。 import() 返回一个 Promise 对象。下面是一个例子。 123456789const main = document.querySelector('main');import(`./section-modules/$&#123;someVariable&#125;.js`) .then(module =&gt; &#123; module.loadPageInto(main); &#125;) .catch(err =&gt; &#123; main.textContent = err.message; &#125;); import() 函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，也会加载指定的模块。另外， import() 函数与所加载的模块没有静态连接关系，这点也是与 import 语句不相同。 import() 类似于 Node 的require方法，区别主要是前者是异步加载，后者是同步加载。 适用场合下面是import()的一些适用场合。 按需加载 import() 可以在需要的时候，再加载某个模块。 123456789button.addEventListener('click', event =&gt; &#123; import('./dialogBox.js') .then(dialogBox =&gt; &#123; dialogBox.open(); &#125;) .catch(error =&gt; &#123; /*Error handling*/ &#125;)&#125;); 条件加载 import()可以放在if代码块，根据不同的情况，加载不同的模块。 12345if (condition) &#123; import('moduleA').then(...);&#125; else &#123; import('moduleB').then(...);&#125; 动态的模块路径 import() 允许模块路径动态生成。 12import(f()) .then(...); 注意点import() 加载模块成功以后，这个模块会作为一个对象，当作then 方法的参数。因此，可以使用对象解构赋值的语法，获取输出接口。 1234import('./myModule.js') .then(&#123;export1, export2&#125; =&gt; &#123; // ...&#125;); 如果模块有default输出接口，可以用参数直接获得。 1234567891011import('./myModule.js') .then(myModule =&gt; &#123; console.log(myModule.default);&#125;);/***********或者***********/import('./myModule.js') .then((&#123;default: theDefault&#125;) =&gt; &#123; console.log(theDefault);&#125;); 如果想同时加载多个模块，可以采用下面的写法。 12345678Promise.all([ import('./module1.js'), import('./module2.js'), import('./module3.js')]).then(([module1, module2, module3]) =&gt; &#123; ...&#125;); import() 也可以用在 async 函数之中。 123456789101112async function main() &#123; const myModule = await import('./myModule.js'); const &#123;export1, export2&#125; = await import('./myModule.js'); const [module1, module2, module3] = await Promise.all([ import('./module1.js'), import('./module2.js'), import('./module3.js'), ]);&#125;main(); Module的加载实现浏览器加载传统方法在 HTML 网页中，浏览器通过&lt;script&gt;标签加载 JavaScript 脚本。 默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到 &lt;script&gt; 标 签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入 脚本下载的时间。 如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感 觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以浏览器允许脚 本异步加载，下面就是两种异步加载的语法。 12&lt;script src="path/to/myModule.js" defer&gt;&lt;/script&gt;&lt;script src="path/to/myModule.js" async&gt;&lt;/script&gt; 上面代码中， &lt;script&gt; 标签打开 defer 或 async 属性，脚本就会异步加载。 渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是 直接执行后面的命令。 defer与async 的区别是：前者要等到整个页面正常渲染结束，才会执行；后者一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话， defer 是“渲染完再执行”， async 是“下载完就执行”。另外，如果有多个 defer 脚本，会按照它们在页面出现的顺序加载，而多个 async 脚本是不能保证加载顺序的。 加载规则浏览器加载 ES6 模块，也使用&lt;script&gt; 标签，但是要加入type=&#39;module&#39;属性。 1&lt;script type='module' src='foo.js'&gt;&lt;/script&gt;&gt; 浏览器对于带有 type=&quot;module&quot; 的 &lt;script&gt; ，都是异步加载，不会造成堵塞浏 览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了 &lt;script&gt; 标签的defer 属性。 &lt;script&gt; 标签的async 属性也可以打开，这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染。 ES6 模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。 12345&lt;script type='module'&gt; import utils from './utils.js'; // other code&lt;/script&gt; 对于外部的模块脚本，有几点需要注意： 代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变 量，外部不可见。 模块脚本自动采用严格模式，不管有没有声明 use strict 。 模块之中，可以使用 import 命令加载其他模块（ .js后缀不可省略，需要 提供绝对 URL 或相对 URL），也可以使用 export 命令输出对外接口。 模块之中，顶层的 this 关键字返回 undefined ，而不是指向window 。也 就是说，在模块顶层使用 this 关键字，是无意义的。 同一个模块如果加载多次，将只执行一次。 12345678import utils from 'https://example.com/js/utils.js';const x = 1;console.log(x === window.x); // falseconsole.log(this === undefined); // truedelete x; // 句法错误，严格模式禁止删除变量 利用顶层的this等于undefined这个语法点，可以侦测当前代码是否在 ES6 模块之中。 1const isNotModuleScript = this !== undefined; ES6模块与CommonJS模块的差异讨论 Node 加载 ES6 模块之前，必须了解 ES6 模块与 CommonJS 模块完全不 同。 它们有两个重大差异。 CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。 CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。 第二个差异是因为 CommonJS 加载的是一个对象（即 module.exports 属性）， 该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一 种静态定义，在代码静态解析阶段就会生成。 下面重点解释第一个差异。 CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变 化就影响不到这个值。请看下面这个模块文件 lib.js 的例子。 123456789// lib.jsvar counter = 3;function incCounter() &#123; counter++;&#125;module.exports = &#123; counter: counter, incCounter: incCounter,&#125;; 上面代码输出内部变量 counter 和改写这个变量的内部方法 inCounter。然后，在 main.js 里面加载这个模块。 123456// main.jsvar mod = require('./lib');console.log(mod.counter); // 3mod.inCounter();console.log(mod.counter); // 3 lib.js模块加载以后，它的内部变化就影响不到输出的 mod.counter 了。这是因为 mod.counter 是一个原始类型的值，会被缓存。 除非写成一个函数，才能得到内部变动后的值。 1234567891011// lib.jsvar counter = 3;function incCounter() &#123; counter++;&#125;module.exports = &#123; get counter() &#123; return counter &#125;, incCounter: incCounter,&#125;; ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到 模块加载命令 import ，就会生成一个只读引用。等到脚本真正执行时，再根据这 个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的 import 有点 像 Unix 系统的“符号连接”，原始值变了， import 加载的值也会跟着变。因此， ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。 1234567891011// lib.jsexport let counter = 3;export function incCounter() &#123; counter++;&#125;// main.jsimport &#123; counter, incCounter &#125; from './lib';console.log(counter); // 3incCounter();console.log(counter); // 4 由于 ES6 输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进 行重新赋值会报错。 12345678// lib.jsexport let obj = &#123;&#125;;// main.jsimport &#123; obj &#125; from './lib';obj.prop = 123; // okobj = &#123;&#125;; // TypeError 最后， export 通过接口，输出的是同一个值。不同的脚本加载这个接口，得到的 都是同样的实例。 Node加载概述Node 对 ES6 模块的处理比较麻烦，因为它有自己的 CommonJS 模块格式，与 ES6 模块格式是不兼容的。目前的解决方案是，将两者分开，ES6 模块和 CommonJS 采用各自的加载方案。 在静态分析阶段，一个模块脚本只要有一行 import 或 export 语句，Node 就会 认为该脚本为 ES6 模块，否则就为 CommonJS 模块。如果不输出任何接口，但是 希望被 Node 认为是 ES6 模块，可以在脚本中加一行语句。 1export &#123;&#125;; 上面的命令并不是输出一个空对象，而是不输出任何接口的 ES6 标准写法。 如果不指定绝对路径，Node 加载 ES6 模块会依次寻找以下脚本， 与 require() 的规则一致。 12345678910111213141516import './foo';// 依次寻找// ./foo.js// ./foo/package.json// ./foo/index.jsimport 'baz';// 依次寻找// ./node_modules/baz.js// ./node_modules/baz/package.json// ./node_modules/baz/index.js// 寻找上一级目录// ../node_modules/baz.js// ../node_modules/baz/package.json// ../node_modules/baz/index.js// 再上一级目录 ES6 模块之中，顶层的 this 指向 undefined ；CommonJS 模块的顶 层 this 指向当前模块，这是两者的一个重大差异。 import命令加载CommonJS模块Node 采用 CommonJS 模块格式，模块的输出都定义在 module.exports 这个属 性上面。在 Node 环境中，使用 import 命令加载 CommonJS 模块，Node 会自 动将 module.exports 属性，当作模块的默认输出，即等同于 export default。 下面是一个 CommonJS 模块。 1234567891011// a.jsmodule.exports = &#123; foo: 'hello', bar: 'world'&#125;;// 等同于export default &#123; foo: 'hello', bar: 'world'&#125;; import命令加载上面的模块，module.exports会被视为默认输出。 1234567// 写法一import baz from './a';// baz = &#123;foo: 'hello', bar: 'world'&#125;;// 写法二import &#123;default as baz&#125; from './a';// baz = &#123;foo: 'hello', bar: 'world'&#125;; 如果采用整体输入的写法（import * as xxx from someModule），default会取代module.exports，作为输入的接口。 123456import * as baz from './a';// baz = &#123;// get default() &#123;return module.exports;&#125;,// get foo() &#123;return this.default.foo&#125;.bind(baz),// get bar() &#123;return this.default.bar&#125;.bind(baz)// &#125; 上面代码中， this.default 取代了 module.exports 。需要注意的是，Node 会自动为 baz 添加 default 属性，通过 baz.default 拿到module.exports。 123456789// b.jsmodule.exports = null;// es.jsimport foo from './b';// foo = null;import * as bar from './b';// bar = &#123;default: null&#125;; bar本身是一个对象，不能当作函数调用，只能通过bar.default调用。 CommonJS 模块的输出缓存机制，在 ES6 加载方式下依然有效。 123// foo.jsmodule.exports = 123;setTimeout(_ =&gt; module.exports = null); 上面代码中，对于加载foo.js的脚本， module.exports将一直是 123 ，而不会变成 null 。 由于 ES6 模块是编译时确定输出接口，CommonJS 模块是运行时确定输出接口， 所以采用 import 命令加载 CommonJS 模块时，不允许采用下面的写法。 1import &#123;readfile&#125; from 'fs'; 上面的写法不正确，因为 fs是 CommonJS 格式，只有在运行时才能确定 readfile 接口，而 import 命令要求编译时就确定这个接口。解决方法就是改为整体输入。 12345import * as express from 'express';const app = express.default();import express from 'express';const app = express(); require 命令加载ES6模块采用 require命令加载 ES6 模块时，ES6 模块的所有输出接口，会成为输入对象的属性。 123456789// es.jslet foo = &#123;bar: 'my-default'&#125;;export default foo;foo = null;// cjs.jsconst es_namespace = require('./es');console.log(es_namespace.default);// &#123;bar:'my-default'&#125; 上面代码中， default 接口变成了 es_namespace.default 属性。另外，由于存在缓存机制， es.js对 foo的重新赋值没有在模块外部反映出来。 循环加载“循环加载”（circular dependency）指的是，a脚本的执行依赖b脚本，而b脚本的执行又依赖a脚本。 12345// a.jsvar b = require('b');// b.jsvar a = require('a'); 通常，“循环加载”表示存在强耦合，如果处理不好，还可能导致递归加载，使得程 序无法执行，因此应该避免出现。 但是实际上，这是很难避免的，尤其是依赖关系复杂的大项目，很容易出现 a依 赖b ，b 依赖c ， c 又依赖 a 这样的情况。这意味着，模块加载机制必须考虑“循环加载”的情况。 对于JavaScript语言来说，目前最常见的两种模块格式CommonJS和ES6，处理“循 环加载”的方法是不一样的，返回的结果也不一样。 CommonJS模块的加载原理介绍ES6如何处理”循环加载”之前，先介绍目前最流行的CommonJS模块格式的加 载原理。 CommonJS的一个模块，就是一个脚本文件。 require命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。 123456&#123; id: '...', exports: &#123;...&#125;, loaded: true, ...&#125; 上面代码就是Node内部加载模块后生成的一个对象。该对象的 id属性是模块 名，exports 属性是模块输出的各个接口， loaded 属性是一个布尔值，表示该模块的脚本是否执行完毕。其他还有很多属性，这里都省略了。 以后需要用到这个模块的时候，就会到 exports 属性上面取值。即使再次执行 require 命令，也不会再次执行该模块，而是到缓存之中取值。也就是说， CommonJS模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载， 就返回第一次运行的结果，除非手动清除系统缓存。 CommonJS模块的循环加载CommonJS 模块的重要特性是加载时执行，即脚本代码在 require 的时候，就会 全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行 的部分不会输出。 让我们来看，Node 官方文档里面的例子。脚本文件a.js代码如下: 12345exports.done = false;var b = require('b.js');console.log('在 a.js 之中，b.done = %j', b.done);exports.done = true;console.log('a.js 执行完毕'); 上面代码之中， a.js 脚本先输出一个 done 变量，然后加载另一个脚本文件 b.js 。注意，此时 a.js 代码就停在这里，等待 b.js 执行完毕，再往下执行。 再看b.js的代码。 12345exports.done = false;var a = require('./a.js');console.log('在 b.js 之中，a.done = %j', a.done);exports.done = true;console.log('b.js 执行完毕'); 上面代码之中， b.js 执行到第二行，就会去加载 a.js ，这时，就发生了“循环加载”。系统会去 a.js 模块对应对象的 exports 属性取值，可是因为 a.js 还 没有执行完，从 exports 属性只能取回已经执行的部分，而不是最后的值。 a.js已经执行的部分，只有一行。 1exports.done = false; 因此，对于b.js来说，它从a.js只输入一个变量done，值为false。 然后， b.js 接着往下执行，等到全部执行完毕，再把执行权交还给 a.js 。于 是， a.js 接着往下执行，直到执行完毕。我们写一个脚本 main.js ，验证这个过程。 123var a = require('./a.js');var b = require('./b.js');console.log('在 main.js 之中, a.done=%j, b.done=%j', a.done, b.done); 1234567$ node main.js在 b.js 之中，a.done = falseb.js 执行完毕在 a.js 之中，b.done = truea.js 执行完毕在 main.js 之中, a.done=true, b.done=true 总之，CommonJS输入的是被输出值的拷贝，不是引用。 另外，由于CommonJS模块遇到循环加载时，返回的是当前已经执行的部分的值， 而不是代码全部执行后的值，两者可能会有差异。所以，输入变量的时候，必须非 常小心。 12345678910var a = require('a'); // 安全的写法var foo = require('a').foo; // 危险的写法exports.good = function (arg) &#123; return a.foo('good', arg); // 使用的是 a.foo 的最新值&#125;;exports.bad = function (arg) &#123; return foo('bad', arg); // 使用的是一个部分加载时的值&#125;; 上面代码中，如果发生循环加载， require(&#39;a&#39;).foo的值很可能后面会被改写，改用require(&#39;a&#39;) 会更保险一点。 ES6模块的循环加载ES6 处理“循环加载”与CommonJS有本质的不同。ES6模块是动态引用，如果使 用 import 从一个模块加载变量（即import foo from &#39;foo&#39; ），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值 的时候能够取到值。 1234567891011// a.js如下import &#123;bar&#125; from './b.js';console.log('a.js');console.log(bar);export let foo = 'foo';// b.jsimport &#123;foo&#125; from './a.js';console.log('b.js');console.log(foo);export let bar = 'bar'; 12345$ babel-node a.jsb.jsundefineda.jsbar 上面代码中，由于 a.js 的第一行是加载 b.js ，所以先执行的是b.js 。而 b.js 的第一行又是加载 a.js ，这时由于 a.js 已经开始执行了，所以不会重复执行，而是继续往下执行 b.js ，所以第一行输出的是b.js 。 接着， b.js要打印变量foo，这时a.js还没执行完，取不到 foo的值，导致打印出来是undefined。b.js 执行完，开始执行 a.js ，这时就一切正常了。 再看一个稍微复杂的例子（摘自 Axel Rauschmayer 的《Exploring ES6》）。 1234567891011121314151617// a.jsimport &#123;bar&#125; from './b.js';export function foo() &#123; console.log('foo'); bar(); console.log('执行完毕');&#125;foo();// b.jsimport &#123;foo&#125; from './a.js';export function bar() &#123; console.log('bar'); if (Math.random() &gt; 0.5) &#123; foo(); &#125;&#125; 按照 CommonJS 规范，上面的代码是没法执行的。 a 先加载 b ，然后 b 又加载 a ，这时a 还没有任何执行结果，所以输出结果为 null ，即对于 b.js 来 说，变量foo 的值等于 null ，后面的foo() 就会报错。 但是，ES6可以执行上面的代码。 123456789101112$ babel-node a.jsfoobar执行完毕// 执行结果也有可能是foobarfoobar执行完毕执行完毕 上面代码中， a.js 之所以能够执行，原因就在于ES6加载的变量，都是动态引用 其所在的模块。只要引用存在，代码就能执行。 下面，我们详细分析这段代码的运行过程。 1234567891011121314151617181920212223242526272829// a.js// 这一行建立一个引用，// 从`b.js`引用`bar`import &#123;bar&#125; from './b.js';export function foo() &#123; // 执行时第一行输出 foo console.log('foo'); // 到 b.js 执行 bar bar(); console.log('执行完毕');&#125;foo();// b.js// 建立`a.js`的`foo`引用import &#123;foo&#125; from './a.js';export function bar() &#123; // 执行时，第二行输出 bar console.log('bar'); // 递归执行 foo，一旦随机数 // 小于等于0.5，就停止执行 if (Math.random() &gt; 0.5) &#123; foo(); &#125;&#125; 编程风格块级作用域 let取代var ES6提出了两个新的声明变量的命令：let和const。其中， let 完全可以取代var，因为两者语义相同，而且let没有副作用。 全局常量和线程安全 let和const 之间，建议优先使用const，尤其是在全局环境，不应该设置变量，只应设置常量。 const优于let 有几个原因。一个是 const 可以提醒阅读程序的人，这个变量 不应该改变；另一个是 const 比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式运算；最后一个原因是 JavaScript 编译器会对 const 进行优化，所以多使用const ，有利于提供程序的运行效率，也就是说 let 和 const 的本质区别，其实是编译器内部的处理不同。 所有的函数都应该设置为常量。 字符串静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。 解构赋值使用数组成员对变量赋值时，优先使用解构赋值。 12345678const arr = [1, 2, 3, 4];// badconst first = arr[0];const second = arr[1];// goodconst [first, second] = arr; 函数的参数如果是对象的成员，优先使用解构赋值。 123456789101112131415// badfunction getFullName(user) &#123; const firstName = user.firstName; const lastName = user.lastName;&#125;// goodfunction getFullName(obj) &#123; const &#123; firstName, lastName &#125; = obj;&#125;// bestfunction getFullName(&#123; firstName, lastName &#125;) &#123; &#125; 如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。 对象单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以 逗号结尾。 对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免， 要使用 Object.assign 方法。 1234567891011// badconst a = &#123;&#125;;a.x = 3;// if reshape unavoidableconst a = &#123;&#125;;Object.assign(a, &#123; x: 3 &#125;);// goodconst a = &#123; x: null &#125;;a.x = 3; 如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义。 12345678910111213// badconst obj = &#123; id: 5, name: 'San Francisco'&#125;;obj[getKey('enabled')] = true;// goodconst obj = &#123; id: 5, name: 'San Francisco', [getKey('enabled')]: true,&#125;; 另外，对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写。 12345678910111213141516171819var ref = 'some value';// badconst atom = &#123; ref: ref, value: 1, addValue: function (value) &#123; return atom.value + value; &#125;,&#125;;// goodconst atom = &#123; ref, value: 1, addValue (value) &#123; return atom.value + value; &#125;,&#125;; 数组使用扩展运算符（…）拷贝数组。 使用Array.from方法，将类似数组的对象转为数组。 函数立即执行函数可以写成箭头函数的形式。 123(() =&gt; &#123; console.log('Welcome to the Internet.');&#125;)(); 那些需要使用函数表达式的场合，尽量用箭头函数代替。因为这样更简洁，而且绑 定了this。 箭头函数取代Function.prototype.bind，不应再用self/_this/that绑定 this。 简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体较为复杂，行 数较多，还是应该采用传统的函数写法。 所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参 数。 123456789// badfunction divide(a, b, option = false) &#123;&#125;// goodfunction divide(a, b, &#123;option = false&#125; = &#123;&#125;) &#123;&#125; 不要在函数体内使用arguments变量，使用rest运算符（…）代替。因为rest运算符 显式表明你想要获取参数，而且arguments是一个类似数组的对象，而rest运算符可 以提供一个真正的数组。 使用默认值语法设置函数参数的默认值。 123456789// badfunction handleThings(opts) &#123; opts = opts || &#123;&#125;;&#125;// goodfunction handleThings(opts = &#123;&#125;) &#123;&#125; Map结构注意区分Object和Map，只有模拟现实世界的实体对象时，才使用Object。如果只 是需要 key: value 的数据结构，使用Map结构。因为Map有内建的遍历机制。 Class总是用Class，取代需要prototype的操作。因为Class的写法更简洁，更易于理解。 123456789101112131415161718192021// badfunction Queue(contents = []) &#123; this._queue = [...contents];&#125;Queue.prototype.pop = function() &#123; const value = this._queue[0]; this._queue.splice(0, 1); return value;&#125;// goodclass Queue &#123; constructor(contents = []) &#123; this._queue = [...contents]; &#125; pop() &#123; const value = this._queue[0]; this._queue.splice(0, 1); return value; &#125;&#125; 使用extends实现继承，因为这样更简单，不会有破坏instanceof运算的危险。 12345678910111213141516// badconst inherits = require('inherits');function PeekableQueue(contents) &#123; Queue.apply(this, contents);&#125;inherits(PeekableQueue, Queue);PeekableQueue.prototype.peek = function() &#123; return this._queue[0];&#125;// goodclass PeekableQueue extends Queue &#123; peek() &#123; return this._queue[0]; &#125;&#125; 模块首先，Module语法是JavaScript模块的标准写法，坚持使用这种写法。使用 import 取代require 。 使用export取代module.exports。 如果模块只有一个输出值，就使用 export default ，如果模块有多个输出值， 就不使用 export default ，export default 与普通的export 不要同时使用。 不要在模块输入中使用通配符。因为这样可以确保你的模块之中，有一个默认输出 （export default）。 12345// badimport * as myObject from './importModule';// goodimport myObject from './importModule'; 如果模块默认输出一个函数，函数名的首字母应该小写。 如果模块默认输出一个对象，对象名的首字母应该大写。 读懂ECMAScript规格概述ECMAScript 6的规格，可以在ECMA国际标准组织的官方网站免费下载和在线阅读。 ECMAScript 6规格的26章之中，第1章到第3章是对文件本身的介绍，与语言关系 不大。第4章是对这门语言总体设计的描述，有兴趣的读者可以读一下。第5章到第 8章是语言宏观层面的描述。第5章是规格的名词解释和写法的介绍，第6章介绍数 据类型，第7章介绍语言内部用到的抽象操作，第8章介绍代码如何运行。第9章到 第26章介绍具体的语法。 对于一般用户来说，除了第4章，其他章节都涉及某一方面的细节，不用通读，只 要在用到的时候，查阅相关章节即可。下面通过一些例子，介绍如何使用这份规 格。 规格对每一种语法行为的描述，都分成两部分：先是总体的行为描述，然后是实现 的算法细节。 ArrayBufferArrayBuffer对象、TypedArray 视图和DataView视图是 JavaScript 操作二 进制数据的一个接口。这些对象早就存在，属于独立的规格（2011年2月发布）， ES6 将它们纳入了 ECMAScript 规格，并且增加了新的方法。它们都是以数组的语 法处理二进制数据，所以统称为二进制数组。 这个接口的原始设计目的，与 WebGL 项目有关。所谓 WebGL，就是指浏览器与 显卡之间的通信接口，为了满足 JavaScript 与显卡之间大量的、实时的数据交换， 它们之间的数据通信必须是二进制的，而不能是传统的文本格式。文本格式传递一 个32位整数，两端的 JavaScript 脚本与显卡都要进行格式转化，将非常耗时。这时 要是存在一种机制，可以像 C 语言那样，直接操作字节，将4个字节的32位整数， 以二进制形式原封不动地送入显卡，脚本的性能就会大幅提升。 二进制数组就是在这种背景下诞生的。它很像C语言的数组，允许开发者以数组下 标的形式，直接操作内存，大大增强了 JavaScript 处理二进制数据的能力，使得开 发者有可能通过 JavaScript 与操作系统的原生接口进行二进制通信。 二进制数组由三类对象组成。 （1） ArrayBuffer对象：代表内存之中的一段二进制数据，可以通过“视图”进行 操作。“视图”部署了数组接口，这意味着，可以用数组的方法操作内存。 （2） TypedArray视图：共包括9种类型的视图，比如Uint8Array（无符号8位整数）数组视图,Int16Array（16位整数）数组视图,Float32Array（32位浮点数）数组视图等等。 （3） DataView视图：可以自定义复合格式的视图，比如第一个字节是 Uint8（无符号8位整数）、第二、三个字节是 Int16（16位整数）、第四个字节开 始是 Float32（32位浮点数）等等，此外还可以自定义字节序。 简单说， ArrayBuffer 对象代表原始的二进制数据，TypedArray视图用来读写简 单类型的二进制数据， DataView 视图用来读写复杂类型的二进制数据。 TypedArray 视图支持的数据类型一共有9种（DataView视图支持除Uint8c以外的其他8种）。 注意，二进制数组并不是真正的数组，而是类似数组的对象。 很多浏览器操作的API，用到了二进制数组操作二进制数据，下面是其中的几个。 File API XMLHttpRequest Fetch API Canvas WebSockets ArrayBuffer对象概述 ArrayBuffer对象代表储存二进制数据的一段内存，它不能直接读写，只能通过视图（TypedArray 视图和 DataView 视图)来读写，视图的作用是以指定格式解读二进制数据。 ArrayBuffer 也是一个构造函数，可以分配一段可以存放数据的连续内存区域。 1var buf = new ArrayBuffer(32); 上面代码生成了一段32字节的内存区域，每个字节的值默认都是0。可以看 到， ArrayBuffer 构造函数的参数是所需要的内存大小（单位字节）。 为了读写这段内容，需要为它指定视图。DataView视图的创建，需要提供 ArrayBuffer 对象实例作为参数。 123var buf = new ArrayBuffer(32);var dataView = new DataView(buf);dataView.getUint8(0) // 0 上面代码对一段32字节的内存，建立 DataView 视图，然后以不带符号的8位整数格式，读取第一个元素，结果得到0，因为原始内存的 ArrayBuffer 对象，默认 所有位都是0。 另一种TypedArray视图，与 DataView 视图的一个区别是，它不是一个构造函 数，而是一组构造函数，代表不同的数据格式。 12345678var buffer = new ArrayBuffer(12);var x1 = new Int32Array(buffer);x1[0] = 1;var x2 = new Uint8Array(buffer);x2[0] = 2;x1[0] // 2 上面代码对同一段内存，分别建立两种视图：32位带符号整数（ Int32Array 构造函数）和8位不带符号整数（ Uint8Array 构造函数）。由于两个视图对应的是 同一段内存，一个视图修改底层内存，会影响到另一个视图。 TypedArray视图的构造函数，除了接受 ArrayBuffer 实例作为参数，还可以接受 普通数组作为参数，直接分配内存生成底层的 ArrayBuffer 实例，并同时完成对 这段内存的赋值。 12345var typedArray = new Uint8Array([0 ,1 ,2]);typedArray.length // 3typedArray[0] = 5;typedArray // [5, 1, 2] 上面代码使用TypedArray视图的 Uint8Array 构造函数，新建一个不带符号的8位 整数视图。可以看到， Uint8Array 直接使用普通数组作为参数，对底层内存的 赋值同时完成。 ArrayBuffer.prototype.byteLengthArrayBuffer实例的byteLength属性，返回所分配的内存区域的字节长度。 如果要分配的内存区域很大，有可能分配失败（因为没有那么多的连续空余内 存），所以有必要检查是否分配成功。 ArrayBuffer.prototype.slice()ArrayBuffer实例有一个 slice方法，允许将内存区域的一部分，拷贝生成一个新的ArrayBuffer对象。 12var buffer = new ArrayBuffer(8);var newBuffer = buffer.slice(0 ,3); slice方法其实包含两步，第一步是先分配一 段新内存，第二步是将原来那个 ArrayBuffer 对象拷贝过去。 slice 方法接受两个参数，第一个参数表示拷贝开始的字节序号（含该字节）， 第二个参数表示拷贝截止的字节序号（不含该字节）。如果省略第二个参数，则默 认到原 ArrayBuffer 对象的结尾。 除了 slice 方法， ArrayBuffer 对象不提供任何直接读写内存的方法，只允许 在其上方建立视图，然后通过视图读写。 ArrayBuffer.isView()ArrayBuffer有一个静态方法 isView ，返回一个布尔值，表示参数是否为ArrayBuffer 的视图实例。这个方法大致相当于判断参数，是否为TypedArray实例或DataView实例。 TypedArray视图概述ArrayBuffer 对象作为内存区域，可以存放多种类型的数据。同一段内存，不同 数据有不同的解读方式，这就叫做“视图”（view）。ArrayBuffer 有两种视图， 一种是TypedArray视图，另一种是 DataView 视图。前者的数组成员都是同一个 数据类型，后者的数组成员可以是不同的数据类型。 目前，TypedArray视图一共包括9种类型，每一种视图都是一种构造函数。 Int8Array：8位有符号整数，长度1个字节。 Uint8Array：8位无符号整数，长度1个字节。 Uint8ClampedArray：8位无符号整数，长度1个字节，溢出处理不同。 Int16Array：16位有符号整数，长度2个字节。 Uint16Array ：16位无符号整数，长度2个字节。 Int32Array ：32位有符号整数，长度4个字节。 Uint32Array：32位无符号整数，长度4个字节。 Float32Array ：32位浮点数，长度4个字节。 Float64Array ：64位浮点数，长度8个字节。 这9个构造函数生成的数组，统称为TypedArray视图。它们很像普通数组，都 有 length属性，都能用方括号运算符（[] ）获取单个元素，所有数组的方法，在它们上面都能使用。普通数组与TypedArray数组的差异主要在以下方面。 TypedArray数组的所有成员，都是同一种类型。 TypedArray数组的成员是连续的，不会有空位。 TypedArray数组成员的默认值为0。比如， new Array(10)返回一个普通数 组，里面没有任何成员，只是10个空位； new Uint8Array(10) 返回一个 TypedArray数组，里面10个成员都是0。 TypedArray数组只是一层视图，本身不储存数据，它的数据都储存在底层的ArrayBuffer 对象之中，要获取底层对象必须使用 buffer 属性。 DataView视图如果一段数据包括多种类型（比如服务器传来的HTTP数据），这时除了建立 ArrayBuffer 对象的复合视图以外，还可以通过 DataView视图进行操作。 DataView视图提供更多操作选项，而且支持设定字节序。本来，在设计目的上，ArrayBuffer 对象的各种TypedArray视图，是用来向网卡、声卡之类的本机设备传送数据，所以使用本机的字节序就可以了；而 DataView 视图的设计目的， 是用来处理网络设备传来的数据，所以大端字节序或小端字节序是可以自行设定 的。 DataView 视图本身也是构造函数，接受一个ArrayBuffer对象作为参数，生成视图。 二进制数组的应用AJAX传统上，服务器通过AJAX操作只能返回文本数据，即 responseType 属性默认为 text 。 XMLHttpRequest 第二版 XHR2 允许服务器返回二进制数据，这时分成两种情况。如果明确知道返回的二进制数据类型，可以把返回类型（responseType ）设为 arraybuffer ；如果不知道，就设为blob。 12345678910var xhr = new XMLHttpRequest();xhr.open('GET', someUrl);xhr.responseType = 'arraybuffer';xhr.onload = function () &#123; let arrayBuffer = xhr.response; // ...&#125;;xhr.send(); 如果知道传回来的是32位整数，可以像下面这样处理。 12345678910xhr.onreadystatechange = function () &#123; if (req.readyState === 4) &#123; var arrayResponse = xhr.response; var dataView = new DataView(arrayResponse); var ints = new Uint32Array(dataView.byteLength / 4); xhrDiv.style.backgroundColor = '#00FF00'; xhrDiv.innerText = 'Array is ' + ints.length + "uints long"; &#125;&#125;; CanvasCanvas元素输出的二进制像素数据，就是TypedArray数组。 12345var canvas = document.getElementById('myCanvas');var ctx = canvas.getContext('2d');var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);var uint8ClampedArray = imageData.data; 需要注意的是，上面代码的 uint8ClampedArray 虽然是一个TypedArray数组，但 是它的视图类型是一种针对Canvas元素的专有类型 Uint8ClampedArray 。这个 视图类型的特点，就是专门针对颜色，把每个字节解读为无符号的8位整数，即只能取值0～255，而且发生运算的时候自动过滤高位溢出。这为图像处理带来了巨大 的方便。 WebSocketWebSocket可以通过ArrayBuffer，发送或接收二进制数据。 123456789101112131415var socket = new WebSocket('ws://127.0.0.1:8081');socket.binaryType = 'arraybuffer';// Wait until socket is opensocket.addEventListener('open', function (event) &#123; // Send binary data var typedArray = new Uint8Array(4); socket.send(typedArray.buffer);&#125;);// Receive binary datasocket.addEventListener('message', function (event) &#123; var arrayBuffer = event.data; // ...&#125;); Fetch APIFetch API取回的数据，就是ArrayBuffer对象。 1234567fetch(url).then(function (request) &#123; return request.arrayBuffer()&#125;).then(function (arrayBuffer) &#123; // ...&#125;); File API如果知道一个文件的二进制数据类型，也可以将这个文件读取为ArrayBuffer对象。 12345678var fileInput = document.getElementById('fileInput');var file = fileInput.files[0];var reader = new FileReader();reader.readAsArrayBuffer(file);reader.onload = function () &#123; var arrayBuffer = reader.result; // ...&#125;; 下面以处理bmp文件为例。假定file 变量是一个指向bmp文件的文件对象，首先读取文件。 123var reader = new FileReader();reader.addEventListener('load', processimage, false);reader.readAsArrayBuffer(file); 然后，定义处理图像的回调函数：先在二进制数据之上建立一个 DataView视图， 再建立一个bitmap 对象，用于存放处理后的数据，最后将图像展示在Canvas元素之中。 123456function processimage(e) &#123; var buffer = e.target.result; var datav = new DataView(buffer); var bitmap = &#123;&#125;; // 具体处理步骤&#125; 具体处理图像数据时，先处理bmp的文件头。具体每个文件头的格式和定义，请参 阅有关资料。 123456bitmap.fileheader = &#123;&#125;;bitmap.fileheader.bfType = datav.getUint16(0, true);bitmap.fileheader.bfSize = datav.getUint32(2, true);bitmap.fileheader.bfReserved1 = datav.getUint16(6, true);bitmap.fileheader.bfReserved2 = datav.getUint16(8, true);bitmap.fileheader.bfOffBits = datav.getUint32(10, true); 接着处理图像元信息部分。 123456789101112bitmap.infoheader = &#123;&#125;;bitmap.infoheader.biSize = datav.getUint32(14, true);bitmap.infoheader.biWidth = datav.getUint32(18, true);bitmap.infoheader.biHeight = datav.getUint32(22, true);bitmap.infoheader.biPlanes = datav.getUint16(26, true);bitmap.infoheader.biBitCount = datav.getUint16(28, true);bitmap.infoheader.biCompression = datav.getUint32(30, true);bitmap.infoheader.biSizeImage = datav.getUint32(34, true);bitmap.infoheader.biXPelsPerMeter = datav.getUint32(38, true);bitmap.infoheader.biYPelsPerMeter = datav.getUint32(42, true);bitmap.infoheader.biClrUsed = datav.getUint32(46, true);bitmap.infoheader.biClrImportant = datav.getUint32(50, true); 最后处理图像本身的像素信息。 12var start = bitmap.fileheader.bfOffBits;bitmap.pixels = new Uint8Array(buffer, start); 至此，图像文件的数据全部处理完成。下一步，可以根据需要，进行图像变形，或 者转换格式，或者展示在 Canvas 网页元素之中。 SharedArrayBufferJavaScript 是单线程的，Web worker 引入了多线程：主线程用来与用户互动， Worker 线程用来承担计算任务。每个线程的数据都是隔离的，通过 postMessage() 通信。下面是一个例子。 123456789101112// 主线程var w = new Worker('myworker.js');w.postMessage('hi');w.onmessage = function (ev) &#123; // 监听 Worker 线程的回应 console.log(ev.data);&#125;;// worker线程onmessage = function (ev) &#123; // 获取主线程发来的消息 console.log(ev.data); postMessage('ho');&#125;; 线程之间的数据交换可以是各种格式，不仅仅是字符串，也可以是二进制数据。这 种交换采用的是复制机制，即一个进程将需要分享的数据复制一份，通过 postMessage 方法交给另一个进程。如果数据量比较大，这种通信的效率显然 比较低。很容易想到，这时可以留出一块内存区域，由主线程与 Worker 线程共 享，两方都可以读写，那么就会大大提高效率，协作起来也会比较简单（不像 postMessage 那么麻烦）。 ES2017 引入SharedArrayBuffer，允许 Worker 线程与主线程共享同一块内存。SharedArrayBuffer的 API 与 ArrayBuffer 一模一样，唯一的区别是后者无法共享。 123456789// 主线程// 新建1kb共享内存var sharedBuffer = new SharedArrayBuffer(1024);// 主线程将共享内存的地址发送出去w.postMessage(sharedBuffer);// 在共享内存上建立视图，供写入数据const sharedArray = new Int32Array(sharedBuffer); Worker 线程从事件的 data 属性上面取到数据。 1234567891011// Worker 线程var sharedBuffer;onmessage = function (ev) &#123; // 主线程共享的数据，就是 1KB 的共享内存 sharedBuffer = ev.data; // 在共享内存上建立视图，方便读写 const sharedArray = new Int32Array(sharedBuffer); // ...&#125;; 共享内存也可以在 Worker 线程创建，发给主线程。 SharedArrayBuffer 与 ArrayBuffer 一样，本身是无法读写的，必须在上面建立视图，然后通过视图读写。 Atomics对象多线程共享内存，最大的问题就是如何防止两个线程同时修改某个地址，或者说， 当一个线程修改共享内存以后，必须有一个机制让其他线程同步。SharedArrayBuffer API 提供 Atomics 对象，保证所有共享内存的操作都是“原子性”的，并且可以在所有线程内同步。 什么叫“原子性操作”呢？现代编程语言中，一条普通的命令被编译器处理以后，会 变成多条机器指令。如果是单线程运行，这是没有问题的；多线程环境并且共享内 存时，就会出问题，因为这一组机器指令的运行期间，可能会插入其他线程的指令，从而导致运行结果出错。 Atomics 对象就是为了解决这个问题而提出，它可以保证一个操作所对应的多条 机器指令，一定是作为一个整体运行的，中间不会被打断。也就是说，它所涉及的 操作都可以看作是原子性的单操作，这可以避免线程竞争，提高多线程共享内存时 的操作安全。 Atomics对象提供多种方法。 （1）Atomics.store()，Atomics.load() store()方法用来向共享内存写入数据， load()方法用来从共享内存读出数 据。比起直接的读写操作，它们的好处是保证了读写操作的原子性。 此外，它们还用来解决一个问题：多个线程使用共享线程的某个位置作为开关 （flag），一旦该位置的值变了，就执行特定操作。这时，必须保证该位置的赋值 操作，一定是在它前面的所有可能会改写内存的操作结束后执行；而该位置的取值 操作，一定是在它后面所有可能会读取该位置的操作开始之前执行。 store 方法 和load方法就能做到这一点，编译器不会为了优化，而打乱机器指令的执行顺序。 （2）Atomics.wait()，Atomics.wake() 使用 while 循环等待主线程的通知，不是很高效，如果用在主线程，就会造成卡 顿， Atomics 对象提供了 wait() 和 wake() 两个方法用于等待通知。这两个方 法相当于锁内存，即在一个线程进行操作时，让其他线程休眠（建立锁），等到操 作结束，再唤醒那些休眠的线程（解除锁）。 （3）运算方法 共享内存上面的某些运算是不能被打断的，即不能在运算过程中，让其他线程改写 内存上面的值。Atomics 对象提供了一些运算方法，防止数据被改写。比如Atomics.add、Atomics.sub、Atomics.and、Atomics.or、Atomics.xor。 （4）其他方法 Atomics.compareExchange(sharedArray, index, oldval, newval) Atomics.exchange(sharedArray, index, value) Atomics.isLockFree(size)]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用群晖中的Docker套件安装Jenkins]]></title>
    <url>%2F2018%2F06%2F23%2F%E5%88%A9%E7%94%A8%E7%BE%A4%E6%99%96%E4%B8%AD%E7%9A%84Docker%E5%A5%97%E4%BB%B6%E5%AE%89%E8%A3%85Jenkins%2F</url>
    <content type="text"><![CDATA[去年在公众号中介绍了一下群晖的NAS系统（群晖NAS–你的私有云）。这次就是要通过群晖自带的Docker套件安装Jenkins，这有可能是全网第一篇介绍在群晖新系统下怎么安装Jenkins的文章。 安装Jenkins想自己搞一套Jenkins是因为Travis CI只支持Github，我的博客为了保证在国内访问的稳定性，部署在了Coding上，导致了一直以来持续集成（CI）不可用，如果没有CI的话，每次部署都需要多敲3行代码，懒是第一生产力，所以，今天就试着在群晖NAS安装了Jenkins。 Jenkins是一个用Java编写的开源的持续集成工具。Jenkins提供了软件开发的持续集成服务。它运行在Servlet容器中（例如Apache Tomcat）。它支持软件配置管理（SCM）工具（包括AccuRev SCM、CVS、Subversion、Git、Perforce、Clearcase和RTC），可以执行基于Apache Ant和Apache Maven的项目，以及任意的Shell脚本和Windows批处理命令。Jenkins的主要开发者是川口耕介。Jenkins是在MIT许可证下发布的自由软件。 持续集成说白了就是项目的”自动化”编译、打包、分发部署，大大提高了项目的自动化程度。废话不多说，接下来我们看一下怎么安装。 在群晖中打开Docker套件，点击注册表，注册表里有很多已上传的镜像下载： 注册表 双击Jenkins的镜像，选择Jenkins的版本，这里选择最新版就行了： 等下载完成后，就可以在映像中看到（吐槽一下这个翻译，应该是镜像）： 选中Jenkins后点击上方的启动按钮，进入设置页面： 这里的容器名称按自己的喜好起名，其他设置可以不变，直接进入高级设置： 在高级设置中选择快捷方式为网页，后面端口号写8080，这样在桌面上直接点击就可以跳到Jenkins。 点击端口设置，把8080端口修改成下面这样： 修改完成后点击应用，在容器中就能看到Jenkins已经运行了： 这是我们点击桌面上的Jenkins的快捷方式，就会跳出这个页面： 这时候我们需要去取得已经生成的管理员密码。还是回到Docker套件中，点击容器中的详情按钮，进入详情界面，选择终端机选项卡，直接点击新增按钮，跳出bash页面： 然后输入下面一行命令(cat后面是Jenkins页面红色提示的地址)： 1cat /var/jenkins_home/secrets/initialAdminPassword 这时候回得到一串密码，复制后粘贴到刚刚Jenkins的页面，点击Continue进入插件安装页面，这里根据个人喜好选择安装默认插件还是自己选择： 在自己选择安装的界面点击Install按钮后，会出现卡死的现象，这时候关掉页面，重新进入，就能看到安装界面： 安装完毕后就可以创建账号了： 账号创建完，就可以进入Jenkins那熟悉的界面（依然那么丑）： 使用Jenkins构建Coding项目这一节内容，其实coding已经帮我写好了，而且很详细，具体可以查看coding的文档，我就懒得再写了。 唯一需要说明的是，要使用使用Jenkins构建Coding项目的首要条件是你的Jenkins地址能在外网访问。平常我们都是通过内网地址访问群晖的NAS，外网访问不到，如果需要接入外网，大概有下面几种方法： 走群晖自带的QuickConnect服务（国内比较慢，因为服务器在台湾） 通过ngrok、花生壳之类的工具进行内网穿透 通过自己购买阿里云、腾讯云等VPS，获取公网IP，然后把内网映射到公网IP上 打电话给运营商，取得公网IP，然后把内网映射出去（关键看运营商给不给，不过网上成功案例还是蛮多的）]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>群晖</tag>
        <tag>Docker</tag>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[码一个去除优酷世界杯直播聊天室的chrome扩展]]></title>
    <url>%2F2018%2F06%2F20%2F%E7%A0%81%E4%B8%80%E4%B8%AA%E5%8E%BB%E9%99%A4%E4%BC%98%E9%85%B7%E4%B8%96%E7%95%8C%E6%9D%AF%E7%9B%B4%E6%92%AD%E8%81%8A%E5%A4%A9%E5%AE%A4%E7%9A%84chrome%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[最近看世界杯的时候，优酷视频右侧有个聊天室，还没有关闭按钮，想边看比赛边码代码的时候刷得很心烦。于是顺手写了一个chrome的扩展，你可以在这里找到源码，或者在这里下载crx文件。 crx文件安装：点击进入浏览器右上角三条杠按钮，依次点击 更多程序—&gt;扩展程序，进入页面后直接把crx文件拖到浏览器中就安装成功啦。 先看一下最后的目录结构： 123456./ ├─ manifest.json //扩展的配置项 ├─ index.js //自定义js脚本 ├─ index.css //自定义css样式(这个扩展程序可以不要) ├─ images //存放图片的文件夹 └─ popup.html //扩展的展示弹窗(这个扩展程序可以不要) 通过配置manifest.json文件，告诉Chrome这个扩展的一些重要信息。 那我们首先新建一个manifest.json文件： 123456789101112131415161718192021222324252627282930313233343536373839404142&#123; "name": "hideChatRoom", "version": "0.0.1", "manifest_version": 2, "description": "隐藏优酷世界杯直播时的聊天室", "icons": &#123; // 扩展的icon "72": "./images/icons/icon-72x72.png", "96": "./images/icons/icon-96x96.png", "128": "./images/icons/icon-128x128.png" &#125;, "browser_action": &#123; // browser_action表示程序图标会出现在地址栏右侧 "default_title": "hideChatRoom", "default_icon": "./images/icons/icon-72x72.png", "default_popup": "popup.html" &#125;, "content_scripts": [ //content_scripts是在Web页面内运行的javascript脚本。 //通过使用标准的DOM，它们可以获取浏览器所访问页面的详细信息，并可以修改这些信息。 &#123; //这里的值是数组，可以针对多个站点进行不同的操作配置 "matches": [ "https://vku.youku.com/live/*" ], "css": [ "index.css" ], "js": [ "index.js" ], "all_frames": true, "run_at": "document_idle" &#125; ], "permissions": [ //一些权限的配置， "cookies", //比如cookie权限，比如系统通知权限，类似于notify这样的东西，在window系统上未右下角的小气泡 "notifications" ]&#125; manifest.json文件中其他一些参数的含义和设置可以去google官网查看。 因为涉及不到css样式和扩展程序的弹出框，所以popup.html和index.css可以不用管它们，这里只是为了做个演示。 在index.js中就要写隐藏聊天室的主要逻辑： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071let isNeedHide = true; // 为以后做切换预留参数/** 增强版window.onload，可以多次加载function** @param &#123; Function &#125; func - 需要运行的函数* ******************************************************** */function addLoadEvent(func) &#123; const oldonload = window.onload; if (typeof window.onload !== "function") &#123; window.onload = func; &#125; else &#123; window.onload = function () &#123; oldonload(); func(); &#125; &#125;&#125;/** 检测元素是否存在** @param &#123; HTMLElement &#125; ele - 需要检测的元素* ******************************************************** */function checkElement(ele) &#123; if (!ele) &#123; console.log(`can't get class, element info: $&#123;ele&#125;`); return; &#125;&#125;/** 改变有指定className的元素样式** @param &#123; String &#125; className - 元素className** @param &#123; Object &#125; style - 元素样式对象（包含样式名称、隐藏* 和显示时的样式）* ******************************************************** */function changeStyle(className, style) &#123; const element = document.getElementsByClassName(className)[0]; checkElement(element); element.style[style.styleName] = isNeedHide ? style.hide : style.show; console.log(`$&#123;className&#125; $&#123;style.styleName&#125;: $&#123;element.style[style.styleName]&#125;`);&#125;function main() &#123; const interactionStyle = &#123; styleName: 'display', hide: 'none', show: 'block' &#125;; const videoStyle = &#123; styleName: 'width', hide: '100%', show: 'calc(100% - 300px)' &#125;; changeStyle('interaction', interactionStyle); changeStyle('video-playing', videoStyle);&#125;addLoadEvent(main); 代码逻辑很简单，就是通过DOM操作，获取具有interaction和video-playingclass名称的元素，然后分别设置它们的display和width属性。 写好代码后就可以去调试了，在扩展程序页面切换到开发者模式，再点击加载已解压的扩展程序，选择代码所在的文件夹，这样你的扩展程序就可以在chrome中调试了。 调试完了就可以点击打包扩展程序打包成crx文件，第一次打包的时候私钥文件可以不填。 这样一个很简单的扩展程序就完成啦。这个扩展程序主要是自娱自乐，所以就没有上传到 Chrome 网上应用商店，上传的流程可以google一下，有蛮多教程的。]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】在Angular中使用DOM：意想不到的后果及优化技术]]></title>
    <url>%2F2018%2F06%2F12%2F%E3%80%90%E8%AF%91%E3%80%91%E5%9C%A8Angular%E4%B8%AD%E4%BD%BF%E7%94%A8DOM%EF%BC%9A%E6%84%8F%E6%83%B3%E4%B8%8D%E5%88%B0%E7%9A%84%E5%90%8E%E6%9E%9C%E5%8F%8A%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[原文链接：Working with DOM in Angular: unexpected consequences and optimization techniques YouTube视频 我最近在NgConf上以讲习班的形式讲述了Angular中的高级DOM操作。我从基本的使用模板引用和DOM查询等访问DOM元素，一直讲到使用view container动态地呈现模板和组件。如果你还没有看过这个话题，我推荐你去看一下。通过一系列实践练习，你将能够更快地学习和强化新知识。我在NgViking上也有一个关于此主题的较短演讲。 然而，如果你想要一个TL;DR版本或者只是想阅读而不是听讲，我在本文中总结了关键概念。我将首先讲解在Angular中使用DOM的工具和方法，然后继续讨论我在研讨会期间未讲的更高级的优化技术。 你可以在这个github仓库中找到我在演讲中使用的例子。 窥视视图引擎假设你有一个任务从DOM中删除一个子组件。这是一个父组件的模板，带有一个需要删除的子组件A： 12345678@Component(&#123; ... template: ` &lt;button (click)="remove()"&gt;Remove child component&lt;/button&gt; &lt;a-comp&gt;&lt;/a-comp&gt; `&#125;)export class AppComponent &#123;&#125; 解决此需求的不正确方法是直接使用Renderer或原生DOM API删除DOM元素&lt;a-comp&gt;： 12345678910@Component(&#123;...&#125;)export class AppComponent &#123; ... remove() &#123; this.renderer.removeChild( this.hostElement.nativeElement, // parent App comp node this.childComps.first.nativeElement // child A comp node ); &#125;&#125; 你可以在这里看到完整的解决方案。如果删除节点后你在Elements选项卡中检查生成的HTML，则会看到子组件A已经不在DOM中： 但是，如果你再检查控制台，Angular仍然会将子组件的数量报告为1而不是0。更糟糕的是，对于子组件A及其子组件仍然运行变更检测。这是来自控制台的日志： 为什么呢发生这种情况是因为Angular在内部使用通常称为视图或组件视图的数据结构来表示组件。这是一个表示视图和DOM之间关系的图表： 每个视图由视图节点组成，这些视图节点保存对相应DOM元素的引用。因此，当我们直接更改DOM时，视图内保存对该DOM元素引用的视图节点不受影响。这是一个图表，显示了从DOM中删除A组件元素后的视图和DOM的状态： 由于所有变更检测操作（包括在视图上而不是在DOM上运行的子视图），Angular都会检测与A组件对应的视图并输出1，而不是按预期的那样输出0。而且，由于与A组件相对应的视图的存在，它也对A组件及其所有子组件进行变更检测。 这表明，你不能直接从DOM中删除子组件。事实上，你应该避免删除由框架创建的任何HTML元素，只删除Angular不知道的元素，这些可能是由你的代码或某个第三方插件创建的元素。 为了正确地解决这个问题，我们需要一个可以直接处理视图的工具，在Angular中这个工具就是View Container。 View ContainerView Container对DOM层次结构的安全性进行了变动，并供Angular中的所有内置结构指令使用。它是一种特殊的视图节点，它位于视图内并充当其他视图的容器： 如你所见，它可以包含两种类型的视图：嵌入视图和宿主视图。 这些是Angular中存在的唯一的视图类型，它们主要不同之处是由用于创建它们的输入数据决定。此外，嵌入视图只能附属于view container，而宿主视图可以附属到任何DOM元素（通常称为宿主元素）。 嵌入视图是使用TemplateRef从模板创建的，而宿主视图是使用视图（组件）工厂创建的。例如，用于引导应用程序的主要组件（AppComponent）在内部相当于附加到组件宿主元素（&lt;app-comp&gt;）的宿主视图。 View Container提供API来创建，操作和删除动态视图。我将它们称为动态视图，而不是由模板中静态组件创建的静态视图。 Angular不会为静态视图使用View Container，而是在子组件的特定节点内持有对子视图的引用。下面的图证明了这个想法： 如你所见，此处没有View Container节点，并且对子视图的引用直接附加到A组件视图节点。 操作动态视图在开始创建并将视图附加到view container之前，你需要将该容器引入组件的模板并初始化它。模板内的任何元素都可以充当view container，但是该角色最常见的候选对象是&lt;ng-container&gt;，因为它被呈现为注释节点，因此不会向DOM引入冗余元素。 要将任何元素转换为view container，我们使用{read：ViewContainerRef}来进行视图查询： 1234567@Component(&#123; … template: `&lt;ng-container #vc&gt;&lt;/ng-container&gt;`&#125;)export class AppComponent implements AfterViewChecked &#123; @ViewChild('vc', &#123;read: ViewContainerRef&#125;) vc: ViewContainerRef;&#125; 一旦Angular完成视图查询评估并将对view container的引用分配给类的属性，则可以使用该引用来创建动态视图。 创建嵌入视图要创建嵌入视图，需要一个模板。在Angular中，我们使用&lt;ng-template&gt;元素包裹任何DOM元素来定义模板的结构。然后，我们可以简单地使用带有{read：TemplateRef}参数的视图查询来获取对该模板的引用： 1234567891011@Component(&#123; ... template: ` &lt;ng-template #tpl&gt; &lt;!-- any HTML elements can go here --&gt; &lt;/ng-template&gt; `&#125;)export class AppComponent implements AfterViewChecked &#123; @ViewChild('tpl', &#123;read: TemplateRef&#125;) tpl: TemplateRef&lt;null&gt;;&#125; 一旦Angular评估完此查询并将对模板的引用分配给类的属性，我们就可以使用该引用来创建并使用createEmbeddedView方法将嵌入视图附加到view container： 1234567@Component(&#123; ... &#125;)export class AppComponent implements AfterViewInit &#123; ... ngAfterViewInit() &#123; this.viewContainer.createEmbeddedView(this.tpl); &#125;&#125; 你应该在ngAfterViewInit生命周期钩子内实现你的逻辑，因为这是在视图查询被初始化的时候。另外，对于嵌入视图，你可以使用模板内绑定的值来定义上下文对象。查看API文档可以获取更多详细信息。 你可以在这里找到创建嵌入视图的完整示例。 创建宿主视图要创建宿主视图，你需要一个组件工厂。想要了解更多关于工厂和动态组件检查的信息，先了解这里关于Angular中动态组件的知识。 在Angular中，我们使用componentFactoryResolver服务来获取对组件工厂的引用： 123456789@Component(&#123; ... &#125;)export class AppComponent implements AfterViewChecked &#123; ... constructor(private r: ComponentFactoryResolver) &#123;&#125; ngAfterViewInit() &#123; const factory = this.r.resolveComponentFactory(ComponentClass); &#125; &#125;&#125; 一旦我们获得了组件的工厂，我们可以使用它来初始化组件，创建宿主视图并将此视图附加到view container。为此，我们只需调用createComponent方法并传入一个组件工厂： 1234567@Component(&#123; ... &#125;)export class AppComponent implements AfterViewChecked &#123; ... ngAfterViewInit() &#123; this.viewContainer.createComponent(this.factory); &#125;&#125; 你可以在这里找到创建宿主视图的完整示例。 移除视图附加到view container的任何视图都可以使用remove或detach方法来删除。这两种方法都是从view container和DOM中移除一个视图。但是，remove方法会破坏视图，导致以后不能被重新附着，但detach方法会保留它以便在将来重用，这对于我将在下面展示的优化技术非常重要。 因此，为了正确地删除子组件或任何DOM元素，首先需要创建一个嵌入或宿主视图并将其附加到view container。这样做后，你将能够使用任何可用的API方法将其从view container和DOM中移除。 优化技术有时你可能需要重复显示和隐藏由模板定义的相同组件或HTML。在下面的例子中，通过点击不同的按钮，切换组件显示： 我们简单地使用上面学到的方法，并用下面的代码来实现这一点： 1234567891011@Component(&#123;...&#125;)export class AppComponent &#123; show(type) &#123; ... // a view is destroyed this.viewContainer.clear(); // a view is created and attached to a view container this.viewContainer.createComponent(factory); &#125;&#125; 每次单击按钮并执行show方法时，销毁并重新创建视图，这样最终会产生不良后果。 在这个例子中，它是宿主视图，因为我们使用了组件工厂和createComponent方法，所以它要被销毁并重新创建。如果相反，我们使用createEmbeddedView方法和TemplateRef，嵌入视图将被销毁并重新创建： 1234567show(type) &#123; ... // a view is destroyed this.viewContainer.clear(); // a view is created and attached to a view container this.viewContainer.createEmbeddedView(this.tpl);&#125; 理想情况下，我们需要创建一次视图，然后在需要时再使用它。view container API提供了一种将现有视图附加到view container的方法，并在不销毁它的情况下将其删除。 ViewRefComponentFactory和TemplateRef都实现了可用于创建视图的视图创建方法。实际上，当你调用createEmbeddedView或createComponent方法并传入参数时，view container 在后台就使用这些方法。好消息是，我们可以自己调用这些方法来创建嵌入或宿主视图并获取对视图的引用。在Angular中视图使用ViewRef类型及其子类型进行引用。 创建宿主视图所以这就是你如何使用一个组件工厂来创建一个宿主视图，并获得对它的引用： 123aComponentFactory = resolver.resolveComponentFactory(AComponent);aComponentRef = aComponentFactory.create(this.injector);view: ViewRef = aComponentRef.hostView; 如果是宿主视图，可以从create方法返回的ComponentRef中检索与组件关联的视图。它通过类似命名的hostView属性暴露出来。 一旦我们获得了视图，就可以使用insert方法将其附加到view container。如果你不想再显示的另一个视图可以使用detach方法删除和保留(译者注：原文是preserved，可以和上文提到的detach和remove方法不同之处一起理解)。因此，切换组件的优化方案应该如下实现： 1234567showView2() &#123; ... // Existing view 1 is removed from a view container and the DOM this.viewContainer.detach(); // Existing view 2 is attached to a view container and the DOM this.viewContainer.insert(view);&#125; 再次注意，我们使用detach方法来保留视图以备后用而不是clear或remove。你可以在这里找到完整的实现。 创建嵌入视图在基于模板创建嵌入视图的情况下，视图直接由createEmbeddedView方法返回： 123456view1: ViewRef;view2: ViewRef;ngAfterViewInit() &#123; this.view1 = this.t1.createEmbeddedView(null); this.view2 = this.t2.createEmbeddedView(null);&#125; 和前面的示例类似，一个视图可以从view container中移除，另一个视图可以重新附加上去。你还是可以在这里找到完整的实现。 有趣的是，视图创建方法createEmbeddedView和view container的createComponent也返回对创建的视图的引用。]]></content>
      <categories>
        <category>技术类</category>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客评论系统迁移说明]]></title>
    <url>%2F2018%2F06%2F11%2F%E5%8D%9A%E5%AE%A2%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%E8%BF%81%E7%A7%BB%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[最早的时候博客评论系统用的多说，后来多说关闭后，转向了hypercomments，不过最近邮件通知我要收费了，感觉评论系统貌似生存多少有点问题，于是就转向了开源的评论系统：valine（号称无后端的评论系统，不过要依赖leancloud）。不考虑Gitment是因为需要有Github账号才能评论，然而并不是每个人都有Github账号。 原本准备自己把这个功能加进来，后来发现Next 6.0已经把valine加进去了，并且还把以前我自己魔改的一些功能也做成了配置项，一切变得so easy，所以我也把Next升级到了6.0。 在Next6.0中建议把自己添加的样式可以放在/hexo/themes/next/source/css/_custom/custom.styl下面，布局上的更改可以放在/hexo/themes/next/layout/_custom文件下面的三个文件中，这样以后只要git pull就可以更新Next，也不会有啥冲突。 这个评论系统唯一比较遗憾的是邮件通知功能有问题，所以暂时只能在leancloud后台去看有没有人留言，不过网上有Hexo 优化 — Valine 扩展之邮件通知解决办法，就是不知道效果怎么样，等等再折腾一下。 valine感觉还是不太好用，最后还是选择了DISQUS作为评论系统~~ 最后，感谢下面给我留过言的朋友。]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】Angular Ivy的变更检测执行：你准备好了吗？]]></title>
    <url>%2F2018%2F06%2F07%2F%E3%80%90%E8%AF%91%E3%80%91Angular%20Ivy%E7%9A%84%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E6%89%A7%E8%A1%8C%EF%BC%9A%E4%BD%A0%E5%87%86%E5%A4%87%E5%A5%BD%E4%BA%86%E5%90%97%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[原文链接：Angular Ivy change detection execution: are you prepared? 让我们看看Angular为我们做了什么。 声明：这只是我对Angular新渲染器的学习之旅。 Angular视图引擎的演变 虽然新的Ivy渲染器的重要性还没有完全展现出来，但许多人想知道它将如何工作以及它为我们准备的变化。 在本文中，我将展示Ivy变更检测机制，展示一些让我非常兴奋的事情，并从头开始，根据指导（类似于Angular Ivy指导）构建简单的app。 首先，介绍一下我下面将研究的app： 123456789101112131415161718192021222324252627282930313233343536@Component(&#123; selector: 'my-app', template: ` &lt;h2&gt;Parent&lt;/h2&gt; &lt;child [prop1]="x"&gt;&lt;/child&gt; `&#125;)export class AppComponent &#123; x = 1;&#125;@Component(&#123; selector: 'child', template: ` &lt;h2&gt;Child &#123;&#123; prop1 &#125;&#125;&lt;/h2&gt; &lt;sub-child [item]="3"&gt;&lt;/sub-child&gt; &lt;sub-child *ngFor="let item of items" [item]="item"&gt;&lt;/sub-child&gt; `&#125;)export class ChildComponent &#123; @Input() prop1: number; items = [1, 2];&#125;@Component(&#123; selector: 'sub-child', template: ` &lt;h2 (click)="clicked.emit()"&gt;Sub-Child &#123;&#123; item &#125;&#125;&lt;/h2&gt; &lt;input (input)="text = $event.target.value"&gt; &lt;p&gt;&#123;&#123; text &#125;&#125;&lt;/p&gt; `&#125;)export class SubChildComponent &#123; @Input() item: number; @Output() clicked = new EventEmitter(); text: string;&#125; 我创建了一个在线demo，用于了解Ivy如何在幕后运行：https://alexzuza.github.io/ivy-cd/ Demo使用了Angular 6.0.1 aot 编译器。你可以单击任何生命周期块来跳转到对应的代码。 为了运行变更检测过程，只需在Sub-Child下面的输入框中输入一些内容即可。 视图当然，视图是Angular中主要的低级抽象。 对于我们的例子，我们会得到下面类似的结构： 123456789101112131415Root view | |___ AppComponent view | |__ ChildComponent view | |_ Embedded view | | | |_ SubChildComponent view | |_ Embedded view | | | |_ SubChildComponent view | |_ SubChildComponent view 视图应该描述模板，以及它包含一些反映该模板结构的数据。 我们来看看ChildComponent视图。它有以下模板： 123&lt;h2&gt;Child &#123;&#123; prop1 &#125;&#125;&lt;/h2&gt;&lt;sub-child [item]="3"&gt;&lt;/sub-child&gt;&lt;sub-child *ngFor="let item of items" [item]="item"&gt;&lt;/sub-child&gt; 当前视图引擎从视图定义工厂创建nodes并将它们存储在视图定义的nodes数组中。 Ivy从instructions创建LNodes，这个instructions被写入ngComponentDef.template函数，并将它们存储在data数组中： 除了nodes之外，新视图还包含data数组中的绑定（参见上图中的data[4]，data[5]，data[6]）。给定视图的所有绑定，从bindingStartIndex开始按照它们出现在模板中的顺序进行存储。 注意我如何从ChildComponent获取视图实例。 ComponentInstance . ngHostLNode包含对组件宿主节点的引用。 （另一种方法是注入ChangeDetectorRef） 在这种方式下，angular 会首先创建根视图，并在data数组索引0处定位宿主元素 123RootView data: [LNode] native: root component selector 然后遍历所有组件并为每个视图填充data数组。 变更检测众所周知，ChangeDetectorRef只是抽象类，具有诸如detectChanges，markForCheck等抽象方法。 当我们在组件构造函数中询问这个依赖关系时，我们实际上得到了继承 ChangeDetectorRef 类的ViewRef实例。 现在，我们来看看用于在Ivy中运行变更检测的内部方法。其中一些可用作公共API（markViewDirty和detectChanges），但我不确定其他的API。 detectChangesdetectChanges 是对组件（及其可能的子组件）同步执行变更检测。 这个函数在组件中以同步方式触发变更检测。应该没有什么理由直接调用此函数，执行变更检测的首选方法是使用markDirty（请参见下文），并等待调度程序在将来某个时间点调用此方法。这是因为单个用户操作通常会导致许多组件失效，并且在每个组件上同步调用变更检测效率低下。最好等到所有组件都标记为脏，然后在所有组件上执行单一变更检测。 tick用于在整个应用程序上执行变更检测。 这相当于detectChanges，但是要在根组件上调用。另外，tick执行生命周期钩子，并根据它们的ChangeDetectionStrategy和dirtiness来有条件地检查组件。 12345678export function tick&lt;T&gt;(component: T): void &#123; const rootView = getRootView(component); const rootComponent = (rootView.context as RootContext).component; const hostNode = _getComponentHostLElementNode(rootComponent); ngDevMode &amp;&amp; assertNotNull(hostNode.data, 'Component host node should be attached to an LView'); renderComponentOrTemplate(hostNode, rootView, rootComponent);&#125; scheduleTick用于安排整个应用程序的变更检测。与tick不同，scheduleTick将多个调用合并为一个变更检测运行。当视图需要重新渲染时，通常通过调用markDirty间接调用它。 1234567891011export function scheduleTick&lt;T&gt;(rootContext: RootContext) &#123; if (rootContext.clean == _CLEAN_PROMISE) &#123; let res: null|((val: null) =&gt; void); rootContext.clean = new Promise&lt;null&gt;((r) =&gt; res = r); rootContext.scheduler(() =&gt; &#123; tick(rootContext.component); res !(null); rootContext.clean = _CLEAN_PROMISE; &#125;); &#125;&#125; markViewDirty(markForCheck)标记当前视图和所有祖先视图为脏（译者注：脏为需要变更检测）。 在早期的Angular 5中，它只向上迭代并启用了所有父视图的检查，现在请注意，markForCheck的确触发了Ivy变更检测周期！ 😮😮😮 123456789101112export function markViewDirty(view: LView): void &#123; let currentView: LView|null = view; while (currentView.parent != null) &#123; currentView.flags |= LViewFlags.Dirty; currentView = currentView.parent; &#125; currentView.flags |= LViewFlags.Dirty; ngDevMode &amp;&amp; assertNotNull(currentView !.context, 'rootContext'); scheduleTick(currentView !.context as RootContext);&#125; markDirty将组件标记为脏。 标记为脏的组件将在未来的某个时间安排对此组件进行变更检测。将一个已经为脏的组件标记为脏是一个空操作。每个组件树只能安排一次未完成的变更检测。 （使用单独的renderComponent引导的两个组件将具有单独的调度器） 12345export function markDirty&lt;T&gt;(component: T) &#123; ngDevMode &amp;&amp; assertNotNull(component, 'component'); const lElementNode = _getComponentHostLElementNode(component); markViewDirty(lElementNode.view);&#125; checkNoChanges没变化:) 当我调试新的变更检测机制时，我注意到我忘记了安装zone.js。而且，正如你已经猜到的一样，它没有依赖性，没有cdRef.detectChanges或tick，它依然完美运行。 为什么呢？ 你可能知道Angular只会对onPush组件触发变更检测（请参阅我在stackoverflow上的回答）。 这些规则同样适用于Ivy： 其中一个输入发生变化 https://github.com/angular/angular/blob/43d62029f0e2da0150ba6f09fd8989ca6391a355/packages/core/src/render3/instructions.ts#L890 由组件或其子组件触发的绑定事件 https://github.com/angular/angular/blob/43d62029f0e2da0150ba6f09fd8989ca6391a355/packages/core/src/render3/instructions.ts#L1743 手动调用markForCheck（现在用markViewDirty函数（见下文）） 在SubChildComponent中，有（input）output绑定。第二条规则将导致调用markForCheck。既然我们已经知道这个方法实际上调用变更检测，现在应该清楚它如何在没有zonejs的情况下工作。 如果在检测后表达式变化了怎么办？ 不要着急，它还在 变更检测顺序自从发布Ivy以来，Angular团队一直在努力确保新引擎以正确的顺序正确处理所有生命周期钩子。这意味着操作顺序应该是相似的。 Max NgWizard K在他的文章中写道（强烈建议阅读它）： 正如你所看到的，所有熟悉的操作仍然在这里。但操作顺序似乎已经改变。例如，现在看来Angular首先检查子组件，然后检查嵌入的视图。由于目前没有编译器能够产生适合测试我假设的输出，所以这点我无法确定。 回到刚刚demo的子组件中来： 123&lt;h2&gt;Child &#123;&#123; prop1 &#125;&#125;&lt;/h2&gt;&lt;sub-child [item]="3"&gt;&lt;/sub-child&gt;&lt;sub-child *ngFor="let item of items" [item]="item"&gt;&lt;/sub-child&gt; 我打算在其他内嵌视图之前写一个sub-child作为常规组件。 现在观察它的运行： angular首先检查嵌入视图，然后检查常规组件。所以这里和以前的引擎相比没有改变。 无论如何，我的演示中有可选的“run Angular compile”按钮，我们可以测试其他情况。 https://alexzuza.github.io/ivy-cd/ 一次性字符串初始化想象一下，我们写了可以接收颜色作为字符串输入值的组件。现在我们想把这个输入作为永远不会改变的常量字符串来传递： 1&lt;comp color="#efefef"&gt;&lt;/comp&gt; 这就是所谓的一次性字符串初始化，angular文档中的陈述如下： Angular 设置它，然后忘记它。 对我而言，这意味着 angular 不会对此绑定进行任何额外的检查。但是我们在 angular5 中实际看到的是，它在 updateDirectives 调用期间，每一次变更检测期间就会检查一次。 另请参阅Netanel Basal的关于此问题的文章了解Angular的@Attribute装饰器 现在让我们看看它在新的引擎中是怎么样的： 12345678910111213141516var _c0 = ["color", "#efefef"];AppComponent.ngComponentDef = i0.ɵdefineComponent(&#123; type: AppComponent, selectors: [["my-app"]], ... template: function AppComponent_Template(rf, ctx) &#123; // create mode if (rf &amp; 1) &#123; i0.ɵE(0, "child", _c0); &lt;========== used only in create mode i0.ɵe(); &#125; if (rf &amp; 2) &#123; ... &#125; &#125;&#125;) 正如我们所看到的，angular编译器将常量存储在负责创建和更新组件的代码之外，并且只在创建模式下使用此值。 Angular不再为容器创建文本节点 更新：https://github.com/angular/angular/pull/24346 即使你不知道angular ViewContainer 在引擎中如何工作，你在打开devtools时可能会注意到下面的图片： 在生产模式下，我们只看到&lt;！—&gt;。 这是Ivy的输出： 我无法100％确定，但似乎一旦Ivy变得稳定，我们就会有这样的结果。 因此对于下面的代码中query，angular将返回null 1234567@Component(&#123; ..., template: '&lt;ng-template #foo&gt;&lt;/ng-template&gt;'&#125;)class SomeComponent &#123; @ViewChild('foo', &#123;read: ElementRef&#125;) query;&#125; 应该不再使用指向容器中的注释DOM节点的本地元素读取ElementRef 全新的 Incremental DOM（IDOM）很久以前，Google发布了所谓的Incremental DOM库。 该库专注于构建DOM树并允许动态更新。它不能直接使用，而是作为模板引擎的编译目标。而且似乎Ivy与Incremental DOM库有一些共同之处。 让我们从头开始构建一个简单的app，这将帮助我们了解IDOM渲染如何工作的。Demo 我们的app将有计数器，并会把通过input元素输入的用户名打印出来。 假设页面上已经有&lt;input&gt;和&lt;button&gt;元素： 12&lt;input type="text" value="Alexey"&gt;&lt;button&gt;Increment&lt;/button&gt; 我们需要做的只是渲染动态html，看起来像这样： 123456&lt;h1&gt;Hello, Alexey&lt;/h1&gt;&lt;ul&gt; &lt;li&gt; Counter: &lt;span&gt;1&lt;/span&gt; &lt;/li&gt;&lt;/ul&gt; 为了渲染这些，让我们编写elementOpen，elementClose和文本“instructions”（我这样称呼它，因为Angular使用像Ivy这样的名称可以被认为是特殊类型的虚拟CPU）。 首先，我们需要编写特殊的助手来遍历节点树： 1234567891011121314151617// The current nodes being processedlet currentNode = null;let currentParent = null;function enterNode() &#123; currentParent = currentNode; currentNode = null;&#125;function nextNode() &#123; currentNode = currentNode ? currentNode.nextSibling : currentParent.firstChild;&#125;function exitNode() &#123; currentNode = currentParent; currentParent = currentParent.parentNode;&#125; 现在让我们写instructions： 12345678910111213141516171819202122232425262728293031323334function renderDOM(name) &#123; const node = name === '#text' ? document.createTextNode('') : document.createElement(name); currentParent.insertBefore(node, currentNode); currentNode = node; return node;&#125;function elementOpen(name) &#123; nextNode(); const node = renderDOM(name); enterNode(); return currentParent;&#125;function elementClose(node) &#123; exitNode(); return currentNode;&#125;function text(value) &#123; nextNode(); const node = renderDOM('#text'); node.data = value; return currentNode;&#125; 换句话说，这些函数只是遍历DOM节点并在当前位置插入节点。此外，文本命令设置data属性，以便我们可以看到浏览器的文本值。 我们希望我们的元素能够保持某种状态，所以我们来介绍NodeData： 12345678910111213141516171819const NODE_DATA_KEY = '__ID_Data__';class NodeData &#123; // key // attrs constructor(name) &#123; this.name = name; this.text = null; &#125;&#125;function getData(node) &#123; if (!node[NODE_DATA_KEY]) &#123; node[NODE_DATA_KEY] = new NodeData(node.nodeName.toLowerCase()); &#125; return node[NODE_DATA_KEY];&#125; 现在，让我们改动一下renderDOM函数，以便在当前位置已经相同的情况下，我们不会向DOM添加新元素： 123456789101112const matches = function(matchNode, name/*, key */) &#123; const data = getData(matchNode); return name === data.name // &amp;&amp; key === data.key;&#125;;function renderDOM(name) &#123; if (currentNode &amp;&amp; matches(currentNode, name/*, key */)) &#123; return currentNode; &#125; ...&#125; 注意我注释的 /*, key */。如果元素有key来区分元素会更好。另请参阅http://google.github.io/incremental-dom/#demos/using-keys 之后，让我们添加将负责文本节点更新的逻辑： 123456789101112131415function text(value) &#123; nextNode(); const node = renderDOM('#text'); // update // checks for text updates const data = getData(node); if (data.text !== value) &#123; data.text = (value); node.data = value; &#125; // end update return currentNode;&#125; 我们可以为元素节点做同样的事情。 然后，让我们来编写patch函数，它将需要DOM元素，update函数以及一些数据（这些数据将由update函数使用）： 1234567function patch(node, fn, data) &#123; currentNode = node; enterNode(); fn(data); exitNode();&#125;; 最后，让我们测试一下这个instructions： 1234567891011121314151617181920212223242526272829303132333435363738function render(data) &#123; elementOpen('h1'); &#123; text('Hello, ' + data.user) &#125; elementClose('h1'); elementOpen('ul') &#123; elementOpen('li'); &#123; text('Counter: ') elementOpen('span'); &#123; text(data.counter); &#125; elementClose('span'); &#125; elementClose('li'); &#125; elementClose('ul');&#125;document.querySelector('button').addEventListener('click', () =&gt; &#123; data.counter ++; patch(document.body, render, data);&#125;);document.querySelector('input').addEventListener('input', (e) =&gt; &#123; data.user = e.target.value; patch(document.body, render, data);&#125;);const data = &#123; user: 'Alexey', counter: 1&#125;;patch(document.body, render, data); 结果可以在这找到。 你还可以通过使用浏览器工具，来验证代码是否仅更新其内容已更改的文本节点： 所以IDOM的主要理念就是使用真正的DOM来和新树进行对比。 全文完。谢谢阅读。]]></content>
      <categories>
        <category>技术类</category>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[西班牙国家德比之旅]]></title>
    <url>%2F2018%2F05%2F28%2F%E8%A5%BF%E7%8F%AD%E7%89%99%E5%9B%BD%E5%AE%B6%E5%BE%B7%E6%AF%94%E4%B9%8B%E6%97%85%2F</url>
    <content type="text"><![CDATA[多图预警 巴塞罗那，一直是我心心念念的目的地之一，因为那里有巴萨，有高迪，而在诺坎普看巴萨和皇马的西班牙国家德比则成了我这辈子一定要达成的目标之一。 去年双十一定完机票后就开始筹划这次行程，虽然6天时间全给了这座城，但是还是觉得少了一点。 先上一段小视频，球赛现场的视频放在后面了，不然体积太大了，腾讯不让上传。 Day 1乘坐的芬兰航空的飞机，在赫尔辛基转机，飞的时候还看到了贝加尔湖。 贝加尔湖 到巴塞罗那已经是晚上8点半了。取完行李，就往地铁站方向走，就能看到下面的自动售票机。 地铁自动售票机 机场的售票机是买不了T-10票的，而且好像也不能用T-10票，选4.6欧的BITLLET AEROPORT就行。 BITLLET AEROPORT T-10票可以在其他地铁站买，10.2欧可以坐十次，一年过期，还是比较划算的。 这张卡是纸质的，很容易折掉，我一共更换了两次，折了以后如果刷不了，可以和地铁站的工作人员或者公交司机申请更换，地铁工作人员更换的卡还是和原来的一样，公交司机更换的卡是这样的： 公交司机更换后的T-10卡 公交司机更换后的T-10卡背面 乘车次数就看背面的记录，下面这张卡一共有两条记录，也就是使用了两次。（这种记录方式总让我想起美剧里面上个世纪50年代里面用的打卡机） T-10卡背面的乘车次数 Day 2巴塞罗那属于地中海气候，一年四季阳光充足，不过我去的时候不是很巧，大部分时候都是阴雨天气，不过只要一放晴，你就能感受到地中海阳光的热情。 早上酒店窗外 第一站当然直奔诺坎普球场，地铁车门两面都会有个按钮，如果你要下车或者上车，按一下这个按钮门才打开。 圣家堂地铁站 地铁车门上的按钮 地铁出来要走一会儿才能找到诺坎普，路上会碰到其他过来朝圣的球迷，还好来的早，门口人不多。 如果仔细看的话，下面图片里面小男孩穿的是皇马球衣。 诺坎普大门口 售票处 诺坎普 诺坎普 巴萨博物馆参观门票可以在官网或者淘宝订好，打印出来或者保存在手机里面，进去的时候出示一下就行。 语音讲解器会额外收费，作为看过巴萨队史的铁粉，我很傲娇的拒绝了工作人员的推荐（其实是穷）。 入口处会给你一个纸质手环，博物馆里面有几个拍纪念照的地方会用到，最后出去的时候会把照片做成纪念册卖给你。 巴萨博物馆入口 球员身高了解一下，貌似煤老板被拉高了~ 巴萨博物馆 教父镇楼 当然少不了老马 煤老板轰进队史5000球的球衣 煤老板战靴 五座欧冠奖杯 五座欧冠奖杯 煤老板的四座金靴，今年要喜提第五座啦 煤老板的五座金球 参观完了博物馆，沿着指示牌出来就是诺坎普球场。作为全欧洲最大、世界第三大的足球场，最多能容纳99354 人，想象一下几天后9万多人在这座球场加油呐喊，那会是怎么样的壮观。 诺坎普球场 诺坎普球场 球员区域的一面墙 新闻发布会 客队球员休息室 球员通道 诺坎普 工作人员在保养草坪 媒体直播室 出口处整面墙在播放关于巴萨的视频，看得泪流满面。 球场出来就是巴萨球迷店，一共三层，在这里面买东西可以现场退税，可以选择退现金或者退到卡里面，办完手续后会给你一个信封，这个信封要去机场退税处盖章，然后扔进机场退税处边上的黄色邮筒里面。 离开诺坎普后就直奔巴特罗之家。 巴特罗之家一共去了两次，一次白天，在内部感受高迪对光和曲线的运用，一次晚上，在楼外面静静地看着它。 相比米拉之家，我更喜欢巴特罗之家，精致、小巧、丰富的细节，看过巴特罗之家再去看米拉之家反而觉得少了一些惊艳的感觉。 巴特罗之家（Casa Batlló）是建筑师安东尼·高迪同若热普-玛丽亚·茹若尔（Josep Maria Jujol）合作装修改造的一座建筑。该建筑建于1877年，在1904年到1906年间接受改造。2005年被扩充入世界遗产安东尼·高迪的建筑作品中。 巴特罗之家本身就是一个故事。一位美丽的公主被龙困在城堡里，加泰罗尼亚的英雄圣.乔治为了救出公主与龙展开了搏斗，用剑杀死了龙。龙的血变成了一朵鲜红的玫瑰花，圣乔治把它献给了公主。高迪的灵感来源于此，所以这座房子的每一个设计都有着特殊的含义。十字架形的烟囱代表英雄，鳞片状拱起的屋顶是巨龙的脊背，镶嵌彩饰的玻璃和构思独特的阳台则是面具，人骨造型的支架一点也没有给人阴森的感觉，阳光照耀下色彩缤纷的拼贴玻璃叫人眼花缭乱。 巴特罗之家 巴特罗之家 巴特罗之家 巴特罗之家 楼梯形状的灵感来自鲸鱼的鱼骨。 楼梯 楼梯 楼梯 橡木质地的楼梯扶手中间会凹陷下去，正好符合手的形状，扶上去很舒服。 楼梯扶手 楼梯扶手 楼梯扶手 所有的把手都是高迪亲自设计的，把手的形状先按照他自己手型不断做模型改进，最后才成形，手感爆表，不小心就被这些把手种了草，礼品商店里面也有卖，不过还蛮贵的，还有用这些把手做成的杯子，看着50多欧的价格最后还是没下去手，等下次再来，一定要把它们都收了，哈哈。 把手 把手 把手 把手 壁炉房 天花板上的漩涡设计 门下方会有下面这样的通风设计，这种设计灵感来源是鱼鳃。在巴特罗之家中，你可以找到很多类似的仿鱼鳃设计，比如屋顶上会增加这种设计来保证采光和通风。 仿鱼鳃的通风设计 仿鱼鳃的设计 仿鱼鳃的设计 高迪的设计大量运用的碎片马赛克装饰的墙面，这是因为，他的设计里面大多为不规则的曲线。他说直线属于人类，曲线属于上帝。所以他的设计里，大量的曲线元素只能用细碎的小瓷砖拼贴才能达到完整的贴合覆盖。 转角处的曲线 转角处的曲线 转角处的曲线 窗户 门上的字母也是高迪亲自设计的 正好巴特罗之家也在办关于Love的主题展览，所以有些地方会有一些特别的布置。 Love主题展 餐厅的屋顶 餐厅 餐厅有两个很大的窗户，通过这两个窗户可以看到露台的景色，很有意思的是，高迪在正对窗户的地方用马赛克瓷片碎片设计了两处小景观，这让我想起苏州园林里面常用的一步一景的设计。 餐厅的窗外 餐厅通往露台的门有两个骨骼形状的柱子，感觉像是因为承载力不得已而为之的一处设计。 餐厅 露台 露台 巴特罗之家的主题就是海洋和龙，在天井处，高迪由用下浅上深的蓝色贴片瓷砖，利用光线从上自下由强到弱的变化规律，使得天井看上去整体是一个色系，避免了视觉上上面亮，下面暗的不和谐感。 天井 天井 天井 天井 阁楼采用了悬链拱设计，设计的灵感来自于鲸鱼肋骨，这种悬链拱设计高迪也运用在了圣家堂上。 阁楼主要是洗衣房，这里晾晒衣服非常需要及时通风流动。将倾斜的墙面错位放置，中间留出的空隙用来通风，同时又能让外面的光线进入。而外低里高的错位位置又可以防止外面的人看到房子里面，也同时起到了防偷窥的作用。一举三得的实用设计，不可多得的美观结构。 阁楼的悬链拱 阁楼的悬链拱 阁楼的悬链拱 阁楼的楼梯 阁楼洗衣房 在看似龙背脊的顶楼天台上，矗立着四组造型奇特的烟囱。这个设计不仅具有美学层面的意义，其功能性也得到极高的保障: 在与外墙相辉映的马赛克烟囱顶上，罩子的设计保证了既是在大风天，烟雾也能顺利排出。 顶楼天台 顶楼天台 楼梯上的植物状的金属装饰 巴特罗之家的夜景也很有特色，卖个关子，毕竟这是Day Two的内容，哈哈。 巴特罗之家和米拉之家相隔不远，因为时间关系，我没有把米拉之家放到第一天的行程。 从巴特罗之家出来往前走不远就是加泰罗尼亚广场。广场过去就是著名的兰布拉大道，沿着兰布拉大道走到头就是哥伦布纪念碑。 加泰罗尼亚广场 加泰罗尼亚广场 加泰罗尼亚广场 兰布拉大道没走多远，你就能发现波盖利亚市场，这是一个菜市场，不过它又是一个超越菜市场的存在，他是欧洲最大的菜市场，在巴塞罗那是一个很有名的景点，号称“巴塞罗那的菜篮子”，在这里你可以吃到水果，蔬菜，干果，香肠，海鲜，各类鲜榨的果汁…… 有意思的是，波盖利亚市场对面有个性博物馆，二楼的窗台上放着一个梦露造型的假人，可能馆长知道“饱暖思淫欲“这个成语吧。 性博物馆 波盖利亚市场 市场里面的果汁，好喝便宜，一口气喝了两杯。水果也便宜，买了一份边吃边逛。 波盖利亚市场 波盖利亚市场 波盖利亚市场 下图是著名的西班牙火腿，花了5欧买了一份，第一口差点吐出来。。。什么鬼，这么难吃，就着果汁勉强吃了一半，剩下的都扔掉了。。。 西班牙火腿 这家是里面比较火的一家卖海鲜的摊位，本来想在这里吃，可是生意太好了，不过在大众点评和TripAdvisor上的评价不是特别好。发现他们吃生蚝都是吃生的，放点柠檬汁就直接吃。 波盖利亚市场 波盖利亚市场 兰布拉大道 兰布拉大道 加泰罗尼亚是西班牙的自治区之一，而巴塞罗那是加泰罗尼亚首府，去年10月加泰罗尼亚闹过独立，所以路上经常可以看到代表支持加泰罗尼亚独立的黄色丝带。 兰布拉大道 兰布拉大道上有很多街头艺人，造型都很别致。下面”金角大王“和“银角大王”正好离得很近，不过，大家都喜欢和“金角大王”合照，“银角大王”在一边很寂寞，可能真的只有金子才能发光吧。 兰布拉大道上的街头艺人 兰布拉大道上的街头艺人 兰布拉大道上的街头艺人 再往前走就是哥伦布纪念碑，虽然走得很累，但是不得不感叹，巴塞罗那真小。 哥伦布纪念碑 哥伦布纪念碑 哥伦布纪念碑 哥伦布纪念碑 哥伦布纪念碑 因为下雨，逛完哥伦布纪念碑就回去了。 住的地方正好在圣家堂附近，每次回去都要围着圣家堂转一圈，不停感叹，真屌啊。 特意拍了几张正在施工的图片，学土木的童鞋们可以看看，哈哈。 圣家堂施工照片 圣家堂施工照片 圣家堂施工照片 圣家堂施工照片 Day 3圣家堂的门票是在官网上订的，比淘宝买要便宜一点，而且年龄小于29周岁可以享受27欧的青年票，不得不说，年轻真好。登顶的话建议登诞生立面，这个立面是在高迪生前完工的，个人觉得也是最震撼的一个立面。 为了去圣家堂前面的公园抢拍几张照片，早上8点多就起来了。公园除了一个中国大妈团，其他没啥人。 关于圣家堂的介绍直接摘自维基百科： 圣家宗座圣殿暨赎罪殿，一般简称为圣家堂（Sagrada Família），是位于西班牙加泰罗尼亚首府巴塞罗那的天主教教堂，由安东尼·高迪设计，其高耸与独特的建筑设计，使得该教堂成为巴塞罗那最为人所知的观光景点。 圣家堂从1882年开始修建，因为是赎罪教堂，资金的来源主要靠个人捐款，捐款的多少直接影响到工程进度的快慢，所以至今还未完工，是世界上唯一尚未完工就被列为世界遗产的建筑物。虽然该教堂并非主教座堂，但教宗本笃十六世于2010年11月7日造访此教堂时将其册封为宗座圣殿。 高迪一生中43年的心血都花在这个教堂的设计上，1925年后还干脆搬到教堂的工地去住，全心全意设计教堂，直到1926年他因被电车擦撞死亡为止，一直不断的研究教堂的结构设计。同年6月12日，高迪的葬礼隆重举行，前来送葬的队伍从圣十字医院一直缓缓地延伸到了圣家堂。高迪被安葬于圣家堂的地下墓室。 这个教堂的设计带有强烈的自然色彩，高迪以很多动植物的形态为蓝本来设计教堂，更以《圣经》中的各个场景在整个建筑中如同图画一样逐幅展现，使这个教堂成为每个来访者都可以读到的一本天主教教义问答书。 这个教堂有东、西、南三个立面：“诞生立面”（位于东侧）、“受难立面”（位于西侧）和“荣耀立面”（位于南侧，尚未完工）。每个立面各建有四座钟塔，共计十二座，分别代表耶稣的十二宗徒。除此之外，建筑的中央另有六座高塔，其中四座代表圣经四福音书的作者——马太（玛窦）、马可（马尔谷）、路加以及约翰（若望），一座代表圣母玛利亚，一座代表耶稣基督。所以整个圣家堂的设计当中总共将建造十八座高塔。代表十二宗徒的十二座高塔的高度介于98.4米到117米，代表福音书作者的四座高塔为120米，代表圣母玛利亚的高塔为120米，代表耶稣基督的高塔则为170米。 大部分的设计都未在高迪生前真正建成。地下圣堂建于1889 - 1892年，“诞生立面”建于1892 - 1930年，高迪去世于1926年，“受难立面”建于1954 - 1977年，偏殿和中殿建于1978 - 2000年，“荣耀立面”还在建造当中，教堂中间的六座高塔还没开始建造。 “诞生立面”以基督的诞生为题，墙上的雕塑展现了由童贞玛利亚怀胎到基督长成的故事，因是欢迎庆祝基督诞生，以欢喜愉悦的雕塑为主。“受难立面”以基督的死亡为题，高迪为了表现受难的痛苦，设计了有棱有角的现代线条，雕刻家苏比拉克斯按照高迪留下的图稿刻出了由最后的晚餐到基督被钉十架，到基督升天的故事。 从高迪以后，现在的建筑师Jordi fauli已是第四代了，目前，三个立面已建好“诞生立面”和“受难立面”，十八座高塔已建好“诞生立面”的四座钟塔和“受难立面”的四座钟塔，还差十座高塔，整个建筑完成了将近50%，预计要在2026年完工。 圣家堂诞生立面 圣家堂受难立面 圣家堂顶上的果实分为冬夏两季水果，象征了圣灵洒向人间的果实。 圣家堂 圣家堂 圣家堂 诞生立面讲述了耶稣基督的诞生，象征着信仰、希望和仁爱。 绿色的柏树象征了生命的永恒。和平鸽象征求助于上帝的虔诚信徒。尖顶冠有希腊字母“T”–希腊语中上帝名字的首字母。 如果仔细看，树下方刻有JHS三个字母，这个字母在圣家堂的围栏和巴特罗之家中也能看到，它是拉丁文“耶稣是人类救主”的意思，J是拉丁文“耶稣”的第一个字母；H是拉丁文“人类”的第一个字母；S是拉丁文“救主”的第一个字母。 圣家堂 圣家堂 圣家堂 圣家堂 圣家堂 圣家堂 下图的雕塑描绘了在约瑟和玛利亚的保护下耶稣诞生。 圣家堂 门上的雕塑 在高迪构想中所设计的立柱应呈现树木欣欣向荣之姿兼自然流畅的外形。因此，他模仿树干的生长方式，将立柱倾斜一定角度，并以螺旋状翻转，从而避免了竖直线条的机械刻板。此外到达一定高度后，立柱会精确分叉，以支撑圣家堂中殿的拱顶。这种树状立柱我第一次接触是做南京牛首山大穹顶设计的时候，当时看到这种分叉柱的时候，感觉很新鲜，后来才知道高迪是这种设计的先驱。 根据承受重量的差异，高迪使用不同的基座与石材来建造立柱。浅红色的斑岩是承重量最高的岩石，接着是深灰色的玄武岩、蓝灰色的花岗岩和浅灰色的蒙荷依卡石。 拱顶由树状立柱汇聚而成，呈棕榈叶状–殉难的象征。树叶结构的交汇处有的凹陷，有的则凸起，缕缕光线也能由此透入。星状拱顶钻有圆孔，光线透过星星点的小洞洒入殿堂。 圣家堂 圣家堂 圣家堂 圣家堂 圣家堂 圣家堂 圣家堂 圣家堂 圣家堂平面模型 圣家堂 圣坛地下室 楼梯细部 圣家堂 从诞生立面顶部看巴塞罗那 圣家堂 圣家堂 圣家堂 与“诞生立面”反相，“受难立面”风格简朴庄严、粗糙刺目，表达了基督受难的痛苦。其西面–日落方位设置了一系列雕像群，以展现耶稣生命中最后的日子，从而令人联想起其牺牲的残酷事实。从最后的晚餐到埋葬仪式，各个场景按S型顺序再现了耶稣前往加略山的路径。 圣家堂受难立面 高迪为了支撑门廊的重量，构想出巨大的斜形立柱，状似红杉树的树干。这些雄伟的石柱加强了立面荒秃凄凉的效果。 圣家堂受难立面 下面场景之中，维罗尼卡用一块手帕扶起了耶稣流汗的脸，所以后世就流传了一方印有耶稣头像的手帕。但她雕像没有五官，目地是人们能更加注意耶稣的面庞。在这组雕像中，福音书作者的形象来源自高迪（第一张图最左边的人），而士兵头盔则是模仿米拉之家的烟囱造型，雕塑家想借此向高迪致以敬意。 圣家堂受难立面 耶稣钉死在十字架上。位于其左是跪着的玛丽·玛德莉纳及圣母玛利亚，而约翰正在安慰后者。十字架是由两根铁条所构成。竖直方向铁条的顶前端涂成了鲜红色。圆月孤独地悬挂一旁象征着夜晚。死亡由一具骷髅头代替。 圣家堂受难立面 圣家堂受难立面 下面图片中的九宫格行、列和对角线相加等于33，代表了耶稣受难时的年龄。 圣家堂受难立面 从受难立面出来后左边有个高迪建的教会学校。 教会学校 教会学校波浪形屋顶结构 教会学校里的教室 教会学校边上的地下室有个小小的博物馆，不要被门口的厕所标志迷惑了，当时心心念念想着见一下圣家堂受力结构模型，找了一圈才发现，原来还有个地下博物馆。博物馆里面可以看到一些圣家堂的历史资料、力学模型、高迪灵感来源、现在的工作室和高迪的坟墓。 圣家堂图纸 圣家堂图纸 圣家堂柱网图 下面模型是高迪制作的，也是高迪生前唯一带出去展览的模型。 圣家堂模型 高迪在圣家堂的工作室 高迪的雕像 圣家堂模型 圣家堂现在的工作室 下面这个就是多次在书本上看到的力学模型啦，圣家堂中有很多斜柱和拱，但倾斜角度和结构计算很复杂。高迪把教堂上下颠倒，用绳子表示柱子。在绳子上规律的悬挂重物。这些重物重量不同以对应不同的建筑材料。更改绳子或重物，模型的形状会得到即时的改变。 圣家堂力学模型 圣家堂一些结构灵感来源 圣家堂一些结构灵感来源 圣家堂一些结构灵感来源 圣家堂一些结构灵感来源 离开了圣家堂就直奔桂尔公园。个人觉得这个景点看点不多，不过可以感受一下，高迪在建筑规划方面所展现的设计理念。 此公园原本是一个在商业上并不成功的住宅区，开发者桂尔伯爵受到英国的花园城市运动的影响，选择这个只有少许植被的荒山（Muntanya Pelada）建造60栋花园洋房。但是最终只建成了门房，中央公园，高架走廊和几个附属用房等“公共设施”部分，但高迪自然主义理念在这里逐步成熟并得到了充分展现。 其中一座由Francesc Berenguer设计并在1904年完成后出售，由于没有买家，高迪听从桂尔的建议，用自己的储蓄买下，1906年全家入住。高迪从1906年到1926年住在这里。自1963年以来是高迪住宅博物馆（Casa Museu Gaudí）。 桂尔公园 桂尔公园 桂尔公园 桂尔公园 桂尔公园 桂尔公园 桂尔公园 桂尔公园 桂尔公园 大门口有两栋房子，有一栋排队的人蛮多的，所以我也懒得去排，就去了被改造成礼品店的那栋。 巨大的窗户 屋顶的拱 屋顶的拱 细部构造 屋子边上的围栏 高迪故居离桂尔公园参观区域不远，门票可以现场买，好像5欧。 高迪故居 高迪故居 高迪故居 高迪故居 高迪设计的家居 高迪设计的家居 高迪的卧室 高迪的祷告室 高迪故居 在桂尔公园没有呆太长时间就出来了，相对来说，看点比较少。坐公交离开桂尔公园，就直奔米拉之家。 米拉之家建于1906年至1912年间，当时是富豪佩雷·米拉先生因非常欣赏高迪为巴特略先生设计的巴特略公寓，为了和Roser Segimon 结婚，而请高迪设计的。米拉之家是高迪设计的最后一个私人住宅。它占地1,323平方米，有33个阳台，150扇窗户，3个采光中庭（2个大中庭，1个小天井）；6层住宅，1层顶楼（阁楼），1个地下停车场；共有3个立面；两个正门入口，一个在格拉西亚大道上，一个在普罗班萨街上。 米拉之家设计的特点是‘它本身建筑物的重量完全由柱子来承受，不论是内墙外墙都没有承受建筑本身的重量，建筑物本身没有主墙’，所以内部可以随意隔间改建，建筑物不会塌下来，而且，可以设计出更宽大的窗户，保证每个房间的采光。当时米拉夫妇出钱建这房子，一楼是出租的店铺，二楼叫“主楼”，屋顶挑高，在米拉夫妇在世时就住这一层楼，，一楼和二楼之间有一层“间层”，二楼之上有四层楼：三、四、五、六楼，是出租的公寓，因为高迪设计的力学结构很特别，建筑物的重量完全由柱子来承受，所以出租的每一层楼的隔间布局都不一样，三楼隔出三户住家，四楼隔出四户住家，五楼隔出四户住家，六楼隔出三户住家，每户住家占地也不一样，最大600平方米，最小290平方米。顶楼是用来调节温度，晒衣服用的。屋顶阳台则类似高迪的另一个作品桂尔公园中似蛇般的长椅，有30个奇特的烟囱，2个通风口，与6个楼梯口，塔状的楼梯口形状最大，螺旋梯里面暗藏水塔。 米拉之家最著名的是它的楼顶，所以参观顺序是直接坐电梯到顶层，然后从上到下参观。里面会展出当时不同人生活状态的场景、高迪设计的来源等。 米拉之家还有夜场票，不过不能参观内部，只能参观楼顶，而且价格也会比白天的票贵一点。白天的票建议可以傍晚的时候去，可以在米拉之家的楼顶看日落。 傍晚的米拉之家 米拉之家模型 米拉之家 米拉之家楼顶的拱结构 米拉之家楼顶的拱结构 米拉之家 米拉之家 米拉之家 米拉之家 米拉之家 米拉之家 米拉之家 米拉之家 米拉之家 米拉之家 米拉之家 米拉之家出来后，便去了当地一家有名的甜品店，叫Pastelerias Mauri，离米拉之家不远，走路大概5-10分钟，这家店从1929年开始营业，是十足的老字号，食客大都是本地人。 点了当地特色的croqueta，其实就是炸肉团，味道感觉一般，点的草莓蛋糕还能接受，不像其他店里面的甜品那么甜。吃完三文鱼面包后，我就对欧洲的面包绝望了，为啥这几天吃得所有面包都这么硬，咬在嘴里硌得慌。 这边点单的时候会给你一张卡，所有的消费都先记录在卡里面，等最后结账的时候，把卡给收银员就行。 Pastelerias Mauri Pastelerias Mauri Pastelerias Mauri Pastelerias Mauri 从Pastelerias Mauri出来后准备去Bar Mut吃顿大的，听说他家都是当季食材，进店后，我就后悔过来了，这家店没有菜单，可能没到饭点，也没啥人，我都不知道怎么说那些我想吃的东西，最后只能退出来。有兴趣的童鞋可以去试试，看网上评价还可以的。 Bar Mut 最后在米拉之家边上的一家餐厅解决了今天的晚饭。特地点了墨鱼饭，是用墨鱼汁烧的，吃完牙齿上也是黑色，第二天拉粑粑也是黑色，哈哈哈。 墨鱼饭 晚上回去的时候，正好经过巴特罗之家，夜景很赞。 巴特罗之家夜景 巴特罗之家夜景 巴特罗之家夜景 Day 4早上去圣家堂边上一个看起来很好吃的面包店买了早餐，吃完后，我发誓，这是我最后一次买面包，真的太硬了~ 早餐 早餐 吃完就坐地铁去爬蒙特惠奇山。特惠奇山高173米，而圣家堂高170米，这是因为，高迪觉得自己造的建筑不能高过上帝造的。蒙特惠奇山山顶有兴建于17世纪的蒙特惠奇城堡。1929年巴塞罗那世界博览会选址于蒙特惠奇山后，这里开始大兴土木，建成了巨大的国家宫、奥林匹克体育场、华丽的魔法喷泉及位处西侧以表现西班牙不同的建筑风格的西班牙村。 国家宫 国家宫 还没开始爬，就开始下雨，于是我开始了雨中爬山之旅。 国家宫 国家宫 奥林匹克体育场 奥林匹克体育场 奥林匹克体育场 奥林匹克体育场 这个小男孩一定是亲生的 偶遇一个大悬挑建筑 路上的花 蒙特惠奇城堡门票是3欧（29岁以下的青年票），站在上面看俯瞰整个巴塞罗那城市。 蒙特惠奇城堡是一处古军事要塞，修建于1640年，位于蒙特惠奇山的山顶。该建筑现在是巴塞罗那的市政设施。这座城堡因在1938年至1939年的西班牙内战期间是监禁及枪杀政治犯的场所而在加泰罗尼亚历史上声名狼藉。在20世纪后期，该城堡曾被用做博物馆。 帝国主义的大炮 蒙特惠奇城堡 蒙特惠奇城堡 蒙特惠奇城堡 蒙特惠奇城堡 蒙特惠奇城堡 蒙特惠奇城堡 蒙特惠奇城堡 蒙特惠奇城堡 蒙特惠奇城堡 从山上下去可以坐大巴，直接刷T-10卡就行。本来是想去毕加索博物馆，看看门口的队伍排得那么长就没进去，不过网上订票可以直接进去，不要排队。 正好巧克力博物馆离毕加索博物馆也不远，就往巧克力博物馆方向逛逛。 小巷 街头涂鸦 有意思的建筑 小巷 巴塞罗那的公寓都和下面图一样，门口很小，基本上都有电梯，电梯也很小，三四个人就能挤满。经过一家房产中心的时候特地拍了一张照片，西班牙接收买房移民，壕有兴趣可以看一下。 公寓 街头涂鸦 巧克力博物馆里面展示了各种用巧克力做雕像和巧克力的发展历史，门票就是一块巧克力。 巧克力博物馆门票 再看！再看我就吃掉你！ 巧克力博物馆 煤老板。。。 话说为什么把DC和漫威的英雄放在一起。。。 桂尔公园的蜥蜴 星战 巴萨远古神兽库巴拉 可把我牛逼坏了，让我叉会腰 冰与火之歌 夜王 临冬城 龙妈和她的龙 丁丁历险记 巴塞罗那大教堂离巧克力博物馆也不远，城市小就是好，哪里都可以走着去，哈哈。 巴塞罗那大教堂开放时间 注意教堂是时段开放的，如果保安告诉你开放的时间，最好提前15分钟过来排队，参观的人蛮多的。因为去的时间晚了，而且在下大雨，所以准备等第二天再进去。 巴塞罗那大教堂 巴塞罗那大教堂 巴塞罗那大教堂 顶部凸出的排水装置和中国古代建筑设计有点类似 巴塞罗那大教堂 巴塞罗那大教堂 围着巴塞罗那大教堂转了一圈，发现一家炒鸡好吃的意大利冰激凌店，叫Gelaaati Di Marco，在TripAdvisor上显示，该店在巴塞罗那排第八的甜品店，墙裂推荐。 Gelaaati Di Marco Gelaaati Di Marco 巴塞罗那大教堂边上的皇马official store，莫名想笑，哈哈 Day 5这一天重点当然是晚上的德比啦，所以上午懒懒散散地先挪到巴塞罗那大教堂参观一下，到的时候已经是11点多，被告知要参观等到下午2点。所以我又跑去吃了一次Gelaaati Di Marco的冰激凌，再次墙裂推荐一下。 Gelaaati Di Marco 景区附近会这种设施，貌似是直饮水系统，在蒙特惠奇山上我看到有人直接喝 正好碰上巴塞罗那大教堂的回廊是免费开放的，就进去看了一下。 巴塞罗那大教堂（Barcelona Cathedral）简称大主教堂，是巴塞罗那哥特区的一座哥特式建筑，是天主教巴塞罗那总教区的主教座堂，实际上是由康诺恩荷斯之家、德卡之家和依亚拉迪亚卡之家这三个中世纪教堂组成。 大主教堂始建于巴塞罗那最鼎盛时期的13—15世纪。从开始修建到完工共耗费了150年的时间，环绕鹅井(Fuente de las Ocas)的回廊完成于1450年。而且在随后的漫长岁月里又经过了无数次的加工，新哥特式的立面修建于19世纪。因此教堂的各部分呈现出不同的建筑风格。 教堂主体以哥特式风格为主，细长的线条是主要特色，圆顶和内部结构则显示出新哥特风格。通过教堂穹顶边的电梯可以上到教堂顶端，饱览巴塞罗那老城风光。大教堂回廊的各个祈祷室中供奉着各手工业行会的保护神。圣埃乌拉利娅礼拜堂中唱诗班的座椅、宗教壁画、雕塑和各式各样的金银器具华美夺目。此外，埃乌拉利娅圣女墓穴（她被作为“巴塞罗那保护女神”崇拜）和莱潘多基督祈祷室也值得特别留意。 巴塞罗那大教堂里面的回廊养了13只白鹅，为了纪念被罗马军人残暴杀害的埃乌拉利娅圣女，因她殉教时是13岁。 回廊 回廊 回廊 回廊 回廊 下午两点，教堂准时对外开放，门票7欧。 巴塞罗那大教堂的宗教氛围和浓厚的历史感，让它有别于圣家堂的华丽。还是特别值得一去的。 巴塞罗那大教堂 巴塞罗那大教堂 巴塞罗那大教堂 巴塞罗那大教堂 巴塞罗那大教堂 巴塞罗那大教堂 巴塞罗那大教堂 巴塞罗那大教堂 巴塞罗那大教堂 巴塞罗那大教堂 巴塞罗那大教堂 参观完巴塞罗那大教堂就回住宿的酒店，换上煤老板的战袍，准备奔赴诺坎普。 在地铁上遇上一位老爷爷，帽子上写着“Why be a tourist when you could be a far more complete person?”，很有意思的一个问题。 老爷爷也很有爱，下车等下一班地铁的时候，有个小女孩好奇地问他，这个长方形你是怎么带上去的，老爷爷就脱下来给她展示了怎么制作的。 巴塞罗那地铁上的行为艺术家 在诺坎普附近又吃了一顿海鲜饭，正好边上坐着三个皇马球迷，哈哈哈。 晚饭 国家德比 国家德比 国家德比 国家德比 赛前有媒体在做现场解说，不过比赛时会撤掉 特尔施特根赛前热身 还看到了卡洛斯，长胖了，哈哈 赛前热身的煤老板 比赛中的煤老板 苏牙第一球 一共来了97939人 煤老板在看我，哈哈哈 比赛中超嗨，球场左边球门后面是巴萨死忠区域，全称在活跃气氛高喊，虽然不知道他们唱的什么，我也跟着瞎哼哼。只要皇马球员拿球，全场就是嘘声四起，特别是拉莫斯，反正我经常听到边上小伙在骂他；只要巴萨球员解围了，全场就会送上掌声，对煤老板真的就像对待国王一样，任何对煤老板的犯规，都会引起巨大的嘘声，下半场煤老板的进球，更是全场在做五体投地的姿势。 做了一个比赛中的视频集锦，大家可以感受一下现场的氛围： 其实录了蛮多视频，但是腾讯上传视频最多2G大小，压缩后的视频效果很差，如果想看的话可以点下面的视频，有差不多整场比赛的视频： Day 6去机场选择了坐地铁转大巴，不过大巴不能刷T-10卡，只能付现金。 早上10点多的飞机，因为要办理之前在诺坎普买球衣的退税，所以提前三个小时就到机场，吐槽一下国外的效率，办理登机手续真的太慢了，而且退税多张退税单好像还很麻烦，庆幸我只有一张退税单，不过最后到达登机口时离登机时间也只剩15分钟。所以如果要退税建议提前四个小时到机场。 最后拍一张圣家堂 早上的地铁站 转车的时候碰到一处很好看的建筑 机场大巴 关于球票去年双十一定好去巴塞罗那的机票后，这段行程最不确定的因素就是球票，其他比赛还好，现场买或者官网买都比较容易而且比较便宜，但是只要是国家德比的球票，基本上都比较难买。从穷游和马蜂窝及google上搜到的信息都说票不好买： 巴萨官网购球票成功 15/03 路呆呆慢游西班牙，附球票及美食攻略（完） 巴塞罗那足球队购票指南与心得（2016年4月26日最后编辑） 这次实测，5月6号的比赛，5月4号的时候官网放出了一些票，可能因为巴萨已经夺冠了，所以还是比较好抢的。诺坎普可以容纳99354名观众，这次来了97939人，还是没有坐满。所以如果心大的话，可以比赛前一两天刷，而且会便宜很多，毕竟黄牛网站上都会加价很多。 这次比赛前刷票对我来说太冒险了，所以提前两个月两个月在viagogo上买了黄牛票，viagogo是国外的黄牛票的网站，还算靠谱，虽然也有被骗的案例。当然在黄牛票的代价就是加钱，viagogo上加钱还是蛮黑的。 进入viagogo的网站选择对应场次，然后你就可以看到类似下面的选区域的图（图是巴萨和皇家社会的比赛场次的截图），注意这个图中的价格不是最终价格，会在这个价格基础上看情况再加一个类似于代购费的费用，而且图中的价格不是官网放票的价格，也就是说最终价格要加两次价。 viagogo上选区域页面 球票有两种一种电子票还有一种纸质票，纸质票会在开赛前几天寄到你住的酒店，入住之前和酒店工作人员说一下有快递就行，电子票会直接发你邮箱。还有一种是你拿巴萨会员的会员卡直接进去看，一般会要求付200欧的押金，这种一般不会是假票，对他们来说因为假票而被巴萨取消会员资格是不可接受的。 这次比赛收到的就是电子票，一开始以为是纸质票，因为viagogo开赛前一两周提醒我核对酒店地址，我也和酒店工作人员说有我的快递，让他帮我留意一下，结果比赛前一两天给我发了电子票。。。 国家德比的电子票 在官网买的票面价是431.5欧，但是在viagogo上买价格翻了一倍还不止，真的好黑，所以如果不是德比，请在官网上买吧，还是很好买的，德比的话也可以刷一下。下面是我6号下午刷官网的价格和余票情况（注意截图的时间是西班牙时间，比赛是西班牙时间6号晚上8点半）： 官网价格 官网价格 官网价格 这张票的座位是一层的28排17号座位，是在一层最里面，所以看球比较蛋疼，不过，当时20排有几个位置没人，我就跑到前面的位置看球了。个人觉得20排的位置比较好一点，正好在二层楼下里面一点，还有电视直播画面可以看。 球场里的电视直播画面 后记都说在巴塞罗那没有被偷过就没有去过巴塞罗那，我在巴塞罗那几天包不离手，背包背前面，还是比较安全的，不过大街上背包背前面的人还蛮少的。 这次留下了一些地方没去，比如：毕加索博物馆、桂尔宫、圣保罗医院、奥林匹克港、巴塞罗那海滩、文森之家等，不过毕竟还会回来的嘛，以后煤老板退役、圣家堂完工，都要来走一遍，哈哈哈。 回来后，我决定要开始背单词了，单词量少真的很捉急，特别点餐的时候。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>足球</tag>
        <tag>旅行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何用Angular5创建一个PWA项目]]></title>
    <url>%2F2018%2F03%2F26%2F%E5%A6%82%E4%BD%95%E7%94%A8Angular5%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAPWA%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[什么是PWA PWA（Progressive Web App）利用TLS，webapp manifests和service workers使应用程序能够安装并离线使用。 换句话说，PWA就像手机上的原生应用程序，但它是使用诸如HTML5，JavaScript和CSS3之类的网络技术构建的。 如果构建正确，PWA与原生应用程序无法区分。 PWA 的主要特点包括下面三点： 可靠 - 即使在不稳定的网络环境下，也能瞬间加载并展现 体验 - 快速响应，并且有平滑的动画响应用户的操作 粘性 - 像设备上的原生应用，具有沉浸式的用户体验，用户可以添加到桌面 PWA 本身强调渐进式，并不要求一次性达到安全、性能和体验上的所有要求，开发者可以通过 PWA Checklist 查看现有的特征。 用angular5创建一个PWA项目Angular Service WorkerMDN中对service worker的定义： Service workers 本质上充当Web应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理。它们旨在（除其他之外）使得能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。他们还允许访问推送通知和后台同步API。 Angular 已经提供了ServiceWorkerModule模块来帮助我们建立一个service worker的应用。 如果是全新项目 可以使用angular/cli帮你创建一个Angular Service Worker项目： 1ng new PWA-Angular --service-worker 就这样，cli会帮你安装@angular/service-worker，在.angular-cli.json中启用serviceWorker，为app注册serviceWorker和生成默认配置的ngsw-config.json。 生成的文件中，注意检查一下app.module.ts，其中serviceWorkerModule注册的时候应该是这样： 1234imports: [ // other modules... ServiceWorkerModule.register('ngsw-worker.js', &#123;enabled: environment.production&#125;) ], @angular/cli的1.7.3版本注册的时候会在ngsw-worker.js前加一个/，会导致路径错误。 如果是已有项目 安装@angular/service-worker： 1npm install @angular/service-worker --save 在src下面新增ngsw-config.json文件： 12345678910111213141516171819202122232425262728// src/ngsw-config.json&#123; "index": "/index.html", "assetGroups": [&#123; "name": "app", "installMode": "prefetch", "resources": &#123; "files": [ "/favicon.ico", "/index.html" ], "versionedFiles": [ "/*.bundle.css", "/*.bundle.js", "/*.chunk.js" ] &#125; &#125;, &#123; "name": "assets", "installMode": "lazy", "updateMode": "prefetch", "resources": &#123; "files": [ "/assets/**" ] &#125; &#125;]&#125; 在.angular-cli.json中启用service worker： 12345678// .angular-cli.json...&#123; "apps": [&#123; ..., "serviceWorker": true &#125;]&#125; 然后在app.module.ts中注册Service Worker ： 123456789101112// src/app.module.ts...import &#123; ServiceWorkerModule &#125; from '@angular/service-worker';import &#123; environment &#125; from '../environments/environment';@NgModule(&#123; ... imports: [ ... , ServiceWorkerModule.register('ngsw-worker.js', &#123; enabled: environment.production &#125;) ],&#125;)... 这样项目中就引入Service Worker。 部署这时候我们先尝试把项目部署到github pages，因为PWA需要在HTTPS下运行，方便查看一下现在项目的PWA测试结果。 现在github上创建一个仓库，然后本地运行： 1234git add .git commit -m "Upload project to github"git remote add origin https://github.com/tc9011/PWA-Angular.gitgit push -u origin master 这样就把项目部署到了github。然后用下面命令build你的app： 1ng build --prod --base-href "/仓库名/" 为github pages 创建一个新的分支： 123git checkout -b "gh-pages"git push --set-upstream origin gh-pagesgit checkout master 这时候可以在github项目仓库的setting中看到已经published： 这时候我们需要把/dist里面的文件push到gh-pages的分支，而不是整个项目。这时候可以借助angular-cli-ghpage来实现，运行下面命令： 12npm i -g angular-cli-ghpagengh 这时候在https://tc9011.github.io/PWA-Angular中就可以看到你的项目了。 可以用Chrome DevTools中的Audits 或者Lighthouse先测试一下： 测试结果如下： 增加manifest从上面的audit结果中，有三个红色warning与manifest有关，MDN上对manifest是这么定义的： Web应用程序清单在一个JSON文本文件中提供有关应用程序的信息（如名称，作者，图标和描述）。manifest 的目的是将Web应用程序安装到设备的主屏幕，为用户提供更快的访问和更丰富的体验。 Chrome 和 Firefox 已经实现了这个功能，微软正努力在 Edge 浏览器上实现，Apple 前不久宣布在iOS11.3中会支持。具体请查阅 caniuse.com 来查看主流浏览器的支持情况。 在src文件夹下面新建一个manifest.json : 1234567891011121314151617181920212223242526272829// src/manifest.json&#123; "name": "PWA Angular", "short_name": "PWA Angular", "description": "PWA Angular", "icons": [&#123; "src": "assets/imgs/icon-128x128.png", "sizes": "128x128", "type": "image/png" &#125;, &#123; "src": "assets/imgs/icon-152x152.png", "sizes": "152x152", "type": "image/png" &#125;, &#123; "src": "assets/imgs/icon-256x256.png", "sizes": "256x256", "type": "image/png" &#125;, &#123; "src": "assets/imgs/icon-512x512.png", "sizes": "512x512", "type": "image/png" &#125;], "start_url": "index.html", "display": "standalone", "orientation": "portrait", "background_color": "#ffffff", "theme_color": "#00abff"&#125; 在.angular-cli.json中把它增加到assets中： 12345678// .angular-cli-json..."assets": [ "assets", "favicon.ico", "manifest.json"]... 在index.html中: 1234567// src/index.html&lt;meta name="mobile-web-app-capable" content="yes"&gt;&lt;meta name="apple-mobile-web-app-capable" content="yes"&gt;&lt;meta name="msapplication-starturl" content="/"&gt;&lt;meta name="theme-color" content="#00abff"&gt;&lt;link rel="manifest" href="manifest.json"&gt; 这样成功引入了manifest，这时候重新build再部署一下，用audit测试结果如下： 在Chrome DevTools的Application中，可以查看Manifest： 这时候可以看到已经有一个add to homescreen的链接： 点击后会弹出下面选项： 点击确定后，就可以在桌面上找到你的应用： JS Fallback测试结果中红色warning有一项是没有在JavaScript不可用的时候提供回退内容，可以在index.html中增加&lt;noscript&gt;标签： 12345&lt;noscript&gt; &lt;h3 style="color: #00abff; margin: 2rem;"&gt; Sorry, but app is not available without javascript &lt;/h3&gt;&lt;/noscript&gt; 这时候再测试一下： 这样一个非常简单的基于angular5的pwa项目就完成了。源码在这PWA-Angular。 参考文章 Angular Service Worker - Step-By-Step Guide for turning your Application into a PWA Creating PWA with Angular 5. Part 2: Progressifying the application Build Your First Progressive Web Application with Angular and Spring Boot]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>Angular</tag>
        <tag>PWA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】2018前端性能优化清单]]></title>
    <url>%2F2018%2F02%2F11%2F%E3%80%90%E8%AF%91%E3%80%912018%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%B8%85%E5%8D%95%2F</url>
    <content type="text"><![CDATA[本文翻译了2018前端性能优化清单的PDF简化版本，详细版本原文及其掘金翻译版可以自己去查看。 本文你将找到你可能需要考虑的前端性能问题的概述，它会确保你的响应时间快速顺畅。 准备就绪：计划和指标 建立性能文化 只要团队之间没有达成一致，性能就很难长久维持。研究客户常见的投诉，看看如何改进性能来缓解这些问题。用真实数据建立一个公司量身定制的案例研究。在设计过程中就计划好项目的加载顺序和加载过程中的取舍。 选择正确的指标 不是每个指标都一样重要。 研究哪些指标最重要：通常这将与您开始渲染最重要像素点的速度以及如何快速地为这些渲染的像素点提供输入响应有关。 优先处理客户所感知的页面加载。 交互时间，英雄渲染时间(Hero Rendering Times)，首次有效绘制（First Meaningful Paint），速度指标通常也很重要。 比最快的竞争对手快20％ 在能代表你的受众的设备上收集数据。 用真实的设备代替模拟，可以选择一台Moto G4，一台中档的三星设备或一台像Nexus 5X这样的中档设备。或者通过在受限制的CPU（5倍降速）和受限制的网络（例如，150ms 往返时延，1.5 Mbps下行速度，0.7 Mbps上行速度）下来在桌面上模拟移动端体验。 最后切换到普通的3G，4G和Wi-Fi下测试。 收集这些数据，建立一个电子表格，把这些数据削减20％，并设定你的目标（性能预算）。 与同事分享清单 确保你的团队的每个成员对清单都是熟悉的。 每个决策都对性能有影响，而且你的项目将极大地受益于前端开发人员正确地将性能价值传达给整个团队。 根据性能预算制定相关的设计决策。 设定切实的目标 100毫秒的响应时间，每秒60帧 每帧动画应该在不到16毫秒的时间内完成 - 最好是10毫秒，从而达到每秒60帧（1秒÷60 = 16.6毫秒）的效果。保持乐观的心态并聪明地使用空闲时间。 对于动画这样的高压点，在允许的情况下不要使用它，如果不允许，尽量减少使用它。预计输入延迟时间应该低于50ms。 速度指标&lt;1250，3G网络下的交互时间&lt;5s 目标是首次有效绘制时间在1秒（快速连接）以下，速度指标在1250毫秒以下。 将在3G网络下200美元Android手机作为基准线，可以在400ms 往返延时和400kbps传输速度下模拟，目标是交互时间&lt;5s，重复访问时间低于2s。 尽力去把这些值降到尽可能低。 关键负载切块= 15Kb，最大关键文件大小&lt;170Kb HTML中前14〜15Kb是最关键的负载切块，也是第一次往返（这是在400 ms 往返延时下 1秒内所得到的）预算中唯一可以交付的部分。 为达到上述目标，我们必须在关键的文件大小内进行操作。 在一般的手机上，压缩过后170Kb（解压缩后0.8-1Mb）大小的文件，解析和编译需要1秒。 确定环境 选择并配置你的构建工具 不要太在意什么是很酷的。 只要能很快得到结果，并且在构建过程中没有任何问题就可以了。 渐进增强 首先设计和构建核心体验，然后对支持高级特性的浏览器增强体验，创造弹性体验。 如果你的网站是在一个网络不佳的并且有个糟糕的显示屏上糟糕的浏览器上运行，速度还很快的话，那么，当它运行在一个快速网络下快速的浏览器的机器上，它只会运行得更快。 选择一个强劲的性能基准线 JavaScript 的代价是最大的。 在 170kb 的预算中，已经包括了关键路径的 HTML/CSS/JavaScript、路由器、状态管理、实用程序、框架和应用程序逻辑，我们必须彻底检查网络传输成本，分析/编译时间和我们选择的框架的运行时的成本。 选择明智的战斗：Angular，React，Ember等。 并不是每个项目都需要一个框架，但是如果你需要一个框架的话，可以使用一个支持服务器端渲染的框架。在建立框架之前，务必在移动设备上分别测试服务器渲染和客户端渲染模式下的启动时间。你必须清楚地了解你所依赖的框架的所有细节。PRPL 模式和应用程序 shell 体系结构。 你会使用AMP还是Instant Articles？ 如果没有他们，你可以获得良好的表现，但AMP确实提供了一个免费的内容分发网络（CDN）的性能框架，而Instant Articles将提高你在Facebook上的知名度和表现。 你也可以通过把 AMP 作为你的 PWA 数据源来构建渐进增强的 Web 体验。 明智地选择你的CDN 根据你拥有多少动态数据，你可以将部分内容外包给静态站点生成器，将其放到CDN并从中提供静态版本，从而避免数据请求。 仔细检查您的CDN是否进行内容压缩和转换，智能HTTP / 2传输和边侧包含。 构建优化 确定你的优先顺序 运行所有资产的清单（JavaScript，图像，字体，第三方脚本，页面上的“昂贵”模块），并将它们分组。 定义基本的核心体验（为传统浏览器提供完全可访问的核心内容），增强的体验（对于功能强大的浏览器而言是丰富的，完整的体验）以及额外资源（不是绝对需要而且可以被延迟加载的资源，如字体 ，轮播脚本，视频播放器，社交媒体按钮）。 考虑使用cutting-the-mustard 技术 将核心体验带到传统浏览器，并增强对现代浏览器的体验。 严格要求加载的资源：优先加载核心，对DomContentLoaded进行增强，并对Load事件进行额外处理。 但是：廉价的安卓手机主要运行 Chrome，尽管他们的内存和 CPU 有限，所以考虑功能检测设备内存的JavaScript API，并回退到“符合标准”技术。 解析JavaScript代价很高，所以应保持其较小 使用SPA，你可能需要一些时间来初始化应用程序，然后才能呈现页面。 寻找模块和技术来加速初始渲染时间（在低端移动设备上它可以轻松地提高2-5倍）。 彻底检查每一个JavaScript的依赖关系，看看你在哪里失去了初始启动时间。 考虑微小优化和逐步引导 使用服务器端渲染来获得一个快速的首次有效绘制，而且还要包含一些最小必要的 JavaScript 来保持实时交互来接近第一次的绘排。 然后，无论是按需还是时间所允许的，启动应用程序的非必要部分。 显示应用骨架而不是加载指示器。 使用 tree-shaking和code-splitting 来减少负载 tree-shaking是一种清理构建过程的方法，仅包含实际在生产中使用的代码。 code-splitting将您的代码分割为按需加载的“块”。 scope hoisting检测 import 链接并可以转换成一个内联函数，不影响代码。 可以通过WebPack使用它们。 使用提前编译器将一些客户端渲染卸载到服务器。 异步加载JavaScript 作为开发人员，我们必须用HTML中的defer和async属性明确告诉浏览器不要等待并开始渲染页面。 如果不必兼容IE 9及更低版本，那么请优先考虑defer; 否则，使用async。 静态社交分享按钮和 静态链接 来代替交互式地图。 你是否限制了第三方脚本的影响 通常一个第三方脚本通常会调用一长串脚本。 考虑通过间隔下载资源来使用service workers。 建立内容安全策略（CSP）以限制第三方脚本的影响，例如 不允许下载音频或视频。通过iframe嵌入脚本，因此脚本无法访问DOM。同时使用 sandbox 属性进一步限制。为了压测第三方，在 DevTools 上自底向上概要地检查页面的性能。 HTTP缓存标头是否设置正确 仔细检查 expires，cache-control，max-age 和其他HTTP cache 头设置正确。 一般来说，资源应该在很短的时间内（如果它们可能改变的话）或无限期地（如果它们是静态的）被缓存。 使用Cache-control: immutable，该头部针对被标记指纹的静态资源设计，以避免重新验证。 静态资源优化 使用 Brotli 还是 Zopfli 进行纯文本压缩 所有现代浏览器现在都支持Brotli，一种新的无损数据格式。 它比Gzip和Deflate更有效，压缩速度非常慢，但是解压速度很快。 在最高级别使用Brotli + Gzip预压缩静态资产，用Brotli在1-4级（动态）压缩HTML。 检查CDN上的Brotli支持。 或者，你可以考虑使用 Zopfli 的压缩算法，将数据编码为 Deflate，Gzip 和 Zlib 格式，并且设计为压缩一次可以多次下载。 图像是否正确优化 尽可能通过 srcset，sizes 和 &lt;picture&gt; 元素使用 响应式图片。通过&lt;picture&gt; 使用WebP格式的图像，或者JPEG回退或使用内容协商（使用Accept标头）来提供WebP图像。 对于关键图像，请使用渐进式JPEG，并将不必要的部分模糊（使用高斯模糊滤镜）。 Web字体是否优化 有很大可能使用 Web 网络字体，会包含没有真正被使用的字形和额外的功能。 子集的字体。 优先使用WOFF2 并使用WOFF作为后备。 立即用后备字体显示内容，然后异步加载字体 （例如 loadCSS），再按顺序切换字体。 考虑本地安装的操作系统字体。 不要忘记包含font-display: optional。如果你无法从服务器拿到字体，请务必使用 字体加载事件。 交付优化 是否优先加载关键的 CSS 收集开始渲染页面的第一个可见部分所需的所有CSS（称为 “关键CSS” 或 “上一层CSS”），并将其内联添加到页面的&lt;head&gt;中。 考虑 条件内联方法。 或者，使用HTTP/2服务器推送，但是可能需要创建 缓存监测 HTTP/2 服务器推送机制。 使用babel-preset-env转译ES2015 +特性 ES2015得到了很好的支持，可以考虑使用babel-preset-env来转译你所要支持的现代浏览器不支持的ES2015 +特性。 然后建立两个版本，一个在ES6和一个在ES5。 使用script type=&#39;module&#39;让带有ES模块的浏览器支持加载文件，而旧版浏览器可以使用脚本模块加载旧版本。 提高渲染性能 使用 CSS containment 隔离昂贵的组件。 确保在滚动页面或动画元素时没有延迟，并且每秒持续达到60帧。 如果这是不可能的，那么至少要使每秒帧数持续保持在 60 到 15 的范围。使用 CSS 的 will-change 通知浏览器哪个元素的哪个属性将要发生变化。 是否懒加载了开销很大并使用 Intersection Observer 的代码 Intersection Observer API提供了一种异步观察目标元素与祖先元素或顶层文档的视口的变化的方式。 Chrome，Firefox，Edge和 Samsung Internet都已经支持。 WebKit状态目前正在开发中。 如果不支持交叉点观察者，仍然可以 延迟加载 一个 polyfill 。 是否优化了渲染体验 不要低估感知性能的作用。 在加载资产的同时，尽量始终领先于客户，所以将很多处理放置到后台，响应会很迅速。 让客户参与进来，我们可以用骨架屏幕而不是加载指示器并添加转场/动画。 HTTP/2 准备好HTTP/2 HTTP/2得到很好的支持，并提供了性能提升。在大多数案例中，HTTP/2会让你境况更好。缺点是你必须迁移到HTTPS，并且取决于您的HTTP/1.1用户群（用户在传统操作系统或旧版浏览器上）的大小，你可能需要发送不同的版本，这需要需要你采用不同的构建流程。 正确部署HTTP/2 你需要在打包模块和并行加载许多小模块之间找到一个很好的平衡点。 将你的整个界面分解成许多小模块; 然后分组，压缩和打包它们。 发送 6-10 个包是个理想的折中（对旧版浏览器也不会太差）。 通过实验和测量来为您的网站找到合适的平衡点。 您是否使用Save-Data保存数据 Save-Data客户端提示请求头允许我们将应用程序和有效载荷为成本和性能受限的用户定制。 例如，你可以将高DPI图像请求重写为低DPI图像，删除网页字体和花哨的特效，关闭视频自动播放，服务器推送，甚至更改提供标记的方式。 确保你的服务安全性是“防弹”的 仔细检查你的安全头部被正确设置，消除已知的漏洞，检查你的证书。 确保所有外部插件和跟踪脚本都通过HTTPS加载，不允许跨站点脚本，HTTP 严格传输安全头和内容安全策略头是正确的设置。 你的服务和CDN是否支持HTTP/2 不同的服务和CDN对 HTTP/2 的支持情况不一样。 使用TLS 够快了吗？ 来查看你的可选服务，或者快速的查看你的服务的性能以及你想要其支持的特性。 是否启动了OCSP stapling 通过在你的服务上启动 OCSP stapling，你可以加速 TLS 握手。 OCSP协议不要求浏览器花时间下载然后在列表中搜索证书信息，因此缩短握手所需的时间。 你是否已采用了 IPv6 研究表明，由于“邻居”发现（NDP）和路由优化，IPv6使网站速度提高了10％到15％。 更新IPv6的DNS，以维持未来的防火墙。 只要确保在整个网络上提供双栈支持 - 它允许IPv6和IPv4同时并行运行。 毕竟，IPv6不是向后兼容的。 使用了 HPACK 压缩吗 如果你使用的是HTTP / 2，请仔细检查您的服务器是否对HTTP响应头实现 HPACK 压缩，以减少不必要的开销。 由于HTTP / 2服务器相对较新，因此可能不完全支持该规范，HPACK 就是一个例子。 可以使用 H2spec 这个伟大的（如果技术上很详细）工具来检查。 是否使用了 service workers 来缓存以及用作网络回退 网络上的性能优化不会比用户计算机上本地存储的缓存更快。 如果您的网站通过HTTPS运行，然后将静态资源缓存到service workers缓存中，并存储离线回退（甚至脱机页面），并从用户的计算机检索它们，而不是访问网络。 测试和监控 监控混合内容警告 如果你最近已经从HTTP迁移到HTTPS，请确保使用Report-URI.io等工具来监控主动和被动混合内容警告。 您还可以使用 Mixed Content Scan扫描启用HTTPS的网站以查看混合内容。 DevTools中的开发工作流程是否经过优化 选择一个调试工具，然后单击每个按钮。 确保您了解如何分析渲染性能、控制台输出以及如何调试JavaScript和编辑CSS样式。 你是否在代理浏览器和旧版浏览器中测试过 在Chrome和Firefox中测试是不够的。 看看你的网站如何在代理浏览器和旧版浏览器（包括UC Browser和Opera Mini）。 在你感兴趣的国家测量互联网速度平均值，在未来发现“大惊喜”。 测试网络节流，并仿真一个高 DPI 设备。BrowserStack 很不错，但也要在实际设备上测试。 是否启用了持续监控 良好的性能指标是被动和主动监控工具的组合。 拥有一个WebPagetest的私有实例并使用Lighthouse总是有利于快速测试，而且还可以使用RUM工具（如Calibre，SpeedCurve等）建立持续监控。 设置你自己的用户计时标记来度量和监控特定的业务指标。 速效方案这个列表非常全面，完成所有的优化可能需要一段时间。 所以如果你只有1个小时来进行重大的改进，你会怎么做？ 让我们把这一切归结为10个低挂的水果。 显然，在你开始之前和完成之后，测量结果，包括开始渲染时间以及在 3G 和电缆连接下的speed Index。 测量实际环境的体验并设定适当的目标。一个好的目标是：第一次有意义的绘制 &lt; 1 s，速度指数 &lt; 1250，在慢速的 3G 网络上的交互 &lt; 5s，对于重复访问，TTI &lt; 2s。优化渲染开始时间和交互时间。 为您的主模板准备关键的 CSS，并将其包含在页面的 &lt;head&gt; 中。（你的预算是 14 KB）。对于 CSS/JS，文件大小不超过 170 KB gzipped（解压后 0.8-1 MB）。 延迟加载尽可能多的脚本，包括您自己的和第三方的脚本——特别是社交媒体按钮、视频播放器和耗时的 JavaScript 脚本。 添加资源提示，使用 dns-lookup、preconnect、prefetch 和 preload 加速传输。 分离 web 字体，并以异步方式加载它们（或切换到系统字体）。 优化图像，并在重要页面（例如登录页面）中考虑使用 WebP。 检查 HTTP 缓存头和安全头是否设置正确。 在服务器上启用 Brotli 或 Zopfli 压缩。（如果做不到，不要忘记启用 Gzip 压缩。） 如果 HTTP/2 可用，启用 HPACK 压缩并开启混合内容警告监控。如果您正在运行 LTS，也可以启用 OCSP stapling。 在 service worker 缓存中尽可能多的缓存资产，如字体、样式、JavaScript 和图像。]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《JavaScript高级程序设计》学习笔记（九）]]></title>
    <url>%2F2018%2F02%2F07%2F%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%2F</url>
    <content type="text"><![CDATA[第二十三章： 离线应用与客户端存储 第二十四章： 最佳实践 第二十五章：新兴的API 离线应用与客户端存储所谓离线Web应用，就是在设备不能上网的情况下仍然可以运行的应用。 开发离线Web应用需要几个步骤。首先是确保应用知道设备是否能上网，以便下一步执行正确的操作。然后，应用还必须能访问一定的资源（图像、JavaScript、CSS等），只有这样才能正常工作。最后，必须有一块本地空间用于保存数据，无论能否上网都不妨碍读写。 离线监检测开发离线应用的第一步是要知道设备是在线还是离线。HTML5为此定义了一个navigator.onLine属性，这个属性为true表示设备能上网，为false表示设备离线。这个属性的关键是浏览器必须知道设备能否访问网络，从而返回正确的值。实际应用中，navigator.onLine在不同浏览器间还有些小的差异： 在Chrome和Safari中，如果浏览器连接不上局域网 (LAN)或者路由器，就是离线状态；否则就是在线状态。所以当该属性值为false的时候，你可以说浏览器不能正常联网，但如果该属性值为true的时候，并不意味着浏览器一定能连接上互联网。还有其他一些可能引起误判的原因，比如你的电脑安装了虚拟化软件，可能会有一个虚拟网卡，这时它总是会显示正常联网。因此，如果你想得到浏览器确切的联网状态，应该使用其他额外的检查手段。 在Firefox和Internet Explorer中，如果浏览器处于”脱机工作”状态，则返回 false,其他情况都返回true. Firefox 4以上和 Opera 11.10以上的版本并不检测浏览器是否能真正连接上互联网，而是在浏览器禁用”脱机工作”模式时返回true，启用时返回false。 即便如此，在请求发生错误的情况下，检测这个属性仍然是管用的： 12345if (navigator.onLine) &#123; // 正常工作&#125; else &#123; // 执行离线状态时的任务&#125; 除了navigator.onLine属性之外，为了更好地确定网络是否可用，HTML5还定义了两个事件：online和offline。当网络从离线变为在线或者从在线变成离线时，分别触发这两个事件。这两个事件在window对象上触发： 1234567EventUtil.addHandler(window, 'online', function () &#123; console.log('online');&#125;);EventUtil.addHandler(window, 'offline', function () &#123; console.log('offline');&#125;); 为了检测应用是否离线，在页面加载后，最好先通过navigator.onLine取得初始状态。然后，就是通过上述两个事件来确定网络连接状态是否变化。当上述事件触发时，navigator.onLine属性的值也会改变，不过必须要手工轮询这个属性才能检测到网络状态的变化。 应用缓存HTML5的应用缓存（application cache），或者简称为appcache，是专门为开发离线Web应用而设计的。Appcache就是从浏览器的缓存中分出来的一块缓存区。要想在这个缓存中保存数据，可以使用一个描述文件（manifest file），列出要下载和缓存的资源。下面是一个简单的描述文件示例： 12345CACHE MANIFEST#Commentfile.jsfile.css 在最简单的情况下，描述文件中列出的都是需要下载的资源，以备离线时使用。 要将描述文件与页面关联起来，可以在&lt;html&gt;中的manifest属性中指定这个文件的路径： 1&lt;html manifest="/offline.manifest"&gt; 以上代码告诉页面，/offline.manifest中包含描述文件，这个文件的MIME类型必须是text/cache-manifest。 虽然应用缓存的意图是确保离线时资源可用，但也有相应的JavaScript API让你知道它都在做什么。这个API的核心是applicationCache对象，这个对象有一个status属性，属性值是常量，表示应用缓存的如下当前状态： 应用缓存还有很多相关的事件，表示其状态的改变： 一般来讲，这些事件会随着页面加载按上述顺序依次触发。不过调用update()方法可以手工干预，让应用缓存为检查更新而触发上述事件： 1applicationCache.update(); update()一经调用，应用缓存就会去检查描述文件是否更新（触发checking事件），然后就像页面刚加载一样，继续执行后续操作。如果触发了cached事件，就说明应用缓存已经准备就绪。如果触发了updateready事件，则说明新版本的缓存已经可用，而此时需要调用swapCache()来启用新应用缓存： 123EventUtil.addHandler(applicationCache, 'updateready', function () &#123; applicationCache.swapCache();&#125;); 数据存储CookieHTTP Cookie，通常直接叫做Cookie，最初是在客户端用于存储会话信息的。该标准要求服务器对任意HTTP请求发送Set-Cookie HTTP头作为响应的一部分，其中包含会话信息。例如，这种服务器响应的头可能如下： 1234HTTP/1.1 200 OKContent-type: text/htmlSet-Cookie: name=valueOther-header: other=header-value 这个HTTP响应设置以name为名称、以value为值的一个Cookie，名称和值在传送时都必须是URL编码的。浏览器会存储这样的会话信息，并在这之后，通过为每个请求添加Cookie HTTP头将信息发送回服务器： 123GET /index.html HTTP/1.1Cookie: name=valueOther-header: other-header-value 限制Cookie在性质上是绑定在特定的域名下的。当设定了一个Cookie后，再给创建它的域名发送请求时，都会包含这个Cookie。这个限制确保了存储在Cookie中的信息只能让批准的接受者访问，而无法被其他域访问。 由于Cookie是存在客户端计算机上的，还加入了一些限制确保Cookie不会被恶意使用，同时不会赞同太多磁盘空间。每个域的Cookie总数是有限的，不过不同浏览器之间各有不同： 当超过单个域名限制之后还要再设置Cookie，浏览器就会清楚以前设置的Cookie。IE和Opera会删除最近最少使用过的Cookie，腾出空间给新设置的Cookie。FIrefox看上去好像是随机决定要清除哪个Cookie，所以要考虑Cookie限制非常重要，以免出现不可预期的后果。 浏览器中对于Cookie的尺寸也有个限制。大多数浏览器都有大约4096B（加减1）的长度限制。为了最佳的浏览器兼容性，最好将整个Cookie长度限制在4095B（包含4095B）以内。尺寸限制影响到一个域下所有的Cookie，而并非每个Cookie单独限制。 如果尝试创建超过最大尺寸限制的Cookie，那么该Cookie会被悄无声息地丢掉。注意，虽然一个字符通常占用一字节，但是多字节情况则有不同。 Cookie的构成Cookie由浏览器保存的以下几块信息构成。 名称：一个唯一确定Cookie的名称。Cookie名称是不区分大小写的，所以mycookie和MyCookie被认为是同一个Cookie。然而，实践中最好将Cookie名称看做是区分大小写的，因为某些服务器会这样处理Cookie。Cookie的名称必须是经过URL编码的 值：储存在Cookie中的字符串值。值必须被URL编码 域：Cookie对于哪个域是有效的。所有向该域发送的请求中都会包含这个Cookie信息。这个值可以包含子域，也可以不包含它。如果没有明确设定，那么这个域会被认作来自设置Cookie的那个域 路径：对于指定域中的那个路径，应该向服务器发送cookie。例如，可以指定cookie只有从http://www.tc9011.com/books/中才能访问，那么http://www.tc9011.com的页面就不会发送cookie信息，即使请求都是来自同一个域 失效时间：表示cookie何时应该被删除的时间戳（也就是，何时应该停止向服务器发送这个cookie）。默认情况下，浏览器会话结束时即将所以cookie删除，不过，也可以自己设置删除时间。这个值是个GMT格式的日期，用于指定应该删除cookie的准确时间。因此，cookie可以在浏览器关闭后依然保存在用于的机器上。如果设置的失效日期是个以前的时间，则cookie会被立刻删除 安全标志：指定后，cookie只有在使用SSL连接的时候才会发送到服务器 ，每一段信息都作为Set-Cookie头的一部分，使用分号加空格分隔每一段： 1234HTTP/1.1 200 OKContent-type: text/htmlSet-Cookie: name=value; expires=Mon, 22-Jan-07 07:10:24 GMT; domain=.tc9011.comOther-header: other=header-value 该头信息指定了一个叫做name的cookie，它会在格林威治时间2007年1月22日 7:10:24失效，同时对于www.tc9011.com和tc9011.com的任何子域都有效。 secure标志是cookie中唯一一个非名值对的部分，直接包含一个secure单词： 1234HTTP/1.1 200 OKContent-type: text/htmlSet-Cookie: name=value; domain=.tc9011.com; path=/; secureOther-header: other=header-value 尤其要注意，域、路径、失效时间和secure标识都是服务器给浏览器的指示，以指定何时应该发送cookie。这些参数并不会作为发送到服务器的cookie信息的一部分，只有名值对才会被发送。 JavaScript中的cookie在JavaScript中处理cookie有些复杂，因为其众所周知的蹩脚的接口，即BOM的document.cookie属性。这个属性的独特之处在于它会因为使用它的方式不同而表现出不同的行为。当用来获取属性值时，document.cookie返回当前页面可用的所有cookie的字符串，一系列由分号隔开的名值对： 1name1=value;name2=value2;name3=value3 所有名字和值都是经过URL编码的，所以必须使用decodeURIComponent()来解码。 当用于设置值的时候，document.cookie属性可以设置为一个新的cookie字符串。这个cookie字符串会被解释并添加到现有的cookie集合中。设置document.cookie并不会覆盖cookie，除非设置的cookie的名字已经存在。设置cookie的格式如下，和Set-Cookie头中使用的格式一样。 1name=value; expires=expiration_time; path=domain_path; domain=domain_name; secure 这些参数中，只有cookie的名字和值是必须的： 1document.cookie = 'name=tc'; 当客户端每次向服务端发送请求的时候，都会发送这个cookie；当浏览器关闭的时候，它就会被删除。虽然这段代码没问题，但因为这里正好名称和值都无需编码，所以最好每次设置cookie时都像下面一样使用encodeURIComponent()： 1document.cookie = encodeURIComponent('name') + '=' +encodeURIComponent('tc'); 要给被创建的cookie指定额外的信息，只要将参数追加到该字符串，和Set-Cookie头中的格式一样： 1document.cookie = encodeURIComponent('name') + '=' +encodeURIComponent('tc') + '; domain=.tc9011.com; path=/'; 由于JavaScript中读写cookie不是很直观，常常需要一些函数来简化cookie的功能。基本的cookie操作有三种：读取、写入和删除： 12345678910111213141516171819202122232425262728293031323334353637383940414243var CookieUtil = &#123; get: function (name) &#123; var cookieName = encodeURIComponent(name) + '=', cookieStart = document.cookie.indexOf(cookieName), cookieValue = null; if (cookieStart &gt; -1) &#123; var cookieEnd = document.cookie.indexOf(';', cookieStart); if (cookieEnd == -1) &#123; cookieEnd = document.cookie.length; &#125; cookieValue = decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd)); &#125; return cookieValue; &#125;, set: function (name, value, expires, path, domain, secure) &#123; var cookieText = encodeURIComponent(name) + '=' + encodeURIComponent(value); if (expires instanceof Date) &#123; cookieText += '; expires=' + expires.toGMTString(); &#125; if (path) &#123; cookieText += '; path=' + path; &#125; if (domain) &#123; cookieText += '; domain=' +domain; &#125; if (secure) &#123; cookieText += '; secure'; &#125; document.cookie = cookieText; &#125;, unset: function (name, path, domain, secure) &#123; this.set(name, '', new Date(0), path, domain, secure); &#125; // 没有删除已有cookie的直接方法。所以要使用相同的路径、域和安全选项再次设置cookie，并设置失效时间为过去时间&#125;; 1234567891011121314151617181920// 设置cookieCookieUtil.set('name', 'tc');CookieUtil.set('book', 'yyy');// 读取cookie值console.log(CookieUtil.get('name')); // tcconsole.log(CookieUtil.get('book')); // yyy// 删除cookieCookieUtil.unset('name');CookieUtil.unset('book');// 设置cookie，包括它的路径、域和失效日期CookieUtil.set('name', 'tc', '/books/projs/', 'www.tc9011.com', new Date('January 1, 2010'));// 删除刚刚设置的cookieCookieUtil.unset('name', '/books/projs/', 'www.tc9011.com');// 设置安全的cookieCookieUtil.set('name', 'tc', null, null, null, true); 子cookie为了绕开浏览器的单域名下的cookie数限制，一些开发人员使用了一种称为子cookie的概念。子cookie是存放在单个cookie中的更小段的数据。也就是使用cookie值来存储多个名称值对。子cookie最常见的格式如下： 1name=name1=value1&amp;name2=value2&amp;name3=value3&amp;name4=value4&amp;name5=value5 子cookie一般也以查询字符串的格式进行格式化。然后这些值可以使用单个cookie进行存储和访问。而非每个名值对使用不同的cookie存储。 为了更好地操作子cookie，必须建立一系列新方法。子cookie的解析和序列化会因子cookie的期望用途而略有不同并更加复杂些： 123456789101112131415161718192021222324252627282930313233343536373839404142var SubCookieUtil = &#123; get: function (name, subName) &#123; // 获取单个子cookie的值 var subCookies = this.getAll(name); if (subCookies) &#123; return subCookies(subName); &#125; else &#123; return null; &#125; &#125;, getAll: function (name) &#123; // 获取所有子cookie并将它们放入一个对象中返回 var cookieName = encodeURIComponent(name) + '=', cookieStart = document.cookie.indexOf(cookieName), cookieValue = null, cookieEnd, subCookies, i, parts, result = &#123;&#125;; if (cookieStart &gt; -1) &#123; cookieEnd = document.cookie.indexOf(';', cookieStart); if (cookieEnd == -1) &#123; cookieEnd = document.cookie.length; &#125; cookieValue = document.cookie.substring(cookieStart + cookieName.length, cookieEnd); if (cookieValue.length &gt; 0) &#123; subCookies = cookieValue.split('&amp;'); for (i = 0, len = subCookies.length; i &lt; len; i++) &#123; parts = subCookies[i].split('='); result[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1]); &#125; return result; &#125; &#125; return null; &#125;&#125;; 12345678910// 假设document.cookie = data=tc&amp;book=pro%20js// 取得全部子cookievar data = SubCookieUtil.getAll('data');console.log(data.name); // tcconsole.log(data.book); // pro js// 逐个获取子cookieconsole.log(SubCookieUtil.get('data', 'name')); // tcconsole.log(SubCookieUtil.get('data', 'book')); // pro js 要设置子cookie，也有两种方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344var SubCookieUtil = &#123; set: function (name, subName, value, expires, path, domain, secure) &#123; var subcookies = this.getAll(name) || &#123;&#125;; subcookies[subName] = value; this.setAll(name, subcookies, expires, path, domain, secure); &#125;, setAll: function (name, subcookies, expires, path, domain, secure) &#123; var cookieText = encodeURIComponent(name) + '=', subcookieParts = new Array(), subName; for (subName in subcookies) &#123; if (subName.length &gt; 0 &amp;&amp; subcookies.hasOwnProperty(subName)) &#123; subcookieParts.push(encodeURIComponent(subName) + '=' + encodeURIComponent(subcookies[subName])); &#125; &#125; if (subcookieParts.length &gt; 0) &#123; cookieText += subcookieParts.join('&amp;'); if (expires instanceof Date) &#123; cookieText += '; expires=' + expires.toGMTString(); &#125; if (path) &#123; cookieText += '; path=' + path; &#125; if (domain) &#123; cookieText += '; domain=' + domain; &#125; if (secure) &#123; cookieText += '; secure'; &#125; &#125; else &#123; cookieText += '; expires=' + (new Date(0)).toGMTString(); &#125; document.cookie = cookieText; &#125;&#125;; 123456789// 设置两个cookieSubCookieUtil.set('data', 'name', 'tc');SubCookieUtil.set('data', 'book', 'pro js');// 设置全部子cookie和失效日期SubCookieUtil.setAll('data', &#123;name: 'tc', book: 'pro js'&#125;, new Date('January 1, 2010'));// 修改名字的值，并修改cookie的失效日期SubCookieUtil.set('data', 'name', 'tc', new Date('February 1, 2010')); 子cookie的最后一组方法是用于删除子cookie 的，普通cookie可以通过将失效时间设置为过去的时间的方法来删除，但子cookie不能这样做。为了删除一个子cookie，首先必须获取包含在某个cookie中的所有子cookie，然后仅删除需要删除的那个子cookie，然后再将余下的子cookie的值保存为cookie的值： 12345678910111213var SubCookieUtil = &#123; unset: function (name, subName, path, domain, secure) &#123; var subcookies = this.getAll(name); if (subcookies) &#123; delete subcookies(subName); this.setAll(name, subcookies, null, path, domain, secure); &#125; &#125;, unsetAll: function (name, path, domain, secure) &#123; this.setAll(name, null, new Date(0), path, domain, secure); &#125;&#125; 12345// 仅删除名为name的子cookieSubCookieUtil.unset('data', 'name');// 删除整个cookieSubCookieUtil.unsetAll('data'); 关于cookie的思考还有一类cookie被称为HTTP专有cookie。HTTP专有cookie可以从浏览器或者服务器设置，但是只能从服务端读取，因为JavaScript无法获取HTTP专有cookie的值。 由于所有cookie都会由浏览器作为请求头发送，所以在cookie中存储大量信息会影响到特定域的请求性能。cookie信息越大，完成对服务器请求的时间也就越长。尽管浏览器对cookie进行了大小限制，不过最好还是尽可能在cookie中存储信息，以免影响性能。 web存储机制Web Storage的目的是克服由cookie带来的一些限制，当数据需要被严格控制在客户端上时，无须持续地将数据发回服务器。Web Storage的两个主要目标是： 提供一种在cookie之外存储会话数据的途经 提供一种存储大量可以跨会话存在的数据的机制 Storage类型Storage类型提供最大的存储空间来存储名值对。Storage的实例与其他对象类似，有如下方法： clear()：删除所有值，FIrefox中没有实现 getItem(name)：根据指定的名字name获取对应的值 key(index)：获得index位置处的值的名字 removeItem(name)：删除由name指定的名值对 setItem(name, value)：为指定的name设置一个对应的值 其中，getItem()、removeItem()和setItem()方法可以直接调用，也可以通过Storage对象间接调用。因为每个项目都是作为属性存储在该对象上的，所以可以通过点语法或方括号语法访问属性来读取值，设置也一样，或者通过delete操作符进行删除。不过，还是建议使用方法而不是属性来访问数据，以避免某个键会意外重写该对象上已有的成员。 还可以使用length属性来判断有多少名值对存放在Storage对象中。但无法判断对象中所有数据的大小。 sessionStorage对象sessionStorage对象存储特定于某个会话的数据，也就是该数据只保持到浏览器关闭。这个对象就像会话cookie，也会在浏览器关闭后消失。存储在sessionStorage中的数据可以跨越页面刷新而存在，同时如果浏览器支持，浏览器崩溃并重启后依然可用。 因为sessionStorage对象绑定于某个服务器会话，所以当文件在本地运行的时候是不可用的。存储在sessionStorage中的数据只能由最初给对象存储数据的页面访问到，所以对多页面应用有限制。 由于sessionStorage对象是Storage的一个实例，所以可以使用setItem()或者直接设置新的属性来存储数据： 12345// 使用方法存储数据sessionStorage.setItem('name', 'tc');// 使用属性存储数据sessionStorage.book = 'pro js'; sessionStorage中有数据时，可以用getItem()或者通过直接访问属性名来获取数据： 12345// 使用方法读取数据var name = sessionStorage.getItem('name');// 使用属性读取数据var book = sessionStorage.book; 还可以通过结合length和key()方法来迭代sessionStorage中的值： 12345for (var i = 0, len = sessionStorage.length; i &lt; len; i++) &#123; var key = sessionStorage.key(i); var value = sessionStorage.getItem(key); console.log(key + '=' + value);&#125; 还可以用for-in循环来迭代sessionStorage中的值： 1234for (var key in sessionStorage) &#123; var value = sessionStorage.getItem(key); console.log(key + '=' + value);&#125; 要从sessionStorage中删除数据，可以使用delete操作符删除对象属性，也可调用removeItem()方法： 12345// 使用delete删除一个值-在webkit中无效delete sessionStorage.name;// 使用方法删除一个值sessionStorage.removeItem('book'); sessionStorage对象应该主要用于仅针对会话的小段数据的存储。如何需要跨越会话存储数据，localStorage更为合适。 localStorage对象不能给localStorage指定任何访问规则，规则事先就设定好了。要访问同一个localStorage对象，页面必须来自同一个域名（子域名无效），使用同一种协议，在同一个端口上。 由于localStorage是Storage的实例，所以可以像sessionStorage一样来使用它： 1234567891011// 使用方法存储数据localStorage.setItem('name', 'tc');// 使用属性存储数据localStorage.book = 'pro js';// 使用方法读取数据var name = localStorage.getItem('name');// 使用属性读取数据var book = localStorage.book; 存储在localStorage中的数据保留到通过JavaScript删除或者用户清除浏览器缓存。 Storage事件对Storage对象进行任何修改，都会在文档上触发Storage事件。当通过属性或setItem()方法保存数据，使用delete操作符或removeItem()删除数据，或者调用clear()方法时，都会发送该事件。这个事件的event对象有以下属性： 123EventUtil.addHandler(document, 'storage', function (event) &#123; console.log('storage changed for ' + event.domain);&#125;); 无论对sessionStorage还是localStorage进行操作，都会触发Storage事件，但不作区分。 限制一般来说，对存储空间大小的限制都是以每个来源为单位的。换句话说。每个来源都有固定大小的空间用于保存自己的数据。 对localStorage而言，大多数桌面浏览器会设置每个来源5MB的限制。Chrome和Safari对每个来源的限制是2.5MB，而iOS版Safari和Android版WebKit的限制也是2.5MB。 对sessionStorage限制也因浏览器而异。Chrome、Safari、iOS版Safari和Android版WebKit都是2.5MB，IE8+和Opera是5MB。 IndexedDBIndexedDB是在浏览器中保存结构化数据的一种数据库。IndexedDB的思想是创建一套API，方便保存和读取JavaScript对象，同时还支持查询和搜索。 IndexedDB设计的操作完全是异步进行的。因此，大多数操作会以请求方式进行，但这些操作会在后期执行，然后如果成功则返回结果，如果失败则返回错误。差不多每一次IndexedDB操作，都需要注册onerror和onsuccess事件处理程序，以确保适当地处理结果。 在得到完整支持的情况下，IndexedDB将是一个作为API宿主的全局对象。由于API仍然可能有变化，浏览器也都使用提供商前缀，这个对象在IE10中叫msIndexedDB，在FIrefox中叫mozIndexedDB，在Chrome中叫webkitIndexedDB： 1var indexedDB = window.indexedDB || window.msIndexedDB || window.mozIndexedDB || window.webkitIndexedDB; 数据库IndexedDB就是一个数据库，最大的特色是使用对象保存数据，而不是使用表来保存数据。一个IndexedDB数据库，就是一组位于相同命名空间下的对象的集合。 使用IndexedDB第一步就是打开它，即要把数据库名传给indexDB.open()。如果传入的数据库已经存在，就会发送一个打开它的请求；如果不存在，就会发送一个创建并打开它的请求。调用indexedDB.open()会返回一个IDBRequest对象，在这个对象上可以添加onerror和onsuccess事件处理程序： 123456789var request, database;request = indexedDB.open('admin');request.onerror = function (event) &#123; console.log('something bad happened while trying to open: ' + event.target.errorCode);&#125;;request.onsuccess = function (event) &#123; database = event.target.result;&#125;; 在这两个事件处理程序中，event.target都指向request对象，因此它们可以互换使用。如果响应的是onsuccess事件处理程序，那么event.target.result中将有一个数据库实例对象，这个对象会保存在database变量中。如果发生了错误，event.target.errorCode中将保存一个错误码，表示问题的性质。以下是可能的错误码： 默认情况下，IndexedDB数据库是没有版本号的，最好一开始就为数据库指定一个版本号。可以调用setVersion()方法，传入以字符串形式表示的版本号。同样，调用这个方法也会返回一个请求对象，需要再指定事件处理程序： 1234567891011if (database.version != '1.0') &#123; request = database.setVersion('1.0'); request.onerror = function (event) &#123; console.log('something bad happened while trying to open: ' + event.target.errorCode); &#125;; request.onsuccess = function (event) &#123; console.log('database initialization complete. database name: ' + database.name + ', version: ' + database.version); &#125;&#125; else &#123; console.log('database initialization complete. database name: ' + database.name + ', version: ' + database.version);&#125; 通过这种模式，就能知道想使用的数据库是否已经设置了适当的对象存储空间。在整个web应用中，随着对数据库结构的更新和修改，可能会产生很多不同版本的数据库。 对象存储空间如果数据库版本与传入的版本不匹配，可能就需要创建一个新的对象存储空间。在创建对象存储空间之前，必须想清楚想要保存什么数据类型。 假设你要保存的用户记录由用户名、密码组成，那么保存一条记录的对象应该如下所示： 123456var user = &#123; username: '007', firstname: 'james', lastname: 'bond', password: 'foo'&#125;; 有了这个对象，很容易想到username属性可以作为这个对象存储空间的键。这个username必须全局唯一，而且大多数时候都要通过这个键来访问数据。这一点很重要，因为在创建对象存储空间时，必须指定这么一个键。 1var store = db.createObjectStore('users', &#123;keyPath: 'username'&#125;); 其中第二个参数中的keyPath属性，就是空间中将要保存的对象的一个属性，而这个属性将作为存储空间的键来使用。 可以使用add()或put()方法来向其中添加数据。这两个方法都接收一个参数，即要保存的对象，然后这个对象就会被保存到存储空间中。这两个方法的区别在空间中已经包含键值相同的对象时会体现出来。在这种情况下，add()会返回错误，而put()会重写原有对象。简单地说，可以把add()想象成插入新值，把put()想象成更新原有值。在初始化对象存储空间时，可以使用类似下面的代码： 123456var i = 0, len = user.length;while (i &lt; len) &#123; store.add(user[i++]);&#125; 每次调用add()或put()都会创建一个新的针对这个对象存储空间的更新请求。如果想验证请求是否成功完成，可以把返回的请求对象保存在一个变量中，然后再指定onerror或onsuccess事件处理程序： 12345678910111213141516// user中保存着一批用户对象var i = 0, request, requests = [], len = user.length;while (i &lt; len) &#123; request = store.add(user[i++]); request.onerror = function () &#123; // 处理错误 &#125;; request.onsuccess = function () &#123; // 处理成功 &#125;; requests.push(request);&#125; 事务跨过创建对象存储空间这一步后，接下来所有操作都是通过事务来完成的。在数据库对象上调用transaction()方法可以创建事务。任何时候，只要想读取或修改数据，都要通过事务来组织所有操作。在最简单的情况下，可以像下面这样创建事务： 1var transaction = db.transaction(); 如果没有参数，就只能通过事务来读取数据库中保存的对象。最常见的方式是传入要访问的一或多个对象存储空间。 1var transaction = db.transaction('user'); 这样就能保证只加载存储空间中的数据，以便通过事务进行访问。如果要访问多个对象存储空间，也可以在第一个参数的位置上传入字符串数组： 1var transaction = db.transaction('user', 'anotherStore'); 这些事务都是以只读方式访问数据。要修改访问方式，必须在创建事务时传入第二个参数，这个参数表示访问模式，用IDBTransaction接口定义的如下常量表示：READ_ONLY(0)表示只读，READ_WEITE(1)表示读写，VERSION_CHANGE(2)表示改变。IE10+和FIrefox4+实现的是IDBTransaction，但在Chrome中则叫webkitIDBTransaction： 1var IDBTransaction = window.IDBTransaction || window.webkitIDBtransaction; 1var transaction = db.transaction('user', IDBTransaction.READ_WRITE); 这样就能读写user的存储空间。 取得了事务的索引后，使用objectStore()方法并传入存储空间的名称，就可以访问特定的存储空间。然后，可以用add()和put()方法，使用get()可以取得值，使用delete()可以删除对象，而使用clear()则可以删除所有对象。get()和delete()方法都接收一个对象键作为参数，而这5个方法都会返回一个新的请求对象： 12345678var request = db.transaction('user').objectStore('user').get('007');request.onerror = function (event) &#123; console.log('did not get the object');&#125;;request.onsuccess = function (event) &#123; var result = event.target.result; console.log(result.firstname);&#125;; 因为一个事务可以完成任何多个请求，所以事务对象本事也有事件处理程序：onerror和oncomplete。这个事件可以提供事务级的状态信息： 123456transaction.onerror = function (event) &#123; // 整个事务都被取消了&#125;;transaction.oncomplete = function (event) &#123; // 整个事务都成功完成了&#125;; 通过oncomplete事件的事件对象event访问不到get()请求返回的任何数据，必须在相应请求的onsuccess事件处理程序中才能访问。 使用游标查询使用事务可以直接通过已知的键检索单个对象。而在需要检索多个对象的情况下，则需要在事务内部创建游标。游标是一指向结果集的指针。与传统数据库查询不同，游标并不提前收集结果。游标指针会先指向结果中的第一项，在接到查找下一项的指令时，才会指向下一项。 在对象存储空间上调用openCursor()方法可以创建游标。openCursor()方法返回的是一个请求对象，因此必须为该对象指定onsuccess和onerror事件处理程序： 123456789var store = db.transaction('user').objectStore('user'), request = store.openCursor();request.onsuccess = function (event) &#123; // 处理成功&#125;;request.onerror = function (event) &#123; // 处理失败&#125;; 在onsuccess事件处理程序执行时，可以通过event.target.result取得存储空间中的下一个对象。在结果集中有一项时，这个属性中保存一个IDBCursor的实例，在没有下一项时，这个属性的值为null。IDBCursor的实例有以下几个属性： 要检索某一个结果的信息： 123456request.onsuccess = function (event) &#123; var cursor = event.target.result; if (cursor) &#123; console.log('key: ' + cursor.key + ', value: ' + JSON.stringify(cursor.value)); &#125;&#125;; cursor.value是一个对象。 使用游标可以更新个别的记录。调用update()方法可以用指定的对象更新当前游标的value。update()方法也会创建一个新的请求，要知道结果，就要为它指定onsuccess和onerror事件处理程序： 1234567891011121314151617181920request.onsuccess = function (event) &#123; var cursor = event.target.result, value, updateRequest; if (cursor) &#123; if (cursor.key == 'foo') &#123; value = cursor.value; // 取得当前的值 value.password = 'magic'; // 更新密码 updateRequest = cursor.update(value); // 请求保存更新 updateRequest.onsuccess = function () &#123; // 处理成功 &#125;; updateRequest.onerror = function () &#123; // 处理失败 &#125;; &#125; &#125;&#125;; 此时，如果调用delete()方法，会删除相应的记录。调用delete()也返回一个请求： 1234567891011121314151617request.onsuccess = function (event) &#123; var cursor = event.target.result, value, deleteRequest; if (cursor) &#123; if (cursor.key == 'foo') &#123; deleteRequest = cursor.delete(); // 请求删除当前项 deleteRequest.onsuccess = function () &#123; // 处理成功 &#125;; deleteRequest.onerror = function () &#123; // 处理失败 &#125;; &#125; &#125;&#125;; 如果当前事务没有修改对象存储空间的权限，update()和delete()会抛出错误。 默认情况下，每个游标只发起一次请求。要想发起另一次请求，必须调用下面的一个方法： continue(key)：移动到结果集的下一项。参数key是可选的，不指定这个参数，游标移动到下一项；指定这个参数，游标会移动到指定键的位置 advance(count)：向前移动count指定的项数 这两个方法都会导致游标使用相同的请求，因此相同的onsuccess和onerror事件处理程序也会得到重用： 123456789request.onsuccess = function (event) &#123; var cursor = event.target.result; if (cursor) &#123; console.log('key: ' + cursor.key + ', value: ' + JSON.stringify(cursor.value)); cursor.continue(); // 移动到下一项 &#125; else &#123; console.log('done'); &#125;&#125;; 键范围键范围为使用游标增添了一些灵活性。键范围由IDBKeyRange的实例表示。chrome中叫webkitIDBKeyRange： 1var IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange; 有四种定义键范围的方式。第一种是使用only()方法，传入想要取得的对象的键： 1var onlyRange = IDBKeyRange.only('007'); 这个范围可以保证只取得键为007的对象。使用这个范围创建的游标与直接访问存储空间并调用get(&#39;007&#39;)差不多。 第二种方式是指定结果集的下界。下界表示游标开始的位置。例如，以下键范围可以保证游标从键为007的对象开始，然后继续向前移动，直至最后一个对象。 12// 从键为007的对象开始，然后可以移动到最后var lowerRange = IDBKeyRange.lowerBound('007'); 如果想忽略键为007的对象，从它的下一个对象开始，那么可以传入第二个参数true： 12// 从键为007的下一个对象开始，然后可以移动到最后var lowerRange = IDBKeyRange.lowerBound('007', true); 第三种方式是指定结果集的上界，也就是指定游标不能超越哪个键。指定上界使用upperRange()方法： 12// 从头开始，到键为ace的对象为止var upperRange = IDBKeyRange.upperBound('ace'); 如果不想包含键为指定值的对象，同样传入第二个参数true： 12// 从头开始，到键为ace的上一个对象为止var upperRange = IDBKeyRange.upperBound('ace', true); 第四种方式就是同时定义上下界。使用bound()方法。这个方法可以接受4个参数：表示下界的键，表示上界的键，可选的表示是否跳过下界的布尔值和可选的表示是否跳过上界的布尔值： 1234567891011// 从键为007的对象开始，到键为ace的对象为止var boundRange = IDBKeyRange.bound('007', 'ace');// 从键为007的对象的下一个对象开始，到键为ace的对象为止var boundRange = IDBKeyRange.bound('007', 'ace', true);// 从键为007的对象的下一个对象开始，到键为ace的对象的上一个对象为止var boundRange = IDBKeyRange.bound('007', 'ace', true, true);// 从键为007的对象开始，到键为ace的对象的上一个对象为止var boundRange = IDBKeyRange.bound('007', 'ace', false, true); 在定义键范围后，把它传给openCursor()方法，就能得到一个符合相应约束条件的游标： 123456789request.onsuccess = function (event) &#123; var cursor = event.target.result; if (cursor) &#123; console.log('key: ' + cursor.key + ', value: ' + JSON.stringify(cursor.value)); cursor.continue(); // 移动到下一项 &#125; else &#123; console.log('done'); &#125;&#125;; 设定游标方向openCursor()可以接收两个参数。第一个参数就是刚刚看到的IDBKeyRange的实例，第二个是表示方向的数值常量，作为第二个参数的常量是前面讲查询时介绍的IDBCursor中的常量。 1var IDBCursor = window.IDBCursor || window.webkitIDBCursor; 正常情况下，游标都是从存储空间的第一项开始，调用continue()或advance()前进到最后一项。游标的默认方向值是IDBCursor.NEXT。如果对象存储空间中有重复的项，而你想让游标跳过那些重复的项，可以为openCursor传入IDBCursor.NEXT_NO_DUPLICATE作为第二个参数： 12var store = db.transaction('user').objectStore('user'), request = store.openCursor(null, IDBCursor.NEXT_NO_DUPLICATE); openCursor()的第一个参数是null，表示使用默认的键范围，即包含所有对象。这个游标可以从存储空间中的第一个对象开始，迭代到最后一个对象，但会跳过重复的对象。 也可以创建一个游标，让它在对象存储空间中向后移动，即从最后一个对象开始，逐个迭代，直至第一个对象。此时，要传入的常量是IDBCursor.PREV和IDBCursor.PREV_NO_DUPLICATE。 12var store = db.transaction('user').objectStore('user'), request = store.openCursor(null, IDBCursor.PREV); 使用IDBCursor.PREV和IDBCursor.PREV_NO_DUPLICATE打开游标时，每次调用continue()或advance()，都会在存储空间中向后而不是向前移动游标。 索引对于某些数据，可能需要为一个对象存储空间指定多个键。比如，若要通过用户ID和用户名两种方式保存用户资料，就需要通过这两个键来存取记录。为此，可以考虑将用户ID作为主键，然后为用户名创建索引。 要创建索引，首先引用对象存储空间，然后调用createIndex()方法： 12var store = db.transaction('user').objectStore('user'), index = store.createIndex('username', 'username', &#123;unique: false&#125;); createIndex()第一个参数是索引的名字，第二个参数是索引的属性的名字，第三个参数是一个包含unique属性的选项对象。这个选项通常必须制定，因为它表示键在所有记录中是否唯一。因为username有可能存储，所有这个索引不是唯一的。 createIndex()返回值是IDBIndex的实例。在对象存储空间上调用index()方法也能返回同一个实例： 12var store = db.transaction('user').objectStore('user'), index = store.index('username'); 索引与对象存储空间很相似。在索引上调用openCursor()方法也可以创建新的游标，除了将来会把索引键而非主键保存在event.result.key属性中之外，这个游标与在对象存储空间上调用openCursor()返回的游标完全一样： 1234567var store = db.transaction('user').objectStore('user'), index = store.index('username'), request = index.openCursor();request.onsuccess = function (event) &#123; // 处理成功&#125;; 在索引上也能创建一个特殊的只返回每条记录主键的游标那就要调用openKeyCursor()方法。这个方法接收的参数与openCursor()相同。而最大的不同在于，这种情况下event.result.key中仍然保存着索引键，而event.result.value中保存的则是主键，而不再是整个对象： 12345678var store = db.transaction('user').objectStore('user'), index = store.index('username'), request = index.openKeyCursor();request.onsuccess = function (event) &#123; // 处理成功 // event.result.key中保存索引键，而event.result.value保存主键&#125;; 使用get()方法能从索引中取得一个对象，只要传入相应的索引键即可，这个方法也将返回一个请求： 1234567var store = db.transaction('user').objectStore('user'), index = store.index('username'), request = index.get('007');request.onsuccess = function (event) &#123; // 处理成功&#125;; 要根据给定的索引键取得主键，可以使用getKey()方法。这个方法会创建一个新的请求，但event.result.value等于主键，而不是包含整个对象： 12345678var store = db.transaction('user').objectStore('user'), index = store.index('username'), request = index.getKey('007');request.onsuccess = function (event) &#123; // 处理成功 // event.result.key中保存索引键，而event.result.value保存主键&#125;; 任何时候，通过IDBIndex对象的下列属性都可以取得有关索引的相关信息： 另外，通过对象存储对象的indexName属性可以访问到该空间建立的所有索引。通过下面代码可以知道根据存储的对象建立了哪些索引： 12345678910var store = db.transaction('user').objectStore('user'), indexNames = store.indexNames, index, i = 0, len = indexNames.length;while (i &lt; len) &#123; index = store.index(indexNames[i++]); console.log('index name: ' + index.name + ', keypath: ' + index.keyPath + ', unique: ' + index.unique);&#125; 在对象存储空间上调用deleteIndex()方法并传入索引的名字可以删除索引： 12var store = db.transaction('user').objectStore('user');store.deleteIndex('username'); 因为删除索引不会影响对象存储空间中的数据，所以这个操作没有任何回调函数。 并发问题如果浏览器的两个不同的标签页打开了同一个页面，那么一个页面试图更新另一个页面尚未准备就绪的数据库，并发问题就有可能发生。把数据库设置为最新版本有可能导致这个问题。因此，只有浏览器中仅有一个标签页使用数据库的情况下，调用setVersion()才能完成操作。 刚打开数据库时，记着指定onversionchange事件处理程序。当同一个来源的另一个标签页调用setVersion()时，就会执行这个回调函数，处理这个事件最佳方式是立即关闭数据库，从而保证版本更新顺利完成： 12345678910var request, database;request = indexedDB.open('admin');request.onsuccess = function (event) &#123; database = event.target.result; database.onversionchange = function () &#123; database.close(); &#125;;&#125;; 每次成功打开数据库，都应该指定onversionchange事件处理程序。 调用setVersion()时，指定请求的onblocked事件处理程序也很重要。在想要更新数据库的版本但另一个标签页已经打开数据库的情况下，就会触发这个事件处理程序。此时，最好先通知用户关闭其他标签页，然后再重新调用setVersion()： 1234567var request = database.setVersion('2.0');request.onblocked = function () &#123; alert('please close all other tabs and try again');&#125;;request.onsuccess = function () &#123; // 处理成功，继续&#125;; 其他标签页中的onversionchange事件处理程序也会执行。 限制IndexedDB数据库只能由同源页面操作，因此不能跨域共享信息。 每个来源的数据库占用磁盘空间也是有限制的。FIrefox4+上限是每个源50MB，而chrome限制是5MB。 FIrefox还有另一个限制，即不允许本地文件访问IndexedDB。chrome没有这个限制。 最佳实践可维护性什么是可维护的代码 可理解性：其他人可以接手代码并理解它的意图和一般途经，而无需原开发人员的完整解释 直观性：代码中的东西一看就能明白，不管其操作过程多复杂 可适应性：代码以一种数据上的变化不要求完全重写的方法撰写 可扩展性：在代码架构上已考虑未来允许对核心功能进行扩展 可调试性：当有错误时，代码可以给予足够信息来尽可能直接地确定问题所在。 代码约定一种让代码变得可维护的简单途经是形成一套JavaScript代码的书写约定。 可读性可读性的大部分内容都是和代码的缩进有关的。当所有人都使用一样的缩进方式时，整个项目中的代码都会更加易于阅读。通常会使用若干空格而非制表符来进行缩进，这是因为制表符在不同的文本编辑器中显示效果不同。一种不错的、很常见的缩进大小为4个空格。 可读性的另一方面是注释。JavaScript可以在代码任何地方创建函数，所以为每个函数编写文档就更加重要。一般如下地方需要进行注释： 函数和方法：每个函数或方法都应该包含一个注释，描述其目的和用于完成任务所可能使用的算法。陈述事先的假设也非常重要，比如参数代表什么。函数是否有返回值 大段代码：用于完成单个任务的多行代码应该在前面放一个描述任务的注释 复杂的算法：如果使用了一种独特的方式解决某个问题，则要在注释中解释你是如何做的 Hack：因为浏览器的差异，JavaScript代码一般会包含一些hack。需要使用一些不同的方法，那么请将这些信息放在注释中。这样可以减少出现这种情况的可能性：有人看到你的hack，然而修正了它 变量和函数名适当给变量和函数起名字对增加代码可理解性和可维护性很重要。命名的一般规则如下： 变量名应该为名词如car或person 函数名应该以动词开始，如getName()，返回布尔值类型的函数一般以is开头，如isEnable() 变量和函数都应该使用合乎逻辑的名字，不要担心长度。长度问题可以通过后处理和压缩来缓解 变量类型透明有三种表示变量数据类型的方式： 第一种是初始化。当定义了一个变量后，应该被初始化为一个值，来暗示如何应用： 12345// 通过初始化指定变量类型var found = false; // 布尔型var count = -1; // 数字var name = ''; // 字符串var person = null; // 对象 缺点是无法用于函数声明中的函数参数。 第二种是使用匈牙利标记法类指定变量类型。匈牙利标记法在变量名之前加上一个或多个字符来表示数据类型。JavaScript中最传统的匈牙利标记法是用单个字符表示基本类型：o代表对象，s代表字符串，i代表整数，f代表浮点数，b代表布尔值： 12345// 用于指定数据类型的匈牙利标记法var bFound; // 布尔型var iCount; // 整数var sName; // 字符串var oPerson; // 对象 JavaScript中用匈牙利标记法好处是函数参数一样可以使用。但缺点是让代码某种程度上难以阅读，阻碍了没有用它时代码的直观性和句子式的特质。 最后一种是使用类型注释。类型注释放在变量名右边，但是在初始化前面。这种方式是在变量旁边放一段指定类型的注释： 12345// 用于指定类型的类型注释var found /*:Boolean*/ = false;var count /*:int*/ = 10;var name /*:String*/ = 'tc';var person /*Object*/ = null; 代码注释维持了代码的整体可读性，同时注入了类型信息。类型注释的缺点是不能用多行注释一次注释一大块代码，因为类型注释也是多行注释，两者会冲突。 松散耦合只要应用的某个部分过分依赖于另一个部分，代码就是耦合过紧，难于维护。 解耦HTML/JavaScript一种常见的耦合类型就是HTML/JavaScript耦合。在Web上，HTML和JavaScript各自代表了解决方案中的不同层次：HTML是数据，JavaScript是行为。因为它们天生就需要交互，所以有多种不同的方法将这两个技术关联起来。但有一些方法会将HTML和JavaScript过于紧密地耦合在一起。 直接写在HTML的JavaScript，使用包含内联代码的&lt;script&gt;元素或者是使用HTML属性来分配事件处理程序，都是过于紧密的耦合： 1234567&lt;!--使用了&lt;script&gt;的紧密耦合的HTML和JavaScript--&gt;&lt;script&gt; document.write('hello');&lt;/script&gt;&lt;!--使用事件处理程序属性值的紧密耦合的HTML和JavaScript--&gt;&lt;input type="button" value="click me" onclick="doSomething()" /&gt; 理想情况是，HTML和JavaScript完全分离，并通过外部文件和使用DOM附加行为来包含JavaScript。 当HTML和JavaScript过于紧密的耦合在一起时，出现JavaScript错误时就要先判断错误时出现在HTML部分还是在JavaScript文件中。它还会引入和代码是否可用的相关新问题。 HTTML和JavaScript的紧密耦合也可以在相反的关系上成立：JavaScript包含了HTML： 12345// 将HTML紧密耦合到JavaScriptfunction insertMessage(msg) &#123; var container = document.getElementById('container'); container.innerHTML = '&lt;div class="msg"&gt;&lt;p class="post"&gt;' + msg +'&lt;/p&gt;' + '&lt;p&gt;&lt;em&gt;latest message above.&lt;/em&gt;&lt;/p&gt;&lt;/div&gt;';&#125; 一般来说，应该避免在JavaScript中创建大量HTML。再一次重申要保持层次的分离，这样很容易的确定错误来源。 HTML呈现应该尽可能与JavaScript保持分离。当JavaScript用于插入数据时，尽量不要直接插入标记。一般可以在页面中直接包含并隐藏标记，然后等到整个页面渲染好之后，就可以用JavaScript显示该标记，而非生成它。另一种方法是进行Ajax请求并获取更多要显示的HTML，整个方法可以让同样的渲染层（PHP、JSP、Ruby等）来输出标记，而不是直接嵌到JavaScript中。 解耦CSS/JavaScript另一个Web层则是CSS，它主要负责页面的显示。JavaScript和CSS也是非常紧密相关的。 123// css对JavaScript的紧密耦合element.style.color = 'red';element.style.backgroundColor = 'blue'; 由于CSS负责页面的显示，当显示出现任何问题时都应该只是查看CSS文件来解决。 可以通过动态更改样式类而非特定样式来实现： 12// css对JavaScript的松散耦合element.className = 'edit'; 通过只修改某个元素的CSS类，就可以让大部分样式信息严格保留在CSS中。 解耦应用逻辑/事件处理程序12345678910function handleKeyPress(event) &#123; event = EventUtil.getEvent(event); if (event.keyCode == 13) &#123; var target = EventUtil.getTarget(event); var value = 5 * parseInt(target.value); if (value &gt; 10) &#123; document.getElementById('error-msg').style.display = 'block'; &#125; &#125;&#125; 这个事件处理程序除了包含应用逻辑，还进行了事件处理。这种方式的问题有双重性。首先，除了通过事件之外就再没有方法执行应用逻辑，这让调试变得困难。如果没有发生预想的结果怎么办？是不是表示事件处理程序没有被调用还是指应用逻辑失败？其次，如果一个后续事件引发同样的应用逻辑，那就必须复制功能代码或者将带啊抽取到一个单独的函数中。 较好的方法是应用逻辑和事件处理程序相分离，这样两者分别处理各自的东西。一个事件处理程序应该从事件对象中提取相关信息，并将这些信息传送到处理应用逻辑的某个方法中： 1234567891011121314function validateValue(value) &#123; value = 5 * parseInt(value); if (value &gt; 10) &#123; document.getElementById('error-msg').style.display = 'block'; &#125;&#125;function handleKeyPress(event) &#123; event = EventUtil.getEvent(event); if (event.keyCode == 13) &#123; var target = EventUtil.getTarget(event); validateValue(target.value); &#125;&#125; 从事件处理程序中分离应用逻辑有几个好处。首先，可以更容易更改触发特定过程的事件。其次，可以在不附加到事件的情况下测试代码，使其更易创建单元测试或自动化流程。 以下是要牢记的应用和业务逻辑之间松散耦合的几条原则： 勿将event对象传给其他方法；只传来自event对象中所需的数据 任何可以在应用层面的动作都应该可以在不执行任何事件处理程序的情况下进行 任何事件处理程序都应该处理事件，然后将处理转交给应用逻辑 编程实践尊重对象所有权尊重对象所有权意思是不能修改不属于你的对象： 不要为实例或原型添加属性 不要为实例或原型添加方法 不要重定义已存在的方法 这些规则不仅仅适用于自定义类型和对象，对诸如object、string、document、window等原生类型和对象也适用。 依然可以以下方式为对象创建新的功能： 创建包含所需要功能的新对象，并用它与相关对象进行交互 创建自定义类型，继承需要进行修改的类型。然后可以为自定义类型添加额外功能 避免全局量与尊重对象所有权密切相关的是尽可能避免全局变量和函数。最多创建一个全局变量，让其他对象和函数存在其中： 12345678910111213// 两个全局量---避免var name = 'tc';function sayName() &#123; console.log(name);&#125;// 一个全局量---推荐var MyApplication = &#123; name: 'tc', sayName: function () &#123; console.log('this.name'); &#125;&#125;; 单一的全局量的延伸便是命名空间，命名空间包括创建一个用于放置功能的对象。命名空间很重要的一部分是确定每个人都同意使用的全局对象的名字，并且尽可能唯一，让其他人不太可能也使用这个名字。 123456789// 创建全局对象var Wrox = &#123;&#125;;// 为Professional JavaScript创建命名空间Wrox.ProJS = &#123;&#125;;// 将书中用到的对象附加上去Wrox.ProJS.EventUtil = &#123; ... &#125;;Wrox.ProJS.CookieUtil = &#123; ... &#125;; 命名空间有助于确保代码可以在同一页面上与其他代码以无害的方式一起工作。 避免与null进行比较直接将值与null比较是使用过度的，并且常常由于不充分的类型检查导致错误： 1234567891011function sortArray(values) &#123; if (values != null) &#123; // 避免 values.sort(comparator); &#125;&#125;function sortArray(values) &#123; if (values instanceof Array) &#123; // 推荐 values.sort(comparator); &#125;&#125; 这里if语句仅仅检查values是否为null。还有其他值也可以通过if语句，包括字符串、数字，它们也会导致函数抛出错误。 与null 比较很少适合情况而被使用。必须按照所期望的对值进行检查，而非按照不被期望的那些。 如果看到与null比较的代码，尝试使用以下技术替换： 如果值应为引用类型，使用instanceof操作符检查其构造函数 如果值应为基本类型，使用typeof检查其类型 如果是希望对象包含某个特定的方法名，则使用typeof操作符确保指定名字的方法存在于对象上 代码中null比较越少，就越容易确定代码的目的，并消除不必要的错误。 使用常量尽管JavaScript没有常量的正式概念，但它还是很有用的。这种将数据从应用逻辑分离出来的思想，可以在不冒引入错误的风险的同时，就改变数据： 123456function validate(value) &#123; if (!value) &#123; alert('invalid value!'); location.href = '/errors/invalid.php'; &#125;&#125; 要显示给用户的信息及URL有随着应用成长而改变的倾向。可以通过将数据抽取出来变成单独定义的常量的方式，将应用逻辑与数据修改隔离开来： 1234567891011var Constants = &#123; INVALID_VALUE_MSG: 'invalid value!', INVALID_VALUE_URL: '/errors/invalid.php'&#125;;function validate(value) &#123; if (!value) &#123; alert(Constants.INVALID_VALUE_MSG); location.href = Constants.INVALID_VALUE_URL; &#125;&#125; 关键在于将数据和使用它的逻辑进行分离。要注意的值的类型如下： 重复值：任何在多处用到的值都应抽取为一个常量。这就限制了当一个值变了而另一个没变的时候会造成的错误 用户界面字符串：任何用于显示给用户的字符串，都应该被抽取出来以方便国际化 URLs：在Web应用中，资源位置很容易变更，所以推荐用一个公共地方存放所有的URL 任意可能会更改的值：每当你在用到字面量值的时候，都要问一下自己这个值在未来是不是会变化，如果是，就应该提取出来作为一个常量 性能因为JavaScript最初是一个解释型语言，执行速度要比编译型语言慢得多。Chrome是第一款内置优化引擎，将JavaScript编译成本地代码的浏览器。此后，主流浏览器纷纷效仿，陆续实现了JavaScript的编译执行。 注意作用域随着作用域链中的作用域数量的增加，访问当前作用域以外的变量的时间也在增加。访问全局变量总要比访问局部变量慢，因为需要遍历作用域链。只要减少花费在作用域链上的时间，就能增加脚本的整体的性能。 避免全局查找可以优化脚本性能最重要的就是注意全局查找。使用全局变量和函数肯定要比局部的开销更大，因为要涉及作用域链上的查找： 1234567891011121314151617181920function updateUI() &#123; var imgs = document.getElementsByTagName('img'); for (var i = 0, len = imgs.length; i &lt; len; i++) &#123; imgs[i].title = document.title + ' image ' + i; &#125; var msg = document.getElementById('msg'); msg.innerHTML = 'Update complete';&#125;/***********修改后***************/function updateUI() &#123; var doc = document; var imgs = doc.getElementsByTagName('img'); for (var i = 0, len = imgs.length; i &lt; len; i++) &#123; imgs[i].title = doc.title + ' image ' + i; &#125; var msg = doc.getElementById('msg'); msg.innerHTML = 'Update complete';&#125; 将在一个函数中会多次用到的全局对象存储为局部变量总是没错的。 避免with语句在性能非常重要的地方必须避免使用with语句。和函数类似，with语句会创建自己的作用域，因此会增加其中咨询代码的作用域链的长度。由于额外的作用域链查找，在with语句中执行的代码肯定会比外面执行的代码要慢。 必须使用with语句的情况很少，因为它主要用于消除额外的字符。在大多数情况下，可以用局部变量完成相同的事情而不引入新的作用域： 1234567891011121314function updateBody() &#123; with (document.body) &#123; alert(tagName); innerHTML = 'hello'; &#125;&#125;/***********修改后***************/function updateBody() &#123; var body = document.body; alert(body.tagName); body.innerHTML = 'hello';&#125; 选择正确方法避免不必要的属性查找在计算机科学中，算法复杂度是使用O符号来表示。最简单、最快捷的算法是常数值O(1)。之后，算法变得越来越复杂并花更长时间执行。下面列出JavaScript常见算法类型： 常数值，即O(1)，指代字面值和存储在变量中的值。符号O(1)表示无论有多少个值，需要获取常量值的时间都一样。获取常量值是非常高效的过程： 123var value = 5;var sum = 10 + value;console.log(sum); 该代码进行了四次常量值查找：数字5，变量value，数字10和变量sum。这段代码的整体复杂度被认为是O(1)。 在JavaScript中访问数组元素也是一个O(1)操作，和简单的变量查找效率一样。所以下列代码和前面例子效率一样： 123var value = [5, 10];var sum = value[0] + value[1];console.log(sum); 使用变量和数组要比访问对象上的属性更有效率，后者是一个O(n)操作。对象上的任何属性查找都要比访问变量或者数组花费更长时间，因为必须在原型链中对拥有该名称的属性进行一次搜索。简而言之，属性查找越多，执行时间就越长： 123var value = &#123; first: 5, second: 10&#125;;var sum = value.first + value.second;console.log(sum); 这段代码使用两次属性查找来计算sum值。如果进行成百上千次则肯定会减慢执行速度。 注意获取单个值的多重属性查找： 1var query = window.location.href.substring(window.location.href.indexOf('?')); 这段代码有6次属性查找：window.location.href.substring()有3次，window.location.href.indexOf()有3次。只要数一数代码中点的数量，就可以确定属性查找的次数。 一旦多次用到对象属性，应该将其存储在局部变量中。第一次访问值会是O(n)，然而后续都会是O(1)，就会节省很多： 12var url = window.location.href;var query = url.substring(url.indexOf('?')); 一般来讲，只要能减少算法的复杂度，就要尽可能减少。尽可能多地使用局部变量将属性查找替换为值查找。进一步讲，如果既可以用数字化的数组位置进行访问，也可以使用命名属性。那么使用数字位置。 优化循环由于循环会反复运行同一段代码，从而自动增加执行时间。一个循环的基本优化步骤如下所示： 减值迭代：大多数循环使用一个从0开始、增加到某个特定值的迭代器。在很多情况下，从最大值开始，在循环中不断减值的迭代器更加高效 简化终止条件：由于每次循环过程都会计算终止条件，所以必须保证它尽可能快。也就是说避免属性查找或其他O(n)的操作 简化循环体：循环体是执行最多的，所以要最大限度地优化。确保没有某些可以被很容易移出循环的密集计算 使用后测试循环：最常用for循环和while循环都是前测试循环，而do-while是后测试循环，可以避免最初终止条件的计算，因此运行更快 123for (var i = 0; i &lt; value.length; i++) &#123; process(value[i]);&#125; 假设值的处理顺序无关紧要，那么循环可以改为i减值： 123for (var i = value.length - 1; i &gt;= 0; i--) &#123; process(value[i]);&#125; 变量i每次循环后都会减1。在这个过程中，将终止条件从value.length的O(n)调用简化成了0的O(1)调用。由于循环体只有一个语句，无法进一步优化。不过循环还能改成后测试循环： 123456var i = value.length - 1;if (i &gt; -1) &#123; do &#123; process(value[i]); &#125; while (--i &gt;= 0);&#125; 此时终止条件和自减操作符组合成了单个语句。 使用后测试循环时必须确保要处理的值至少有一个。空数组会导致多余的一次循环而前测试循环则可以避免 展开循环当循环的次数是确定的，消除循环并使用多次函数调用往往更快： 1234// 消除循环process(value[0]);process(value[1]);process(value[2]); 如果循环中迭代次数不能事先确定，可以考虑Duff装置的技术。Duff装置的基本概念是通过计算迭代的次数是否为8的倍数将一个循环展开为一系列语句： 123456789101112131415161718// 假设 values.length &gt; 0var iterations = Math.ceil(values.length / 8);var startAt = values.length % 8;var i = 0;do &#123; switch (startAt) &#123; case 0 : process(values[i++]); case 7 : process(values[i++]); case 6 : process(values[i++]); case 5 : process(values[i++]); case 4 : process(values[i++]); case 3 : process(values[i++]); case 2 : process(values[i++]); case 1 : process(values[i++]); &#125; startAt = 0;&#125; while (--iterations &gt; 0); Duff装置的实现是通过将values数组中元素个数除以8来计算出循环需要进行多少次迭代。然后使用取整的上限函数确保结果是整数。如果完全根据除8来进行迭代，可能会有一些不能被处理到的元素，这个数量保存在startAt变量中，首次执行该循环时，会检查startAt变量看有需要多少额外调用。例如，如果数组中有10个值，startAt则等于2，那么最开始的时候process()则只会被调用2次（执行case 2 和case 1）。在接下来的循环中，startAt被重置为0，这样之后的每次循环都会调用8次process()。展开循环可以提升大数据集的处理速度。 还有一个更快的Duff装置技术，将do-while循环分成2个单独循环： 1234567891011121314151617181920var iterations = Math.floor(values.length / 8);var leftover = values.length % 8;var i = 0;if (leftover &gt; 0 ) &#123; do &#123; process(values[i++]); &#125; while (--leftover &gt; 0); &#125;do &#123; process(values[i++]); process(values[i++]); process(values[i++]); process(values[i++]); process(values[i++]); process(values[i++]); process(values[i++]); process(values[i++]); process(values[i++]);&#125; while (--iterations &gt; 0); 在这个实现中，剩余的计算部分不会再实际循环中处理，而是在一个初始化循环中进行除以8的操作。但处理掉额外的元素，继续执行每次调用8次process()的主循环。这个方法几乎比原始的Duff装置实现快40%。 针对大数据集使用展开循环可以节省很多时间，但对于小数据集，额外的开销则可能得不偿失。它要花更多代码来完成相同的任务，如果处理的不是大数据集，一般来说并不值得。 避免双重解释JavaScript代码想解析JavaScript的时候会存在双重解释惩罚。当使用eval()函数或者是Function构造函数以及使用setTimeout()传一个字符串参数时都会发生这种情况： 12345678// 某些代码求值--避免eval('alert("hello")');// 创建新函数--避免var sayHi = new Function('alert("hello")');// 设置超时--避免setTimeout('alert("hello")', 500); 解析包含JavaScript代码的字符串是不能在初始的解析过程中完成的，因为代码是博爱饭在字符串中，也就是说JavaScript代码运行的同时必须新启动一个解析器来解析新的代码。实例化一个新的解析器有不容忽视的开销，所以这种代码要比直接解析慢得多。 123456789101112// 已修正alert('hello');// 创建新函数--已修正var sayHi = function () &#123; alert('hello');&#125;;// 设置一个超时--已修正setTimeout(function () &#123; alert('hello');&#125;, 500); 性能的其他注意事项 原生方法比较快：只要有可能，使用原生方法而不是自己用JavaScript重写一个。JavaScript中最容易被忘记的就是可以在Math对象中找到复杂的数学运算；这些方法要比任何用JavaScript写的同样方法如正弦、余弦快得多 Switch语句较快：如果有一些列复杂的if-else语句，可以转换成单个switch语句则可以得到更快的代码。还可以通过将case语句按照最可能的到最不可能的顺序进行组织，来进一步优化switch语句 位运算较快：当进行数学运算的时候，位运算操作要比任何布尔运算或者算术运算快。选择性地用位运算替换算数运算可以极大提升计算的性能，诸如取模，逻辑与和逻辑或都可以考虑用位运算来替换 最小化语句数JavaScript代码中的语句数量也影响所执行的操作速度。完成多个操作的单个语句要比完成单个操作的多个语句快。所以，要找出可以组合在一起的语句，以减少脚本整体的执行的时间。 多个变量声明12345// 4个语句---很浪费var count = 5;var color = 'blue';var values = [1, 2, 3];var now = new Date(); 在强类型语言中，不同的数据类型的变量必须在不同的语句中声明。然而在JavaScript中所有的变量都可以使用单个var语句来声明： 12345// 一个语句var count = 5, color = 'blue', values = [1, 2, 3], now = new Date(); 大多数情况下这种优化很容易做，并且要比单个变量分别声明快得多。 插入迭代值当使用迭代值（也就是在不同的位置进行增加或减少的值）的时候，尽可能合并语句： 123456var name = values[i];i++;/********修改后*********/var name = values[i++]; 使用数组和对象字面量使用构造函数或使用字面量都是可以创建数组和对象的方法。使用构造函数总是要用到更多的语句来插入元素或定义属性，而字面量可以将这些操作在一个语句中完成： 123456789101112131415161718192021222324252627// 4个语句创建和初始化数组---浪费var values = new Array();values[0] = 123;values[1] = 456;values[2] = 789;// 用4个语句创建和初始化对象--浪费var person = new Object();person.name = 'tc';person.age = 28;person.sayName = function () &#123; alert(this.name);&#125;;/*************修改后****************/// 只用一条语句创建和初始化数组var values = [123, 456, 789];// 只用一条语句创建和初始化对象var person = &#123; name: 'tc', age: 28, sayName: function () &#123; alert(this.name); &#125;&#125;; 只要可能，尽量使用数组和对象的字面量表达式方式来消除不必要的语句。 优化DOM交互在JavaScript各个方面中，DOM是最慢的一部分。DOM操作与交互要消耗大量时间，因为需要重新渲染整个页面或者某一部分。 最小化现场更新一旦需要访问的DOM部分是已经显示的页面的一部分，那么就是在进行一个现场更新。每一个更改都有一个性能惩罚。现场更新越多，代码完成执行所花的时间就越长： 123456789var list = document.getElementById('myList'), item, i;for (i = 0; i &lt; 10; i++) &#123; item = document.createElement('li'); list.appendChild(item); item.appendChild(document.createTextNode('Item ' + i));&#125; 这个操作共要完成20个现场更新。 要修正这个性能瓶颈，需要减少现场更新的数量。可以使用文档碎片来构建DOM结构，接着将其添加到List元素中。这个方式避免了现场更新和页面闪烁问题： 123456789101112var list = document.getElementById('myList'), fragment = document.createDocumentFragment(), item, i;for (i = 0; i &lt; 10; i++) &#123; item = document.createElement('li'); fragment.appendChild(item); item.appendChild(document.createTextNode('Item '+ i));&#125;list.appendChild(fragment); 文档碎片用作一个临时的占位符，放置新创建的项目。当appendChild()传入文档碎片时，只有碎片中的子节点被添加到目标，碎片本身不会被添加的。 使用innerHTML对于大的DOM更改，使用innerHTML要比标准DOM方法创建同样的DOM结构快。 当把innerHTML设置为某个值，后台会创建一个HTML解析器，然后使用内部的DOM调用来创建DOM结构，而非基于JavaScript的DOM调用。由于内部方法是编译好的而非解释执行，所以执行快得多： 123456789var list = document.getElementById('myList'), html = '', i;for (i = 0; i &lt; 10; i++) &#123; html += '&lt;li&gt;Item ' + i + '&lt;/li&gt;';&#125;list.innerHTML = html; 在使用innerHTML的关键在于最小化调用它的次数： 123456var list = document.getElementById('myList'), i;for (i = 0; i &lt; 10; i++) &#123; list.innerHTML += '&lt;li&gt;Item ' + i + '&lt;/li&gt;'; // 避免&#125; 使用事件代理页面上的事件处理程序的数量和页面响应用户交互的速度之间有个负相关。为了减轻这种惩罚，最好使用事件代理。 注意HTMLCollectionHTMLCollection对于Web应用的性能是巨大的损害。任何时候要访问HTMLCollection，都是在文档上进行查询，这个查询开销很昂贵。最小化访问HTMLCollection的次数可以极大地改进脚本的性能。 1234567891011121314151617var images = document.getElementsByTagName('img'), i, len;for (i = 0, len = images.length; i &lt; len; i++) &#123; // 处理&#125;/************修改后***************/var images = document.getElementsByTagName('img'), image, i, len;for (i = 0, len = images.length; i &lt; len; i++) &#123; image = images[i]; // 处理&#125; 编写JavaScript时，一定要知道何时返回HTMLCollection对象，这样就可以最小化访问。一下情况会返回HTMLCollection对象： 进行对getElementsByTagName()的调用 获取了元素的childNodes属性 获取元素的attributes属性 访问了特殊的集合，如document.forms、document.images等 部署构建过程写的代码不应该原封不动地放入浏览器中，因为： 知识产权问题：如果把带有完整注释的代码放到线上，别人就更容易知道你的意图，对它再利用，并且可能找到安全漏洞 文件大小：书写代码要保证容易阅读，才能更好地维护，但是对于性能不利 代码组织：组织代码要考虑到可维护性并不一定是传送给浏览器的最好方式 基于这些原因，最好给JavaScript定义一个构建过程。 构建过程始于在源控制中定义用于存储文件的逻辑结构。最好避免使用一个文件存放所有JavaScript，遵循以下面向对象语言中的典型模式：将每个对象或自定义类型分别放入其单独的文件中。这样可以确保每个文件包含最少量的代码，使其在不引入错误的情况下更容易修改。 将代码分离成多个文件只是为了提高可维护性，并非为了部署。要进行部署的时候，需要将这些源码合并为一个或几个归并文件。推荐Web应用中尽可能使用最少的JavaScript文件。通过&lt;script&gt;标记引用JavaScript文件是一个阻塞操作，当代码下载并运行的时候会停止其他所有的下载。 一旦组织好文件和目录结构，并确定哪些要出现在部署文件中，就可以创建构件系统了。 验证JSLint可以查找JavaScript代码中的语法错误以及常见的编码错误。 给开发周期添加代码验证有助于避免将来可能出现的一些错误。 压缩当谈及JavaScript文件压缩，其实在讨论两个东西：代码长度和配重（Write weight）。代码长度指的是浏览器所需要解析的字节数，配重指的是实际从服务器传送到浏览器的字节数。在今天的Web上，这两者很少相等，实际上也不应相等。 文件压缩可以使用压缩工具减少文件大小。 压缩器一般进行如下一些步骤： 删除额外的空白（包括换行） 删除所有注释 缩短变量名 HTTP压缩所有的浏览器都支持对接收的资源进行客户端压缩。这样服务器端就可以使用服务器端相关功能来压缩JavaScript文件。一个指定了文件使用了给定格式进行了压缩的HTTP头包含在了服务器相应中。接着浏览器会查看该HTTP头确定文件是否已被压缩，然后使用合适的格式进行解压缩。结果是和原来代码量相比在网络传递的字节量大大减少。 对于Apache Web服务器，有两个模块可以进行HTTP压缩：mod_gzip（Apache1.3.x）和mod_deflate（Apache2.0.x）。对于mod_gzip，可以给httpd.conf文件或者是.htaccess文件添加下面代码启动对JavaScript的自动压缩： 12# 告诉mod_gzip要包含任何以.js结尾的文件mod_gzip_item_include file \.js$ 对于mod_defate可以添加类似代码： 12# 告诉mod_defate要包含任何以.js结尾的文件AddOutputFilterByType DEFLATE application/x-javascript 减少文件的配重可以减少需要传输到浏览器的时间。 新兴的APIrequestAnimationFrame()早期动画循环在JavaScript中创建动画的典型方式，就是使用setInterval()方法来控制所有动画： 123456789(function () &#123; function updateAnimations() &#123; doAnimation1(); doAnimation2(); // 其他动画 &#125; setInterval(updateAnimations, 100);&#125;)(); 为了创建一个小型动画库，updateAnimations()方法就得不断循环地运行每个动画，并相应地改变不同元素的状态。 编写这种动画循环的关键是要知道延迟时间多长合适。循环间隔必须足够短，这样才能让不同的动画效果显得更平滑顺畅；另一方面，循环间隔还要足够长，这样才能确保浏览器有能力渲染产生的变化。大多数电脑显示器的刷新频率是60Hz，大概相当于每秒重绘60次。大多数浏览器都会对重绘操作加以限制，不超过显示器的重绘频率，因为即使超过那个频率用户体验也不会提升。 因此，最平滑动画的最佳循环间隔是1000ms/60，约等于17ms。为了适应17ms的循环间隔，多重动画可能需要加以节制，以便不会完成得太快。 虽然与使用多组setTimeout()的循环方式相比，使用setInterval()的动画循环效率更高。无论使用setInterval()还是setTimeout()都不十分精确。为它们传入的第二个参数，实际上只是指定了动画代码添加到浏览器UI线程队列中以等待执行的时间。如果队列前面已经加入了其他任务，那动画代码就要等到前面任务完成之后再执行。如果UI线程繁忙，即使把代码加入队列也不会立即执行。 循环间隔的问题知道什么时候绘制下一帧是保证动画平滑的关键。 浏览器使用的计时器的精度也会进一步恶化问题。浏览器使用的计时器并非精确到毫秒级别： mozRequestAnimationFramemozRequestAnimationFrame()告诉浏览器某些JavaScript代码将要执行动画。这样浏览器可以在运行某些代码后进行适当优化。 mozRequestAnimationFrame()方法接收一个参数，即在重绘屏幕前调用的一个函数。这个函数负责改变下一次重绘时的DOM样式。为了创建动画循环，可以像setTimeout()一样，把多个对mozRequestAnimationFrame()的调用连缀起来： 12345678910function updateProgress() &#123; var div = document.getElementById('status'); div.style.width = (parseInt(div.style.width, 10) + 5) + '%'; if (div.style.left != '100%') &#123; mozRequestAnimationFrame(updateProgress); &#125;&#125;mozRequestAnimationFrame(updateProgress); 因为mozRequestAnimationFrame()只运行一次传入的函数，因此在需要再次修改UI从而生成动画时，需要再次手工调用它。同样，也需要同时考虑什么时候停止动画。这样就能得到非常平滑顺畅的动画。 mozRequestAnimationFrame()解决了浏览器不知道JavaScript动画什么时候开始、不知道最佳循环间隔时间的问题，但不知道代码到底什么时候执行的问题呢？同样的方案也可以解决这个问题。 传递的mozRequestAnimationFrame()函数也会接收一个参数，它是一个时间码（从1970年1月1日起至今的毫秒数），表示下一次重绘的实际发生时间。mozRequestAnimationFram()会根据这个时间码设定将来的某个时刻进行重绘，而根据这个时间码，也能知道那个时刻是什么时间。然后，再优化动画效果就有了依据。 要知道距上次重绘已经过去了多长时间，可以查询mozAnimationStartTime，其中包含上一次重绘的时间码。用传入回调函数的时间码减去这个时间码，就能计算出在屏幕上重绘下一组变化之前要经过多长时间： 123456789101112131415function draw(timestamp) &#123; // 计算两次重绘的时间间隔 var diff = timestamp - startTime; // 使用diff确定下一步的绘制时间 // 把startTime重写为这一次的重绘时间 startTime = timestamp; // 重绘UI mozRequestAnimationFrame(draw);&#125;var startTime = mozAnimationStartTime;mozRequestAnimationFrame(draw); 第一次读取mozAnimationStartTime的值必须在传递给mozRequestAnimationFrame()的回调函数外面进行。如果是在回调函数内部读取mozAnimationStartTime，得到的值与传入的时间码是相等的。 webkitRequestAnimationFrame与msRequestAnimationFrameChrome和IE10+也都分别实现了webkitRequestAnimationFrame()和msRequestAnimationFrame()。和mozRequestAnimationFrame()相比，它们不会给回调函数传递时间码，因此，无法知道下一次重绘将发生在什么时间。其次，Chrome又增加了第二个可选的参数，即将要发生变化的DOM元素。知道了重绘将发生在页面中哪个特定元素的区域内，就可以将重绘限定在该区域中。 Chrome提供了一个webkitCancelAnimationFrame()，用于取消之前计划执行的重绘操作。 12345678910111213141516171819(function () &#123; function draw(timestamp) &#123; // 计算两次重绘时间间隔 var drawStart = (timestamp || Date.now()), diff = drawStart - startTime; // 使用diff确定下一步的绘制时间 // 把startTime重写为这一次的绘制时间 startTime = drawStart; // 重绘UI requestAnimationFrame(draw); &#125; var requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame, startTime = window.mozAnimationStartTime || Date.now(); requestAnimationFrame(draw);&#125;)(); Page Visibility APIPage Visibility API 就是为了让开发人员知道页面是否对用户可见而推出的。它由下面三部分组成： document.hidden：表示页面是否隐藏的布尔值。页面隐藏包括页面在后台标签中或者浏览器最小化 document.visibilityState：表示下列4个可能状态： 页面在后台标签页中或浏览器最小化 页面在前台标签页中 实际的页面已经隐藏，但用户可以看到页面的预览 页面在屏幕外执行预渲染处理 visibilitychange事件：当文档从可见变为不可见或从不可见变为可见时，触发该事件 检测是否支持这个API的最佳方式如下： 123function isHiddenSupported() &#123; return typeof (document.hidden || document.msHidden || document.webkitHidden) != 'undefined';&#125; 类似地，使用同样的模式可以检测页面是否隐藏： 12345if (document.hidden || document.msHidden || document.webkitHidden) &#123; // 页面隐藏了&#125; else &#123; // 页面未隐藏&#125; 为了在页面从可见变为不可见或从不可见变为可见时收到通知，可以侦听visibilitychange事件： 1234567891011121314151617function handleVisibilityChange() &#123; var output = document.getElementById('output'), msg; if (document.hidden || document.msHidden || document.webkitHidden) &#123; msg = 'page is now hidden. ' + (new Date()) + '&lt;br&gt;'; &#125; else &#123; msg = 'page is now visible. ' + (new Date()) + '&lt;br&gt;'; &#125; output.innerHTML += msg;&#125;// 要为两个事件都指定事件处理程序EventUtil.addHandler(document, 'msVisibilitychange', handleVisibilityChange);EventUtil.addHandler(document, 'webkitvisibiltychange', handleVisibilityChange); Geolocation API通过Geolocation API，JavaScript代码能够访问到用户的当前位置信息。当然访问之前必须得到用户的明确许可。 Geolocation API在浏览器中的实现是navigator.geolocation对象，这个对象包含3个方法。第一个方法是getCurrentPosition()，调用这个方法就会触发请求用户共享地理位置信息的对话框。这个方法接收3个参数：成功回调函数、可选的失败回调函数和可选的选项对象。 其中，成功回调函数会接收到一个Position对象参数，该对象有两个属性：coords和timestamp。而coords对象中将包含下列与位置相关的信息： latitude和longitude是大多数web应用最常用到的属性： 123navigator.geolocation.getCurrentPosition(function (position) &#123; drawMapCenterrdAt(position.coords.latitude, position.coords.longitude);&#125;); getCurrentPosition()的第二个参数，即失败回调函数，在被调用的时候也会接收到一个参数。这个参数是一个对象，包含两个属性：message和code。其中，message属性中保存着给人看的文本消息，解释为什么会出错，而code属性中保存着一个数值，表示错误的类型：用户拒绝共享(1)、位置无效(2)或者超时(3)。 123456navigator.geolocation.getCurrentPosition(function (position) &#123; drawMapCenterrdAt(position.coords.latitude, position.coords.longitude);&#125;, function (error) &#123; console.log('Error code: ' + error.code); console.log('Error message: ' + error.message);&#125;); getCurrentPosition()的第三个参数是一个选项对象，用于设定信息的类型。可以设置的选项有三个：enableHighAccuracy是一个布尔值，表示必须尽可能使用最准确的位置信息；timeout是以毫秒数表示的等待位置信息的最长时间；maximumAge表示上一次取得坐标信息的有效时间，以毫秒表示，如果时间到则重新取得新坐标信息： 12345678910navigator.geolocation.getCurrentPosition(function (position) &#123; drawMapCenterrdAt(position.coords.latitude, position.coords.longitude);&#125;, function (error) &#123; console.log('Error code: ' + error.code); console.log('Error message: ' + error.message);&#125;, &#123; enableHighAccuracy: true, timeout: 5000, maximumAge: 25000&#125;); 这三个选项时可选的，可以单独设置，也可以与其他选项一起设置。除非确实需要非常精确的信息，否则建议保持enableHighAccuracy的false值（默认值）。将这个选项设置为true需要更长的时候，而且在移动设备上还会导致消耗更多电量。如果不需要频繁更新用户位置信息，可以将maximumAge设置为Infinity，从而始终都使用上一次的坐标信息。 如果希望跟踪用户的位置，可以使用watchPosition()。这个方法接收的参数与getCurrentPosition()方法完全相同。实际上，watchPosition()与定时调用getCurrentPosition()的效果相同。在第一次调用watchPosition()方法后，会取得当前位置，执行成功回调或者错误回调，然后，watchPosition()就地等待系统发出位置已改变的信号。 调用watchPosition()会返回一个数值标识符，用于跟踪监控的操作。基于这个返回值可以取消监控操作，只要将其传递给clearWatch()方法即可： 12345678var watchId = navigator.geolocation.watchPosition(function (position) &#123; drawMapCenterrdAt(position.coords.latitude, position.coords.longitude);&#125;, function (error) &#123; console.log('Error code: ' + error.code); console.log('Error message: ' + error.message);&#125;);clearWatch(watchId); File APIHTML5在DOM中为文件输入元素添加了一个files集合。在通过文件输入字段选择了一或多个文件时，files集合中将包含一组File对象，每个File对象对应着一个文件。每个File对象都有下列只读属性： name：本地文件系统中的文件名 size：文件的字节大小 type：字符串，文件的MIME类型 lastModifiedDate：字符串，文件上一次被修改的时间 1234567891011var filesList = document.getElementById('files-list');EventUtil.addHandler(filesList, 'change', function (event) &#123; var files = EventUtil.getTarget(event).files, i = 0, len = files.length; while (i &lt; len) &#123; console.log(files[i].name + ' (' + files[i].type + ', ' + files[i].size + ' bytes)'); i++; &#125;&#125;); FileReader类型FileReader类型实现的是一种异步文件读取机制。可以把FileReader想象成XMLHTTPRequest，区别只是它读取的是文件系统。FileReader提供了如下几个方法： readAsText(file, encoding)：以纯文本形式读取文件，将读取的文本保存在result属性中。第二个参数用于指定编码类型，是可选的 readAsDataURL(file)：读取文件并将文件以数据URI的形式保存在result属性中 readAsBinaryString(file)：读取文件并将一个字符串保存在result属性中，字符串中的每个字符表示一字节 readAsArrayBuffer(file)：读取文件并将一个包含文件内容的ArrayBuffer保存在result属性中 由于读取过程是异步的，因此FileReader也提供了几个事件，其中最有用的三个事件时progress、error和load，分别表示是否读取了新数据、是否发生了错误以及是否已经读完整个文件。 每过50ms就会触发一次progress事件，通过事件对象可以获得与XHR的progress事件相同的信息（属性）：lengthComputable、loaded和total。另外，尽可能没有包含全部数据，但每次progress事件中都可以通过FileReader的result属性读取到文件内容。 由于种种原因无法读取文件，就会触发error事件。触发error事件时，相关的信息将保存到FileReader的error属性中。这个属性中将保存一个对象，该对象只有一个属性code，即错误码。这个错误码是1表示未找到文件，2表示安全性错误，3表示读取中断，4表示文件不可读，5表示编码错误。 文件加载成功后会触发laod事件；如果发生了error事件，就不会发生load事件。 1234567891011121314151617181920212223242526272829303132333435363738394041var filesList = document.getElementById('files-list');EventUtil.addHandler(filesList, 'change', function (event) &#123; var info = '', output = document.getElementById('output'), progress = document.getElementById('progress'), files = EventUtil.getTarget(event).files, type = 'default', reader = new FileReader(); if (/image/.test(files[0]).type) &#123; reader.readAsDataURL(files[0]); type = 'image'; &#125; else &#123; reader.readAsText(files[0]); type = 'text'; &#125; reader.onerror = function () &#123; output.innerHTML = 'could not read file, error code is ' + reader.error.code; &#125;; reader.onprogress = function (event) &#123; if (event.lengthComputable) &#123; progress.innerHTML = event.loaded + '/' + event.total; &#125; &#125;; reader.onload = function () &#123; var html = ''; switch (type) &#123; case 'image' : html = '&lt;img src="' + reader.result + '"&gt;'; break; case 'text' : html = reader.result; break; &#125; output.innerHTML = html; &#125;;&#125;); 如果想中断读取过程，可以调用abort()方法，这样就会触发abort事件。在触发load、error或abort事件后，会触发另一个事件loadend。loadend事件发生意味着已经读取完整的文件，或者读取时发生错误，或者读取过程被中断。 读取部分内容File对象还支持一个slice()方法，slice()方法接收两个参数：起始字节及要读取的字节数。这个方法返回一个Blob的实例，Blob是File类型的父类型。 1234567891011function blobSlice(blob, startByte, length) &#123; if (blob.slice) &#123; return blob.slice(startByte, length); &#125; else if (blob.webkitSlice) &#123; return blob.webkitSlice(startByte, length); &#125; else if (blob.mozSlice) &#123; return blob.mozSlice(startByte, length); &#125; else &#123; return null; &#125;&#125; Blob类型有一个size属性和一个type属性，而且它也支持slice()方法，以便进一步切割数据。通过FileReader也可以从Blob中读取数据： 1234567891011121314151617181920212223var filesList = document.getElementById('files-list');EventUtil.addHandler(filesList, 'change', function (event) &#123; var info = '', output = document.getElementById('output'), progress = document.getElementById('progress'), files = EventUtil.getTarget(event).files, reader = new FileReader(), blob = blobSlice(files[0], 0, 32); if (blob) &#123; reader.readAsText(blob); reader.onerror = function () &#123; output.innerHTML = 'could not read file, error code is ' + reader.error.code; &#125;; reader.onload = function () &#123; output.innerHTML = reader.result; &#125;; &#125; else &#123; alert("your browser doesn't support slice()."); &#125;&#125;); 对象URL对象URL也被称为blobURL，指的是引用保存在File或Blob中数据的URL。使用对象URL的好处是可以不必把文件内容读取到JavaScript中而直接使用文件内容。为此，只要在需要文件内容的地方提供对象URL即可。要创建对象URL，可以使用window.URL.createObjectURL()方法，并传入File或Blob对象。 1234567891011121314151617181920212223242526272829function createObjectURL(blob) &#123; if (window.URL) &#123; return window.URL.createObjectURL(blob); &#125; else if (window.webkitURL) &#123; return window.webkitURL.createObjectURL(blob); &#125; else &#123; return null; &#125;&#125;var filesList = document.getElementById('files-list');EventUtil.addHandler(filesList, 'change', function (event) &#123; var info = '', output = document.getElementById('output'), progress = document.getElementById('progress'), files = EventUtil.getTarget(event).files, reader = new FileReader(), url = createObjectURL(files[0]); if (url) &#123; if (/image/.test(files[0].type)) &#123; output.innerHTML = '&lt;img src="' + url + '"&gt;'; &#125; else &#123; output.innerHTML = 'not an image. '; &#125; &#125; else &#123; output.innerHTML = "your browser doesn\'t support object URLs." &#125;&#125;); 如果不再需要相应的数据，最好释放它占用的内容。但只要有代码在引用对象URL，内存就不会释放。要手工释放内存，可以把对象URL传给window.URL.revokeObjectURL()。 页面卸载时会自动释放对象URL占用的内存。不过，为了确保尽可能少地占用内存，最好在不需要某个对象URL时，就马上手工释放其占用的内存。 读取拖放的文件在页面上创建了自定义的放置目标后，可以从桌面上把文件拖放到该目标。与拖放一张图片或者一个链接类似，从桌面上把文件拖放到浏览器中也会触发drop事件。而且可以在event.dataTransfer.files中读取到被放置的文件，当然此时它是一个File对象，与通过文件输入字段取得的File对象一样。 1234567891011121314151617181920212223242526var droptarget = document.getElementById('droptarget');function handleEvent(event) &#123; var info = '', output = document.getElementById('output'), files, i, len; EventUtil.preventDefault(event); if (event.type == 'drop') &#123; files = event.dateTransfer.files; i = 0; len = files.length; while (i &lt; len) &#123; info += files[i].name + " (" + files[i].type + ', ' + files[i].size + 'bytes)&lt;br&gt;'; i++; &#125; output.innerHTML = info; &#125;&#125;EventUtil.addHandler(droptarget, 'dragenter', handleEvent);EventUtil.addHandler(droptarget, 'dragover', handleEvent);EventUtil.addHandler(droptarget, 'drop', handleEvent); 在drop事件中，可以通过event.dataTransfer.files读取文件信息。 使用XHR上传文件通过File API能够访问到文件内容，利用这点就可以通过XHR直接把文件上传到服务器。更好的做法是以表单提交的方式来上传文件。 这样使用FormData类型就很容易做到。首先要创建一个FormData对象，通过它调用append()方法并传入相应的File对象作为参数。然后，再把FormData对象传递给XHR的send()方法，结果与通过表单上传一模一样。 12345678910111213141516171819202122232425262728293031323334var droptarget = document.getElementById('droptarget');function handleEvent(event) &#123; var info = '', output = document.getElementById('output'), files, i, len; EventUtil.preventDefault(event); if (event.type == 'drop') &#123; data = new FormData(); files = event.dateTransfer.files; i = 0; len = files.length; while (i &lt; len) &#123; data.append('file' + i, files[i]); i++; &#125; xhr = new XMLHttpRequest(); xhr.open('post', 'FileAPIExample06Upload.php', true); xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4) &#123; console.log(xhr.responseText); &#125; &#125;; xhr.send(data); &#125;&#125;EventUtil.addHandler(droptarget, 'dragenter', handleEvent);EventUtil.addHandler(droptarget, 'dragover', handleEvent);EventUtil.addHandler(droptarget, 'drop', handleEvent); 使用FormData上传文件，在服务端就好像接收到了常规的表单数据一样，一切按部就班地处理即可。 Web计时Web Timing API让开发者通过JavaScript就能使用浏览器内部的性能度量结果，通过直接读取这些信息可以做任何想做的分析。 Web计时机制的核心是window.performance对象。对页面的所有度量信息，都包含在这个对象里面。 performance.navigation属性是一个对象，包含与页面导航有关的多个属性： performance.timing属性也是一个对象，但这个对象的属性都是时间戳，不同事件会产生不同的时间值： Web Workers长时间运行的JavaScript进程会导致浏览器冻结用户界面，让人感觉屏幕冻结了。Web Workers规范让JavaScript在后台运行解决了这个问题。 使用Worker实例化Worker对象并传入要执行的JavaScript文件名就可以创建一个新的Web Worker： 1var worker = new Worker('stufftodo.js'); 这行代码会导致浏览器下载stufftodo.js，但只有Worker接收到消息才会实际执行文件中的代码。要给Worker传递消息，可以使用postMessage()方法： 1worker.postMessage('start! '); 消息内容可以是任何能够被序列化的值，不过与XDM（跨文档消息传送）不同的是，在所有支持的浏览器中，postMessage()都能接收对象参数。因此，可以随便传递任何形式的对象数据： 1234worker.postMessage(&#123; type: 'command', message: 'start!'&#125;); 一般来说，可以序列化为JSON结构的任何值都可以作为参数传递给postMessage()。这就意味着传入的值是被复制到Worker中，而非直接传过去的。 Worker是通过message和error事件与页面通信的。这里的message事件与XDM中的message事件行为相同，来自Worker的数据保存在event.data中。Worker返回的数据也可以是任何能够被序列化的值： 12345worker.onmessage = function (event) &#123; var data = event.data; // 对数据进行处理&#125; Worker不能完成给定的任务时会触发error事件。具体来说，Worker内部的JavaScript在执行过程中只要遇到错误，就会触发error事件。发生error事件时，事件对象中包含三个属性：filename、lineno和message，分别表示发生错误的文件名、代码行号和完整的错误信息。 123worker.onerror = function (event) &#123; console.log('error: ' + event.filename + ' (' + event.lineno + '); ' + event.message);&#125;; 建议始终要使用onerror事件处理程序，否则，Worker就会在发生错误时，悄无声息地失败了。 任何时候，只要调用terminate()方法就可以停止Worker的工作。而且，Worker中的代码就会立即停止执行，后续的所有过程都不会再发生（包括error和message事件也不会再触发）。 1worker.terminate(); // 立即停止Worker的工作 Worker全局作用域关于Web Worker，最重要的是要知道它所执行的JavaScript代码完全在另一个作用域中，与当前网页中的代码不共享作用域。在Web Worker中，同样忧郁哥全局对象和其他对象以及方法。但在Web Worker中的代码不能访问DOM，也无法通过任何方式影响页面的外观。 Web Worker中的全局对象是worker对象本事，也就是说，在这个特殊的全局作用域中，this和self引用的都是worker对象。为了便于处理数据，Web Worker本身也是一个最小化的运行环境。 显然，和页面环境相比，功能是相当有限的。 当页面在Worker对象上调用postMessage()时，数据会以异步方式被传递给worker，进而触发worker中的message事件。为了处理来自页面的数据，同样也需要创建一个onmessage事件处理程序。 123456// web worker 内部的代码self.onmessage = function (event) &#123; var data = event.data; // 处理数据&#125;; Worker完成工作以后，通过调用postMessage()可以把数据再发回页面： 12345678910// web worker 内部的代码self.onmessage = function (event) &#123; var data = event.data; // 别忘了，默认的sort()方法只比较字符串 data.sort(function (a, b) &#123; return a - b; &#125;); self.postMessage(data);&#125;; 传递消息就是页面与Worker相互之间通信的方式。在Worker中调用postMessage()会以异步方式触发页面中Worker实例的message事件。如果页面想使用这个Worker，可以这样： 123456789101112// 在页面中var data = [23, 4, 7, 9, 2, 14, 6, 651, 87, 41, 7798, 24], worker = new Worker('WebWorker.js');worker.onmessage = function (event) &#123; var data = event.data; // 对排序后的数组进行操作&#125;;// 将数组发送给worker排序worker.postMessage(data); 在Worker内部，调用close()方法也可以停止工作。就像在页面中调用terminate()方法一样，Worker停止工作以后就不会再有事件发生了。 12// web worker 内部的代码self.close(); 包含其他脚本Worker的全局作用域提供importScripts()方法，这个方法接收一个或多个指向JavaScript文件的URL。每个加载过程都是异步进行的，因此所有脚本加载并执行之后，importScripts()才会执行： 12// web worker内部的代码importScripts('file1.js', 'file2.js'); 即使file2.js先于file1.js下载完，执行的时候仍然会按照先后顺序执行。而且，这些脚本是在Worker的全局作用域中执行，如果脚本中包含与页面有关的JavaScript代码，那么脚本无法正确运行。 更多Web Worker内容: 【转向Javascript系列】深入理解Web Worker和使用 Web Workers]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次前端性能优化]]></title>
    <url>%2F2018%2F01%2F21%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[天下武功，无坚不破，唯快不破。对前端而言，快意味着要求资源体量更小、数量更精简、内容更早呈现、交互更加人性化。当项目做到一定程度，就应该考虑性能的问题，前端的性能优化有诸多有迹可循的理论和方法，比如 Yahoo！性能军规、Google PageSpeed Insights Rules。 我们团队一个比较老的项目首屏加载大概需要20多秒，这严重影响了用户体验，于是进行了一次首屏加载的性能优化。 浏览器渲染过程首先，稍微了解一下，浏览器接收到HTML/CSS/JavaScript等资源后的渲染过程： 浏览器在收到 HTML 文档之后会对文档进行解析开始构建 DOM (Document Object Model) 树，进而在文档中发现样式表，开始解析 CSS 来构建 CSSOM（CSS Object Model）树，这两者都构建完成后，开始构建渲染树。 DOM树描述了文档的结构与内容，CSSOM树则描述了对文档应用的样式规则，想要渲染出页面，就需要将DOM树与CSSOM树结合在一起，这就是渲染树。渲染树构建完毕后，浏览器得到了每个可见节点的内容与其样式，下一步工作则需要计算每个节点在窗口内的确切位置与大小，也就是布局阶段。当Layout布局事件完成后，浏览器会立即发出Paint Setup与Paint事件，开始将渲染树绘制成像素，绘制所需的时间跟CSS样式的复杂度成正比，绘制完成后，用户就可以看到页面的最终呈现效果了。 暂缓JavaScript解析在上图构建DOM树时，&lt;script&gt;标签可能会阻塞html解析，从而影响首页加载速度，可以使用async进行异步加载或者用defer进行延迟加载。 async属性表示脚本会在下载后尽快执行，但不能保证脚本会按照顺序执行。 defer属性表示脚本会先下载，但会在整个页面都解析完成后再运行，并且按照脚本出现的先后顺序执行。 用网上一张图能比较明显得看出两者的不同之处。 蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表 HTML 解析。 用这两个属性可以很好解决由&lt;script&gt;引起地加载缓慢问题。 减少不必要的HTML标签从浏览器渲染的流程可以看出，如果HTML中有很多不必要的标签会影响DOM解析速度并且增加了HTML文件的大小，可以对嵌套过深的结构进行优化，去除不必要的标签。 减少CSS嵌套CSS嵌套过深，会影响浏览器查找选择器的速度，一定程度上产出了很多冗余的字节，一般最多嵌套3层。 启用CSS Sprite CSS Sprites在国内很多人叫css精灵，是一种网页图片应用处理方式。它允许你将一个页面涉及到的所有零星图片都包含到一张大图中去，这样一来，当访问该页面时，载入的图片就不会像以前那样一幅一幅地慢慢显示出来了。 该项目首页有有三张svg的图片，参考SVG Sprite对这三张照片进行了svg sprite的简单处理，后续在angular/cli中也可以参照这个SVG icon system with angular-cli对项目中的svg图片进行统一的处理。 进行css sprite处理时，注意以下几点： 把图片横向合并，这样图片大小更小 间距不要太大，这对图片大小影响不是很大，但对客户端解压时需要的内存更少 进行css sprite处理后，降低了首页资源请求次数。 对于图标类的图片，最好用iconfont来减少图片的额外请求。 压缩静态资源合并打包后的js、css、图片文件体积一般会比较大，这个时候要对它们进行压缩处理。gulp和webpack都有相应的压缩插件。 针对个别图片，有时候也可以单独拿出来处理，可以去tinypng 进行在线压缩。 使用lazyload和preloading在Angular中，可以在路由中用loadChildren来实现lazyload，这样可以实现按需加载，加快加载速度。 1234&#123; path: 'home', loadChildren: 'app/home/home.module#HomeModule',&#125;, 首页显示的模块不应该过大，我们项目中首页加载的模块虽然使用了lazyload，但是模块太大，以至于严重影响了加载速度，于是对模块进行了切割，分成2个模块，对于第二个模块进行了preloading，这样在首页加载完毕后，会对该模块进行预加载，加快了路由切换时的速度。关于preloading可以参考Angular官网的自定义预加载策略。 Nginx启用Gzip压缩 HTTP协议上的gzip编码是一种用来改进web应用程序性能的技术，web服务器和客户端（浏览器）必须共同支持gzip。目前主流的浏览器，Chrome,firefox,IE等都支持该协议。常见的服务器如Apache，Nginx，IIS同样支持gzip。 gzip压缩比率在3到10倍左右，可以大大节省服务器的网络带宽。而在实际应用中，并不是对所有文件进行压缩，通常只是压缩静态文件。 在Nginx中，启用gzip： 1234567891011121314151617181920212223242526272829303132333435363738394041# 开启gzipgzip on;# 启用gzip压缩的最小文件，小于设置值的文件将不会压缩gzip_min_length 1k;# gzip 压缩级别，1-10，数字越大压缩的越好，也越占用CPU时间gzip_comp_level 5;# 进行压缩的文件类型。javascript有多种形式。其中的值可以在 mime.types 文件中找到。gzip_types application/atom+xml application/javascript application/json application/ld+json application/manifest+json application/rss+xml application/vnd.geo+json application/vnd.ms-fontobject application/x-font-ttf application/x-web-app-manifest+json application/xhtml+xml application/xml font/opentype image/bmp image/svg+xml image/x-icon text/cache-manifest text/css text/plain text/vcard text/vnd.rim.location.xloc text/vtt text/x-component text/x-cross-domain-policy;# 是否在http header中添加Vary: Accept-Encoding，建议开启gzip_vary on;# 禁用IE 6 gzipgzip_disable "MSIE [1-6]\."; 不同gzip_comp_level的压缩率可以参考下图： gzip对svg和x-icon的压缩效果比较明显，一般可以达到50%以上的压缩效果，但是对于压缩过的PNG、GIF格式图片启用Gzip，反而会因为添加标头、压缩字典，增大了图片的大小。 启用压缩后，首页请求的资源大小由原来的10M降低到2.8M，效果还是比较明显的。 启用http缓存每次访问网页时80%的时间都会花在资源下载上，因此使用缓存可以大大提高网页访问时的响应速度。 参考H5BP配置目录下的expires.conf，作为Nginx服务器配置： 123456789101112131415161718192021222324252627282930313233343536373839404142434445# Expire rules for static content# No default expire rule. This config mirrors that of apache as outlined in the# html5-boilerplate .htaccess file. However, nginx applies rules by location,# the apache rules are defined by type. A consequence of this difference is that# if you use no file extension in the url and serve html, with apache you get an# expire time of 0s, with nginx you'd get an expire header of one month in the# future (if the default expire rule is 1 month). Therefore, do not use a# default expire rule with nginx unless your site is completely static# cache.appcache, your document html and datalocation ~* \.(?:manifest|appcache|html?|xml|json)$ &#123; add_header Cache-Control "max-age=0";&#125;# Feedlocation ~* \.(?:rss|atom)$ &#123; add_header Cache-Control "max-age=3600";&#125;# Media: images, icons, video, audio, HTClocation ~* \.(?:jpg|jpeg|gif|png|ico|cur|gz|svg|mp4|ogg|ogv|webm|htc)$ &#123; access_log off; add_header Cache-Control "max-age=2592000";&#125;# Media: svgz files are already compressed.location ~* \.svgz$ &#123; access_log off; gzip off; add_header Cache-Control "max-age=2592000";&#125;# CSS and Javascriptlocation ~* \.(?:css|js)$ &#123; add_header Cache-Control "max-age=31536000"; access_log off;&#125;# WebFonts# If you are NOT using cross-domain-fonts.conf, uncomment the following directive# location ~* \.(?:ttf|ttc|otf|eot|woff|woff2)$ &#123;# add_header Cache-Control "max-age=2592000";# access_log off;# &#125; 上述配置禁用manifest，appcache，html，xml和json文件的缓存。 它将RSS和ATOM订阅文件缓存1小时，Javascript和CSS文件1年，以及其他静态文件（图像和媒体）1个月。 缓存全部设置为public，所以任何系统都可以缓存它们。 将它们设置为私有将限制它们被私有缓存（例如我们的浏览器）缓存。 关于缓存中资源的新鲜度控制可以看这篇文章HTTP缓存控制小结。 总结这次只是很简单地对首屏加载进行了性能优化，减少了10个http请求，总资源大小从10.4MB降到2.8MB，首屏DOMContentLoaded时间从12秒左右降到2秒左右，load时间从22秒左右降到6秒左右，效果还是很明显的。 参考文章 Google Developers中performance系列文章 Front-End Performance Checklist 2018 前端那些事儿」② 极限性能优化 前端性能优化相关 HTTP缓存控制小结 Nginx缓存最佳实践]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《JavaScript高级程序设计》学习笔记（八）]]></title>
    <url>%2F2018%2F01%2F19%2F%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89%2F</url>
    <content type="text"><![CDATA[第二十一章：Ajax与Comet 第二十二章：高级技巧 Ajax与CometXMLHTTPRequest对象使用XMLHTTPRequest构造函数创建XHR对象： 1var xhr = new XMLHttpRequest(); XHR的用法在使用XHR对象时，要调用的第一个方法是open()，它接受3个参数：要发送的请求的类型（get、post等）、请求的URL和表示是否异步发送请求的布尔值： 1xhr.open('get', 'example.php', false); 这个代码会启动一个针对example.php的GET请求。这行代码中，URL相对于执行代码的当前页面（当然也可以使用绝对路径），调用open()方法并不会真正发送请求，而只是启动一个请求以备发送。 只能向使用相同端口和协议的URL发送请求 要发送特定的请求，必须调用send()方法： 12xhr.open('get', 'example.txt', false);xhr.send(null); send()方法接收一个参数，即要作为请求主题发送的数据。如果不需要通过请求主体发送数据，则必须传入null，因为这个参数对有些浏览器来说是必须的。调用send()之后，请求就好被分派到服务器。 由于这次请求是同步的，JavaScript代码会等到服务器响应之后再继续执行。在收到响应之后，响应数据会自动填充XHR对象的属性，相关属性简介如下： responseText：作为响应主体被返回的文本 responseXML：如果响应的内容类型是text/xml或application/xml，这个属性中将保存包含着响应数据的XML DOM文档 status：响应的HTTP状态 statusText：HTTP状态说明 在接收到响应之后，第一步是检查status属性，以确定响应已经成功返回。一般来说，可以将HTTP状态码为200作为成功的标志。此时，responseText属性的内容已经就绪，而且在内容类型正确的情况下，responseXML也应该能够访问了。此外，状态码为304表示请求的资源并没有被修改，可以直接使用浏览器中缓存的版本；当然，也意味着响应是有效的。为确保接收到适当的响应，应该像下面这样检查上述两种状态码： 12345678xhr.open('get', 'example.php', false);xhr.send(null);if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123; console.log(xhr.responseText);&#125; else &#123; console.log('request was unsuccessful: ' + xhr.status);&#125; 建议通过检测status来决定下一步的操作。无论内容类型是什么，响应主体的内容都会保存到responseText属性中；而对于非XML数据而言，responseXML属性的值为null。 发送异步请求时，可以检测XHR对象的readyState属性，该属性表示请求/响应过程的当前活动阶段。这个属性可取值如下： 0：未初始化。尚未调用open()方法。 1：启动。已经调用open()方法，但尚未调用send()方法。 2：发送。已经调用send()方法，但尚未接收响应。 3：接收。已经接收到部分响应数据。 4：完成。已经接收到全部响应数据，而且已经可以在客户端使用。 只要readyState属性的值由一个值变成另一个值，都会触发一次readystatechange事件。可以利用这个事件来检测每次状态变化后readyState的值。通常，我们只对readyState值为4的阶段感兴趣，因为这时所有数据都已经就绪。不过，必须在调用open()之前指定onreadystatechange事件处理程序才能确保跨浏览器兼容性： 1234567891011121314var xhr = createXHR();xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4) &#123; if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) &#123; console.log(xhr.responseText); &#125; else &#123; console.log('request was unsuccessful: ' + xhr.status); &#125; &#125;&#125;;xhr.open('get', 'example.txt', true);xhr.send(null); 没有使用this对象是因为onreadystatechange事件处理程序的作用域问题。如果使用this对象，在有的浏览器中会导致函数执行失败，或导致错误发生。 在接收到响应之前还可以调用abort()方法来取消异步请求： 1xhr.abort(); 调用这个方法后，XHR对象会停止触发事件，而且也不再允许访问任何与响应有关的对象属性。在终止请求之后，还应该对XHR对象进行解引用操作。由于内存原因，不建议重用XHR对象。 HTTP头部信息每个HTTP请求和响应都会带有响应的头部信息。XHR对象提供了操作请求头部和响应头部信息的方法。 默认情况下，在发送XHR请求的同时，还会发送下列头部信息： Accept：浏览器能够处理的内容类型 Accept-Charset：浏览器能够显示的字符集 Accept-Encoding：浏览器能够处理的压缩编码 Accept-Language：浏览器当前设置的语言 Connection：浏览器与服务器之间连接的类型 Cookie：当前页面设置的任何Cookie Host：发出请求的页面所在的域 Referer：发出请求的页面的URI User-Agent：浏览器的用户代理字符串 使用setRequestHeader()方法可以设置自定义的请求头部信息。这个方法接收两个参数：头部字段的名称和头部字段的值。要成功发送请求头部信息，必须在调用open()方法之后且调用send()方法之前调用setRequestHeader()： 123456789101112131415var xhr = createXHR();xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4) &#123; if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) &#123; console.log(xhr.responseText); &#125; else &#123; console.log('request was unsuccessful: ' + xhr.status); &#125; &#125;&#125;;xhr.open('get', 'example.txt', true);xhr.setRequestHeader('MyHeader', 'MyValue');xhr.send(null); 调用XHR对象的getResponseHeader()方法并传入头部字段名称，可以取得相应的响应头部信息。而调用getAllResponseHeaders()方法则可以取得一个包含所有头部信息的长字符串： 12var myHeader = xhr.getResponseHeader('MyHeader');var allHeaders = xhr.getAllResponseHeaders(); GET请求GET是最常见的请求类型，最常用于向服务器查询某些信息。必要时，可以将查询字符串参数追加到URL的末尾，以便将信息发送给服务器。对XHR而言，位于传入open()方法的URL末尾的查询字符串必须经过正确的编码才行。 使用GET请求经常会发生的一个错误，就是查询字符串的格式有问题。查询字符串中每个参数的名称和值都必须使用encodeURIComponent()进行编码，然后才能放到URL的末尾；而且所有名-值对都必须由&amp;分隔： 1xhr.open('get', 'example.php?name1=value1&amp;name2=value2', true); 可以使用下面这个函数辅助向现有URL的末尾添加查询字符串参数： 1234567891011121314function addURLParam(url, name, value) &#123; url += (url.indexOf('?') == -1 ? '?' : '&amp;'); url += encodeURIComponent(name) + '=' + encodeURIComponent(value); return url;&#125;var url = 'example.php';// 添加参数url = addURLParam(url, 'name', 'tc');url = addURLParam(url, 'book', 'js');// 初始化请求xhr.open('get', url, false); POST请求POST请求通常用于向服务器发送应该被保存的数据。POST请求应该把数据作为请求的主体提交，而GET请求传统上不是这样。POST请求的主体可以包含非常多的数据，而且格式不限。在open()方法第一个参数的位置传入post，就可以初始化一个POST请求： 1xhr.open('post', 'example.php', true); 发送POST请求的第二步就是向send()方法中传入某些数据。传入的数据经序列化后将作为请求主体被提交到服务器。 默认情况下，服务器对POST请求和提交Web表单的请求并不会一视同仁。因此，服务器端必须有程序来读取发送过来的原始数据，并从中解析出有用的部分。不过，可以用XHR来模仿表单提交：首先将Content-Type头部信息设置为application/x-www-form-urlencoded，其次是以适当的格式创建一个字符串。 与GET请求相比，POST请求消耗的资源更多一些。从性能角度来看，以发送相同的数据计，GET请求的速度最多可达到POST请求的两倍。 XMLHttpRequest2级FormDataFormData为序列化表单以及创建与表单格式相同的数据提供了便利。 12var data = new FormData();data.append('name', 'tc'); 这个append()方法接收两个参数：键和值，分别对应表单字段的名字和字段中包含的值。可以像这样添加任意多个键值对。而通过向FormData构造函数中传入表单元素，也可以用表单元素的数据预先向其中填入键值对： 1var data = new FormData(document.forms[0]); 创建了FormData的实例后，可以将它直接传给XHR的send()方法： 1234567891011121314var xhr = createXHR();xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123; console.log(xhr.responseText); &#125; else &#123; console.log('request was unsuccessful: ' + xhr.status); &#125; &#125;&#125;;xhr.open('post', 'postexample.php', true);var form = document.getElementById('user-info');xhr.send(new FormData(form)); 使用FormData的方便之处在于不必明确地在XHR对象上设置请求头部。XHR对象能够识别传入的数据类型是FormData的实例，并配置适当的头部信息。 超时设定IE8为XHR对象添加了一个timeout属性，表示请求在等待响应多少毫秒后就终止。在给timeout设置一个数值后，如果在规定的时间内浏览器还没有接收到响应，那么就会触发timeout事件，进而会调用ontimeout事件处理程序。 123456789101112131415161718192021var xhr = createXHR();xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4) &#123; try &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123; console.log(xhr.responseText); &#125; else &#123; console.log('request was unsuccessful: ' + xhr.status); &#125; &#125; catch (ex) &#123; // 假设由ontimeout事件程序处理 &#125; &#125;&#125;;xhr.open('post', 'postexample.php', true);xhr.timeout = 1000; // 将超时设置为1秒钟(仅适用于IE8+)xhr.ontimeout = function () &#123; console.log('request did not return in a second')&#125;;xhr.send(null); overrideMimeType()方法overrideMimeType()方法用于重写XHR响应的MIME类型。 如果服务器返回的MIME类型是text/plain，但数据中实际包含的是XML。根据MIME类型，即使数据是XML，responseXML属性中仍然是null 。通过调用overrideMimeType()方法，可以保证把响应当做XML而非纯文本来处理： 1234var xhr = createXHR();xhr.open('get', 'text.php', true);xhr.overrideMimeType('text/xml');xhr.send(null); 进度事件Progress Event规范定义了与客户端服务器通信有关的事件： laodstart：在接收到响应数据的第一个字节时触发 progress：在接收响应期间持续不断地触发 error：在请求发生错误时触发 abort：在因为调用abort()方法而终止连接时触发 load：在接收到完整的响应数据时触发 loadend：在通信完成或触发error、abort或load事件后触发 每个请求都从触发loadstart事件开始，接下来是一或多个progress事件、然后触发error、abort或load事件中的一个，最后触发loadend事件结束。 load事件FIrefox实现中引入了load事件，用以代替readystatechange事件。响应接收完毕后将触发load事件，因此没有必要检查readyState属性。而onload事件处理程序会接收到一个event对象，其target属性就指向XHR对象实例，因而可以访问到XHR对象的所有方法和属性。然而，并非所有浏览器都为这个事件实现了适当的事件对象。 1234567891011var xhr = createXHR();xhr.onload = function () &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123; console.log(xhr.reponseText); &#125; else &#123; console.log('request was unsuccessful: ' + xhr.status); &#125;&#125;;xhr.open('get', 'altevent.php', true);xhr.send(null); 只要浏览器接收到服务器的响应，不管其状态如何，都会触发load事件。这个意味着必须检查status属性，才能确定数据是否真的已经可用了。 progress事件progress事件会在浏览器接收新数据期间周期性触发。而onprogress事件处理程序会接收到一个event对象，其target属性是XHR对象，但包含额外的属性：lengthComputable、position和totalSize。其中，lengthComputable是一个表示进度信息是否可用的布尔值，position表示已经接收的字节数，totalSize表示根据Content-Length响应头部确定的预期字节数。有了这些信息，就可以为用户创建一个进度指示器： 12345678910111213141516var xhr = createXHR();xhr.onload = function (event) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123; console.log(xhr.reponseText); &#125; else &#123; console.log('request was unsuccessful: ' + xhr.status); &#125;&#125;;xhr.onprogress = function (event) &#123; var divStatus = document.getElementById('status'); if (event.lengthComputable) &#123; divStatus.innerHTML = 'Received ' + event.position + 'of' + event.totalSize + 'bytes'; &#125;&#125;;xhr.open('get', 'altevent.php', true);xhr.send(null); 为了确保正常执行，必须在调用open()方法之前添加onprogress事件处理程序。如果响应头部中包含Content-Length字段，那么也可以利用这个信息来计算从响应中已经接收到的数据的百分比。 跨域资源共享默认情况，XHR对象只能访问与包含它的页面位于同一域中的资源。这种安全策略可以预防某些恶意行为。 CORS（Cross-Origin Resource Sharing，跨源资源共享）定义了在必须访问跨源资源时，浏览器与服务器如何沟通。CORS背后的基本思想，就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是失败。 比如一个简单的使用GET或POST发送的请求，它没有自定义的头部，而主体内容是text/plain。在发送该请求时，需要给它附加一个额外的Origin头部，其中包含请求页面的源信息，以便服务器根据这个头部信息来决定是否给予响应下面是Origin头部的一个示例： 1Origin: http://www.tc9011.com 如果服务器认为这个请求可以接受，就在Access-Control-Allow-Origin头部中回发相同的源信息（如果是公共资源，可以回发*）： 1Access-Control-Allow-Origin: http://www.tc9011.com 如果没有这个头部，或者有这个头部但源信息不匹配，浏览器就会驳回请求。请求和响应都不包含cookie信息。 浏览器对CORS的实现FIrefox3.5+、Safari4+、Chrome、iOS版Safari和Android平台中的WebKit都通过XHLHttpRequest对象实现了对CORS的原生支持。在尝试打开不同来源的资源时，无需额外编写代码就可以触发这个行为。要请求另一个域中的资源，使用标准XHR对象并在open()方法中传入绝对URL即可： 123456789101112var xhr = createXHR();xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4) &#123; if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304) &#123; console.log(xhr.responseText); &#125; else &#123; console.log('request was unsuccessful: ' + xhr.status); &#125; &#125;&#125;;xhr.open('get', 'http://www.tc9011.com/page/', true);xhr.send(null); 通过跨域XHR对象可以访问status和statusText属性，而且还支持同步请求。跨域XHR对象也有一些限制，但为了安全这些限制是必须的： 不能使用setRequestHeader()设置自定义头部 不能接收和发送cookie 调用getAllResponseHeaders()方法总会返回空字符串 由于无论同源请求还是跨源请求都使用相同的接口，因此对于本地资源，最好使用相对URL，在访问远程资源时再使用绝对URL。这样能消除歧义，避免出现限制访问头部或本地cookie信息等问题。 Preflighted RequestCORS通过一种叫做Preflighted Request的透明服务器验证机制支持开发人员使用自定义的头部、GET或POST之外的方法，以及不同类型的主体内容。在使用下列高级选项来发送请求时，就会向服务器发送一个Preflight请求。这种请求使用OPTIONS方法，发送下列头部： Origin：与简单的请求相同 Access-Control-Request-Method：请求自身使用的方法 Access-Control-Request-Headers：（可选）自定义的头部信息，多个头部以逗号分隔 发送这个请求后，服务器可以决定是否允许这种类型的请求。服务器通过在响应中发送如下头部与浏览器进行沟通： Access-Control-Allow-Origin：与简单的请求相同 Access-Control-Allow-Methods：允许的方法，多个方法以逗号分隔 Access-Control-Allow-Headers：允许的头部，多个头部以逗号分隔 Access-Control-Max-Age：应该将这个Prefloght请求缓存多长时间（以秒表示） Preflight请求结束后，结果将按照响应中指定的时间缓存起来。而为此付出的代价只是第一次发送这种请求时会多一次HTTP请求。 带凭据的请求默认情况下，跨源请求不提供凭据（cookie、HTTP认证及客户端SSL证明等）。通过将withCredentials属性设置为true，可以指定某个请求应该发送凭据。如果服务器接受带凭据请求，会用下面的HTTP头部来响应： 1Access-Control-Allow-Credentials: true 如果发送的是带凭据的请求，但服务器的响应中没有包含这个头部，那么浏览器就不会把响应交给JavaScript（于是，responseText中将是空字符串，status的值为0，而且会调用onerror()事件处理程序）。另外，服务器还可以在Preflight响应中发送这个HTTP头部，表示允许源发送带凭据的请求。 其他跨域技术图像Ping一个网页可以从任何网页中加载图像，不用担心跨域不跨域。动态创建图像经常用于图像Ping。图像Ping是与服务器进行简单、单向的跨域通讯的一种方式。请求的数据是通过查询字符串形式发送的，而响应可以是任意内容，但通常是像素图或204响应。通过图像Ping，浏览器得不到具体的数据，但通过侦听load和error事件，能知道响应是什么时候接收到的： 12345var img = new Image();img.onload = img.onerror = function () &#123; console.log('done')&#125;;img.src = 'http://tc9011.com/test?name=tc'; 这里创建了一个Image的实例，然后将onload和onerror事件处理程序指定为同一个函数。这样无论是什么响应，只要请求完成，就能得到通知。请求从设置src属性那一刻开始，而这个例子在请求中发送了一个name参数。 图像Ping最常用于跟踪用户点击页面或动态广告曝光次数。图像Ping有两个主要的缺点，一是只能发送GET请求，而是无法访问服务器的响应文本。 JSONPJSONP是JSON with padding（填充式JSON或参数式JSON）的简写，是应用JSON的一种新方法。JSONP是被包含在函数调用中的JSON： 1callback(&#123;'name': 'tc'&#125;); JSONP由两部分组成：回调函数和数据。回调函数是当响应来时应该在页面中调用的函数。回调函数的名字一般是在请求中指定的。而数据就是传入回调函数中的JSON数据。下面就是一个典型的JSONP请求： 1http://freegeoip.net/json/?callback=handleResponse 这个URL是在请求一个JSONP地理定位服务。通过查询字符串来指定JSONP服务的回调参数是很常见的，这里指定的回调函数的名字叫handleResponse。 JSONP是通过动态&lt;script&gt;元素来使用的，使用时可以为src属性指定一个跨域URL。这里的&lt;script&gt;元素与&lt;img&gt;元素类似，都有能力不受限制地从其他域加载资源。因为JSONP是有效的JavaScript代码，所以在请求完成后，即在JSONP响应加载到页面中以后，就会立即执行： 1234567function handleResponse(response) &#123; console.log('you are at ip address' + response.ip + ', which is in ' + response.city + ', ' + response.region_name);&#125;var script = document.createElement('script');script.src = 'http://freegeoip.net/json/?callback=handleResponse';document.body.insertBefore(script, document.body.firstChild); 与图像Ping相比，它的优点在于能直接访问响应文本，支持在浏览器与服务器之间双向通信。 JSONP的缺点是从其他不安全域中加载代码执行时，如果响应中夹带一些恶意代码，而此时除了完全放弃JSONP调用之外，没办法追究。另外，要确定JSONP请求是否失败并不容易。在HTML5中可以用给&lt;script&gt;新增的onerror事件处理程序。 CometComet则是一种服务器向页面推送数据的技术。Comet能够让信息近乎实时地被推送到页面上。 有两种实现Comet的方式：长轮询和流。长轮询是传统轮询的一个翻版，即浏览器定时向服务器发送请求，看有没有更新数据。下图是短轮询的时间线： 长轮询把短轮询颠倒一下。页面发起一个到服务器的请求，然后服务器一直保持连接打开，直到有数据发送。发送完数据之后，浏览器关闭连接，随即又发起一个到服务器的新请求。这一过程在页面打开期间一直持续不断。下面是长轮询的时间线： 无论是短轮询还是长轮询，浏览器都要在接收数据之前，先发起对服务器的连接。两者最大的区别在于服务器如何发送数据。短轮询是服务器立即发送响应，无论数据是否有效，而长轮询是等待发送响应。轮询的优势是所有浏览器都支持的，因为使用XHR对象和setTimeout()就能实现，你需要做的是决定什么时候发送请求。 第二种流行的Comet实现是HTTP流。流不同于上述两种轮询，因为它在页面的整个生命周期内只使用一个HTTP链接。就是浏览器向服务器发送一个请求，而服务器保持连接打开，然后周期性地向浏览器发送数据。 所有服务器端语言都支持打印到输出缓存然后刷新（将输出缓存中的内容一次性全部发送到客户端）的功能。而这正是实现HTTP流的关键所在。 在FIrefox、Safari、Opera和Chrome中，通过侦听readystatechange事件及检测readyState的值是否为3，就可以利用XHR对象实现HTTP流。在上述浏览器中，随着不断从服务器接收数据，readyState的值会周期性地变为3。当readyState值变为3时，responseText属性中就会保存接收到的所有数据。此时，就需要比较此前接收到的数据，决定从什么位置开始取得最新的数据。使用XHR对象实现HTTP流的典型代码如下： 1234567891011121314151617181920212223242526272829function createStreamingClient(url, progress, finished) &#123; var xhr = new XMLHttpRequest(), received = 0; xhr.open('get', url, true); xhr.onreadystatechange = function () &#123; var result; if (xhr.readyState == 3) &#123; // 只取得最新数据并调整计数器 result = xhr.responseText.substring(received); received += result.length; // 调用progress回调函数 progress(result); &#125; else if (xhr.readyState == 4)&#123; finished(xhr.responseText); &#125; &#125;; xhr.send(null); return xhr;&#125;var client = createStreamingClient('streaming.php', function (data) &#123; console.log('received: ' + data);&#125;, function (data) &#123; console.log('Done');&#125;); 服务器发送事件SSE（Server-Sent Event，服务器发送事件）是围绕只读Comet交互推出的API或者模式。SSE API用于创建到服务器的单向连接，服务器通过这个连接可以发送任意数量的数据。服务器响应的MIME类型必须是text/event-stream，而且是浏览器中的JavaScript API能解析格式输出。SSE支持短轮询、长轮询和HTTP流，而且能在断开连接时自动确定何时重新连接。 SSE API要预定新的事件流，首先要创建一个新的EventSource对象，并传进一个入口点： 1var source = new EventSource('myevents.php'); 注意，传入的URL必须与创建对象的页面同源（相同的URL模式、域及端口）。EventSource的实例有一个readyState属性，值为0表示正连接到服务器，值为1表示打开了连接，值为2表示关闭了连接。 另外，还有下面三个事件： open：在建立连接时触发 message：在从服务器接收到新事件时触发 error：在无法建立连接时触发 1234source.onmessage = function (event) &#123; var data = event.data; // 处理数据&#125;; 服务器发回的数据以字符串形式保存在event.data中。 默认情况下，EventSource对象会保持与服务器的活动连接。如果连接断开，还会重新连接。这就意味着SSE适合长轮询和HTTP流。如果想强制立即断开连接并且不再重新连接，可以调用close()方法： 1source.close(); 事件流所谓的服务器事件会通过一个持久的HTTP响应发送，这个响应的MIME类型为text/eventstream。响应的格式是纯文本，最简单的情况是每个数据都带有前缀data： 123456data: foodata: bardata: foodata: bar 对以上响应而言，事件流中的第一个message事件返回的event.data值为foo，第二个message事件返回的event.data值为bar，第三个message事件返回的event.data值为foo\nbar（注意中间的换行符）。对于多个连续以data:开头的数据行，将作为多段数据解析，每个值之间以一个换行符分隔。只有在包含data:数据行后面有空行时，才会触发message事件，因此在服务器上生成事件流时不能忘了多添加这一行。 通过id:前缀可以给特定的事件指定一个关联的ID，这个ID行位于data:行前面或后面皆可： 12data: fooid: 1 设置了ID之后，EventSource对象会跟踪上一次触发的事件。如果连接断开，会向服务器发送一个包含名为Last-Event-ID的特殊HTTP头部的请求，以便服务器知道下一次该触发哪个事件。 Web SocketsWeb Sockets的目标是在一个单独的持久连接上提供全双工、双向通信。在JavaScript中创建了Web Sockets之后，会有一个HTTP请求发送到浏览器以发起连接。在取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为Web Sockets协议。使用标准的HTTP服务器无法实现Web Sockets，只有支持这种协议的专门服务器才能正常工作。 由于Web Sockets使用了自定义的协议，所以URL模式也略有不同。未加密的连接不上http://，而是ws://；加密的连接不上https://，而是wss://。在使用Web Sockets URL时，必须带着这个模式，因为将来还可能支持其他模式。 使用自定义协议而非HTTP协议的好处是，能够在客户端和服务器之间发生非常少量的数据，而不必担心HTTP那样字节级的开销。由于传递的数据包很小，因此Web Sockets很适合移动应用。 使用自定义协议的缺点在于，制定协议的时间比制定JavaScript API的时间还要长。 Web Sockets API要创建Web Sockets，先实例一个Web Socket对象并传入要连接的URL： 1var socket = new WebSocket('ws://www.example.com/server.php'); 注意，必须给Web Socket构造函数传入绝对URL。同源策略对Web Socket不适用，因此可以通过它打开到任何站点的连接。至于是否会与某个域中的页面通信，则完全取决于服务器。 实例化Web Socket对象后，浏览器会马上尝试创建连接。与XHR类似，Web Socket也有一个表示当前状态的readyState属性： WebSocket.OPENING(0)：正在建立连接 WebSocket.OPEN(1)：已经建立连接 WebSocket.CLOSING(2)：正在关闭连接 WebSocket.CLOSE(3)：已经关闭连接 Web Socket没有readystatechange事件，不过，它有其他事件，对应着不同的状态。readyState的值永远从0开始。 要关闭Web Socket连接，可以在任何时候调用close()方法。 1socket.close(); 调用close()之后，readyState的值立即变为2（正在关闭），而在关闭连接以后就会变成3。 发送和接收数据Web Socket打开之后，就可以通过连接发送和接收数据。要向服务器发送数据，使用send()方法，并传入任意字符串： 12var socket = new WebSocket('ws://www.example.com/server.php');socket.send('hello'); 因为Web Sockets只能通过连接发送纯文本数据，所以对复杂的数据结构，在通过连接发送之前，必须进行序列化： 123456var message = &#123; time: new Date(), text: 'hello', clientID: 'a'&#125;;socket.send(JSON.stringify(message)); 当服务器向客户端发来消息时，WebSocket对象就会触发message事件。这个message事件与其他传递消息的协议类似，也会把返回的数据保存在event.data属性中： 12345socket.onmessage = function (event) &#123; var data = event.data; // 处理数据&#125;; event.data中返回的数据也是字符串。 其他事件WebSocket对象还有下面三个事件，在连接生命周期的不同阶段触发： open：在成功建立连接时触发 error：在发生错误时触发，连接不能持续 close：在连接关闭时触发 WebSocket对象不支持DOM2级事件侦听，因此必须使用DOM 0级语法分别定义每个事件处理程序： 123456789101112var socket = new WebSocket('ws://www.example.com/server.php');socket.onopen = function () &#123; console.log('connection established');&#125;;socket.onerror = function () &#123; console.log('connection error');&#125;;socket.onclose = function () &#123; console.log('connection closed');&#125;; 在这三个事件中，只有close事件的event对象有额外的信息。这个事件的事件对象有三个额外的属性：wasClean、code和reason。其中，wasClean是一个布尔值，表示连接是否已经明确地关闭；code是服务器返回的数值状态码；reason是一个字符串，包含服务器发回的消息。可以把这些信息显示给用户，也可以记录到日志中以便将来分析： 123socket.onclose = function (event) &#123; console.log('was clean? ' + event.wasClean + 'code = ' + event.code + 'reason = ' + event.reason);&#125;; SSE与Web Sockets考虑使用SSE还是Web Sockets可以考虑一下因素： 是否有自由度建立和维护Web Sockets服务器 需不需双向通信。如果只需读取服务器数据，那么SSE比较容易实现。如果必须双向通信（如聊天室），那么Web Sockets更好。在不选择Web Sockets时，组合XHR和SSE也能实现双向通信 安全对于未被授权系统有权访问某个资源的情况，称之为CSRF（跨站点请求伪造）。未被授权系统会伪装自己，让处理请求的服务器认为它是合法的。 为了确保XHR访问的URL安全，通行的做法是验证发送请求者是否有权限访问相应的资源，有以下几种方式可以选择： 要求以SSL连接来访问可以通过XHR请求的资源 要求每一次请求都要附带经过相应算法计算得到的验证码 下列措施对CSRF攻击不起作用： 要求发送POST而不是GET请求—很容易改变 检查来源URL以确定是否可信—来源记录很容易伪造 基于cookie信息进行验证—同样很容易伪造 高级技巧高级函数安全的类型检测JavaScript内置的类型检测机制并非完全可靠。 在任何值上调用Object原生的toString()方法，都会返回一个[object NativeConstructorName]格式的字符串。每个类在内部都有一个[[class]]属性，这个属性中指定了上述字符串中的构造函数名： 12var value = new Array();console.log(Object.prototype.toString.call(value)); // [object Array] 由于原生数组的构造函数名与全局作用域无关，因此用toString()能保证返回一致的值。利用这点，可以创建如下函数： 1234567891011function isArray(value) &#123; return Object.prototype.toString.call(value) == '[object Array]';&#125;function isFunction(value) &#123; return Object.prototype.toString.call(value) == '[object Function]';&#125;function isRegExp(value) &#123; return Object.prototype.toString.call(value) == '[object RegExp]';&#125; 在Web开发中能够区分原生与非原生JavaScript对象非常重要。只有这样才能确切知道某个对象到底有哪些功能。这个技巧可以对任何对象给出正确的结论。 作用域安全的构造函数构造函数其实就是一个使用new操作符调用的函数。当使用new调用时，，构造函数内用到的this对象会指向新创建的对象实例： 1234567function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job;&#125;var person = new Person('tc', 27, 'fep'); 上面代码当没有使用new操作符来调用该构造函数时，由于this对象是在运行时绑定的，直接调用Person()，this会映射到全局对象window上，导致错误对象属性的意外增加： 1234var person = Person('tc', 27, 'fep');console.log(window.name); //tcconsole.log(window.age); //27console.log(window.job); //fep 这里，原本针对Person实例的三个属性被加到window对象上，因为构造函数是作为普通函数调用，忽略了new操作符。这个问题是由this对象的晚绑定造成的，在这里this被解析成了window对象。这个问题的解决方法就是创建一个作用域安全的构造函数。 作用域安全的构造函数在进行任何更改前，首先确认this对象是正确类型的实例。如果不是，那么会创建新的实例并返回： 12345678910111213141516function Person(name, age, job) &#123; if (this instanceof Person) &#123; this.name = name; this.age = age; this.job = job; &#125; else &#123; return new Person(name, age, job); &#125;&#125;var person1 = Person('tc', 27, 'fep');console.log(window.name); // ''console.log(person1.name); // 'tc'var person2 = new Person('tc', 27, 'fep');console.log(person2.name); // 'tc' 实现这个模式以后，就锁定了可以调用构造函数的环境。如果使用构造函数窃取模式的继承且不使用原型链，那么这个继承很可能被破坏： 12345678910111213141516171819202122function Polygon(sides) &#123; if (this instanceof Polygon) &#123; this.sides = sides; this.getArea = function () &#123; return 0; &#125;; &#125; else &#123; return new Polygon(sides); &#125;&#125;function Rectangle(width, height) &#123; Polygon.call(this, 2); this.width = width; this.height = height; this.getArea = function () &#123; return this.width * this.height; &#125;;&#125;var rect = new Rectangle(5, 10);console.log(rect.sides); // undefined 这段代码中，Polygon构造函数是作用域安全的，然而Rectangle构造函数不是。新建一个Rectangle实例之后，这个实例应该通过Polygon.call()来继承Polygon的sides属性。但是，由于Polygon构造函数是作用域安全的，this对象并非Polygon的实例，所以会创建并返回一个新的Polygon对象。Rectangle构造函数中的this对象并没有得到增长，同时Polygon.call()返回的值也没有用到，所以Rectangle实例中就不会有sides属性。 如果构造函数窃取结合使用原型链或者寄生组合则可以解决这个问题： 1234567891011121314151617181920212223function Polygon(sides) &#123; if (this instanceof Polygon) &#123; this.sides = sides; this.getArea = function () &#123; return 0; &#125;; &#125; else &#123; return new Polygon(sides); &#125;&#125;function Rectangle(width, height) &#123; Polygon.call(this, 2); this.width = width; this.height = height; this.getArea = function () &#123; return this.width * this.height; &#125;;&#125;Rectangle.prototype = new Polygon();var rect = new Rectangle(5, 10);console.log(rect.sides); // 2 上面代码中，一个Rectangle实例也同时是一个Polygon实例，所以Polygon.call()会照原意执行。 推荐作用域安全的构造函数作为最佳实践。 惰性载入函数惰性载入表示函数执行的分支只会发生一次。有两种实现惰性载入的方式，第一种就是在函数被调用时再处理函数。在第一次调用的过程中，该函数会被覆盖为另一个按合适方式执行的函数，这样任何对原函数的调用都不用再经过执行的分支了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/*************原函数*************/function createXHR() &#123; if (typeof XMLHttpRequest != 'undefined') &#123; return new XMLHttpRequest(); &#125; else if (typeof ActiveXObject != 'undefined') &#123; if (typeof arguments.callee.activeXString != 'string') &#123; var versions = ['MSXML2 .XMLHttp.6.0', 'MSXML2.XMLHttp.3.0', "MSXML2 .XMLHttp"], i, len; for (i = 0, len = versions.length; i &lt; len; i++) &#123; try &#123; new ActiveXObject(versions[i]); arguments.callee.activeXString = versions[i]; break; &#125; catch (ex) &#123; // 跳过 &#125; &#125; &#125; return new ActiveXObject(arguments.callee.activeXString); &#125; else &#123; throw new Error('no xhr object available'); &#125;&#125;/*************重写后*************/function createXHR() &#123; if (typeof XMLHttpRequest != 'undefined') &#123; createXHR = function () &#123; return new XMLHttpRequest(); &#125;; &#125; else if (typeof ActiveXObject != 'undefined') &#123; createXHR = function () &#123; if (typeof arguments.callee.activeXString != 'string') &#123; var versions = ['MSXML2 .XMLHttp.6.0', 'MSXML2.XMLHttp.3.0', "MSXML2 .XMLHttp"], i, len; for (i = 0, len = versions.length; i &lt; len; i++) &#123; try &#123; new ActiveXObject(versions[i]); arguments.callee.activeXString = versions[i]; break; &#125; catch (ex) &#123; // 跳过 &#125; &#125; &#125; return new ActiveXObject(arguments.callee.activeXString); &#125;; &#125; else &#123; createXHR = function () &#123; throw new Error('no xhr object available'); &#125; &#125; return createXHR();&#125; 在这个惰性载入的createXHR()中，if语句的每一个分支都会为createXHR变量赋值，有效覆盖了原有的函数。最后一步便是调用新赋的函数。下一次调用createXHR()的时候，就会直接调用被分配的函数，这样就不用再次执行if语句。 第二种实现惰性载入的方式是在声明函数时声明时就指定适当的函数。这样，第一次调用函数时就不会损失性能了，而在代码首次加载时会损失一点性能： 1234567891011121314151617181920212223242526272829var createXHR = (function () &#123; if (typeof XMLHttpRequest != 'undefined') &#123; return function () &#123; new XMLHttpRequest(); &#125;; &#125; else if (typeof ActiveXObject != 'undefined') &#123; return function () &#123; if (typeof arguments.callee.activeXString != 'string') &#123; var versions = ['MSXML2 .XMLHttp.6.0', 'MSXML2.XMLHttp.3.0', "MSXML2 .XMLHttp"], i, len; for (i = 0, len = versions.length; i &lt; len; i++) &#123; try &#123; new ActiveXObject(versions[i]); arguments.callee.activeXString = versions[i]; break; &#125; catch (ex) &#123; // 跳过 &#125; &#125; &#125; return new ActiveXObject(arguments.callee.activeXString); &#125;; &#125; else &#123; return function () &#123; throw new Error('no xhr object available'); &#125;; &#125;&#125;)(); 上面代码使用的技巧是创建一个匿名、自执行的函数，用以确定应该使用哪一个函数实现。实际的逻辑都一样。不一样的地方就是第一行代码、新增了自执行的匿名函数，另外每个分支都返回正确的函数定义，以便立即将其赋值给createXHR()。 函数绑定函数绑定要创建一个函数，可以在特定的this环境中以指定参数调用另一个函数。该技巧常常和回调函数与事件处理程序一起使用，以便在将函数作为变量传递时保留代码执行环境： 12345678910var handler = &#123; message: 'Event handled', handleClick: function (event) &#123; console.log(this.message); &#125;&#125;;var btn = document.getElementById('my-btn');EventUtil.addHandler(btn, 'click', handler.handleClick); 上面例子中，创建了一个handler的对象。handler.handleClick()方法被分配为一个DOM按钮的事件处理程序。当按下该按钮时，就调用该函数。虽然貌似打印的应该是Event handled，实际却是undefined。这个问题在于没有保存handler.handleClick()的环境，所以this对象最后是指向DOM按钮而非handler。可以使用一个闭包修正这个问题： 12345678910111213var handler = &#123; message: 'Event handled', handleClick: function (event) &#123; console.log(this.message); &#125;&#125;;var btn = document.getElementById('my-btn');EventUtil.addHandler(btn, 'click', function (event) &#123; handler.handleClick(event);&#125;); 这个解决方案在onclick事件处理程序内使用了一个闭包直接调用handler.handleClick()。 闭包会携带包含它的函数的作用域 多个闭包可能会令代码难于理解和调试。因此可以创建一个将函数绑定到指定环境的函数： 123456// 接受一个函数和一个环境，并返回一个在给定环境中调用给定函数的函数，并且将所有参数原封不动传递过去function bind(fn, context) &#123; return function () &#123; return fn.apply(context, arguments); &#125;;&#125; 在bind()中创建一个闭包，闭包使用apply()调用传入的函数，并给apply()传递context对象和参数。注意这里使用的arguments对象是函数内部的，而非bind()的。当调用返回的函数时，它会在给定环境中执行被传入函数并给出所有参数： 12345678910var handler = &#123; message: 'Event handled', handleClick: function (event) &#123; console.log(this.message + ":" + event.type); &#125;&#125;;var btn = document.getElementById('my-btn');EventUtil.addHandler(btn, 'click', bind(handler.handleClick, handler)); ECMAScript5为所有函数定义了一个原生的bind()方法： 1EventUtil.addHandler(btn, 'click', handler.handleClick.bind(handler)); 只要是将某个函数指针以值的形式传递，同时该函数必须在特定环境中执行，被绑定函数的特效就凸显出来。它们主要用于处理事件处理程序以及setTimeout()和setInterval()。然而，被绑定函数与普通函数相比有更多开销，需要更多内存，同时也因为多重函数调用稍微慢一点，所以最好只在必要时使用。 函数柯里化与函数绑定密切相关的主题是函数柯里化，它用于创建已经设置好了一个或多个参数的函数。函数柯里化的基本方法和函数绑定是一样的：使用一个闭包返回一个函数。两者的区别在于，当函数被调用时，返回的函数还需要设置一些传入的参数： 12345678910function add(num1, num2) &#123; return num1 + num2;&#125;function curriedAdd(num2) &#123; return add(5, num2);&#125;console.log(add(2, 3)); // 5console.log(curriedAdd(3)); // 8 curriedAdd()本质上是在任何情况下第一个参数为5的add()版本。尽管从技术上说，这并非柯里化的函数，但它很好地展示了其概念。 柯里化函数通常由以下步骤动态创建：调用另一个函数并为它传入要柯里化的函数和必要参数。下面是创建柯里化函数的通用方式： 12345678function curry(fn) &#123; var args = Array.prototype.slice.call(arguments, 1); return function () &#123; var innerArgs = Array.prototype.slice.call(arguments); var finalArgs = args.concat(innerArgs); return fn.apply(null, finalArgs); &#125;;&#125; curry()函数的主要工作就是将被返回的参数进行排序。curry()的第一个参数是要进行柯里化的函数，其他参数是要传入的值。为了获取第一个参数之后的所有参数，在arguments对象上调用slice()方法，并传入参数1表示被返回的数组包含从第二个参数开始的所有参数。然后args 数组包含了来自外部函数的参数。在内部函数中，创建了innerArgs数组用来存放所有传入的参数。有了存放来自外部函数和内部函数的参数数组后，就可以使用concat()方法将它们组合为finalArgs，然后使用apply()将结果传递给该函数。注意这个函数并没有考虑到执行环境，所以调用apply()时第一个参数是null。curry()函数可以按以下方式应用： 123456789101112131415function curry(fn) &#123; var args = Array.prototype.slice.call(arguments, 1); //args=[5] return function () &#123; var innerArgs = Array.prototype.slice.call(arguments); //innerArgs=[3], arguments为引用对象curriedAdd的参数 var finalArgs = args.concat(innerArgs); return fn.apply(null, finalArgs); // fn为add函数 &#125;;&#125;function add(num1, num2) &#123; return num1 + num2;&#125;var curriedAdd = curry(add, 5);console.log(curriedAdd(3)); // 8 在这个例子中，创建了第一个参数绑定为5的add()的柯里化版本。当调用curriedAdd()并传入3时，3会成为add()的第二个参数，同时第一个参数依然是5，最后结果便是8。也可以像下面这样给出所有函数参数： 123456function add(num1, num2) &#123; return num1 + num2;&#125;var curriedAdd = curry(add, 5, 12);console.log(curriedAdd()); // 17 函数柯里化还常常作为函数绑定的一部分包含在其中，构造出更为复杂的bind()函数： 12345678function bind(fn, context) &#123; var args = Array.prototype.slice.call(arguments, 2); return function () &#123; var innerArgs = Array.prototype.slice.call(arguments); var finalArgs = args.concat(innerArgs); return fn.apply(context, finalArgs); &#125;;&#125; 对curry()函数主要更改在于传入的参数个数，以及它如何影响代码的结果。curry()仅仅接受一个要包裹的函数作为参数，而bind()同时接受函数和一个object对象。这表示给绑定的函数的参数是从第三个开始。倒数第三行将object对象传给apply()。当使用bind()时，它会返回绑定到给定环境的函数，并且可能它其中某些函数参数已经被设好。当想除了event对象再额外给事件处理程序传递参数时非常有用： 123456789101112131415161718function bind(fn, context) &#123; var args = Array.prototype.slice.call(arguments, 2); return function () &#123; var innerArgs = Array.prototype.slice.call(arguments); var finalArgs = args.concat(innerArgs); return fn.apply(context, finalArgs); &#125;;&#125;var handler = &#123; message: 'event handled', handleClick: function (name, event) &#123; console.log(this.message + ':' + name + ':' + event.type); &#125;&#125;;var btn = document.getElementById('my-btn');EventUtil.addHandler(btn, 'click', bind(handler.handleClick, handler, 'my-btn')); handler.handleClick()方法接受两个参数：要处理的元素的名字和event对象。作为第三个参数传递给bind()函数的名字，又被传递给了handler.handleClick()，而handler.handleClick()也会同时接受到event对象。 ECMAScript5的bind()方法也实现函数柯里化，只要在this的值之后再传入另一个参数即可： 12345678var handler = &#123; message: 'event handled', handleClick: function (name, event) &#123; console.log(this.message + ':' + name + ':' + event.type); &#125;&#125;;var btn = document.getElementById('my-btn');EventUtil.addHandler(btn, 'click', handler.handleClick.bind(handler, 'my-btn')); JavaScript中的柯里化函数和绑定函数提供了强大的动态函数创建功能，使用bind()还是curry()要根据是否需要object对象响应来决定。它们都能用于创建复杂的算法和功能，当然两者都不能滥用，因为每个函数都会带来额外的开销。 柯里化扩展阅读：JS中的柯里化(currying)，为什么要柯里化，JavaScript专题之函数柯里化，柯里化 防篡改对象一旦把对象定义为防篡改，就无法撤销。 不可扩展对象默认情况下，所有对象都是可以扩展的。任何时候都可以向对象中添加属性和方法： 12var person = &#123;name: 'tc'&#125;;person.age = 29; 使用Object.preventExtensions()方法可以改变这个行为，让你不能再给对象添加属性和方法： 12345var person = &#123;name: 'tc'&#125;;Object.preventExtensions(person);person.age = 29;console.log(person.age); // undefined 在调用了Object.preventExtensions()方法以后，就不能给person对象添加属性和方法。在非严格模式下，给对象添加新成员会导致默认失败。在严格模式下，尝试给不可扩展对象添加新成员会导致抛出错误。 虽然不能给对象添加新成员，但已有的成员不受影响，仍然可以修改和删除已有的成员。另外，使用Object.isExtensible()方法还可以确定对象是否可以扩展： 12345var person = &#123;name: 'tc'&#125;;console.log(Object.isExtensible(person)); // trueObject.preventExtensions(person);console.log(Object.isExtensible(person)); // false 密封的对象ECMAScript5为对象定义的第二个保护级别是密封对象。密封对象不可扩展，而且已有成员的[[configurable]]特性将被设置为false。这就意味着不能删除属性和方法，因为不能使用Object.defineProperty()把数据属性修改为访问器属性，或者相反。属性值是可以修改的。 要密封对象，可以使用Object.seal()方法。 12345678var person = &#123;name: 'tc'&#125;;Object.seal(person);person.age = 28;console.log(person.age); // undefineddelete person.name;console.log(person.name); // tc 使用Object.isSealed()方法可以确定对象是否被密封。因为被密封的对象不可扩展，所以Object.isExtensible()检测密封的对象也会返回false： 1234567var person = &#123;name: 'tc'&#125;;console.log(Object.isExtensible(person)); // trueconsole.log(Object.isSealed(person)); // falseObject.seal(person);console.log(Object.isExtensible(person)); // falseconsole.log(Object.isSealed(person)); // true 冻结的对象最严格的防篡改级别是冻结对象。冻结的对象即不可扩展，又是密封的，而且对象数据属性的[[writable]]特性会被设置为false。如果定义[[set]]函数，访问器属性仍然是可写的。ECMAScript5定义的Object.freeze()方法可以用来冻结对象： 1234567891011var person = &#123;name: 'tc'&#125;;Object.freeze(person);person.age = 29;console.log(person.age); // undefineddelete person.name;console.log(person.name); // tcperson.name = 'tt';console.log(person.name); // tc Object.isFrozen()方法用于检测冻结对象。因为冻结对象既是密封的又是不可扩展的，所以用Object.isExtensible()和Object.isSealed()检测冻结对象将分别返回false和true： 123456789var person = &#123;name: 'tc'&#125;;console.log(Object.isExtensible(person)); // trueconsole.log(Object.isSealed(person)); // falseconsole.log(Object.isFrozen(person)); // falseObject.freeze(person);console.log(Object.isExtensible(person)); // falseconsole.log(Object.isSealed(person)); // trueconsole.log(Object.isFrozen(person)); // true 高级定时器使用setTimeout()和setInterval()创建的定时器可以用于实现有趣且有用的功能。虽然人们对JavaScript的定时器存在普遍的误解，认为它们是线程，其实JavaScript是运行与单线程环境中的，而定时器仅仅只是计划代码在未来的某个时间执行。执行时机是不能保证的，因为在页面的生命周期中，不同时间可能有其他代码在控制JavaScript进程。在页面下载完成后的代码运行、事件处理程序、Ajax回调函数都必须使用同样的线程来执行。实际上，浏览器负责进行排序，指派某段代码在某个时间点运行的优先级。 可以把JavaScript想象成在时间线上运行的。当页面载入时，首先执行是任何包含在&lt;script&gt;元素中的代码，通常是页面生命周期后面要用到的一些简单的函数和变量的声明，不过有时候也包含一些初始数据的处理。在这之后，JavaScript进程将等待更多代码执行。当进程空闲的时候，下一个代码会被触发并立即执行。例如，当点击某个按钮时，onclick事件处理程序会立刻执行，只要JavaScript进程处于空闲状态。 除了主JavaScript执行进程外，还有一个需要在进程下一次空闲时执行的代码队列。随着页面在其生命周期中推移，代码会按照执行顺序添加入队列。例如，当按钮被按下时，它的事件处理程序代码会被添加到队列中，并在下一个可能的时间里执行。当接收到某个Ajax响应时，回调函数的代码会被添加到队列。在JavaScript中没有任何代码是立刻执行的，但一旦进程空闲则尽快执行。 定时器队列的工作方式是，当特定时间过去后将代码插入。注意，给队列添加代码并不意味着对它立即执行，而只能表示它会尽快执行。如果在插入的时间点上，队列中没有其他东西，那么这段代码就会被执行，表面上看上去好像代码就在精确指定的时间点上执行了。其他情况下，代码可能明显地等待更长时间才执行： 1234567var btn = document.getElementById('my-btn');btn.onclick = function () &#123; setTimeout(function () &#123; document.getElementById('message').style.visibility = 'visuble'; &#125;, 250); // 250s后指定代码才会被添加到队列中等待执行 // 其他代码&#125; 关于定时器要记住的最重要的事情是，指定的时间间隔表示何时将定时器的代码添加到队列，而不是何时实际执行代码。 实际上，FIrefox中定时器的实现还能让你确定定时器过了多久才执行，这需要传递一个实际执行的时间与指定的间隔的差值： 12345678910// 仅FIrefox中setTimeout(function (diff) &#123; if (diff &gt; 0) &#123; // 晚调用 &#125; else if (diff &lt; 0) &#123; // 早调用 &#125; else &#123; // 调用及时 &#125;&#125;, 250); 执行完一套代码后，JavaScript进程返回一段很短的时间，这样页面上的其他处理就可以进行。由于JavaScript进程会阻塞其他页面处理，所以必须有这些小间隔来防止用户界面被锁定。这样设置一个定时器，可以确保在定时器代码执行前至少有一个进程间隔。 重复的定时器使用setInterval()创建的定时器确保了定时器代码规则地插入队列中。这个方式的问题在于，定时器代码可能在代码再次被添加到队列之前还没有完成执行，结果导致定时器代码连续运行好几次，而之间没有任何停顿。幸好，JavaScript引擎够聪明，能避免这个问题。当使用setInterval()时，仅当没有该定时器的任何代码实例时，才将定时器代码添加到队列中。这确保了定时器代码加入到队列中的最小时间间隔为指定间隔。 这种重复定时器的规则有2个问题： 某些间隔会被跳过 多个定时器的代码执行之间的间隔可能会比预期的小 假设，某个onclick事件处理程序使用setInterval()设置了一个200ms间隔的重复定时器。如果事件处理程序花了300ms多一点的时间完成，同时定时器代码也花了差不多的时间，就会跳过一个间隔同时运行着一个定时器代码： 这个例子中的第一个定时器是在205ms处添加到队列中，但是直到过了300ms处才能执行。当执行这个定时器代码时，在405ms处又给队列添加了另一个副本。在下一个间隔，即605ms处，第一个定时器代码仍在运行，同时在队列中已经有了一个定时器代码的实例。结果是，在这个时间点上的定时器代码不会被添加到队列中。结果在5ms处添加的定时器代码结束之后，405ms处添加的定时器代码就立刻执行。 为了避免setInterval()的重复定时器的这2个缺点，你可以用如下模式使用链式setTimeout()调用： 12345setTimeout(function () &#123; // 处理中 setTimeout(arguments.callee, interval);&#125;, interval); 这个模式链式调用了setTimeout()，每次函数执行的时候都会创建一个新的定时器。第二个setTimeout()调用使用了arguments.callee来获取对当前执行的函数的引用，并为其设置另外一个定时器。这样做的好处是，在前一个定时器代码执行完之前，不会向队列插入新的定时器代码，确保不会有任何缺失的间隔。而且，它可以保证在一次定时器代码执行之前，至少要等待指定的间隔，避免了连续的运行。这个模式主要用于重复定时器： 123456789setTimeout(function () &#123; var div = document.getElementById('myDiv'); left = parseInt(div.style.left) + 5; div.style.left = left + 'px'; if (left &lt; 200) &#123; setTimeout(arguments.callee, 50); &#125;&#125;, 50); Yielding Processes运行在浏览器中的JavaScript都被分配了一个确定数量的资源。不同于桌面应用往往能够随意控制他们要的内存大小和处理时间，JavaScript被严格限制了，以防止恶意的Web程序把用户的计算机搞挂了。其中一个限制是长时间运行脚本的制约，如果代码运行超过特定的时间或特定语句数量就不会让它继续执行。如果代码达到了这个限制，会弹出一个浏览器错误的对话框，告诉用户某个脚本会用过长的时间执行，询问是允许其继续执行还是停止它。所有JavaScript开发人员的目标就是，确保用户永远不会再浏览器中看到这个对话框。定时器是绕开此限制的方法之一。 脚本长时间运行的问题通常是由两个原因造成的：过长的、过深嵌套的函数调用或者是进行大量处理的循环。这两者中，后者比较容易解决。长时间运行的循环通常遵循下面模式： 123for (var i = 0, len = data.length; i &lt; len; i++) &#123; process(data);&#125; 这个模式的问题在于要处理的项目的数量在运行前是不可知的。如果process()要花100ms，只有2个项目的数组可能不会造成影响，但是10个的数组可能会导致脚本要运行一秒钟才能完成。数组中的项目数量直接关系到执行完该循环的时间长度。同时由于JavaScript的执行是一个阻塞操作，脚本运行所花时间越久，用户无法与页面交互的时间也越久。 在展开该循环之前，你需要回答下面两个问题： 该处理是否必须同步完成？如果这个数据的处理会造成其他运行的阻塞，那么最好不要改动它。 数据是否必须按顺序完成？如果项目的顺序不重要，那么可以将某些处理推迟到以后。 当你发现某个循环占用了大量时间，同时对于上述问题，回答都是否，可以使用定时器分割这个循环。这是一种数组分块的技术，小块小块地处理数据，通常每次一小块。基本思路是为要处理的项目创建一个队列，然后使用定时器取下一个要处理的项目进行处理，接着再设置另一个定时器。基本模式如下： 12345678910setTimeout(function () &#123; // 取出下一个条目并处理 var item = array.shift(); process(item); // 若还有条目，再设置另一个定时器 if (array.length &gt; 0) &#123; setTimeout(arguments.callee, 100); &#125;&#125;, 100); 在数组分块模式中，array变量本质上就是一个待办事宜列表，它包含了要处理的项目。使用shift()方法可以获取队列中下一个要处理的项目，然后将其传递给某个函数。如果在队列中还有其他项目，则设置另一个定时器，并通过arguments.callee调用同一个匿名函数： 12345678910function chunk(array, process, context) &#123; setTimeout(function () &#123; var item = array.shift(); process.call(context, item); if (array.length &gt; 0) &#123; setTimeout(arguments.callee, 100); &#125; &#125;, 100)&#125; chunk()方法接受三个参数：要处理的项目的数组，用于处理项目的函数，以及可选的运行该函数的环境。函数内部用了之前描述过的基本模式，通过call()调用的process()函数，这样可以设置一个合适的执行环境。定时器的时间间隔设置为100ms，使得JavaScript进程有时间在处理项目的事件之间转入空闲。可以像下面这样使用该函数： 12345678var data = [123, 123, 1234, 4323, 3241, 332, 213, 21312, 321, 23, 11];function printValue(item) &#123; var div = document.getElementById('myDiv'); div.innerHTML += item + '&lt;br&gt;';&#125;chunk(data, printValue); 传递给chunk()的数组是用作一个队列的，因此当处理数据的同时，数组中的条目也在改变，如果要保持原数组不变，应该将该数组的克隆传递给chunk()： 1chunk(data.concat(), printValue) 当不传递任何参数调用concat()时，将返回和原来数组中项目一样的数组。 函数节流函数节流背后的基本思想是指，某些代码不可以在没有间断的情况下连续重复执行。第一次调用函数，创建一个定时器，在指定的时间间隔之后运行代码。当第二次调用该函数时，它会清除前一次的定时器并设置另一个。如果前一个定时器已经执行过了，这个操作就没有任何意义。然而，如果前一个定时器尚未执行，其实就是将其替换为一个新的定时器。目的是只有在执行函数的请求停止了一段时间之后才执行： 123456789101112131415161718192021var processor = &#123; timeoutId: null, // 实际进行处理的方法 performProcessing: function () &#123; // 实际执行的代码 &#125;, // 初始处理调用的方法 process: function () &#123; clearTimeout(this.timeoutId); var that = this; this.timeoutId = setTimeout(function () &#123; that.performProcessing(); &#125;, 100); // 最后一次调用process()后至少100ms后才会调用performProcessing() &#125;&#125;;// 尝试开始执行processor.process(); 这个模式可以使用throttle()函数来简化，这个函数可以自动进行定时器的设置和清楚： 123456function throttle(method, context) &#123; clearTimeout(method.tId); method.tId = setTimeout(function () &#123; method.call(context); &#125;, 100);&#125; throttle()函数接受两个参数：要执行的函数以及在哪个作用域中执行。上吗这个函数首先清除之前设置的任何定时器。定时器ID是存储在函数的tId属性中的，第一次把方法传递给throttle()的时候，这个属性可能并不存在。接下来，创建一个新的定时器，将其ID存储在方法的tId属性中。定时器使用call()方法来确保方法在适当的环境中执行。 节流在resize事件中最常使用。如果基于该事件来改变布局的话，最好控制处理频率，以确保浏览器不会再极短的时间内进行过多的计算。例如，有一个&lt;div&gt;元素需要保持它的高度始终等于宽度： 1234window.onresize = function () &#123; var div = document.getElementById('myDiv'); div.style.height = div.offsetWidth + 'px';&#125; 这段非常简单的例子可能会造成浏览器允许缓慢。首先，要计算offsetWidth属性，如果该元素或者页面上其他元素有非常复杂的CSS样式，那么这个过程将会很复杂。其次，设置某个元素的高度需要对页面进行回流来令改动生效。如果页面有很多元素同时应用了相当数量的CSS，则需要很多计算。可以用throttle()来解决： 12345678function resizeDiv() &#123; var div = document.getElementById('myDiv'); div.style.height = div.offsetWidth + 'px';&#125;window.onresize = function () &#123; throttle(resizeDiv);&#125;; 只要代码是周期性执行的，都应该使用节流。 自定义事件事件是一种叫做观察者的设计模式，这是一种创建松散耦合代码的技术。对象可以发布事件，用来表示在该对象生命周期中某个有趣的时刻到了。然后其他对象可以观察该对象，等待这些有趣的时刻到来并通过运行代码来响应。 观察者模式由两类对象组成：主体和观察者。主体负责发布事件，同时观察者通过订阅这些事件来观察该主体。该模式的一个关键概念是主体并不知道观察者的任何事情，也就是说它可以独自存在并正常运作即使观察者不存在。从另一方面来说，观察者知道主体并能注册事件的回调函数（事件处理程序）。涉及DOM上时，DOM元素便是主体，你的事件处理代码便是观察者。 事件时与DOM交互的最常见的方式，但它们也可以用于非DOM代码中—-通过实现自定义事件。自定义事件背后的概念是创建一个管理事件的对象，让其他对象监听那些事件。实现此功能的基本模式可以如下定义： 123456789101112131415161718192021222324252627282930313233343536373839function EventTarget() &#123; this.handlers = &#123;&#125;;&#125;EventTarget.prototype = &#123; constructor: EventTarget, addHandler: function (type, handler) &#123; if (typeof this.handlers[type] == 'undefined') &#123; this.handlers[type] = []; &#125; this.handlers[type].push(handler); &#125;, fire: function (event) &#123; if (!event.target) &#123; event.target = this; &#125; if (this.handlers[event.type] instanceof Array) &#123; var handlers = this.handlers[event.type]; for (var i = 0, len = handlers.length; i &lt; len; i++) &#123; handlers[i](event); &#125; &#125; &#125;, removeHandler: function (type, handler) &#123; if (this.handlers[type] instanceof Array) &#123; var handlers = this.handlers[type]; for (var i = 0, len = handlers.length; i &lt; len; i++) &#123; if (handlers[i] === handler) &#123; break; &#125; &#125; handlers.splice(i, 1); &#125; &#125;&#125;; EventTarget类型有一个单独的属性handlers，用于储存事件处理程序。还有三个方法：addHandler()，用于注册给定类型事件的事件处理程序；fire()，用于触发一个事件；removeHandler()用于注销某个事件类型的事件处理程序。 addHandler()方法接受两个参数：事件类型和用于处理该事件的函数。当调用该方法时，会进行一次检查，看看handlers属性中是否已经存在一个针对该事件类型的数组；如果没有，则创建一个新的。然后使用push()将该处理程序添加到数组的末尾。 如果要触发一个事件，要调用fire()函数。该方法接受一个单独的参数，是一个至少包含type属性的对象。fire()方法先给event对象设置一个target属性，如果它尚未被指定的话。然后它就查找对应该事件类型的一组处理程序，调用各个函数，并给出event对象。因为这些都是自定义事件，所以event对象上还需要的额外信息由你自己决定。 removeHandler()方法是addHandler()的辅助，它们接受的参数一样：事件的类型和事件处理程序。这个方法搜索事件处理程序的数组找到要删除的处理程序的位置。如果找到了，用break退出for循环。然后使用splice()方法将该项目从数组中删除。 然后，使用EventTarget类型的自定义事件可以如下使用： 123456789101112131415161718function handleMessage(event) &#123; console.log('message received: ' + event.message);&#125;// 创建一个新对象var target = new EventTarget();// 添加一个事件处理程序target.addHandler('message', handleMessage);// 触发事件target.fire(&#123;type: 'message', message: 'hello'&#125;);// 删除事件处理程序target.removeHandler('message', handleMessage);// 再次，应没有处理程序target.fire(&#123;type: 'message', message: 'hello'&#125;); 因为这种功能时封装在一种自定义类型中的，其他对象可以继承EventTarget并获得这个行为： 12345678910111213141516171819202122function Person(name, age) &#123; EventTarget.call(this); this.name = name; this.age = age;&#125;inheritPrototype(Person, EventTarget);/*function inheritPrototype(subType, superType) &#123; var prototype = object(superType.prototype); //创建对象 prototype.constructor = subType; //增强对象 subType.prototype = prototype; //指定对象&#125;function object(o) &#123; function F() &#123; &#125; F.prototype = o; return new F();&#125;*/Person.prototype.say = function (message) &#123; this.fire(&#123;type: 'message', message: message&#125;);&#125;; Person类型使用了寄生组合继承方法继承EventTarget。一旦调用了say()方法，便触发了事件，它包含了消息的细节。在某种类型的另外的方法中调用fire()方法很常见，同时它通常不是公开调用的。 123456789101112function handleMessage(event) &#123; console.log(event.target + ' says: ' + event.message);&#125;// 创建新personvar person = new Person('tc', 28);// 添加一个事件处理程序person.addHandler('message', handleMessage);// 在该对象上调用1个方法，它触发消息事件person.say('hi there.'); 当调用say()方法并传递一个消息时，就会触发message事件。接下来，它又会调用handleMessage()函数。 当代码中存在多个部分在特定时刻相互交互的情况下，自定义事件就非常有用了。这时，如果每个对象都有对其他所有对象的引用。使用自定义事件有助于解耦相关对象，保持功能的隔绝。在很多情况中，触发事件的代码和监听事件的代码是完全分离的。 拖放拖放的基本概念很简单：创建一个绝对定位的元素，使其可以用鼠标移动。这个技术源自一种叫做鼠标拖尾的经典网页技巧。鼠标拖尾是一或者多个图片在页面上跟着鼠标指针移动。单元素鼠标拖尾的基本代码需要为文档设置一个onmousemove事件处理程序，它总是将指定元素移动到鼠标指针的位置： 12345EventUtil.addHandler(document, 'mousemove', function (event) &#123; var myDiv = document.getElementById('myDiv'); myDiv.style.left = event.clientX + 'px'; myDiv.style.top = event.clientY + 'px';&#125;); 在例子中将元素放到了视口中指针的位置上。它的效果是一个元素始终跟随指针在页面上移动。只要正确时刻实现该功能，并在之后删除它，就可以实现拖放： 123456789101112131415161718192021222324252627282930313233343536373839404142434445var DrapDrop = function () &#123; var dragging = null; function handleEvent(event) &#123; // 获取事件和目标 event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); // 确定事件类型 switch (event.type) &#123; case 'mousedown' : if (target.className.indexOf('draggable') &gt; -1) &#123; dragging = target; &#125; break; case 'mousemove' : if (dragging !== null) &#123; // assign location dragging.style.left = event.clientX + 'px'; dragging.style.top = event.clientY + 'px'; &#125; break; case 'mouseup' : dragging = null; break; &#125; &#125; // 公共接口 return &#123; enable: function () &#123; EventUtil.addHandler(document, 'mousedown', handleEvent); EventUtil.addHandler(document, 'mousemove', handleEvent); EventUtil.addHandler(document, 'mouseup', handleEvent); &#125;, disable: function () &#123; EventUtil.removeHandler(document, 'mousedown', handleEvent); EventUtil.removeHandler(document, 'mousemove', handleEvent); EventUtil.removeHandler(document, 'mouseup', handleEvent); &#125; &#125;&#125;(); 要使用DragDrop对象，只要在页面上包含这些代码并调用enable()。拖放会自动针对所有包含draggable类的元素启用： 1&lt;div class="draggable" style="position: absolute; background: red"&gt;&lt;/div&gt; 注意为了元素能被拖放，它必须是绝对定位的。 修缮拖放功能上面例子中，元素的左上角总是和指针在一起。当鼠标开始移动时，元素好像突然跳了一下。 要修复这个bug，必须做一些额外的计算。需要计算元素左上角和指针位置之间的差值。这个差值应该在mousedown事件发生的时候确定，并且一直保持，直到mouseup事件发生。通过将event的clientX和clientY属性与该元素的offsetLeft和offsetTop属性进行比较，就可以算出水平方向和垂直方向上需要多少空间： 为了保存x和y坐标上的差值，还需要几个变量。diffX和diffY这些变量需要在onmousemove事件处理程序中用到，来对元素进行适当的定位： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var DragDrop = function () &#123; var dragging = null, diffX = 0, diffY = 0; function handleEvent(event) &#123; // 获取事件和目标 event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); // 确定事件类型 switch (event.type) &#123; case 'mousedown' : if (target.className.indexOf('draggable') &gt; -1) &#123; dragging = target; diffX = event.clientX - target.offsetLeft; diffY = event.clientY - target.offsetTop; &#125; break; case 'mousemove' : if (dragging !== null) &#123; // 指定位置 dragging.style.left = (event.clientX - diffX) + 'px'; dragging.style.top = (event.clientY - diffY) + 'px'; &#125; break; case 'mouseup' : dragging = null; break; &#125; &#125; // 公共接口 return &#123; enable: function () &#123; EventUtil.addHandler(document, 'mousedown', handleEvent); EventUtil.addHandler(document, 'mousemove', handleEvent); EventUtil.addHandler(document, 'mouseup', handleEvent); &#125;, disable: function () &#123; EventUtil.removeHandler(document, 'mousedown', handleEvent); EventUtil.removeHandler(document, 'mousemove', handleEvent); EventUtil.removeHandler(document, 'mouseup', handleEvent); &#125; &#125;&#125;(); 添加自定义事件拖放功能还不能真正应用起来，除非知道什么时候拖动开始。从这点上看，前面的代码没有提供任何方法表示拖动开始、正在拖动或者已经结束。这时候可以使用自定义事件来指示这几个事件的发生，让应用的其他部分与拖动功能进行交互。 由于DragDrop对象是一个使用了模块模式的单例，所以需要进行一些更改来使用EventTarget类型。首先，创建一个新的EventTarget对象，然后添加enable()和disable()方法，最后返回这个对象： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556var DragDrop = function () &#123; var dragdrop = new EventTarget(); dragging = null, diffX = 0, diffY = 0; function handleEvent(event) &#123; // 获取事件和目标 event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); // 确定事件类型 switch (event.type) &#123; case 'mousedown' : if (target.className.indexOf('draggable') &gt; -1) &#123; dragging = target; diffX = event.clientX - target.offsetLeft; diffY = event.clientY - target.offsetTop; dragdrop.fire(&#123;type: 'dragstart', target: dragging, x: event.clientX, y: event.clientY&#125;); &#125; break; case 'mousemove' : if (dragging !== null) &#123; // 指定位置 dragging.style.left = (event.clientX - diffX) + 'px'; dragging.style.top = (event.clientY - diffY) + 'px'; // 触发自定义事件 dragdrop.fire(&#123;type: 'drag', target: dragging, x: event.clientX, y: event.clientY&#125;); &#125; break; case 'mouseup' : dragdrop.fire(&#123;type: 'dragend', target: dragging, x: event.clientX, y: event.clientY&#125;); dragging = null; break; &#125; &#125; // 公共接口 dragdrop.enable = function () &#123; EventUtil.addHandler(document, 'mousedown', handleEvent); EventUtil.addHandler(document, 'mousemove', handleEvent); EventUtil.addHandler(document, 'mouseup', handleEvent); &#125;; dragdrop.disable = function () &#123; EventUtil.removeHandler(document, 'mousedown', handleEvent); EventUtil.removeHandler(document, 'mousemove', handleEvent); EventUtil.removeHandler(document, 'mouseup', handleEvent); &#125;; return dragdrop;&#125;(); 123456789101112DragDrop.addHandler('dragstart', function (event) &#123; var status = document.getElementById('status'); status.innerHTML = 'start dragging ' + event.target.id;&#125;);DragDrop.addHandler('drag', function (event) &#123; var status = document.getElementById('status'); status.innerHTML = '&lt;br/&gt;dragged ' + event.target.id + 'to (' + event.x + ',' + event.y + ')';&#125;);DragDrop.addHandler('dragend', function (event) &#123; var status = document.getElementById('status'); status.innerHTML = '&lt;br/&gt;dropped ' + event.target.id + 'at (' + event.x + ',' + event.y + ')';&#125;);]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《JavaScript高级程序设计》学习笔记（七）]]></title>
    <url>%2F2017%2F12%2F21%2F%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[第十七章：错误处理与调试 第二十章：JSON 错误处理与调试错误处理try-catch语句12345try&#123; // 可能会导致错误的代码&#125; catch (error) &#123; // 在错误发生时怎么处理&#125; 如果try块中的任何代码发生了错误，就会立刻退出代码执行过程，然后执行catch块。此时，catch块会接收到一个包含错误信息的对象。即使不想使用这个错误对象，也要给它起个名字。这个对象中包含的实际信息会因浏览器而异，但共同的是有一个保存着错误消息的message属性。ECMA-262还规定一个保存错误类型的name属性；当前所有浏览器都支持这个属性。 12345try&#123; window.someNoneexistentFunction();&#125; catch (error) &#123; alert(error.message);&#125; finally子句虽然在try-catch语句中是可选的，但finally子句一经使用，其代码无论如何都会执行。只要代码中包含finally子句，则无论try或catch语句块中包含什么代码—甚至return语句，都不会阻止finally子句的执行： 123456789function testFinally() &#123; try &#123; return 2; &#125; catch (error) &#123; return 1; &#125; finally &#123; return 0; &#125;&#125; // 返回0 错误类型ECMA-262定义了下列7种错误类型： Error EvalError RangeError ReferenceError SyntaxError TypeError URIError 其中，Error是基本类型，其他错误类型都继承自该类型。因此，所有错误类型共享一组相同的属性。Error类型的错误很少见，如果有也是浏览器抛出的；这个基本类型的主要目的是供开发人员抛出自定义错误。 EvalError类型的错误会在使用eval()函数而发生异常时被抛出。ECMA-262中对这个错误有如下描述：如果以非直接调用的方式使用eval属性的值（换句话说，没有明确地将其名称为作一个Identifier，即用作callExpression中的MemberExpression），或者为eval属性赋值。简单地说，如果没有把eval()当成函数调用，就会抛出错误： 12new eval(); // 抛出EvalErroreval = foo // 抛出EvalError 在实践中，浏览器不一定会在应该抛出错误时就抛出EvalError。加上实际开发中极少用到eval()，所以遇到这种错误类型的可能性极小。 RangeError类型的错误会在数值超出相应范围时触发： 12var items1 = new Array(-20); // 抛出RangeErrorvar items2 = new Array(Number.MAX_VALUE); // 抛出RangeError 在找不到对象的情况下，会发生ReferenceError。通常，在访问不存在的变量时，就会发生这种错误： 1var obj = x; // 在x并未声明的情况下抛出ReferenceError 当把语法错误的JavaScript字符串传入eval()函数时，会导致SyntaxError： 1eval('a ++ b'); // 抛出SyntaxError TypeError类型在JavaScript中经常用到，在变量中保存着意外的类型时，或者在访问不存在的方法时，都会导致这种错误。错误的原因虽然多种多样，但归根结底还是由于在执行特定于类型的操作时，变量的类型并不符合要求所致： 123var o = new 10; // 抛出TypeErrorconsole.log('name' in true); // 抛出TypeErrorFunction.prototype.toString.call('name'); // 抛出TypeError 在使用encodeURI()和decodeURI()，而URI格式不正确时，就会导致URIError错误。 可以像下面这样在try-catch语句的catch语句中使用instanceof操作符： 1234567891011try &#123; someFunction();&#125;catch (error)&#123; if (error instanceof TypeError)&#123; // 处理类型错误 &#125;else if (error instanceof ReferenceError)&#123; // 处理引用错误 &#125;else &#123; // 处理其他类型错误 &#125;&#125; 在跨浏览器编程中，检查错误类型是确定处理方式的最简便途经；包含在message属性中的错误消息会因浏览器而异。 合理使用try-catch使用try-catch最适合处理那些无法控制的错误。在明白地知道自己的代码会发生错误时，再使用try-catch语句就不太合适。 抛出错误与try-catch语句相匹配的还有一个throw操作符，用于随时抛出自定义错误。抛出错误时，必须要给throw操作符指定一个值，这个值是什么类型，没有要求。 1234throw 12345;throw 'hello';throw true;throw &#123;name: 'JavaScript'&#125;; 在遇到throw操作符时，代码会立即停止执行。仅当try-catch语句捕获到被抛出的值时，代码才会继续执行。 通过使用某种内置错误类型，可以更真实地模拟浏览器错误。每种错误类型的构造函数接收一个参数，即实际的错误消息： 1throw new Error('something bad happened'); 还可以使用其他错误类型，模拟出类似的浏览器错误： 123456throw new SyntaxError("i don't like your syntax");throw new TypeError('what type of variable do you take me for');throw new RangeError('Sorry, you just do not have the range');throw new EvalError('that does not evaluate');throw new URIError('uri, is that you');throw new ReferenceError('you do not cite your references properly'); 另外，利用原型链还可以通过继承Error来创建自定义错误类型。此时，需要为新创建的错误类型指定name和message属性： 12345678function CustomError(message) &#123; this.name = 'CustomError'; this.message = message;&#125;CustomError.prototype = new Error();throw new CustomError('My message'); 抛出错误的时机浏览器会在某种特定的条件下自习函数时抛出错误： 123456789101112// 如果values不是数组，浏览器会报错function process(values) &#123; values.sort(); for (var i = 0, len = values.length; i &lt; len; i++) &#123; if (values[i] &gt; 100) &#123; return values[i]; &#125; &#125; return -1;&#125; 但错误消息没有清楚的告诉我们到底出了什么问题。当面对复杂的Web应用时，要想查找错误来源就没有那么容易。这种情况下，带有适当信息的自定义错误能够显著提升代码的可维护性： 1234567891011121314function process(values) &#123; if (!(values instanceof Array)) &#123; throw new Error('process(): Argument must be an array'); &#125; values.sort(); for (var i = 0, len = values.length; i &lt; len; i++) &#123; if (values[i] &gt; 100) &#123; return values[i]; &#125; &#125; return -1;&#125; 建议重点关注函数和可能导致函数执行失败的因素。 抛出错误与使用try-catch在编写一个要在很多应用程序中使用的JavaScript库，甚至编写一个可能会在应用内部多个地方使用的辅助函数，强烈建议在抛出错误时提供详尽的信息。然后，即可在应用程序中捕获并适当处理这些错误。 只应该捕获那些确切知道该如何处理的错误。捕获错误的目的在于避免浏览器以默认方式处理它们；而抛出错误的目的在于提供错误发生具体原因的消息。 错误事件任何没有通过try-catch处理的错误都会触发window对象的error事件。在任何浏览器中，onerror事件处理程序都不会创建event对象，但它可以接收三个参数：错误消息、错误所在的URL和行号。要使用onerror事件处理程序，必须使用如下DOM0级技术，它没有遵循DOM2级事件的标准格式： 123window.onerror = function (message, url, line) &#123; console.log(message);&#125; 只要发生错误，无论是不是浏览器生成的，都会触发error事件，并执行这个事件处理程序。然后，浏览器默认的机制发挥作用，像往常一样显示错误消息。像下面这样在事件处理程序中返回false，可以阻止浏览器报告错误的默认行为： 1234window.onerror = function (message, url, line) &#123; console.log(message); return false;&#125; 只要适当地使用try-catch语句，就不会有错误交给浏览器，也就不会触发error事件。 图像也支持error事件。只要图像的src特性中的URL不能返回可以被识别的图像格式，就会触发error事件。此时的error事件遵循DOM格式，会返回一个以图像为目标的event对象： 12345678var image = new Image();EventUtil.addHandler(image, 'load', function (event) &#123; console.log('image loaded');&#125;);EventUtil.addHandler(image, 'error', function (event) &#123; console.log('image not loaded');&#125;);image.src = 'test.gif'; // 指定不存在的文件 常见的错误类型一般来说，需要关注三种错误： 类型转换错误 数据类型错误 通信错误 类型转换错误类型转换错误发生在使用某个操作符，或者使用其他可能会自动转换值的数据类型的语言结构时。在使用==和!=，或者在if、for和while等流控制语句中使用非布尔值时，最常发生类型转换错误。 多数情况下，建议使用===和!==，以避免类型转换。 流控制语句会在确定下一步操作前，把任何值转换为布尔值，尤其是if语句，使用不当，容易出错： 1234567function concat(str1, str2, str3) &#123; var result = str1 + str2; if (str3) &#123; // 绝对不要这样, 如果str是0也会是false result += str3; &#125; return result;&#125; 在流控制语句中使用非布尔值，是极为常见的错误来源。为了避免此类错误，就要做到在条件比较时切实传入布尔值： 1234567function concat(str1, str2, str3) &#123; var result = str1 + str2; if (typeof str3 == 'string') &#123; // 恰当比较 result += str3; &#125; return result;&#125; 数据类型错误JavaScript在使用变量和函数参数之前，不会对它们进行比较以确保它们的数据类型正确。在将预料之外的值传递给函数的情况下，最容易发送数据类型错误。 1234567891011121314151617181920// 不安全的函数，任何非字符串值都会导致错误function getQueryString(url) &#123; var pos = url.indexOf('?'); if (pos &gt; -1) &#123; return url.substring(pos + 1); &#125; return "";&#125;/*--------------重写后----------------*/function getQueryString(url) &#123; if (typeof url == 'string') &#123; // 通过检查类型确保安全 var pos = url.indexOf('?'); if (pos &gt; -1) &#123; return url.substring(pos + 1); &#125; return ""; &#125;&#125; 在流控制语句中使用非布尔值作为条件很容易导致数据类型错误： 123456function reverseSort(values) &#123; if (values) &#123; // 任何会转换为true的非数组值都会导致错误 values.sort(); values.reverse(); &#125;&#125; 另一个常见错误是将参数与null比较： 123456function reverseSort(values) &#123; if (values != null) &#123; // 与null比较只能确保相应的值不少null和undefined values.sort(); values.reverse(); &#125;&#125; 另一种错误做法，就是只针对要使用的某一个特性执行检测： 123456function reverseSort(values) &#123; if (typeof values.sort == 'function') &#123; // 如果传入一个包含sort()方法的对象(而不是数组)也会通过检测 values.sort(); values.reverse(); &#125;&#125; 在知道应该传入什么类型的情况下，最好使用instanceof来检测其数据类型： 123456function reverseSort(values) &#123; if (values instanceof Array) &#123; // 问题解决了 values.sort(); values.reverse(); &#125;&#125; 大体上，基本类型的值应该用typeof来检测，而对象类型的值应该使用instanceof来检测。 通信错误第一种通信错误与格式不正确的URL或发送的数据有关。最常见的问题是在将数据发送给服务器之前，没有使用encodeURIComponent()对数据进行编码。可以定义一个处理查询字符串的函数： 1234567891011121314function addQueryStringArg(url, name, value) &#123; if (url.indexOf('?') == -1) &#123; url += '?'; &#125;else &#123; url += '&amp;'; &#125; url += encodeURIComponent(name) + '=' + encodeURIComponent(value); return url;&#125;var url = 'http://www.tc9011.com';var newUrl = addQueryStringArg(url, 'redir', 'http://www.someotherdomain.com?a=b&amp;c=d');console.log(newUrl); 另外，在服务器响应的数据不正确时，也会发生通信错误。 区分致命错误和非致命错误对于非致命错误，可以根据下列一或多个条件来确定： 不影响用户的主要任务 只影响页面的一部分 可以恢复 重复相同操作可以消除错误 致命错误，可以通过下列一或多个条件来确定： 应用程序根本无法继续运行 错误明显影响到了用户的主要操作 会导致其他连带错误 区分非致命错误和致命错误的主要依据，就是看它们对用户的影响。设计良好的代码，可以做到应用程序某一部分发生错误不会不必要地影响另一个实际上毫不相干的部分。 调试技术将消息记录到控制台console对象有下列方法： error(message)：将错误消息记录到控制台 info(message)：将信息性消息记录到控制台 log(message)：将一般消息记录到控制台 warn(message)：将警告消息记录到控制台 抛出错误对大型应用程序来说，自定义的错误通常都使用assert()函数抛出。这个函数接受两个参数，一个是求值结果应该为true的条件，另一个是条件为false时要抛出的错误。以下就是一个非常基本的assert()函数： 12345678910function assert(condition, message) &#123; if (!condition) &#123; throw new Error(message); &#125;&#125;function divide(num1, num2) &#123; assert(typeof num1 == 'number' &amp;&amp; typeof num2 =='number', 'divide():Both arguments must be numbers'); return num1/num2;&#125; JSON语法JSON语法可以表示下列三种类型的值： 简单值：使用与JavaScript相同的语法，可以在JSON中表示字符串、数值、布尔值和null，但JSON不支持JavaScript中的特殊值unefined。 对象：对象作为一种复杂数据类型，表示的是一组有序的键值对。而每个键值对中的值可以是简单值，也可以是复杂数据类型的值。 数组：数组也是一种复杂数据类型，表示一组有序的值的列表，可以通过数值索引来访问其中的值。数组的值也可以是任意类型。 JSON不支持变量、函数或对象实例，它就是一种表示结构化数据的格式。 简单值最简单的JSON数据形式就是简单值。例如： 15 这是JSON表示数值5的方式。类似地，下面是JSON表示字符串的方式： 1"hello world" JavaScript字符串与JSON字符串的最大区别在于，JSON字符串必须使用双引号（单引号会导致语法错误）。 布尔值和null也是有效的JSON形式。 对象JSON中的对象要求给属性加引号： 1234&#123; "name": "tc", "age": 29&#125; 属性的值可以是简单值，也可以是复杂类型值： 12345678&#123; "name": "tc", "age": 29, "school": &#123; "name": "aaa", "location": "uuu" &#125;&#125; 数组在JSON中，可以采用JavaScript同样的语法表示同一个数组： 1[25, "hi", true] JSON数组没有变量和分号。把数组和对象结合起来，可以构成更复杂的数据集合： 123456789101112131415161718[ &#123; "name": "tc", "age": 29, "school": &#123; "name": "aaa", "location": "uuu" &#125; &#125;, &#123; "name": "tc1", "age": 27, "school": &#123; "name": "aaa", "location": "uuu" &#125; &#125;] 解析与序列化JSON对象JSON对象有两个方法：stringfy()和parse()。在最简单的情况下，这两个方法分别用于把JavaScript对象序列化为JSON字符串和把JSON字符串解析为原生JavaScript值： 12345678910var book = &#123; title: "professional javascript", authors: [ "Nicholas C. Zakas" ], edition: 3, year: 2011&#125;;var jsonText = JSON.stringify(book); 默认情况下，JSON.stringify()输出的JSON字符串不包含任何空格字符或缩进： 1&#123;"title":"professional javascript","authors":["Nicholas C. Zakas"],"edition":3,"year":2011&#125; 在序列化JavaScript对象时，所有函数及原型成员都会被有意忽略，不体现在结果中。此外，值为undefined的任何属性也都会被跳过。 将JSON字符串直接传递给JSON.parse()就可以得到相应的JavaScript值： 1var bookCopy = JSON.parse(jsonText); 如果传给JSON.parse()的字符串不是有效的JSON，该方法会抛出错误。 序列化选项JSON.stringify()还可以接收另外两个参数，这两个参数用于指定以不同的方式序列化JavaScript对象。第一个参数是个过滤器，可以是个数组，也可以是个函数；第二个参数是一个选项，表示是否在JSON字符串中保留缩进。单独或组合使用这两个参数，可以更全面深入地控制JSON的序列化。 过滤结果如果过滤器参数是数组，那么JSON.stringify()的结果中将只包含数组中列出的属性： 1234567891011var book = &#123; title: "professional javascript", authors: [ "Nicholas C. Zakas" ], edition: 3, year: 2011&#125;;var jsonText = JSON.stringify(book, ['title', 'edition']);// &#123;"title":"professional javascript","edition":3&#125; 如果第二个参数是函数，传入的函数接受两个参数，属性（键）名和属性值。根据属性（键）名可以知道应该如何处理要序列化的对象中的属性。属性名只能是字符串，而在值并非键值对结构的值时，键名可以是空字符串。 为了改变序列化对象的结果，函数返回的值就是相应键的值。如果函数返回了undefined，那么相应的属性会被忽略： 1234567891011121314151617181920212223242526var book = &#123; title: "professional javascript", authors: [ "Nicholas C. Zakas" ], edition: 3, year: 2011&#125;;var jsonText = JSON.stringify(book, function (key, value) &#123; switch (key) &#123; case 'authors': return value.join(","); case 'year': return 5000; case "edition": return undefined; default: // 一定要提供default项 return value; &#125;&#125;);// &#123;"title":"professional javascript","authors":"Nicholas C. Zakas","year":5000&#125; 字符串缩进JSON.stringify()方法的第三个参数用于控制结果中的缩进和空白符。如果这个参数是一个数值，那它表示的是每个级别缩进的空格数： 123456789101112131415161718var book = &#123; title: "professional javascript", authors: [ "Nicholas C. Zakas" ], edition: 3, year: 2011&#125;;var jsonText = JSON.stringify(book, null, 4); // 每个级别缩进4个空格/*&#123; "title": "professional javascript", "authors": [ "Nicholas C. Zakas" ], "edition": 3, "year": 2011&#125;*/ JSON.stringify()也在结果字符串中插入了换行符以提高可读性。只要传入有效的控制缩进的参数值，结果字符串就会包含换行符。最大缩进空格数为10，所有大于10的值都会自动转换为10. 如果缩进参数是一个字符串而非数值，则这个字符串将在JSON字符串中被用作缩进字符。在使用字符串的情况下，可以将缩进字符设置为制表符，或者两个短划线之类的任意字符： 1234567891011var jsonText = JSON.stringify(book, null, '- -');/*&#123;- -"title": "professional javascript",- -"authors": [- -- -"Nicholas C. Zakas"- -],- -"edition": 3,- -"year": 2011&#125;*/ toJSON()方法可以调用toJSON()方法，返回其自身的JSON数据格式。原生Date对象有一个toJSON()方法，能够将JavaScript的Date对象自动转换成ISO 8601日期字符串。 可以为任何对象添加toJSON()方法： 1234567891011121314var book = &#123; title: "professional javascript", authors: [ "Nicholas C. Zakas" ], edition: 3, year: 2011, toJSON: function () &#123; return this.title; &#125;&#125;;var jsonText = JSON.stringify(book);// "professional javascript" 可以让toJSON()方法返回任何序列化的值，它都能正常工作。也可以让这个方法返回undefined，此时如果包含它的对象嵌入在另一个对象中，会导致该对象的值变成null，而如果包含它的对象是顶级对象，结果就是undefined。 toJSON()可以作为函数过滤器的补充，因此理解序列化的内部顺序十分重要。假设把一个对象传入JSON.stringify()，序列化该对象的顺序如下： 如果存在toJSON()方法而且能通过它取得有效值，则调用该方法。否则按默认顺序执行序列化 如果提供了第二个参数，应用这个函数过滤器。传入函数过滤器的值是第一步返回的值 对第二部返回的每个值进行相应的序列化 如果提供了第三个参数，执行相应的格式化 解析选项JSON.parse()方法也可以接收另一个参数，该参数是一个函数，将每个键值对上调用。为了区别JSON.stringify()接收的过滤函数，这个函数被称为还原函数，但实际上两个函数的签名是相同的—它们都接收两个参数，一个键和一个值，而且都需要返回一个值。 如果还原函数返回undefined，则表示要从结果中删除相应的键；如果返回其他值，则将该值插入到结果中。在将日期字符串转换为Date对象时，经常要用到还原函数： 123456789101112131415161718192021var book = &#123; title: "professional javascript", authors: [ "Nicholas C. Zakas" ], edition: 3, year: 2011, releaseDate: new Date(2011, 11, 1)&#125;;var jsonText = JSON.stringify(book);var bookCopy = JSON.parse(jsonText, function (key, value) &#123; if (key == 'releaseDate') &#123; return new Date(value); &#125;else &#123; return value; &#125;&#125;);console.log(bookCopy.releaseDate.getFullYear()); // 2011]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular中ngx-translate使用简介]]></title>
    <url>%2F2017%2F12%2F16%2FAngular%E4%B8%ADngx-translate%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[前段时间，我们团队的项目要在国外演示，对所有相关项目进行了国际化改造。下面简单介绍一下ngx-translate库在Angular5下的使用方法。 导入ngx-translate运行下面命令安装@ngx-translate/core和@ngx-translate/http-loader： 12npm install @ngx-translate/core --savenpm install @ngx-translate/http-loader --save 然后在根模块（一般是app.module.ts）下引入TranslateModule 1234567891011121314151617181920212223242526272829import &#123; BrowserModule &#125; from '@angular/platform-browser';import &#123; NgModule &#125; from '@angular/core';import &#123;HttpClient&#125; from "@angular/common/http";import &#123;TranslateLoader, TranslateModule&#125; from "@ngx-translate/core";import &#123;TranslateHttpLoader&#125; from "@ngx-translate/http-loader";import &#123; AppComponent &#125; from './app.component';// 为AOT准备export function createTranslateLoader(http: HttpClient) &#123; return new TranslateHttpLoader(http, './assets/i18n/', '.json');&#125;@NgModule(&#123; imports: [ BrowserModule, TranslateModule.forRoot(&#123; loader: &#123; provide: TranslateLoader, useFactory: (createTranslateLoader), deps: [HttpClient] &#125; &#125;) ], declarations: [AppComponent], providers: [], bootstrap: [AppComponent]&#125;)export class AppModule &#123; &#125; 如果Angular版本小于4.3，可以使用`http-loader@0.1.0，并用@angular/http中的Http代替HttpClient`。 为了方便在其他模块下使用，在sharedModule下面导入TranslateModule： 12345678910111213141516import &#123; NgModule &#125; from '@angular/core';import &#123; CommonModule &#125; from '@angular/common';import &#123;TranslateModule&#125; from "@ngx-translate/core";const sharedModule = [ CommonModule, TranslateModule];@NgModule(&#123; imports: sharedModule, declarations: [], exports: sharedModule&#125;)export class SharedModule &#123; &#125; 这样在其他模块下导入sharedModule就可以使用ngx-translate了。 使用ngx-translate在/assets/i18n/目录下新建en.json和zh.json两个文件，如果用Angular-Cli新建的工程，默认会有这两个文件。这个目录下的json文件名会作为ngx-translate中的语言名称使用，比如translate.use(&#39;zh&#39;)中的zh就是zh.json的文件名，如果json文件改成zh-CN，相应代码中的也要更改为translate.use(&#39;zh-CN&#39;)。 翻译HTML中的内容TypeScript： 1234567891011121314151617181920212223import &#123; Component&#125; from '@angular/core';import &#123;TranslateService&#125; from '@ngx-translate/core';@Component(&#123; selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.scss'],&#125;)export class AppComponent&#123; constructor(public translate: TranslateService)&#123; translate.addLangs(['zh', 'en']); // 增加语言 translate.setDefaultLang('zh'); // 设置默认语言 translate.use('zh'); // 启用语言 &#125; useEnglish() &#123; this.translate.use('en'); &#125; useChinese() &#123; this.translate.use('zh'); &#125;&#125; HTML： 123&lt;p&gt;&#123;&#123;'projectname' | translate&#125;&#125;&lt;/p&gt;&lt;button type="button" (click)="useChinese()"&gt;中文&lt;/button&gt;&lt;button type="button" (click)="useEnglish()"&gt;English&lt;/button&gt; TranslateService仅需在要使用该服务的地方注入，在不需要的组件中，可以不注入，直接使用管道在HTMl翻译对应的内容。 在HTML中还可以使用属性指令来翻译： 1&lt;div [translate]="'projectname'"&gt;&lt;/div&gt; 翻译TypeScript中的内容可以使用TranslateService中的instant()方法配合订阅onLangChange来实现。onLangChange是一个监听语言变化的EventEmitter，可以实现跨模块通讯，比如A模块中切换成英文，onLangChange会通知所有模块下语言都切换成英文，此时去B模块下，界面也是英文状态的。 TypeScript： 12345678910111213141516171819202122232425262728293031import &#123; Component, OnInit&#125; from '@angular/core';import &#123;TranslateService, TranslationChangeEvent&#125; from '@ngx-translate/core';@Component(&#123; selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.scss'],&#125;)export class AppComponent implements OnInit &#123; name: string; constructor(public translate: TranslateService)&#123; translate.addLangs(['zh', 'en']); // 增加语言 translate.setDefaultLang('zh'); // 设置默认语言 translate.use('zh'); // 启用语言 &#125; ngOnInit() &#123; this.translate.onLangChange.subscribe((event: TranslationChangeEvent) =&gt; &#123; this.name = this.translate.instant('projectname'); &#125;); &#125; useEnglish() &#123; this.translate.use('en'); &#125; useChinese() &#123; this.translate.use('zh'); &#125;&#125; HTML： 123&lt;p&gt;&#123;&#123;name&#125;&#125;&lt;/p&gt;&lt;button type="button" (click)="useChinese()"&gt;中文&lt;/button&gt;&lt;button type="button" (click)="useEnglish()"&gt;English&lt;/button&gt; 如果你的项目里面也使用了bootstrap-table，可以像下面这样去实现表格的国际化： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135import &#123;Component, OnInit&#125; from '@angular/core';import &#123;TranslateService, TranslationChangeEvent&#125; from "@ngx-translate/core";@Component(&#123; selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.scss']&#125;)export class AppComponent implements OnInit &#123; window: any = window; rowData: any; isDropdownOpen: boolean; constructor(public translate: TranslateService) &#123; const that = this; this.window.operateEvents = &#123; 'click .delete': function (e, value, row, index) &#123; that.delete(); &#125;, 'click .modify': function (e, value, row, index) &#123; that.modify(); &#125; &#125;; &#125; ngOnInit() &#123; this.rowData = [ &#123; 'groupname': '1', 'describe': '2' &#125;, &#123; 'groupname': '1', 'describe': '2' &#125; ]; this.translate.onLangChange.subscribe((event: TranslationChangeEvent) =&gt; &#123; $('#table').bootstrapTable('destroy'); this.initTable(); &#125;); this.initTable(); &#125; initTable() &#123; const gridOptions: any = &#123; pagination: true, pageSize: 10, pageList: [10, 25, 50, 100], search: true, strictSearch: false, searchText: '', paginationDetailHAlign: 'left', paginationHAlign: 'right', clickToSelect: false, sortable: true, &#125;; if (this.translate.currentLang === 'zh') &#123; $.extend($.fn.bootstrapTable.defaults, $.fn.bootstrapTable.locales['zh-CN']); &#125; else &#123; $.extend($.fn.bootstrapTable.defaults, $.fn.bootstrapTable.locales['en']); &#125; $('#table').bootstrapTable($.extend(gridOptions, &#123; data: this.rowData, columns: this.getColumns() &#125;)); $('#table').on('show.bs.dropdown', function () &#123; this.isDropdownOpen = true; &#125;); $('#table').on('hide.bs.dropdown', function () &#123; this.isDropdownOpen = false; &#125;); &#125; getColumns() &#123; const columnDefs: any = [ &#123; field: 'groupname', title: this.translate.instant('groupmanagement.groupname'), valign: 'middle', align: 'center', events: 'operateEvents', &#125;, &#123; field: 'describe', title: this.translate.instant('groupmanagement.describe'), valign: 'middle', align: 'center', events: 'operateEvents', &#125;, &#123; field: 'operate', title: this.translate.instant('common.operate'), align: 'center', valign: 'middle', events: 'operateEvents', formatter: (value, row, index) =&gt; &#123; return `&lt;div class="btn-group table-operate-float" style="position:relative;margin:0;"&gt;\&lt;button class="btn btn-default authority table-operate-btn floor-settings modify" style="margin:0;border-right: none;"&gt;$&#123;this.translate.instant('common.edit')&#125;&lt;/button&gt;\ &lt;button class="btn btn-default dropdown-toggle table-operate-btn" style="margin:0;" id="dropdownMenu" \ data-toggle="dropdown" &gt;&lt;span class="caret"&gt;&lt;/span&gt;\ &lt;/button&gt;\ &lt;ul class="dropdown-menu dropdown-menu-top table-operate-ulfont" role="menu" aria-labelledby="dropdownMenu1"&gt;\ &lt;li role="presentation"&gt;\ &lt;a href="javascript:void(0);" class="delete" data-toggle="modal" data-target="#delConfirmModal"&gt;$&#123;this.translate.instant('common.delete')&#125;&lt;/a&gt;\ &lt;/li&gt;\ &lt;/ul&gt;\ &lt;/div&gt;`; &#125; &#125; ]; return columnDefs; &#125; delete() &#123; console.log('delete'); &#125; modify() &#123; console.log('modify'); &#125; useEnglish() &#123; this.translate.use('en'); &#125; useChinese() &#123; this.translate.use('zh'); &#125;&#125; HTML： 1&lt;table id="table"&gt;&lt;/table&gt; 提取工具国际化过程中需要维护/assets/i18n/下的所有json文件，每次提取key的时候会比较麻烦，此时可以使用ngx-translate提供的一个小工具：ngx-translate-extract。 首先安装ngx-translate-extract： 1npm install @biesbjerg/ngx-translate-extract --save-dev 然后在package.json的scripts中加上： 1"extract": "ngx-translate-extract --input ./src --output ./src/assets/i18n/*.json --clean --sort --format namespaced-json" 然后在终端中运行： 1npm run extract 这样就可以把HTML和TypeScript中所有的key都一起提取出来。 extract命令中： --clean表示会清除/assets/i18n/下的json文件中未使用过的key； --sort表示对json文件中的key进行按照字母顺序排序； --format namespaced-json表示对json文件使用namespaced-json方式进行格式化。 结尾ngx-translate使用起来还是比较方便，不过在做国际化过程中还会遇到其他很多问题，比如地图、地址选取、英文状态下样式变更等。关于国际化改造方案可以参考淘宝前端国际化方案探索和组件库设计实战系列：国际化方案两篇文章，还是比较有启发性的。]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《JavaScript高级程序设计》学习笔记（六）]]></title>
    <url>%2F2017%2F12%2F10%2F%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[第十四章：表单脚本 第十五章：使用Canvas绘图 第十六章：HTML5脚本编程 表单脚本表单的基础知识在HTML中，表单是由&lt;form&gt;元素来表示，而在JavaScript中，表单对应的则是HTMLFormElement类型。HTMLFormElement继承了HTMLElement，因而与其他HTML元素具有相同的默认属性。不过，HTMLFormElement也有自己独有的属性和方法： acceptCharset：服务器能够处理的字符集；等价于HTML中的accept-charset特性 action：接受请求的URL；等价于HTML中的action特性 elements：表单中所有控件的集合 enctype：请求的编码类型；等价于HTML中的enctype特性 length：表单中控件的数量 method：要发送的HTTP请求类型，通常是get或post；等价于HTML的method特性 name：表单的名称；等价于HTML的name特性 reset()：将所有表单域重置为默认值 submit()：提交表单 target：用于发送请求和接收响应的窗口名称；等价于HTML的target特性 取得&lt;form&gt;元素引用的方式有好几种，其中最常见的方式就是将他看成与其他元素一样，并为其添加id特性，然后再想下面这样使用getElementById()方法找到它： 1var form = document.getElementById('form1'); 其次，通过document.forms可以取得页面中所有的表单。这个集合中，可以通过数值索引或name值来取得特定的表单： 12var firstForm = document.forms[0]; // 取得页面中的第一个表单var myForm = document.forms['form2']; //取得页面中名为form2的表单 可以同时为表单指定id和name属性，但它们的值不一定相同。 提交表单使用&lt;input&gt;或&lt;button&gt;都可以定义提交按钮，只要将其type特性的值设置为submit即可，而图像按钮则是通过将&lt;input&gt;的type特性设置为image来定义的： 12345678&lt;!--通过提交按钮--&gt;&lt;input type="submit" value="submit form"&gt;&lt;!--自定义提交按钮--&gt;&lt;button type="submit"&gt;submit form&lt;/button&gt;&lt;!--图像按钮--&gt;&lt;input type="image" src="graphic.gif"&gt; 只要表单中存在上面列出的任何一种按钮，那么在相应表单控件拥有焦点的情况下，按回车键就可以提交该表单（textarea是一个例外，在文本区中回车会换行）。如果表单没有提交按钮，按回车键就不会提交表单。 以这种方式提交表单时，浏览器会在将请求发给服务器之前触发submit事件。这样，就有机会验证表单数据，并据以决定是否允许表单提交。阻止这个事件的默认行为就可以取消表单提交: 1234567EventUtil.addHandler(form, 'submit', function (event) &#123; // 取得事件对象 event = EventUtil.getEvent(event); // 阻止默认事件 EventUtil.preventDefault(event);&#125;); 一般来说，在表单数据无效而不能发送给服务器时，可以使用这一技术。 在JavaScript中，以编程方式调用submit()方法也可以提交表单。而且，这种方式无需表单包含提交按钮，任何时候都可以正常提交表单： 1form.submit(); 在以调用submit()方法的形式提交表单时，不会触发submit事件，因此要记得在调用此方法之前先验证表单数据。 提交表单时可能出现的最大问题，就是重复提交表单。解决这一问题的办法有两个：在第一次提交表单后就禁用提交按钮，或者利用onsubmit事件处理程序取消后续的表单提交操作。 重置表单在用户单击重置按钮时，表单会被重置。使用type特性值为reset的&lt;input&gt;或&lt;button&gt;都可以创建重置按钮： 12345&lt;!--通用重置按钮--&gt;&lt;input type="reset" value="reset form"&gt;&lt;!--自定义重置按钮--&gt;&lt;button type="reset"&gt;reset form&lt;/button&gt; 这两个按钮都可以用来重置表单。在重置表单时，所有表单字段都会恢复到页面刚加载完时的初始值。如果某个字段的初始值为空，就会恢复为空；而带有默认值的字段，也会恢复为默认值。 用户单击重置按钮时，会触发reset事件。利用这个机会，可以在必要时取消重置操作： 1234567EventUtil.addHandler(form, 'submit', function (event) &#123; // 取得事件对象 event = EventUtil.getEvent(event); // 阻止默认事件 EventUtil.preventDefault(event);&#125;); 与提交表单一样，也可以通过JavaScript来重置表单： 1form.reset(); 与调用submit()方法不同，调用reset()方法会像单击重置按钮一样触发reset事件。 事实上重置表单的需求很少见。更常见的做法是提供一个取消按钮，让用户能够返回到前一个页面，而不是不分青红皂白地重置表单中的所有值。 表单字段可以像访问页面中的其他元素一样，使用原生DOM方法访问表单元素。此外，每个表单都有elements属性，该属性是表单中所有元素的集合。这个elements集合是一个有序列表，其中包含着表单中的所有字段，例如&lt;input&gt;、&lt;textarea&gt;、&lt;button&gt;和&lt;fieldset&gt;。每个表单字段在elements集合中的顺序，与它们出现在标记中的顺序相同，可以按照位置和name特性来访问它们： 12345678// 取得表单中的第一个字段var field1 = form.elements[0];// 取得name为textbox1的字段var field2 = form.elements['textbox1'];// 取得表单中包含的字段的数量var fieldCount = form.elements.length; 如果有多个表单控件都在使用一个name（如单选按钮），那么就会返回以该name命名的一个NodeList： 1234567&lt;form method="post" id="myForm"&gt; &lt;ul&gt; &lt;li&gt;&lt;input type="radio" name="color" value="red"&gt;RED&lt;/li&gt; &lt;li&gt;&lt;input type="radio" name="color" value="green"&gt;GREEN&lt;/li&gt; &lt;li&gt;&lt;input type="radio" name="color" value="blue"&gt;BLUE&lt;/li&gt; &lt;/ul&gt;&lt;/form&gt; 12345678var form = document.getElementById('myForm');var colorFields = form.elements['color'];alert(colorFields.length); //3var firstColorField = colorFields[0];var firstFormField = form.elements[0];alert(firstColorField === firstFormField); //true 共有的表单字段属性除了&lt;fieldset&gt;元素外，所有表单字段都拥有相同的一组属性。由于&lt;input&gt;类型可以表示多种表单字段，因此有些属性只适用于某些字段，但还有一些属性是所有字段所共有的。表单字段共有的属性如下： disabled：布尔值，表示当前字段是否被禁用 form：指向当前字段所属表单的指针；只读 name：当前字段的名称 readOnly：布尔值，表示当前字段是否只读 tabIndex：表示当前字段的切换（tab）序号 type：当前字段的类型，如checkbox、radio等等 value：当前字段将被提交给服务器的值。对文件字段来说，这个属性是只读的，包含着文件在计算机中的路径 除了form属性之外，可以通过JavaScript动态修改其他任何属性： 12345678910111213141516var field = form.elements[0];//修改value属性field.value = 'Another Value';//检查form属性的值alert(field.form === form); //true//把焦点设置到当前字段field.focus();//禁用当前字段field.disabled = true;//修改type属性（不推荐，但对&lt;input&gt;来说是可行的）field.type = 'checkbox'; 能够动态修改表单字段属性，意味着可以在任何时候以任何方式来动态操作表单。例如在第一次单击后禁用提交按钮： 1234567891011//避免多次提交表单EventUtil.addHandler(form, 'submit', function (event) &#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); //取得提交按钮 var btn = target.elements['submit-btn']; //禁用它 btn.disabled = true;&#125;); 注意，不能通过onclick事件处理程序来实现这个功能，原因是不同浏览器之间存在”时差”：有的浏览器会在触发表单的submit事件之前触发click事件，而有的浏览器则相反。因此，最好是通过submit事件来禁用提交按钮。不过，这种方式不适合表单中不包含提交按钮的情况，只有在包含提交按钮的情况下，才有可能触发表单的submit事件。 除了&lt;fieldset&gt;之外，所有表单字段都有type属性。对于&lt;input&gt;元素，这个值等于HTML特性type的值。对于其他元素，这个type属性的值如下： 此外，&lt;input&gt;和&lt;button&gt;元素的type属性是可以动态修改的，而&lt;select&gt;元素的type属性则是只读的。 共有的表单字段方法每个表单字段都有两个方法：focus()和blur()。其中，focus()方法用于将浏览器的焦点设置到表单字段，即激活表单字段，使其可以响应键盘事件。使用focus()方法，可以将用户的注意力吸引到页面中的某个部位。为此，可以侦听页面的load事件，并在该事件发生时在表单的第一个字段上调用focus()方法： 123EventUtil.addHandler(window, 'load', function (event) &#123; document.forms[0].elements[0].focus();&#125;); 要注意的是，如果第一个表单字段是一个&lt;input&gt;元素，且其type特性的值为hidden，那么上面代码会导致错误。另外，如果使用CSS的display和visibility属性隐藏了该字段，同样也会导致错误。 HTML5为表单字段新增了一个autofocus属性。在支持这个属性的浏览器中，只要设置这个属性，不用JavaScript就能自动把焦点移动到相应字段： 1&lt;input type="text" autofocus&gt; autofocus是一个布尔值，在支持的浏览器中它的值应该是true，在不支持的浏览器中，它的值是空字符串。 与focus()方法相对的是blur()方法，它的作用是从元素中移走焦点。调用blur()方法时，并不会把焦点转移到某个特定的元素上；仅仅是将焦点从调用这个方法的元素上面移走而已。 1document.forms[0].elements[0].blur(); 共有的表单字段事件除了支持鼠标、键盘、更改和HTML事件之外，所有表单字段都支持下列3个事件： blur：当前字段失去焦点时触发 change：对于&lt;input&gt;和&lt;textarea&gt;元素，在它们失去焦点且value值改变时触发；对于&lt;select&gt;元素，在其选项改变时触发 focus：当前字段获得焦点时触发 当用户改变了当前字段的焦点，或者调用了blur()或focus()方法时，都可以触发blur和focus事件。这两个事件在所有表单字段中都是相同的。但是，change事件再不同表单控件中触发的次数会有所不同。对于&lt;input&gt;和&lt;textarea&gt;元素，当它们从获得焦点到失去焦点且value值改变时，才会触发change事件。对于&lt;select&gt;元素，只要用户选择了不同的选项，就会触发change事件，也就是不失去焦点也会触发change事件。 通常，可以使用focus和blur事件来以某种方式改变用户界面，要么是向用户给出视觉提示，要么是向界面中添加额外的功能。而change事件则经常用于验证用户在字段中输入的数据： 123456789101112131415161718192021222324252627282930313233343536/* 如果文本框只允许输入数值，利用focus事件修改文本框的背景颜色，以便更清楚地表明这个字段获得了焦点。利用blur事件恢复文本框的背景颜色，利用change事件在用户输入了非数值字符时再次修改背景颜色。*/var textbox = document.forms[0].elements[0];EventUtil.addHandler(textbox, 'focus', function (event) &#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); if (target.style.backgroundColor != 'red')&#123; target.style.backgroundColor = 'yellow'; &#125;&#125;);EventUtil.addHandler(textbox, 'blur', function (event) &#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); if (/[^\d]/.test(target.value))&#123; target.style.backgroundColor = 'red'; &#125;else &#123; target.style.backgroundColor = ''; &#125;&#125;);EventUtil.addHandler(textbox, 'change', function (event) &#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); if (/[^\d]/.test(target.value))&#123; target.style.backgroundColor = 'red'; &#125;else &#123; target.style.backgroundColor = ''; &#125;&#125;); 文本框脚本在HTML中，有两种方式来表现文本框：一种是使用&lt;input&gt;元素的单行文本框，另一种是使用&lt;textarea&gt;的多行文本框。这两个控件非常相似，而且多数时候的行为也差不多。不过，它们之间仍然存在一些重要的区别。 要表现文本框，必须将&lt;input&gt;元素的type特性设置为text。而通过设置size特性，可以指定文本框中能够显示的字符数。通过value特性，可以设置文本框的初始值，而maxlength特性则用于指定文本框可以接受的最大字符数。 1&lt;input type="text" size="25" maxlength="50" value="initial value"&gt; &lt;textarea&gt;元素则始终会呈现为一个多行文本框。要指定文本框的大小，可以使用rows和cols特性。其中，rows特性指定的是文本框的字符行数，而cols特性指定的是文本框的字符列数（类似于&lt;input&gt;元素的size特性）。与&lt;input&gt;元素不同，&lt;textarea&gt;的初始值必须要放在&lt;textarea&gt;和&lt;/textarea&gt;之间： 1&lt;textarea cols="5" rows="25"&gt;initial value&lt;/textarea&gt; 另一个与&lt;input&gt;的区别在于，不能在HTML中给&lt;textarea&gt;指定最大字符数。 无论这两种文本框在标记中有什么区别，但它们都会将用户输入的内容保存在value属性中。可以通过这个属性读取和设置文本框的值： 1234var textbox = document.forms[0].elements['textbox1'];console.log(textbox.value);textbox.value = 'some new value'; 建议使用value属性读取或设置文本框的值，不建议使用标准DOM方法，即不要使用setAttribute()设置&lt;input&gt;元素的value特性，也不要去修改&lt;textarea&gt;元素的第一个子节点。原因很简单：对value属性所做的修改，不一定会反应在DOM中。因此，在处理文本框的值时，最好不要使用DOM方法。 选择文本上面两种文本框都支持select()方法，这个方法用于选择文本框中的所有文本。在调用select()方法时，大多数浏览器都会将焦点设置在文本框中。这个方法不接受参数，可以在任何时候被调用。 123456789textbox.select();//获得焦点时选择其所有文本EventUtil.addHandler(textbox, 'focus', function (event) &#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); target.select();&#125;); 选择（select）事件与select()方法对应的是一个select事件。在选择了文本框中的文本时，就会触发select事件。不过，到底什么时候触发select事件，还会因浏览器而异。在IE9+、Opera、Firefox、Chrome和Safari中，只有用户选择了文本（而且要释放鼠标），才会触发select事件。在IE8及更早的版本中，只要用户选择了一个字母（不必释放鼠标），就会触发select事件。另外，调用select()方法时也会触发select事件。 123EventUtil.addHandler(textbox, 'select', function (event) &#123; console.log('Text selected ' + textbox.value);&#125;); 取得选择的文本虽然通过select事件可以知道用户什么时候选择了文本，但仍然不知道用户选择了什么文本。HTML5通过一些扩展方案解决了这个问题，以便顺利地取得选择的文本。该规范的办法是添加两个属性：selectionStart和selectionEnd。这两个属性中保存的是基于0的数值，表示所选择文本的范围（即文本选区开头和结尾的偏移量）。 123function getSelectedText(textbox) &#123; return textbox.value.substring(textbox.selectionStart, textbox.selectionEnd);&#125; 因为substring()方法基于字符串的偏移量执行操作，所以将selectionStart和selectionEnd直接传给它就可以取得选中的文本。 选择部分文本HTML5也为选择文本框中的部分文本提供了解决方案，即setSelectionRange()方法。所有文本框都有一个setSelectionRange()方法。这个方法接收两个参数：要选择的第一个字符的索引和要选择的最后一个字符之后的字符的索引。 12345678910textbox.value = 'hello world!';//选择所有文本textbox.setSelectionRange(0, textbox.value.length); //hello world!//选择前3个字符textbox.setSelectionRange(0, 3); //hel//选择第4到第6个字符textbox.setSelectionRange(4, 7); //o w 要看到选择的文本，必须在调用setSelectionRange()之前或之后立即将焦点设置到文本框。 过滤输入屏蔽字符有时候需要用户输入的文本中包含或不包含某些字符。例如，电话号码中不能包含非数值字符。响应文本框中插入字符操作的是keypress事件。因此，可以通过阻止这个事件的默认行为来屏蔽此类字符。在极端的情况下，可以通过下列代码屏蔽所有按键操作： 1234EventUtil.addHandler(textbox, 'keypress', function (event) &#123; event = EventUtil.getEvent(event); EventUtil.preventDefault(event);&#125;); 运行上面代码后，由于所有按键操作都将被屏蔽，结果会导致文本框变成只读。如果只想屏蔽特定的字符，则需要检测keypress事件对应的字符编码，然后再决定如何响应： 123456789EventUtil.addHandler(textbox, 'keypress', function (event) &#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); var charCode = EventUtil.getCharCode(event); if (!/\d/.test(String.fromCharCode(charCode)))&#123; EventUtil.preventDefault(event); &#125;&#125;); 虽然理论上只应该在用户按下字符键时才触发keypress事件，但有些浏览器也会对其他键触发此事件。Firefox和Safari（3.1版本以前）会对向上键、向下键、退格键和删除键触发keypress事件。这意味着，仅考虑到屏蔽不是数值的字符还不够，还要避免屏蔽这些极为常用和必要的键。在Firefox中，所有由非字符键触发的keypress事件对应的字符编码为0，在Safari3以前的版本中，对应的字符编码全部为8.为了让代码更通用，只要不屏蔽那些字符编码小于10的键即可： 123456789EventUtil.addHandler(textbox, 'keypress', function (event) &#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); var charCode = EventUtil.getCharCode(event); if (!/\d/.test(String.fromCharCode(charCode)) &amp;&amp; charCode &gt; 9)&#123; EventUtil.preventDefault(event); &#125;&#125;); 除此之外，复制、粘贴及其他操作还要用到ctrl键。在除IE之外的所有浏览器中，前面的代码也会屏蔽使用Ctrl的组合键。因此，最后还要添加一个检测条件，以确保用户没有按下ctrl键： 123456789EventUtil.addHandler(textbox, 'keypress', function (event) &#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); var charCode = EventUtil.getCharCode(event); if (!/\d/.test(String.fromCharCode(charCode)) &amp;&amp; charCode &gt; 9 &amp;&amp; !event.ctrlKey)&#123; EventUtil.preventDefault(event); &#125;&#125;); 操作剪贴板IE是第一个支持与剪贴板相关事件，以及通过JavaScript访问剪贴板数据的浏览器。IE的实现成为了事实上的标准。下列就是6个剪贴板事件： beforecopy：在发生复制操作前出发 copy：在发生复制操作时触发 beforecut：在发生剪切操作前触发 cut：在发生剪切操作时触发 beforepaste：在发生粘贴操作前出发 paste：在发生粘贴操作时触发 由于没有针对剪贴板操作的标准，这些事件及相关对象会因浏览器而异。在Safari、Chrome和Firefox中，beforecopy、beforecut和beforepaste事件只会在显示针对文本框的上下文菜单的情况下触发。但是，IE则会在触发copy、cut和paste事件之前先行触发这些事件。至于copy、cut、paste事件，只要是在上下文菜单中选择了相应选项，或者使用了相应的键盘组合键，所有浏览器都会触发它们。 在实际的事件发生之前，通过beforecopy、beforecut和beforepaste事件可以向剪贴板发送数据，或者从剪贴板取得数据之前修改数据。不过，取消这些事件并不会取消对剪贴板的操作，只有取消copy、cut和paste事件，才能阻止相应操作发生。 要访问剪贴板中的数据，可以使用clipboardData对象：在IE中，这个对象是window对象的属性；而在Firefox4+、Safari和Chrome中，这个对象是相应event对象的属性。但是，在Firefox、Safari和Chrome中，只有在处理剪贴板事件期间clipboardData对象才有效，这是为了防止对剪贴板的未授权访问；在IE中，则可以随时访问clipboardData对象。为了确保跨浏览器兼容性，最好只在发生剪贴板事件期间使用这个对象。 这个clipboardData对象有三个方法：getData()、setData()和clearData()。其中，getData()用于从剪贴板中取得数据，它接受一个参数，即要取得的数据的格式。在IE中，有两种数据格式：text和URL。在Firefox、Safari和Chrome中，这个参数是一种MIME类型；不过，可以用text代表text/plain。 类似地，setData()方法的第一个参数也是数据类型，第二个参数是要放在剪贴板中的文本。对于第一个参数，IE照样支持text和URL，而Safari和Chrome仍然只支持MIME类型。但是，与getData()方法不同的是，Safari和Chrome的setData()方法不能识别text类型。这两个浏览器在成功将文本放到剪贴板中后，都会返回true；否则返回false。 123456789101112131415var EventUtil = &#123; getClipboardText: function (event) &#123; var clipboardData = (event.clipboardData || window.clipboardData); return clipboardData.getData('text'); &#125;, setClipboardText: function (event, value) &#123; if (event.clipboardData)&#123; return event.clipboardData.setData('text/plain', value); &#125;else if (window.clipboardData)&#123; return window.clipboardData.setData('text', value); &#125; &#125;&#125;; 在需要确保粘贴到文本框中的文本中包含某些字符，或者符合某种格式要求时，能够访问剪贴板是非常有用的。在paste事件中，可以确定剪贴板中的值是否有效，如果无效，就可以取消默认行为： 12345678EventUtil.addHandler(textbox, 'paste', function (event) &#123; event = EventUtil.getEvent(event); var text = EventUtil.getClipboardText(event); if (!/^\d*$/.test(text))&#123; EventUtil.preventDefault(event); &#125;&#125;); Firefox、Safari和Chrome只允许在onpaste事件处理程序中访问getData()方法。 由于并非所有浏览器都支持访问剪贴板，所以更简单的做法是屏蔽一或多个剪贴板操作。在支持copy、cut和paste事件的浏览器中，很容易阻止这些事件的默认行为。在Opera中，则需要阻止那些会触发这些事件的按键操作，同时还要阻止在文本框中显示上下文菜单。 自动切换焦点使用JavaScript可以从多个方面增强表单字段的易用性。其中，最常见的一种方式就是在用户填写完当前字段时，自动将焦点切换到下一个字段。通常，在自动切换焦点之前，必须知道用户已经输入了既定长度的数据。 123&lt;input type="text" name="tel1" id="txtTel1" maxlength="3"&gt;&lt;input type="text" name="tel2" id="txtTel2" maxlength="3"&gt;&lt;input type="text" name="tel3" id="txtTel3" maxlength="4"&gt; 为了增强易用性，同时加快数据输入，可以在前一个文本框中的字符达到最大数量后，自动将焦点切换到下一个文本框： 123456789101112131415161718192021222324252627(function () &#123; function tabForward(event) &#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); if (target.value.length == target.maxLength)&#123; var form = target.form; for (var i = 0, len = form.elements.length; i &lt; len; i++)&#123; if (form.elements[i] == target)&#123; if (form.elements[i+1])&#123; form.elements[i+1].focus(); &#125; return; &#125; &#125; &#125; &#125; var textbox1 = document.getElementById('txtTel1'); var textbox2 = document.getElementById('txtTel2'); var textbox3 = document.getElementById('txtTel3'); EventUtil.addHandler(textbox1, 'keyup', tabForward); EventUtil.addHandler(textbox2, 'keyup', tabForward); EventUtil.addHandler(textbox3, 'keyup', tabForward);&#125;)(); HTML5约束验证API为了在将表单提交到服务器之前验证数据，HTML5新增了一些功能。有了这些功能，即便JavaScript被禁用或者由于种种原因未能加载，也可以确保基本的验证。这个功能只在支持HTML5这部分内容的浏览器中才有效。 必填字段第一种情况是在表单字段中指定了required属性： 1&lt;input type="text" name="username" required&gt; 任何标注有required的字段，在提交表单时都不能空着。这个属性适用于&lt;input&gt;、&lt;textarea&gt;和&lt;select&gt;字段。在JavaScript中，通过对应的required属性，可以检查某个表单字段是否为必填字段。 1var isUsernameRequired = document.forms[0].elements['username'].required; 另外，使用下面代码可以测试浏览器是否支持required属性。 1var isRequiredSupported = 'required' in document.createElement('input'); 上面代码通过特性检测来确定新创建的&lt;input&gt;元素中是否存在required属性。 对于空着的必填字段，不同浏览器有不同的处理方式。Firefox4和Opera11会阻止表单提交并在相应字段下方弹出帮助框，而Safari（5之前）和Chrome（9之前）则什么也不做，而且也不阻止表单提交。 其他输入类型HTML5为&lt;input&gt;元素的type属性又增加了几个值。这些新的类型不仅能反映数据类型的信息，而且还能提供一些默认的验证功能。其中，email和url是两个得到支持最多的类型，各浏览器也都为它们增加了定制的验证机制： 12&lt;input type="email" name="email"&gt;&lt;input type="url" name="homepage"&gt; email类型要求输入的文本必须符合电子邮件地址的模式，而url类型要求输入的文本必须符合URL的模式。不过，浏览器在恰当匹配模式方面都存在问题。最明显的是-@-会被当成一个有效的电子邮件地址。 要检测浏览器是否支持这些新类型，可以在JavaScript创建一个&lt;input&gt;元素，然后将type属性设置为email或url，最后再检测这个属性的值。不支持它们的旧版本浏览器会自动将未知的值设置为text，而支持的浏览器则会返回正确的值： 1234var input = document.createElement('input');input.type = 'email';var isEmailSupported = (input.type == 'email'); 要注意的是，如果不给&lt;input&gt;元素设置required属性，那么空文本框也会验证通过。另一方面，设置特定的输入类型并不能阻止用户输入无效的值，只是应用某些默认的验证而已。 数值范围除了email和url，HTML5还定义了另外几个输入元素。这个几个元素都要求填写某种基于数字的值：number、range、datetime、datetime-local、date、month、week、time。浏览器对这几个类型的支持情况并不好。 对所有这些数值类型的输入元素，可以指定min属性、max属性和step属性（从min到max的两个刻度间的差值）。 1&lt;input type="number" min="0" max="100" step="5" name="count"&gt; 以上这些属性在JavaScript中都能通过对应的元素访问（或修改）。此外，还有两个方法：stepUp()和stepDown()，都接收一个可选的参数：要在当前值基础上加上或减去的数值（默认是加或减1）。 1234input.stepUp(); //加1input.stepUp(5); //加5input.stepDown(); //减1input.stepDown(10); //减10 输入模式HTML5为文本字段新增了pattern属性。这个属性的值是一个正则表达式，用于匹配文本框中的值。例如，如果只想允许在文本字段中输入数值，可以像下面的代码一样应用约束： 1&lt;input type="text" pattern="\d+" name="count"&gt; 注意，模式的开头和结尾不用加^和$符号。这两个符号表示输入的值必须从头到尾都与模式匹配。 与其他输入类型相似，指定pattern也不能阻止用户输入无效的文本。这个模式应用给值，浏览器来判断值是有效还是无效。在JavaScript中可以通过pattern属性访问模式。 1var pattern = document.forms[0].elements['count'].pattern; 使用下列代码可以检测浏览器是否支持pattern属性： 1var isPatternSupported = 'pattern' in document.createElement('input'); 检测有效性使用checkValidity()方法可以检测表单中的某个字段是否有效。所有表单字段都有个方法，如果字段的值有效，这个方法返回true，否则返回false。字段的值是否有效的判断依据是本节前面介绍过的那些约束。也就是，必填字段中如果没有值就是无效的，而字段中的值与pattern属性不匹配也是无效的。 12345if (document.forms[0].elements[0].checkValidity())&#123; // 字段有效，继续&#125;else &#123; // 字段无效&#125; 要检测整个表单是否有效，可以在表单自身调用checkValidity()方法。如果所有表单字段都有效，这个方法会返回true，即使有一个字段无效，这个方法也会返回false： 12345if (document.forms[0].checkValidity())&#123; // 字段有效，继续&#125;else &#123; // 字段无效&#125; 与checkValidity()方法简单地告诉你字段是否有效相比，validty属性则会告诉你为什么字段有效或无效。这个对象中包含一系列属性，每个属性会返回一个布尔值： customError：如果设置了setCustomValidity()，则为true，否则返回false patternMismatch：如果值与指定的pattern属性不匹配，返回true rangeOverflow：如果值比max大，返回true rangeUnderflow：如果值比min小，返回true stepMismatch：如果min和max之间的步长值不合理，返回true tooLong：如果值的长度超过了maxlength属性指定的长度，返回true。有的浏览器（如Firefox4）会自动约束字符数量，因此这个值可能永远返回false typeMismatch：如果值不少mail或url要求的格式，返回true valid：如果这里的其他属性都是false，返回true valueMissing：如果标注为required的字段中没有值，返回true 因此，要想得到更具体的信息，就应该使用validity属性来检测表单的有效性： 123456789if (input.validity &amp;&amp; !input.validity.valid)&#123; if (input.validity.valueMissing)&#123; console.log('please specify a value'); &#125;else if (input.validity.typeMismatch)&#123; console.log('please enter an email address'); &#125;else &#123; console.log('value is invalid'); &#125;&#125; 禁用验证通过设置novalidate属性，可以告诉表单不进行验证： 123&lt;form method="post" action="signup.php" novalidate&gt; &lt;!--这里插入表单元素--&gt;&lt;/form&gt; 在JavaScript中使用novalidate属性可以取得或设置这个值，如果这个属性存在，值为true，如果不存在，值为false。 1document.forms[0].noValidate = true; //禁用验证 如果一个表单中有多个提交按钮，为了指定点击某个提交按钮不必验证表单，可以在相应的按钮上添加formnovalidate属性。 12345&lt;form method="post" action="signup.php" novalidate&gt; &lt;!--这里插入表单元素--&gt; &lt;input type="submit" value="regular submit"&gt; &lt;input type="submit" formnovalidate name="btnNovalidate" value="Non-validating submit"&gt;&lt;/form&gt; 使用JavaScript也可以设置这个属性： 12// 禁用验证document.forms[0].elements['btnNoValidate'].formNoValidate = true; 选择框脚本选择框是通过&lt;select&gt;和option元素创建的。为了方便与这个控件交互，除了所有表单字段共有的属性和方法外，HTMLSelectElement类型还提供了下列属性和方法： add(newOption, relOption)：向控件中插入新&lt;option&gt;元素，其位置在相关项relOption之前 multiple：布尔值，表示是否允许多项选择；等价于HTML中的multiple特性 options：控件中所有&lt;option&gt;元素的HTMLCollection remove(index)：移除给定位置的选项 selectedIndex：基于0的选中项索引，如果没有选中项，则值为-1。对于支持多选的控件，只保存选中项中第一项的索引 size：选择框中可见的行数；等价于HTML中size特性 选择框的type属性不是select-one，就是select-multiple，这取决于HTML代码中有没有multiple特性。选择框的value属性由当前选中项决定，相应规则如下： 如果没有选中的项，则选择框的value属性保存空字符串 如果有一个选中项，而且该项的value特性已经在HTML中指定，则选择框的value属性等于选中项的value特性。即使value特性是空字符串，也同样遵循这条规则 如果有一个选中项，但该项的value特性在HTML中未指定，则选择框的value属性等于该项的文本 如果有多个选中项，则选择框的value属性将依据前两条规则取得第一个选中项的值 1234567&lt;select name="location" id="selLocation"&gt; &lt;option value="Sunnyvalue, CA"&gt;Sunnyvalue&lt;/option&gt; &lt;option value="Los Angeles, CA"&gt;Los Angeles&lt;/option&gt; &lt;option value="Mountain View, CA"&gt;Mountain View&lt;/option&gt; &lt;option value=""&gt;China&lt;/option&gt; &lt;option&gt;Australia&lt;/option&gt;&lt;/select&gt; 在DOM中，每个&lt;option&gt;元素都有一个HTMLOptionElement对象表示。为便于访问数据，HTMLOptionElement对象添加了下列属性： index：当前选项在options集合中的索引 label：当前选项的标签；等价于HTML中的label特性 selected：布尔值，表示当前选项是否被选中。将这个属性设置为true可以选中当前选项 text：选项的文本 value：选项的值 其中大部分属性的目的都是为了方便对选项数据的访问。虽然可以使用常规的DOM来访问这些信息，但效率比较低： 123456789var selectbox = document.forms[0].elements['location'];//不推荐var text = selectbox.options[0].firstChild.nodeValue;var value = selectbox.options[0].getAttribute('value');//推荐var text = selectbox.options[0].text;var value = selectbox.options[0].value; 在操作选项时，建议最好是使用特定于选项的属性，因为所有浏览器都支持这些属性。 选择框的change事件与其他表单字段的change事件触发的条件不一样。其他表单字段的change事件是在值被修改且焦点离开当前字段时触发，而选择框的change事件只要选中了选项就会触发。 选择选项对于只允许选择一项的选择框，访问选中项的最简单方式，就是使用选择框的selectedIndex属性： 1var selectedOption = selectbox.options[selectbox.selectedIndex]; 取得选中项之后，可以像下面这样显示该选项的信息： 123var selectedIndex = selectbox.selectedIndex;var selectedOption = selectbox.options['selectedIndex']；console.log('selected index: ' + selectedIndex + '\nSelected text: ' + selectedOption.text + '\nSelected value: ' + selectedOption.value); 对于可以选择多项的选择框，selectedIndex属性就好像只允许选择一项一样。设置selectedIndex会导致取消以前的所有选项并选择指定的那一项，而读取selectedIndex则只会返回选中项第一项的索引值。 另一个选择选项的方式，就是取得对某一项的引用，然后将其selected属性设置为true： 1selectbox.options[0].selected = true; 与selectedIndex不同，在允许多选的选择框中设置选项的selected属性，不会取消对其他选中项的选择，因而可以动态选中任意多个项。但是，如果是在单选选择框中，修改某个选项的selected属性则会取消对其他选项的选择。需要注意的是，将selected属性设置为false对单选选择框没有影响。 实际上，selected属性的主要作用是确定用户选择了选择框中的哪一项。要取得所有选中的项，可以循环遍历选项集合，然后测试每个选项的selected属性。 1234567891011121314151617181920212223function getSelectedOptions(selectbox) &#123; var result = new Array(); var option = null; for (var i = 0, len = selectbox.options.length; i &lt; len; i++)&#123; option = selectbox.options[i]; if (option.selected)&#123; result.push(option); &#125; &#125; return result;&#125;var selectbox = document.getElementById('selLocation');var selectedOptions = getSelectedOptions(selectbox);var message = '';for (var i = 0, len = selectedOptions.length; i &lt; len; i++)&#123; message += 'Selected index: ' + selectedOptions[i].index + '\nSelected text: ' + selectedOptions[i].text + '\nSelected value: ' + selectedOptions[i].value + '\n\n';&#125;console.log(message); 添加选项可以使用JavaScript动态创建选项，并将它们添加到选择框中。添加选项的方式有很多，第一种方式就是使用下面的DOM方法： 12345var newOption = document.createElement('option');newOption.appendChild(document.createTextNode('Option text'));newOption.value = 'Option value';selectbox.appendChild(newOption); 第二种方式是使用Option构造函数来创建新选项，这个构造函数是DOM出现之前就有的，一直遗留到现在。Option构造函数接受两个参数：text（文本）和value（值）；第二个参数可选。虽然这个构造函数会创建一个Object的实例，但兼容DOM的浏览器会返回一个&lt;option&gt;元素。 12var newOption = new Option('option text', 'option value');selectbox.appendChild(newOption); //IE8及之前版本有问题 第三种方式是使用选择框的add()方法。DOM规定这个方法接受两个参数：要添加的新选项和将位于新选项之后的选项。如果想在列表的最后添加一个选项，应该将第二个参数设为null。在IE对add()方法的实现中，第二个参数是可选的，而且如果指定，该参数必须是新选项之后选项的索引。兼容DOM的浏览器要求必须指定第二个参数，因此要想编写跨浏览器的代码，就不能只传入一个参数。这时候，为第二个参数传入undefined，就可以在所有浏览器中都将新选项插入到列表最好了。 12var newOption = new Option('option text', 'option value');selectbox.add(newOption, undefined); //最佳方案 移除选项移除选项的方式也有很多种。首先，可以使用DOM的removeChild()方法，为其传入要移除的选项： 1selectbox.removeChild(selectbox.options[0]); //移除第一个选项 其次，可以使用选择框的remove()方法。这个方法接受一个参数，即要移除选项的索引： 1selectbox.remove(0); //移除第一个选项 最后一种方式，就是将相应选项设置为null。这种方式也是DOM出现之前浏览器的遗留机制： 1selectbox.options[0] = null; //移除第一个选项 要清除选择框中所有的项，需要迭代所有选项并逐个移除它们： 12345function clearSelectbox(selectbox) &#123; for (var i = 0, len = selectbox.options.length; i &lt; len; i++)&#123; selectbox.remove(i); &#125;&#125; 移动和重排选项使用DOM的appendChild()方法，就可以将第一个选择框中的选项直接移动到第二个选择框中。如果为appendChild()方法传入一个文档中已有的元素，那么就会先从该元素的父节点中移除它，再把它添加到指定的位置。 1234var selectbox1 = document.getElementById('selLocation1');var selectbox2 = document.getElementById('selLocation2');selectbox2.appendChild(selectbox1.options[0]); 移动选项与移除选项有一个共同之处，即会重置每一个选项的index属性。 重排选项次序的过程也十分类似，最好的方式依然是使用DOM方法。要将选择框中的某一项移动到特定位置，最合适的DOM方法是insertBerfore()；appendChild()方法只适用于将选项添加到选择框的最后。要在选择框中向前移动一个选项的位置，可以这样： 12var optionToMove = selectbox.options[1];selectbox.insertBefore(optionToMove, selectbox.options[optionToMove.index - 1]); 表单序列化在JavaScript中，可以利用表单字段的type属性，连同name和value属性一起实现对表单的序列化。在编写代码之前，有必须先搞清楚在表单提交期间，浏览器是怎样将数据发送给服务器的。 对表单字段的名称和值进行URL编码，使用&amp;分隔 不发送禁用的表单字段 只发送勾选的复选框和单选框按钮 不发送type为reset和button的按钮 多选选则框中的每个选中的值单独一个条目 在单击提交按钮提交表单的情况下，也会发送提交按钮；否则，不发送提交按钮。也包括type为image的&lt;input&gt;元素 &lt;select&gt;元素的值，就是选中的&lt;option&gt;元素的value特性的值。如果&lt;option&gt;元素没有value特性，则是&lt;option&gt;元素的文本值 在表单序列化过程中，一般不包含任何按钮字段，因为结果字符串很可能通过其他方式提交。除此之外的其他上述规则都应该遵循。下面就是实现表单序列化的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556function serialize(form) &#123; var parts = [], //保存将要创建的字符串的各个部分 field = null, i, len, j, optLen, option, optValue; for (i = 0, len = form.elements.length; i &lt; len; i++)&#123; field = form.elements[i]; switch (field.type)&#123; case 'select-one': case 'select-multiple': if (field.name.length)&#123; for (j = 0, optLen = field.options.length; j &lt; optLen; j++)&#123; optLen = field.options[j]; if (option.selected)&#123; optValue = ''; if (option.hasAttribute)&#123; optValue = (option.hasAttribute('value') ? option.value:option.text); &#125;else &#123; optValue = (option.attributes['value'].specified ? option.value : option.text); //兼容IE &#125; parts.push(encodeURIComponent(field.name) + '=' + encodeURIComponent(optValue)); &#125; &#125; &#125; break; case undefined: //字段集 case 'file': //文件输入 case 'submit': //提交按钮 case 'reset': //重置按钮 case 'button': //自定义按钮 break; case 'radio': //单选框 case 'checkbox': //复选框 if (!field.checked)&#123; break; &#125; /*执行默认操作*/ default: //不包含没有名字的表单字段 if (field.name.length)&#123; parts.push(encodeURIComponent(field.name) + '=' + encodeURIComponent(field.value)); &#125; &#125; &#125; return parts.join('&amp;');&#125; 富文本编辑富文本编辑的本质，就是在页面中嵌入一个包含空HTML页面的iframe。通过设置designMode属性，这个空白的HTML页面可以被编辑，而编辑对象则是该页面&lt;body&gt;元素的HTML代码。designMode属性有两个可能的值：off（默认值）和on。在设置为on时，整个文档都会变得可以编辑。 可以给iframe指定一个非常简单的HTML页面作为其内容来源： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 这个页面在iframe中可以像其他页面一样被加载。要让它可以编辑，必须要将designMode设置为on，但只有在页面完全加载之后才能设置这个属性。因此，在包含页面中，需要使用onload事件处理程序来在恰当的时刻设置designMode： 1234567&lt;iframe name="richedit" style="height: 100px;width: 100px" src="blank.html" frameborder="0"&gt;&lt;/iframe&gt;&lt;script&gt; EventUtil.addHandler(window, 'load', function () &#123; frames['richedit'].document.designMode = 'on'; &#125;);&lt;/script&gt; 等以上代码执行之后，就会在页面中看到一个类似文本框的可编辑区字段。这个区字段具有与其他网页相同的默认样式；不过，通过为空白页面应用CSS样式，可以修改可编辑区字段的外观。 使用contenteditable属性另一种编辑富文本内容的方式是使用名为contenteditable的特殊属性，这个属性也是由IE最早实现的。可以把contenteditable属性应用给页面中的任何元素，然后用户立即就可以编辑该元素。这种方法之所以受欢迎，是因为它不需要iframe、空白页和JavaScript，只要为元素设置contenteditable属性即可： 1&lt;div class="editable" id="richedit" contenteditable&gt;&lt;/div&gt; 这样，元素中包含的任何文本内容就可以编辑。通过在这个元素上设置contenteditable属性，也能打开或关闭编辑模式： 12var richedit = document.getElementById('richedit');richedit.contentEditable = 'true'; contentEditable属性有三个可能的值：true表示打开、false表示关闭，inherit表示从父元素继承。 操作富文本与富文本编辑器交互的主要方式，就是使用document.execCommand()。这个方法可以对文档执行预定义的命令，而且可以应用大多数格式。可以为document.execCommand()方法传递3个参数：要执行的命令名称、表示浏览器是否应该为当前命令提供用户界面的一个布尔值和执行命令必须的一个值（如果不需要值，则传递null）。为了确保跨浏览器的兼容性，第二个参数应该始终设置为false，因为Firefox会在该参数为true时抛出错误。 不同浏览器支持的预定义命令也不一样。下表列出了那些被支持最多的命令： 其中，与剪贴板有关的命令在不同浏览器中的差异极大。Opera根本没有实现任何剪贴板命令，而Firefox在默认情况下会禁用它们（必须修改用户的首选项来启用它们）。Safari和Chrome实现了cut和copy，但没有实现paste。不过，即使不能通过document.execCommand()来执行这些命令，但却可以通过相应的快捷键来实现同样的操作。 可以在任何时候使用这些命令来修改富文本区域的外观： 1234567891011//转换粗体文本frames['richedit'].document.execCommand('bold', false, null);//转换斜体文本frames['richedit'].document.execCommand('italic', false, null);//创建指向tc9011.com的链接frames['richedit'].document.execCommand('createlink', false, 'http://tc9011.com');//格式化为1级标题frames['richedit'].document.execCommand('formatblock', false, '&lt;h1&gt;'); 同样的方法也适用与页面中contentEditable属性为true的区块，只要把对框架的引用替换成当前窗口的document对象即可： 1234567891011//转换粗体文本document.execCommand('bold', false, null);//转换斜体文本document.execCommand('italic', false, null);//创建指向tc9011.com的链接document.execCommand('createlink', false, 'http://tc9011.com');//格式化为1级标题document.execCommand('formatblock', false, '&lt;h1&gt;'); 虽然所有浏览器都支持这些命令，但这些命令所产生的HTML仍然有很大不同。由于各个浏览器实现命令的方式不同，加上它们通过innerHTML实现转换的方式也不一样，因此不能指望富文本编辑器会产生一致的HTML。 除了命令之外，还有一些与命令相关的方法。第一个方法就是queryCommandEnabled()，可以用它来检测是否可以针对当前选择的文本，或者当前插入字符所在位置执行某个命令。这个方法接收一个参数，即要检测的命令。如果当前编辑区域允许执行传入的命令，这个方法返回true，否则返回false。 1var result = frames['richedit'].document.queryCommandEnabled('bold'); 如果能够对当前选择的文本执行bold命令，以上代码会返回true。需要注意的是queryCommandEnabled()方法返回true，并不意味着实际上就可以执行相应命令，而只能说明对当前选择的文本执行相应命令是否合适。例如，Firefox在默认情况下会禁用剪切操作，但执行queryCommandEnabled(&#39;cut&#39;)也可能会返回true。 另外，queryCommandState()方法用于确定是否已将指定命令应用到了选择的文本： 1var isBold = frames['richedit'].document.queryCommandState('bold'); 一些功能全面的富文本编辑器，正是利用这个方法来更新粗体、斜体等按钮状态。 最后一个方法是queryCommandValue()，用于取得执行命令时传入的值（即前面例子中传给document.execCommand()的第三个参数）。 1var fontSize = frames['richedit'].document.queryCommandValue('fontsize'); 通过这个方法可以确定某个命令是怎样应用到选择的文本的，可以据以确定再对其应用后续命令是否合适。 富文本选区在富文本编辑器中，使用iframe的getSelection()方法，可以确定实际选择的文本。这个方法是window对象和document对象的属性，调用它会返回一个表示当前选择文本的Selection对象。每个Selection对象都有下列属性： Selection对象的这些属性并没有包含多少有用的信息。好在，该对象的下列方法提供了更多信息，并支持对选区的操作： Selection对象的这些方法都极为实用，它们利用了DOM范围来管理选区。由于可以直接操作选择文本的DOM表现，因此访问DOM范围与使用execCommand()相比，能够对富文本编辑器进行更加细化的控制： 123456789101112var selection = frames['richedit'].getSelection();//取得选择文本var selectedText = selection.toString();//取得代表选区的范围var range = selection.getRangeAt(0);//突出显示选择的文本var span = frames['richedit'].document.createElement('span');span.style.backgroundColor = 'yellow';range.surroundContents(span); 以上代码会为富文本编辑器中被选中的文本添加黄色的背景。这里使用了默认选区中的DOM范围，通过surroundContents()方法将选区添加到了带有黄色背景的&lt;span&gt;元素中。 表单与富文本由于富文本编辑是使用iframe而非表单控件实现，因此从技术上说，富文本编辑器并不属于表单。也就是，富文本编辑器中的HTML不会被自动提交给服务器，而需要我们手工来提取并提交HTML。为此，通常可以添加一个隐藏的表单字段，让它的值等于从iframe中提取的HTML。 123456EventUtil.addHandler(form, 'submit', function (event) &#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); target.elements['comments'].value = frames['richedit'].document.body.innerHTML;&#125;); 通过文档body的innerHTML属性取得了iframe中的HTML，然后其插入到了名为comments的表单字段中。这样可以确保恰好在提交表单之前填充comments字段。如果想在代码中通过submit()来手工提交表单，那么一定不要忘记事先执行上面的操作。对于contentEditable元素，也可以执行类似操作： 123456EventUtil.addHandler(form, 'submit', function (event) &#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); target.elements['comments'].value = document.getElementById('richedit').innerHTML;&#125;); 使用Canvas绘图基本用法要使用&lt;canvas&gt;元素，必须先设置其width和height属性，指定可以绘图的区域大小。出现在开始和结束标签中的内容是后备信息，如果浏览器不支持&lt;canvas&gt;元素，就会显示这些信息。 1&lt;canvas id="drawing" width="200" height="200"&gt;a drawing of something.&lt;/canvas&gt; &lt;canvas&gt;元素对应的DOM元素对象也有width和height属性，可以随意修改。而且也能通过CSS为该元素添加样式，如果不添加任何样式或者不绘制任何图形，在页面中是看不到该元素的。 找&lt;canvas&gt;上绘图，需要取得绘图上下文。而取得绘图上下文对象的引用，需要调用getContext()方法并传入上下文的名字。传入2d，就可以取得2D上下文对象。 123456var drawing = document.getElementById('drawing');//确定浏览器支持&lt;canvas&gt;if (drawing.getContext)&#123; var context = drawing.getContext('2d');&#125; 使用toDataURL()方法，可以导出在&lt;canvas&gt;元素上绘制的图像。这个方法接受一个参数，即图像的MIME类型格式，而且适合用于创建图像的任何上下文。比如，要取得画布中的一幅PNG格式的图像： 1234567891011121314var drawing = document.getElementById('drawing');//确定浏览器支持&lt;canvas&gt;if (drawing.getContext)&#123; // var context = drawing.getContext('2d'); //取得图像的数据URL var imgURL = drawing.toDataURL('image/png'); //显示图像 var image = document.createElement('img'); img.src = imgURL; document.body.appendChild(image);&#125; 默认情况下，浏览器会将图像编码为PNG格式（除非另行指定）。Firefox和Opera也支持基于image/jpeg参数的JPEG编码格式。 2D上下文使用2D绘图上下文提供的方法，可以绘制简单的2D图形。2D上下文的坐标开始于&lt;canvas&gt;元素的左上角，原点坐标是(0,0)。所有坐标值都基于这个原点计算，x值越大表示越靠右，y值越大表示越靠下。默认情况下，width和height表示水平和垂直两个方向上可用的像素数目。 填充和描边2D上下文的两种基本绘图操作是填充和描边。填充，就是用指定的样式填充图形；描边，就是只在图形的边缘画线。大多数2D上下文操作都会细分为填充和描边两个操作，而操作的结果取决于两个属性：fillStyle和strokeStyle。 这个属性的值可以是字符串、渐变对象或模式对象，而且它们的默认值是#000000。如果为它们指定表示颜色的字符串值，可以使用CSS中指定颜色值的任何格式，包括颜色名、十六进制码、rgb、rgba、hsl或hsla。 12345678var drawing = document.getElementById('drawing');//确定浏览器支持&lt;canvas&gt;if (drawing.getContext)&#123; var context = drawing.getContext('2d'); context.strokeStyle = '#FF0000'; context.fillStyle = '#0000ff';&#125; 绘制矩形矩形是唯一一种可以直接在2D上下文中绘制的形状。与矩形有关的方法包括fillRect()、strokeRect()和clearRect()。这三个方法都能接收4个参数：矩形的x坐标、矩形的y坐标、矩形宽度和矩形高度。这些参数的单位都是像素。 fillRect()方法在画布上绘制的矩形会填充指定的颜色。填充的颜色通过fillStyle属性指定： 1234567891011121314var drawing = document.getElementById('drawing');//确定浏览器支持&lt;canvas&gt;if (drawing.getContext)&#123; var context = drawing.getContext('2d'); //绘制红色矩形 context.fillStyle = '#ff0000'; context.fillRect(10, 10, 50, 50); //绘制半透明的蓝色矩形 context.fillStyle = 'rgba(0,0,255,0.5)'; context.fillRect(30, 30, 50, 50);&#125; strokeRect()方法在画布上绘制的矩形会使用指定的颜色描边。描边颜色通过strokeStyle属性指定： 1234567891011121314var drawing = document.getElementById('drawing');//确定浏览器支持&lt;canvas&gt;if (drawing.getContext)&#123; var context = drawing.getContext('2d'); //绘制红色描边矩形 context.strokeStyle = '#ff0000'; context.strokeRect(10,10,50,50); //绘制半透明的蓝色描边矩形 context.strokeStyle = 'rgba(0,0,255,0.5)'; context.strokeRect(30,30,50,50);&#125; 描边线条的宽度由lineWidth属性控制，该属性的值可以是任意整数。另外，通过lineCap属性可以控制线条末端的形状是平头、圆头还是方头（butt、round或square）。通过lineJoin属性可以控制线条相交的方式是圆交、斜交还是斜接（round、bevel或miter）。 clearRect()方法用于清除画布上的矩形区域。本质上，这个方法可以把绘制上下文中的某一矩形区域变透明。通过绘制形状然后再清除指定区域，就可以生成有意思的效果： 1234567891011121314151617var drawing = document.getElementById('drawing');//确定浏览器支持&lt;canvas&gt;if (drawing.getContext)&#123; var context = drawing.getContext('2d'); //绘制红色矩形 context.fillStyle = '#ff0000'; context.fillRect(10, 10, 50, 50); //绘制半透明的蓝色矩形 context.fillStyle = 'rgba(0,0,255,0.5)'; context.fillRect(30, 30, 50, 50); //在两个矩形重叠的地方清除一个小矩形 context.clearRect(40,40,10,10);&#125; 绘制路径2D绘制上下文支持很多在画布上绘制路径的方法。通过路径可以创造出复杂的形状和线条。要绘制路径，首先必须调用beginPath()方法，表示要开始绘制新路径。然后，再通过调用下列方法来实际地绘制路径。 arc(x,y,radius,startAngle,endAngle,counterclockwise)：以(x,y)为圆心绘制一条弧线，弧线半径为radius，起始和结束角度（用弧度表示）分别为startAngle和endAngle。最后一个参数表示startAngle和endAngle是否按逆时针方向计算，值为false表示按顺时针方向计算 arcTo(x1,y1,x2,y2,radius)：从上一点开始绘制一条弧线，到(x2,y2)为止，并且以给定的半径radius穿过(x1,y1)。 bezierCurveTo(c1x,c1y,c2x,c2y,x,y)：从上一点开始绘制一条曲线，到(x,y)为止，并以(c1x,c1y)和(c2x,c2y)为控制点 lineTo(x,y)：从上一点开始绘制一条直线，到(x,y)为止 moveTo(x,y)：将绘图游标移动到(x,y)，不画线 quadraticCurveTo(cx,cy,x,y)：从上一点开始绘制一条二次曲线，到(x,y)为止，并以(cx,cy)作为控制点 rect(x,y,width,height)：从点(x,y)开始绘制一个矩形，宽度和高度分别由width和height指定。这个方法绘制的是矩形路径，而不是strokeRect()和fillRect()所绘制的独立形状 123456789101112131415161718192021222324252627var drawing = document.getElementById('drawing');//确定浏览器支持&lt;canvas&gt;if (drawing.getContext)&#123; var context = drawing.getContext('2d'); //开始路径 context.beginPath(); //绘制外圆 context.arc(100,100,99,0,2*Math.PI,false); //绘制内圆 context.moveTo(194,100); //必须把路径移动到外圆上某一个点，避免绘制出多余的线条 context.arc(100,100,94,0,2*Math.PI,false); //绘制分针 context.moveTo(100,100); context.lineTo(100,15); //绘制时针 context.moveTo(100,100); context.lineTo(35,100); //描边路径 context.stroke();&#125; 在2D绘图上下文中，路径是一种主要的绘图方式，因为路径能为要绘制的图像提供更多控制。由于路径的使用很频繁，所以就有了一个名为isPointInPath()的方法。这个方法接收x和y坐标作为参数，用于在路径被关闭之前确定画布上的某一点是否位于路径上： 123if (context.isPointInPath(100,100))&#123; alert('point(100,100) is in the path');&#125; 绘制文本绘制文本主要有两个方法：fillText()和strokeText()。这两个方法都可以接收4个参数：要绘制的文本字符串、x坐标、y坐标和可选的最大像素宽度。而且，这两个方法都以下列3个属性为基础： font：表示文本样式、大小及字体，用CSS中指定字体的格式来指定，例如10px Arial textAlign：表示文本对齐方式。可能的值有start、end、left、right和center。建议使用start和end，不要使用left和right，因为前两者的意思更稳妥，能同时适合从左到右和从右到左显示的语言 textBaseline：表示文本的基线。可能的值有top、hanging、middle、alphabetic、ideographic和bottom 这几个属性都有默认值，因此没有必要每次使用它们都重新设置一遍。fillText()方法使用fillStyle属性绘制文本，而strokeText()方法使用strokeStyle属性为文本描边。相对来说，还是使用fillText()的时候更多，因为该方法模仿了在网页中正常显示文本： 1234context.font = 'blod 14px Arial';context.textAlign = 'center';context.textBaseline = 'middle';context.fillText('12', 100, 20); 12345678910111213//正常context.font = 'blod 14px Arial';context.textAlign = 'center';context.textBaseline = 'middle';context.fillText('12', 100, 20);//起点对齐context.textAlign = 'start';context.fillText('12',100,40);//终点对齐context.textAlign = 'end';context.fillText('12', 100, 60); 类似地，修改textBaseline属性的值可以调整文本的垂直对齐方式：值为top，y坐标表示文本顶端；值为bottom，y坐标表示文本底端；值为hanging、alphabetic和ideographic，则y坐标分别指向字体的特定基线坐标。 由于绘制文本比较复杂，特别是需要把文本控制在某一区域中的时候，2D上下文提供了辅助确定文本大小的方法measureText()。这个方法接收一个参数，即要绘制的文本；返回一个textMetrics对象。返回的对象目前只有一个width属性，但将来还会增加更多度量属性。 measureText()方法利用font、textAlign和textBaseline的当前值计算指定文本的大小。比如，假设你想在一个140像素宽的矩形区域中绘制文本hello world，下面代码从100像素的字体大小开始递减，最终会找到合适的字体大小。 12345678910var fontSize = 100;context.font = fontSize + 'px Arial';while (context.measureText('hello world').width &gt; 140)&#123; fontSize--; context.font = fontSize + 'px Arial';&#125;context.fillText('hello world', 10, 10);context.fillText('font size is ' + fontSize + 'px', 10, 50); fillText()和strokeText()方法都可以接收第四个参数，也就是文本的最大像素宽度。不过，这个可选的参数尚未得到所有浏览器支持。提供这个参数后，调用fillText()或strokeText()时如果传入的字符串大于最大宽度，则绘制的文本字符的高度正确，但宽度会收缩以适应最大宽度。 变换通过上下文的变换，可以把处理后的图像绘制到画布上。2D绘制上下文支持各种基本的绘制变换。创建绘制上下文时，会以默认值初始化变换矩阵，在默认的变换矩阵下，所有处理都按描述直接绘制。为绘制上下文应用变换，会导致使用不同的变换矩阵应用处理，从而产生不同的结果。 可以通过如下方法来修改变换矩阵： rotate(angle)：围绕原点旋转图像angle弧度 scale(scaleX, scaleY)：缩放图像，在x方向乘以scaleX，在y方向乘以scaleY。scaleX和scaleY的默认值都是1.0 translate(x,y)：将坐标原点移动到(x,y)。执行这个变换之后，坐标(0,0)会变成之前由(x,y)表示的点 transform(m1_1, m1_2, m2_2, dx, dy)：直接修改变换矩阵，方式是乘以如下矩阵： 123m1_1 m1_2 dxm2_1 m2_2 dy0 0 1 setTransform(m1_1, m1_2, m2_2, dx, dy)：将变换矩阵重置为默认状态，然后再调用transform() 123456789101112131415161718192021222324252627282930var drawing = document.getElementById('drawing');//确定浏览器支持&lt;canvas&gt;if (drawing.getContext)&#123; var context = drawing.getContext('2d'); //开始路径 context.beginPath(); //绘制外圆 context.arc(100,100,99,0,2*Math.PI,false); //绘制内圆 context.moveTo(194,100); context.arc(100,100,94,0,2*Math.PI,false); //变换原点 context.translate(100, 100);//通过变换原点来绘制指针 //绘制分针 context.moveTo(0,0); context.lineTo(0,-85); //绘制时针 context.moveTo(0,0); context.lineTo(-65,0); //描边路径 context.stroke();&#125; 把原点变换到钟表的中心点(100, 100)后，在同一方向上绘制线条就变成了简单的数学问题，所有数学计算都基于(0, 0)，而不是(100, 100)。还可以用rotate()方法旋转时钟的表针： 123456789101112131415161718192021222324252627282930313233var drawing = document.getElementById('drawing');//确定浏览器支持&lt;canvas&gt;if (drawing.getContext)&#123; var context = drawing.getContext('2d'); //开始路径 context.beginPath(); //绘制外圆 context.arc(100,100,99,0,2*Math.PI,false); //绘制内圆 context.moveTo(194,100); context.arc(100,100,94,0,2*Math.PI,false); //变换原点 context.translate(100, 100); //旋转指针 context.rotate(1); //绘制分针 context.moveTo(0,0); context.lineTo(0,-85); //绘制时针 context.moveTo(0,0); context.lineTo(-65,0); //描边路径 context.stroke();&#125; 因为原点已经变换到了钟表的中心点，所以旋转也是以该点为圆心的。 无论是刚才执行的变换，还是fillStyle、strokeStyle等属性，都会在当前上下文中一直有效，除非再对上下文进行什么修改。虽然没有什么办法把上下文中的一切都重置回默认值，但有两个方法可以跟踪上下文的状态变化。如果知道将来要返回某组属性与变换的组合，可以调用save()方法。调用这个方法后，当时的所有设置都会进入一个栈结构，得以妥善保管。然后可以对上下文进行其他修改。等想要回到之前保存的设置时，可以调用restore()方法，在保存设置的栈结构中向前返回前一级，恢复之前的状态。连续调用save()可以把更多设置保存到栈结构中，之后再连续调用restore()则可以一级一级返回： 12345678910111213141516context.fillStyle = '#ff0000';context.save();context.fillStyle = '#00ff00';context.translate(100,100);context.save();context.fillStyle = '#0000ff';context.fillRect(0,0,100,200); //从点（100，100）开始绘制蓝色矩形context.restore();context.fillRect(10,10,100,200); //从点（110， 110）开始绘制绿色矩形context.restore();context.fillRect(0, 0, 100, 200); //从点（0，0）开始绘制红色矩形 save()方法保存的是对绘图上下文的设置和变换，不会保存绘图上下文的内容。 绘制图像2D绘图上下文内置了对图像的支持。如果想把一幅图像绘制到画布上，可以使用drawImage()方法。根据期望的最终结果不同，调用这个方法时，可以使用三种不同的参数组合。最简单的调用方式是传入一个HTML&lt;img&gt;元素，以及绘制该图像的起点的x和y坐标： 12var image = document.images[0];context.drawImage(image, 10, 10); 上面代码中绘制到画布的图像大小与原始大小一样。如果想改变绘制后图像大小，可以再多传入两个参数，分别表示目标宽度和目标高度。通过这种方式来缩放图像并不影响上下文的变换矩阵： 1context.drawImage(image, 50, 10, 20, 30); 此时绘制出来的图像大小会变成20*30像素。 还可以选择把图像中的某个区域绘制到上下文中。drawImage()方法的这种调用方式总共需要传入9个参数：要绘制的图像、源图像的x坐标、源图像的y坐标、源图像的宽度、源图像的高度、目标图像的x坐标、目标图像的y坐标、目标图像的宽度、目标图像的高度。这样调用drawImage()方法可以获得最多的控制： 1context.drawImage(image, 0, 10, 50, 50, 0, 100, 40, 60); 这行代码只会把原始图像的一部分绘制到画布上。原始图像的这一部分的起点为(0, 10)，宽和高都是50像素。最终绘制到上下文中的图像的起点是(0, 100)，而大小变成40*60像素。 除了给drawImage()方法传入HTML&lt;img&gt;元素外，还可以传入另一个&lt;canvas&gt;元素作为其第一个参数。这样，就可以把另一个画布内容绘制到当前画布上。 结合使用drawImage()和其他方法，可以对图像进行各种基本操作。而操作的结果可以通过toDataURL()方法获得。不过，有一个例外，即图像不能来自其他域。如果图像来自其他域，调用toDataURL()方法会抛出一个错误。 阴影2D上下文会根据以下几个属性的值，自动为形状或路径绘制出阴影： shadowColor：用CSS颜色格式表示的阴影颜色，默认为黑色 shadowOffsetX：形状或路径x轴方向的阴影偏移量，默认为0 shadowOffsetY：形状或路径y轴方向的阴影偏移量，默认为0 shadowBlur：模糊的像素数，默认为0，即不模糊 这些属性都可以通过context对象来修改。只要在绘制前为它们设置适当的值，就能自动产生阴影： 123456789101112131415var context = drawing.getContext('2d');// 设置阴影context.shadowOffsetX = 5;context.shadowOffsetY = 5;context.shadowBlur = 4;context.shadowColor = 'rgba(0, 0, 0, 0.5)';// 绘制红色矩形context.fillStyle = '#ff0000';context.fillRect(10, 10, 50, 50);//绘制蓝色矩形context.fillStyle = 'rgba(0, 0, 255, 1)';context.fillRect(30, 30, 50, 50); 渐变渐变由CanvasGradient实例表示，很容易通过2D上下文来创建和修改。要创建一个新的线性渐变，可以调用createLinearGradient()方法。这个方法接收4个参数：起点的x坐标、起点的y坐标、终点的x坐标、终点的y坐标。调用这个方法后，它就会创建一个指定大小的渐变，并返回createLinearGradient对象的实例。 创建了渐变对象后，就使用addColorStop()方法来指定色标。这个方法接收两个参数：色标位置和CSS颜色值。色标位置是一个0（开始的颜色）到1（结束的颜色）之间的数字： 1234var gradient = context.createLinearGradient(30, 30, 70, 70);gradient.addColorStop(0, 'white');gradient.addColorStop(1, 'black'); 此时，gradient对象表示的是一个从画布上点(30, 30)到点(70, 70)的渐变。起点的色标是白色，终点的色标是黑色。然后就可以把fillStyle或strokeStyle设置为这个对象： 1234567// 绘制红色矩形context.fillStyle = '#ff0000';context.fillRect(10, 10, 50, 50);// 绘制渐变矩形context.fillStyle = gradient;context.fillRect(30, 30, 50, 50); 这两行代码执行后得到的矩形只有左上角稍微有一点白色。这主要是因为矩形的起点位于渐变的中间位置，而此时渐变差不多已经结束了。由于渐变不重复，所以矩形的大部分区域都是黑色。确保渐变与形状对齐非常重要，有时候可以考虑使用函数来确保坐标合适： 123function createRectLinearGradient(context, x, y, width, height) &#123; return context.createLinearGradient(x, y, x + width, y + height);&#125; 这个函数基于起点的x和y坐标以及宽度和高度值来创建渐变对象，从而让我们可以在fillRect()使用相同的值： 12345678var gradient = createRectLinearGradient(context, 30, 30, 50, 50);gradient.addColorStop(0, 'white');gradient.addColorStop(1, 'black');// 绘制渐变矩形context.fillStyle = gradient;context.fillRect(30, 30, 50, 50); 要创建径向渐变，可以使用createRadialGradient()方法。这个方法接收6个参数，对应着两个圆的圆心和半径。前三个参数指定的是起点圆的圆心（x和y）及半径，后三个参数指定的是终点圆的圆心和半径。 如果想从某个形状的中心点开始创建一个向外扩散的径向渐变效果，就要将两个圆定义为同心圆： 123456789101112var gradient = context.createRadialGradient(55, 55, 10, 55, 55, 30);gradient.addColorStop(0, 'white');gradient.addColorStop(1, 'black');// 绘制红色矩形context.fillStyle = '#ff0000';context.fillRect(10, 10, 50, 50);// 绘制渐变矩形context.fillStyle = gradient;context.fillRect(30, 30, 50, 50); 模式模式其实就是重复图像，可以用来填充或描边图形。要创建一个新模式，可以调用createPattern()方法并传入两个参数：一个HTML&lt;img&gt;元素和一个表示如何重复图像的字符串。其中，第二个参数的值与CSS的background-repeat属性值相同，包括repeat、repeat-x、repeat-y和no-repeat： 123456var image = document.images[0];var pattern = context.createPattern(image, 'repeat');// 绘制矩形context.fillStyle = pattern;context.fillRect(10, 10, 960, 960); 需要注意的是，模式和渐变一样，都是从画布的原点(0, 0)开始的。将填充样式fillStyle设置为模式对象，只表示在某个特定的区域类显示重复的图像，而不是要从某个位置开始绘制重复的图像。 createPattern()方法的第一个参数也可以是一个&lt;video&gt;元素，或者另一个&lt;canvas&gt;元素。 使用图像数据2D上下文的一个明显的长处是可以通过getImageData()取得原始图像数据。这个方法接收4个参数：要取得其数据的画面区域的x和y坐标以及该区域的像素宽度和高度： 1var imageData = context.getImageData(10, 5, 50, 50); //取得左上角坐标为(10, 5)、大小为50*50像素的区域的图像数据 这里返回的对象是ImageData的实例。每个ImageData对象都有三个属性：width、height和data。其中data属性是一个数组，保存着图像中每一个像素的数据。在data数组中，每一个像素用4个元素来保存，分别表示红、绿、蓝和透明度值。 12345var data = imageData.data, red = data[0], green = data[1], blue = data[2], alpha = data[3]; 数组中每个元素的值都介于0到255之间。能够直接访问到原始图像数据，就能够以各种方式来操作这些数据。例如，通过修改图像数据，可以像下面一样创建一个简单的灰阶过滤器： 12345678910111213141516171819202122232425262728293031323334353637var drawing = document.getElementById('drawing');// 确定浏览器支持&lt;canvas&gt;元素if (drawing.getContext)&#123; var context = drawing.getContext('2d'), image = document.images[0], imageData, data, i, len, average, red, green, blue, alpha; // 绘制原始图像 context.drawImage(image, 0, 0); // 取得图像数据 imageData = context.getImageData(0, 0, image.width, image.height); data = imageData.data; for (i = 0, len = data.length; i &lt; len; i+=4)&#123; red = data[i]; green = data[i + 1]; blue = data[i + 2]; alpha = data[i + 3]; // 求得rgb平均值 average = Math.floor((red + green + blue) / 3); // 设置颜色值， 透明度不变 data[i] = average; data[i + 1] = average; data[i + 2] = average; &#125; // 回写图像数据并显示结果 imageData.data = data; context.putImageData(imageData, 0, 0);&#125; 合成还有两个会应用到2D上下文中所有绘制操作的属性：globalAlpha和globalCompositionOperation。其中，globalAlpha是一个介于0到1之间的值（包括0和1），用于指定所有绘制的透明度。默认值为0。如果所有后续操作都要基于相同的透明度，就可以先把globalAlpha设置为适当值，然后绘制，最后再把它设置回默认值0： 12345678910111213// 绘制红色矩形context.fillStyle = '#ff0000';context.fillRect(10, 10, 50, 50);// 修改全局透明度context.globalAlpha = 0.5;// 绘制蓝色矩形context.fillStyle = 'rgba(0, 0, 255, 1)';context.fillRect(30, 30, 50, 50);// 重置全局透明度context.globalAlpha = 0; globalCompositionOperation表示后绘制的图形怎样与先绘制的图形结合。这个属性的值是字符串，可能的值如下： source-over（默认值）：后绘制的图形位于先绘制的图形上方 source-in：后绘制的图形与先绘制的图形重叠的部分可见，两者其他部分完全透明 source-out：后绘制的图形与先绘制的图形不重叠的部分可见，先绘制的图形完全透明 source-atop：后绘制的图与先绘制的图形重叠的部分可见，先绘制图形不受影响 destination-over：后绘制的图形位于先绘制的图形下方，只有之前透明像素下的部分才可见 destination-in：后绘制的图形位于先绘制的图形下方，两者不重叠的部分完全透明 destination-out：后绘制的图形擦除与先绘制的图形重叠的部分 destination-atop：后绘制的图形位于先绘制的图形下方，在两者不重叠的地方，先绘制的图形会变透明 lighter：后绘制的图形与先绘制的图形重叠部分的值相加，使该部分变亮 copy：后绘制的图形完全代替与之重叠的先绘制图形 xor：后绘制的图形与先绘制的图形重叠部分执行异或操作 12345678910// 绘制红色矩形context.fillStyle = '#ff0000';context.fillRect(10, 10, 50, 50);// 设置合成操作context.globalCompositeOperation = 'destination-over';// 绘制蓝色矩形context.fillStyle = 'rgba(0, 0, 255, 1)';context.fillRect(30, 30, 50, 50); WebGL类型化数组WebGL涉及的复杂计算所需提前知道数值的精度，因此引入了一个概念，叫类型化数组（typed arrays）。类型化数组也是数组，只不过其元素被设置为特定类型的值。 类型化数组的核心就是一个名为ArrayBuffer的类型。每个ArrayBuffer对象表示的只是内存中指定的字节数，但不会指定这些字节用于保存什么类型的数据。通过ArrayBuffer所能做的，就是为了将来使用而分配一定数量的字节。例如，下面代码会在内存中分配20B： 1var buffer = new ArrayBuffer(20); 创建了ArrayBuffer对象后，能够通过该对象获得的信息只有它包含的字节数，方法是访问其byteLength属性： 1var bytes = buffer.byteLength; 视图使用ArrayBuffer（数组缓冲器类型）的一种特别的方式就是用它来创建数组缓冲器视图。其中，最常见的视图是DataView，通过它可以选择ArrayBuffer中一小段字节。为此，可以创建DataView实例的时候传入一个ArrayBuffer、一个可选的字节偏移量（从该字节开始选择）和一个可选的要选择的字节数： 12345678// 基于整个缓冲器创建一个新视图var view = new DataView(buffer);// 创建一个开始于字节9的新视图var view = new DataView(buffer, 9);// 创建一个从字节9开始到字节18的新视图var view = new DataView(buffer, 9, 10); 实例化以后，DataView对象会把字节偏移量以及字节长度信息分别保存在byteOffset和byteLength属性中。 12console.log(view.byteOffset);console.log(view.byteLength); 通过这两个属性可以在以后方便地了解视图的状态。另外，通过其buffer属性也可以取得数组缓冲器。 读取和写入DataView的时候，要根据实际操作的数据类型，选择相应的getter和setter方法。下表列出了DataView支持的数据类型以及相应的读写方法： 所有这些方法的第一个参数都是第一个字节偏移量，表示要从哪个字节开始读取或写入。要保存有些数据类型的数据，可能需要不止1B。比如，无符号8位整数要用1B，而32位浮点数则要用4B。使用DataView，要明确知道自己的数据需要多少字节，并选择正确的读写方法： 1234567var buffer = new ArrayBuffer(20);var view = new DataView(buffer);var value;view.setUint16(0, 25);view.setUint16(2, 50); // 不能从字节1开始，因为16位整数要用2Bvalue = view.getUint16(0); 以上代码把两个无符号16位整数保存到了数组缓冲器中。因为每个16位整数要用2B，所以保存第一个数的字节偏移量为0，而保存第二个数的字节偏移量为2。 用于读写16位或更大数值的方法都有一个可选的参数littleEndian。这个参数是一个布尔值，表示读写数值时是否采用小端字节序（即将数据的最低有效位保存在低内存地址中），而不是大端字节序（即将数据的最低有效位保存在高内存地址中）。如果不确定使用哪种字节序，就采用默认的大端字节序方式保存即可。 因为这里使用的是字节偏移量，而非数组元素数，所以可以通过几种不同的方式来访问同一字节： 1234567var buffer = new ArrayBuffer(20);var view = new DataView(buffer);var value;view.setUint16(0, 25);value = view.getInt8(0);console.log(value); // 0 上面代码中，数值25以16位无符号整数的形式被写入，字节偏移量为0.然后，再以8位有符号整数的方式读取该数据，得到的结果是0。这是因为25的二进制形式的前八位全部是0： 类型化视图类型化视图一般也被称为类型化数组，因为它们除了元素必须是某种特定的数据类型外，与常规的数组无异。类型化视图也分为几种，而且它们都继承了DataView。 每种视图类型都以不同的方式表示数据，而同一数据视选择的类型不同有可能占用一或多字节。例如，20B的ArrayBuffer可以保存20个Int8Array或Uint8Array，或者10个Int16Array或Uint16Array，或者5个Int32Array、Uint32Array或Float32Array，或者2个Float64Array。 由于这些视图都继承自DataView，因而可以使用相同的构造函数参数类实例化。第一个参数是要使用ArrayBuffer对象，第二个参数是作为起点的字节偏移量（默认为0），第三个参数是要包含的字节数。三个参数中只有第一个是必须的： 12345678// 创建一个新数组，使用整个缓冲器var int8s = new Int8Array(buffer);// 只使用从字节9开始的缓冲器var int16s = new Int16Array(buffer, 9);// 只使用从字节9到字节18的缓冲器var uint16s = new Uint16Array(buffer, 9, 10); 能够指定缓冲器中可用的字节段，意味着能在同一个缓冲器中保存不同类型的数值。比如，下面代码就是在缓冲器的开头保存8位整数，而在其他字节中保存16位整数： 123// 使用缓冲器的一部分保存8位整数，而在其他字节中保存16位整数var int8s = new Int8Array(buffer, 0, 10);var uint16s = new Uint16Array(buffer, 11, 10); 每个视图构造函数都有一个名为BYTES_PER_ELEMENT的属性，表示类型化数组的每个元素需要多少字节。因此，Uint8Array.BYTES_PER_ELEMENT就是1，而Float32Array.BYTES_PER_ELEMENT则为4。可以利用这个属性来辅助初始化： 12345// 需要10个元素空间var int8s = new Int8Array(buffer, 0, 10 * Int8Array.BYTES_PER_ELEMENT);// 需要5个元素空间var uint16s = new Uint16Array(buffer, int8s.byteOffset + int8s.byteLength, 5 * BYTES_PER_ELEMENT); 以上代码基于同一个数组缓冲器创建了两个视图。缓冲器的前10B用于保存8位整数，而其他字节用于保存无符号16位整数。在初始化Uint16Array的时候，使用了Int8Array的byteOffset和byteLength属性，以确保uint16s开始于8位数据之后。 类型化视图的目的在于简化对二进制数据的操作。除了前面看到的优点之外，创建类型化视图还可以不用首先创建ArrayBuffer对象。只要传入希望数组保存的元素数，相应的构造函数就可以自动创建一个包含足够字节数的ArrayBuffer对象： 12345// 创建一个数组保存10个8位整数（10字节）var int8s = new Int8Array(10);// 创建一个数组保存10个16位整数（20字节）var int16s = new Int16Array(10); 还可以把常规数组转换为类型化视图，只要把常规数组传入类型化视图的构造函数既可： 12// 创建一个数组保存5个8位整数（10字节）var int8s = new Int8Array([10, 20, 30, 40, 50]); 这是用默认值来初始化类型化视图的最佳方式，也是WebGL项目中最常用的方式。 使用类型化视图时，可以通过方括号语法访问每一个数据成员，可以通过length属性确定数组中有多少元素： 123456789for (var i = 0, len = int8s.length; i &lt; len; i++)&#123; console.log('Value at position ' + i + ' is ' + int8s[i]);&#125;// Value at position 0 is 10// Value at position 1 is 20// Value at position 2 is 30// Value at position 3 is 40// Value at position 4 is 50 当然也可以使用方括号语法为类型化视图的元素赋值。如果为相应元素指定的字节数放不下相应的值，则实际保存的值是最大可能值的模。例如，无符号16位整数所能表示的最大数值是65535，如果你想保存65536，那实际保存的值是0；如果想保存66537，那实际保存的值是1，依次类推。 数据类型不匹配时不会抛出错误，所以必须自己保证所赋得值不会超过相应元素的字节限制。 类型化视图还有一个方法，即subarray()，使用这个方法可以基于底层数组缓冲器的子集创建一个新视图。这个方法接收两个参数：开始元素的索引和可选的结束元素的索引。返回的类型与调用该方法的视图类型相同： 12var uint16s = new Uint16Array(10), sub = uint16s.subarray(2, 5); 在以上代码中，sub也是Uint16Array的一个实例，而且底层与uint16s都基于同一个ArrayBuffer。通过大视图创建小视图的主要好处是，在操作大数组中的一部分元素时，无需担心意外修改了其他元素。 WebGL上下文如果浏览器不支持WebGL，取得该上下文时会返回null： 123456789var drawing = document.getElementById('drawing');// 确定浏览器支持&lt;canvas&gt;元素if (drawing.getContext)&#123; var gl = drawing.getContext('webgl'); //一般都把WebGL上下文对象命名为gl if (gl)&#123; // 使用WebGL &#125;&#125; WebGL是OpenGL ES2.0的Web版本。 通过给getContext()传递第二个参数，可以为WebGL上下文设置一些选项。这个参数本身就是一个对象，可以包含下列属性： 建议确实有必要的情况下再开启这个值，因为可能影响性能。 123456789var drawing = document.getElementById('drawing');// 确定浏览器支持&lt;canvas&gt;元素if (drawing.getContext)&#123; var gl = drawing.getContext('webgl', &#123;alpha: false&#125;); if (gl)&#123; // 使用WebGL &#125;&#125; 大多数时候，各选项默认值就能满足我们的要求。 如果getContext()无法创建WebGL上下文，有的浏览器会抛出错误。为此，最好把调用封装到一个try-catch块中： 123456789101112131415var drawing = document.getElementById('drawing');// 确定浏览器支持&lt;canvas&gt;元素if (drawing.getContext)&#123; try &#123; var gl = drawing.getContext('webgl'); &#125;catch (ex) &#123; // 什么也不做 &#125; if (gl)&#123; // 使用WebGL &#125;else &#123; console.log('webgl context could not be created'); &#125;&#125; 常量OpenGL中的常量都带有GL_前缀。在WebGL中，保存在上下文对象中的这些常量都没有GL_前缀。 方法命名方法名的后缀会包含参数个数和接收的数据类型（f表示浮点数，i表示整数）。例如，gl.uniform4f意味着要接收4个浮点数。 也有很多方法接收数组参数，这样的方法名字中会包含字母v。 准备绘图在实际操作WebGL上下文之前，一般都要使用某种实色清除&lt;canvas&gt;，为绘图做好准备。为此，首先必须使用clearColor()方法来指定要使用的颜色值，该方法接收4个参数：红、绿、蓝和透明度。每个参数必须是一个0到1之间的数值，表示每种分量在最终颜色中的强度： 12gl.clearColor(0, 0, 0, 1); // blackgl.clear(gl.COLOR_BUFFER_BIT); 以上代码把清理颜色缓冲区的值设置为黑色，然后调用clear()方法，这个方法与OpenGL中的glClear()等价。传入的参数gl.COLOR_BUFFER_BIT告诉WebGL使用之前定义的颜色来填充相应区域。 视口与坐标开始绘图之前，通常要先定义WebGL的视口。默认情况下，视口可以使用整个&lt;canvas&gt;区域。要改变视口大小，可以调用viewport()方法并传入4个参数：（视口相对于&lt;canvas&gt;元素的）x坐标、y坐标、宽度和高度： 1gl.viewport(0, 0, drawing.width, drawing.height); 视口坐标的原点(0, 0)在&lt;canvas&gt;元素的左下角，x轴和y轴的正方向分别是向右和向上，最大可以定义为(width-1, height-1)。 12345678// 视口是&lt;canvas&gt;左下角的四分之一区域gl.viewport(0, 0, drawing.width/2, drawing.height/2);// 视口是&lt;canvas&gt;左上角的四分之一区域gl.viewport(0, drawing.height/2, drawing.width/2, drawing.height/2);// 视口是&lt;canvas&gt;右下角的四分之一区域gl.viewport(drawing.width/2, 0, drawing.width/2, drawing.height/2); 视口内部的坐标系与视口的坐标系不一样，在视口内部，坐标原点(0, 0)是视口的中心点，因此视口左下角坐标为(-1, -1)，而左上角坐标为(1, 1)。 如果在视口内部是用视口外部的坐标，结果可能会被视口剪切。 缓冲区顶点信息保存在JavaScript的类型化数组中，使用之前必须转换到WebGL的缓冲区。要创建缓冲区，可以调用gl.createBuffer()，然后使用bindBuffer()绑定到WebGL上下文。这两步做完之后，就可以用数据来填充缓冲区： 123var buffer = gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER, buffer);gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0.5, 1]), gl.STATIC_DRAW); 调用gl.bindBuffer()可以将buffer设置为上下文的当前缓冲区。此后，所有缓冲区操作都直接在buffer中执行。因此，调用gl.bindBuffer()时不需要明确传入buffer也没有问题。最后一行代码使用Float32Array中的数据初始化了buffer。如果想使用drawElements()输出缓冲区的内容，也可以传入gl.ELEMENT_ARRAY_BUFFER。 gl.bufferData()的最后一个参数用于指定使用缓冲区的方式，取值范围是如下几个常量。 多数情况下，将缓冲区使用方式设置为gl.STATIC_DRAW即可。 在包含缓冲区的页面重载之前，缓冲区始终保留在内存中。如果不想要某个缓冲区，直接调用gl.deleteBuffer()释放内存。 错误为了知道是否有错误发生，必须在调用某个可能出错的方法后，手工调用gl.getError()方法。这个方法返回一个表示错误类型的常量： 每次调用gl.getError()方法返回一个错误值。第一次调用后，后续对gl.getError()的调用可能会返回另一个错误值。如果发生多个错误，需要反复调用gl.getError()直至它返回gl.NO_ERROR。在执行了很多操作的情况下，最好通过一个循环来调用getError()： 12345var errorCode = gl.getError();while (errorCode)&#123; console.log("error occurred: " + errorCode); errorCode = gl.getError();&#125; 着色器WebGL中有两种着色器：顶点着色器和片段着色器。顶点着色器用于将3D顶点转换为需要渲染的2D点。片段着色器用于准确计算要绘制的每个像素的颜色。这些着色器是使用GLSL写的，是一种与C和JavaScript完全不同的语言。 编写着色器每个着色器都有一个main()方法，该方法在绘图期间会重复执行。为着色器传递数据的方式有两种：Attribute和Uniform。通过Attribute可以向顶点着色器中传入顶点信息，通过Uniform可以向任何着色器传入常量值。Attribute和Uniform在main()方法外部定义，分别使用关键字attribute和uniform。在这两个值类型关键字之后，是数据类型和变量名： 1234567891011121314// OpenGL着色语言// 顶点着色器attribute vec2 aVertexPosition;void main()&#123; gl_Position = vec4(aVertexPosition, 0.0, 1.0);&#125;// 片段着色器uniform vec4 uColor;void main()&#123; gl_FragColor = uColor;&#125; 编写着色器程序浏览器不能理解GLSL程序，通常是把着色器包含在&lt;script&gt;标签内，并为该标签指定一个自定义的type属性。由于无法识别type属性值，浏览器不会解析&lt;script&gt;标签中的内容，但不影响读写其中的代码： 1234567891011121314&lt;script type="x-webgl/x-vertex-shader" id="vertexShader"&gt; attribute vec2 aVertexPosition; void main()&#123; gl_Position = vec4(aVertexPosition, 0.0, 1.0); &#125;&lt;/script&gt;&lt;script type="x-webgl/x-fragment-shader" id="fragmentShader"&gt; uniform vec4 uColor; void main()&#123; gl_FragColor = uColor; &#125;&lt;/script&gt; 然后通过text属性提取出&lt;script&gt;元素的内容： 12var vertexGlsl = document.getElementById('vertexShader').text, fragmentGlsl = document.getElementById('fragmentShader').text; 复杂一些WebGL应用可能会通过Ajax动态加载着色器。而使用着色器的关键是要有字符串形式的GLSL程序。 取得了GLSL字符串之后，接下来就是创建着色器对象。要创建着色器对象，可以调用gl.createShader()方法并传入要创建的着色器类型（gl.VERTEX_SHADER或gl.FRAGMENT_SHADER）。编译着色器使用的是gl.compileShader()： 1234567var vertexShader = gl.createShader(gl.VERTEX_SHADER);gl.shaderSource(vertexShader, vertexGlsl);gl.compileShader(vertexShader);var framentShader = gl.createShader(gl.FRAGMENT_SHADER);gl.shaderSource(framentShader, fragmentGlsl);gl.compileShader(framentShader); 上面代码创建了两个着色器。使用下列代码，可以把这两个对象链接到着色器程序中： 123456var program = gl.createProgram();gl.attachShader(program, vertexShader);gl.attachShader(program, framentShader);gl.linkProgram(program); // 把两个着色器封装到program变量中gl.useProgram(program); // 调用后，所有后续的绘图操作都将使用这个程序 为着色器传入值前面定义的着色器都必须接受一个值才能工作。为了给着色器传入这个值，必须先找到要接受这个值的变量。对于Uniform变量，可以使用gl.getUniformLocation()，这个方法返回一个对象，表示Uniform变量在内存中的位置。然后可以基于变量的位置来赋值： 12var uColor = gl.getUniformLocation(program, 'uColor'); // 从program中找到Uniform变量uColor，反悔了它在内存中的位置gl.uniform4fv(uColor, [0, 0, 0, 1]); // 给uColor赋值 Attribute变量可以调用gl.getAttribLocation()： 123var aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition');gl.enableVertexAttribArray(aVertexPosition);gl.vertexAttribPointer(aVertexPosition, itemSize, gl.FLOAT, false, 0, 0); //创建了指向gl.bindBuffer()指定的缓冲区的指针，并将其保存在aVertexPosition 调试着色器和程序对于着色器，可以在操作之后调用gl.getShaderParameter()，取得着色器的编译状态： 123if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS))&#123; console.log(gl.getShaderInfoLog(vertexShader));&#125; 程序失败最有可能发生在链接过程，要检测链接错误，可以使用下列代码： 123if (!gl.getProgramParameter(program, gl.LINK_STATUS))&#123; console.log(gl.getProgramInfoLog(program));&#125; 绘图WebGL只能绘制三种形状：点、线和三角。 执行绘图操作要调用gl.drawArrays()或gl.drawElements()方法，前者用于数组缓冲区，后者用于元素数组缓冲区。 gl.drawArrays()或gl.drawElements()的第一个参数都是一个常量，表示要绘制的形状。可取值的常量范围包括： gl.drawArray()方法接收上面列出的常量中的一个作为第一个参数，接收数组缓冲区中的起始索引作为第二个参数，接收数组缓冲区中包含的定点数（点的集合数）作为第三个参数： 1234567891011121314151617181920212223// 假设已经使用前面定义的着色器清楚了视口// 定义三个顶点以及每个顶点的x和y坐标var vertices = new Float32Array([0, 1, 1, -1, -1, -1]), buffer = gl.createBuffer(), vertexSetSize = 2, vertexSetCount = vertices.length/vertexSetSize, uColor, aVertexPosition;// 把数据放到缓冲区gl.bindBuffer(gl.ARRAY_BUFFER, buffer);gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);// 为片段着色器传入颜色值uColor = gl.getUniformLocation(program, 'uColor');gl.uniform4fv(uColor, [0, 0, 0, 1]);// 为着色器传入顶点信息aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition');gl.vertexAttribPointer(aVertexPosition, vertexSetSize, gl.FLOAT, false, 0, 0);// 绘制三角形gl.drawArrays(gl.TRIANGLES, 0, vertexSetCount); 纹理WebGL的纹理可以使用DOM中的图像。要创建一个新纹理，可以调用gl.createTexture()，然后再将一幅图像绑定到该纹理。如果图像尚未加载到内存中，可能需要创建一个Image对象的实例，以便动态加载图像。图像加载完成之前，纹理不会初始化，因此，必须在load事件触发后才能设置纹理： 1234567891011121314var image = new Image(), texture;image.src = 'smile.gif';image.onload = function () &#123; texture = gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D, texture); gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true); gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER,gl.NEAREST); // 清除当前纹理 gl.bindTexture(gl.TEXTURE_2D, null); gl.UNPACK_FLIP_Y_WEBGL是WebGL中独有的常量，在加载Web中的图像时，多数情况下必须使用这个常量。这主要是因为GIF、JPEG和PNG图像与WebGL使用的坐标系不一样，如果没有这个标志，解析图像时就会发生混乱。 用作纹理的图像必须与包含页面来自同一个域，或者保存在启用了CORS的服务器上。 读取像素读取像素值的方法readPixels()与OpenGL中的同名方法只有一点不同，即最后一个参数必须是类型化数组。像素信息是从帧缓冲区读取的，然后保存在类型化数组中。readPixels()方法的参数有：x、y、宽度、高度、图像格式、数据类型和类型化数组。前4个参数指定读取哪个区域中的像素。图像格式参数几乎总是gl.RGBA。数据类型参数用于指定保存在类型化数组中的数据类型，但有一下限制： 12var pixels = new Uint8Array(25*25);gl.readPixels(0, 0, 25, 25, gl.RGBA, gl.UNSIGNED_BYTE, pixels); 在浏览器绘制更新的WebGL图像之前调用readPixels()不会有什么意外。绘制发生后，帧缓冲区会恢复原始的干净状态，而调用readPixels()返回的像素数据反映的就是清除缓冲区后的状态。如果想在绘制发生后读取像素数据，那在初始化WebGL上下文时必须传入适当的preserveDrawingBuffer选项。 1var gl = drawing.getContext('experimental-webgl', &#123;preserveDrawingBuffer: true&#125;); 设置这个标志的意思是让帧缓冲区在下一次绘制之前，保留其最后的状态。这个选项会导致性能损失，因此能不用最好不用。 HTML5脚本编程跨文档消息传递跨文档消息传送（XDM）指的是在来自不同域的页面间传递消息。例如，www.tc9011.com域中的页面与位于一个内嵌框架中的test.tc9011.com域中的页面通信。 XDM的核心就是postMessage()方法。在HTML5规范中，除了XDM部分之外的其他部分也会提到这个方法名，但都是为了一个目的：向另一个地方传递数据。对于XDM而言，另一个地方指的是包含在当前页面中的&lt;iframe&gt;元素，或者由当前页面弹出的窗口。 postMessage()方法接收两个参数：一条消息和一个表示消息接收方来自哪个域的字符串。第二个参数对保障安全通信非常重要，可以防止浏览器把消息发送到不安全的地方： 123// 注意：所有支持XDM的浏览器也支持iframe的contentWindow属性 var iframeWindow = document.getElementById('myframe').contentWiniframeWindow.postMessage('A secret', 'http://www.tc9011.com'); 接收到XDM消息时，会触发window对象的message事件。这个事件是以异步形式触发的，因此从发送消息到接收消息可能要经过一段时间的延迟。触发message事件后，传递给onmessage处理程序的事件对象包含以下三方面的重要信息： data：作为postMessage()第一个参数传入的字符串数据 origin：发送消息的文档所在的域 source：发送消息的文档的window对象的代理。这个代理对象主要用于在发送上一条消息的窗口中调用postMessage()方法。如果发送消息的窗口来自同一个域，那这个对象就是window 接收到消息后验证发送窗口的来源是至关重要的。就像给postMessage()方法指定第二个参数，以确保浏览器不会把消息发送给未知页面一样。在onmessage处理程序中检测消息来源可以确保传入的消息来自已知的页面。 12345678910EventUtil.addHandler(window, 'message', function (event) &#123; // 确保发送消息的域是已知的域 if (event.origin == 'http://www.tc9011.com')&#123; // 处理接收到的数据 processMessage(event.data); // 可选：向来源窗口发送回执 event.source.postMessage('received', 'http://test.tc9011.com'); &#125;&#125;); event.source大多数情况下只是window对象的代理，并非实际的window对象，不能通过这个代理对象访问window对象的其他任何信息，只能通过这个代理去调用postMessage()。 postMessage()第一个参数最好只传字符串，如果想传入结构化数据，最好先使用JSON.stringfy()，再通过postMessage()传入得到字符串，然后再在onmessage事件处理程序中调用JSON.parse()。 原生拖放拖放事件拖动某个元素时，将依次触发下列事件： dragstart drag dragend 按下鼠标键并开始移动鼠标时，会在被拖放的元素上触发dragstart。此时光标变成不能放符号（圆环中有一条反斜杠线），表示不能把元素放到自己上面。拖动开始时，可以通过ondragstart事件处理程序来运行JavaScript代码。 触发dragstart事件后，随即会触发drag事件，而且在元素被拖动期间会持续触发该事件。这个事件与mousemove事件相似，在鼠标移动过程中，mousemove事件也会持续发生。当拖动停止时，会触发dragend事件。 上述三个事件的目标都是被拖动的元素。默认情况下，浏览器不会再拖动期间改变被拖动元素的外观，但你可以自己修改。不过，大多数浏览器会为正被拖动的元素创建一个半透明的副本，这个副本始终跟着光标移动。 当某个元素被拖动到一个有效的放置目标上时，下列事件会一次发生： dragenter dragover dragleave或者drop 只要有元素被拖动到放置目标上，就会触发dragenter事件。紧随其后的是dragover事件，而且被拖动的元素还在放置目标的范围内移动时，就会持续触发该事件。如果元素被放到了放置目标中，则会触发drop事件而不是dragleave事件。上述三个事件的目标都是作为放置目标的元素。 自定义放置目标在拖动元素经过某些无效放置目标时，可以看到一种特殊的光标，表示不能放置。虽然所有元素都支持放置目标事件，但这些元素默认是不允许放置的。如果拖动元素经过不允许放置的元素，无论用户如何操作，都不会发生drop事件。不过，可以把任何元素变成有效的放置目标，方法是重写dragenter和dragover事件的默认行为。 1&lt;div id="droptarget"&gt;&lt;/div&gt; 123456789var droptarget = document.getElementById('droptarget');EventUtil.addHandler(droptarget, 'dropover', function (event) &#123; EventUtil.preventDefault(event);&#125;);EventUtil.addHandler(droptarget, 'dragenter', function (event) &#123; EventUtil.preventDefault(event)&#125;); 在FIrefox3.5+中，放置事件的默认行为是打开被放到放置目标上的URL。换句话说，如果是把图像拖放到放置目标上，页面就会转向图像文件；而如果是把文本拖放到放置目标上，则会导致无效URL错误。为了让FIrefox支持正常拖放，还要取消drop事件的默认行为，阻止它打开URL： 123EventUtil.addHandler(droptarget, 'drop', function (event) &#123; EventUtil.preventDefault(event);&#125;); dataTransfer对象为了在拖放操作时实现数据交换，引入了dataTransfer对象，它是事件对象的一个属性，用于从被拖动元素向放置目标传递字符串格式的数据。因为它是事件对象的属性，所以只能在拖放事件处理程序中访问dataTransfer对象。在事件处理程序中，可以使用这个对象的属性和方法来完善拖放功能。 dataTransfer对象有两个主要方法：getData()和setData()。getData()方法可以取得由setData()方法保存的值。setData()方法的第一个参数，也是getData()方法唯一的一个参数，是一个字符串，表示保存的数据类型，取值为各种MIME类型： 1234567// 设置和接收文本数据event.dataTransfer.setData('text/plain', 'some text');var text = event.dataTransfer.getData('text');// 设置和接收URLevent.dataTransfer.setData('text/uri-list', 'http:// wwww.tc9011.com/');var url = event.dataTransfer.getData('URL'); 保存在dataTransfer对象中的数据只能在drop事件处理程序中读取。如果ondrop处理程序中没有读到数据，那就是dataTransfer对象已经被销毁，数据也丢失了。 在拖动文本框中的文本时，浏览器会调用setData()方法，将拖动的文本以text格式保存在dataTransfer对象中。类似地，在拖放链接或图像时，会调用setData()方法并保存URL。然后，在这些元素被拖放到放置目标时，就可以通过getData()读到这些数据。当然，作为开发人员，也可以在datastart事件处理程序中调用setData()，手工保存自己要传输的数据，以便将来使用。 将数据保存为文本和保存为URL是有区别的。如果将数据保存为文本格式，那么数据不会得到任何特殊处理。而如果将数据保存为URL，浏览器会将其当成网页中的链接，如果你把它放置到另一个浏览器窗口中，浏览器会打开该URL。 dropEffect和effectAllowed利用dataTransfer对象，不关能传输数据，还能通过它来确定被拖动元素以及作为放置目标的元素能够接收什么操作。为此，需要访问dataTransfer对象的两个属性：dropEffect和effectAllowed。 通过dropEffect属性可以知道被拖动元素能够执行哪种放置行为。这个属性有下列4个值： 在把元素拖动到放置目标上时，以上每个值都会导致光标显示为不同的符号，然而，要怎么样实现光标所指示的动作完全取决于你。要使用dropEffect属性，必须在ondragenter事件处理程序中针对放置目标来设置它。 dropEffect属性只有搭配effectAllowed属性才有用。effectAllowed属性表示允许拖动元素的哪种dropEffect，effectAllowed属性可能的值如下： 必须在ondragstart事件处理程序中设置effectAllowed属性。 假设你想允许用户把文本框中的文本拖放到一个&lt;div&gt;元素中。首先，必须将dropEffect和effectAllowed设置为move。但是，由于&lt;div&gt;元素的放置事件的默认行为是什么也不做，所以文本不可能自动移动。重写整个默认行为，就能从文本框中移走文本。然后就可以自己编写代码将文本插入到&lt;div&gt;中。如果将dropEffect和effectAllowed设置为copy，那就不会自动移走文本框中的文本。 可拖动默认情况下，图像、链接和文本是可以拖动的。文本只有在被选中的情况下才能拖动，而图像和链接在任何时候都可以拖动。 让其他元素可以拖动也是可能的。HTML5为所有HTML元素规定了一个draggable属性，表示元素是否可以拖动。图像和链接的draggable属性自动被设置成了true，而其他元素这个属性的默认值都是false。 12345&lt;!--让这个图像不可以拖动--&gt;&lt;img src="img.png" alt="pic" draggable="false"&gt;&lt;!--让这个元素可以拖动--&gt;&lt;div draggable="true"&gt;...&lt;/div&gt; 其他成员HTML5规定dataTransfer对象还应该包含下列方法和属性： 媒体元素&lt;video&gt;和&lt;audio&gt;除了能让开发人员方便地嵌入媒体文件之外，都提供了用于实现正常功能的JavaScript API，允许为媒体创建自定义的控件： 12345&lt;!--嵌入视频--&gt;&lt;video src="test.mp4" id="myVideo"&gt;Video player not available.&lt;/video&gt;&lt;!--嵌入音频--&gt;&lt;audio src="test.mp3" id="myAudio"&gt;Audio player not available.&lt;/audio&gt; 使用这两个元素时，至少要在标签中包含src属性，指向要加载的媒体文件。还可以设置width和height属性以指定视频播放器的大小，而为poster属性指定图像的URL可以在加载视频内容期间显示一幅图像。另外，如果标签中有controls属性，则意味着浏览器应该显示UI控件，以便用户直接操作媒体。位于开始和结束标签之间的任何内容都将作为后备内容，在浏览器不支持这两个媒体元素的情况下显示。 因为并非所有浏览器都支持所有媒体格式，所以可以指定多个不同的媒体来源。为此，不用在标签中指定src属性，而是要像下面这样使用一或多个&lt;source&gt;元素。 1234567891011121314&lt;!--嵌入视频--&gt;&lt;video id="myVideo"&gt; &lt;source src="test.webm" type="video/webm; codecs='vp8, vorbis'"&gt; &lt;source src="test.ogv" type="video/ogg; codecs='theora, vorbis'"&gt; &lt;source src="test.mpg"&gt; Video player not available.&lt;/video&gt;&lt;!--嵌入音频--&gt;&lt;audio id="myAudio"&gt; &lt;source src="test.ogg" type="audio/ogg"&gt; &lt;source src="test.mp3" type="audio/mpeg"&gt; Audio player not available.&lt;/audio&gt; 属性&lt;video&gt;和&lt;audio&gt;元素都提供了完善的JavaScript接口。下表列出了两个元素共有的属性： 事件 自定义媒体播放器使用&lt;audio&gt;和&lt;video&gt;元素的play()和pause()方法，可以手工控制媒体文件的播放。组合使用属性、事件和这两个方法，很容易创建一个自定义的媒体播放器： 1234567891011&lt;div class="mediaplayer"&gt; &lt;div class="video"&gt; &lt;video id="player" src="movie.mov" poster="mymovie.jpg" width="300" height="200"&gt; video player not available. &lt;/video&gt; &lt;/div&gt; &lt;div class="controls"&gt; &lt;input type="button" value="play" id="video-btn"&gt; &lt;span id="curtime"&gt;0&lt;/span&gt;/&lt;span id="duration"&gt;0&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425// 取得元素的引用var player = document.getElementById('player'), btn = document.getElementById('video-btn'), curtime = document.getElementById('curtime'), duration = document.getElementById('duration');// 更新播放时间duration.innerHTML = player.duration;// 为按钮添加事件处理程序EventUtil.addHandler(btn, 'click', function (event) &#123; if (player.paused)&#123; player.play(); btn.value = 'Pause'; &#125;else &#123; player.pause(); btn.value = 'Play'; &#125;&#125;);// 定时更新当前时间setInterval(function () &#123; curtime.innerHTML = player.currentTime;&#125;, 250); 检测编解码器的支持情况&lt;audio&gt;和&lt;video&gt;元素都有一个canPlayType()方法，该方法接收一种格式/编解码器字符串，返回probably、maybe或&#39;&#39;(空字符串)。空字符串是假值，因此可以像下面这样在if语句中使用canPlayType()： 123if (audio.canPlayType('audio/mpeg'))&#123; // 进一步处理&#125; 如果给canPlayType()传入了一种MIME类型，则返回值很可能是maybe或空字符串。这是因为媒体文件本身只不过是音频或视频的一个容器，而真正决定文件能否播放的还是编码的格式。在同时传入MIME类型和编解码器的情况下，可能性就会增加，返回的字符串会变成probably。 1234567891011var audio = document.getElementById('audio-player');// 很可能maybeif (audio.canPlayType('audio/mpeg')) &#123; // 进一步处理&#125;// 很可能是probablyif (audio.canPlayType('audio/ogg; codecs="vorbis"')) &#123; // 进一步处理&#125; 下面列出了已知的已得到支持的音频/视频格式和其编解码器： Audio类型&lt;audio&gt;元素还有一个原生的JavaScript构造函数Audio，可以在任何时候播放音频。从同为DOM元素的角度来看，Audio和Image很相似，但Audio不像Image那样必须插入到文档中。只要创建一个新实例，并传入音频源文件即可： 1234var audio = new Audio('test.mp3');EventUtil.addHandler(audio, 'canplaythrough', function (event) &#123; audio.play();&#125;); 在iOS中，调用play()时会弹出一个对话框，得到用户的许可后才能播放声音。如果想在一段音频播放后再播放另一段音频，必须在onfinish事件处理程序中调用play()方法。 历史状态管理HTML5通过更新history对象为管理历史状态提供了方便。通过hashchange事件，可以知道URL的参数什么时候发生了变化，即什么时候该有所反应。而通过状态管理API，能够在不加载新页面的情况下改变浏览器的URL。为此，需要使用history.pushState()方法，该方法可以接收三个参数：状态对象、新状态的标题和可选的相对URL。 1history.pushState(&#123;name: 'TangCheng'&#125;, "tc's page", 'tc.html'); 执行pushState()方法后，新的状态信息就会被加入历史状态栈，而浏览器地址栏也会变成新的相对URL。但是，浏览器并不会真的向服务器发送请求，即使状态改变之后查询location.href也会返回与地址栏中相同的地址。第一个参数应该尽可能提供初始化页面状态所需要的各种信息。 因为pushState()会创建新的历史状态，所以后退按钮也能使用。按下后退按钮，会触发window对象的popstate事件（popstate事件发生后，事件对象中的状态对象event.state是当前状态）。popstate事件的事件对象有一个state属性，这个属性就包含着当初第一个参数传递给pushState()的状态对象。 123456EventUtil.addHandler(window, 'popstate', function (event) &#123; var state = event.state; if (state)&#123; // 第一个页面加载时state为空 processState(state); &#125;&#125;); 得到这个状态对象后，必须把页面重置为状态对象中的数据表示的状态。浏览器加载的第一个页面没有状态，因此单击后退按钮返回浏览器加载的第一个页面时，event.state值为null。 要更新当前状态，可以调用replaceState()，传入的参数与pushState()的前两个参数相同。调用这个方法不会在历史状态栈中创建新的状态，只会重写当前状态。 1history.replaceState(&#123;name: 'www'&#125;, "www'spage");]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[普吉之旅]]></title>
    <url>%2F2017%2F10%2F15%2F%E6%99%AE%E5%90%89%E4%B9%8B%E6%97%85%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>旅行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《JavaScript高级程序设计》学习笔记（五）]]></title>
    <url>%2F2017%2F10%2F04%2F%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[第十三章：事件 JavaScript与HTML之间的交互是通过事件实现的，就是文档或浏览器窗口中发生的一些特定的交互瞬间。可以使用侦听器（或处理程序）来预定事件，以便事件发生时执行相应的代码。这种在传统软件工程中被称为观察员模式的模型，支持页面的行为与页面的外观之间的松散耦合。 事件流事件流描述的是从页面中接收事件的顺序。IE事件流是事件冒泡流，而Netscape Communicator的事件流是事件捕获流。 事件冒泡IE的事件流叫做事件冒泡，即事件开始时由最具体的元素接收，然后逐级向上传播到较为不具体的节点（文档）。 12345678910&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="myDiv"&gt;Click me&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 点击了页面中的&lt;div&gt;元素，那么这个click事件会按照如下顺序传播： 所有浏览器都支持事件冒泡，但在具体实现上还有一些差别。IE9、Firefox、Chrome和Safari则将事件一直冒泡到window对象。 事件捕获事件捕获的思想是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。事件捕获的用意在于在事件到达预定目标之前捕获它。 点击了上面例子中的&lt;div&gt;元素，那么这个click事件会按照如下顺序传播： IE9、Safari、Chrome、Opera和Firefox也都支持这种事件流模型。尽管DOM2级事件规范要求事件应该从document对象开始传播，但这些浏览器都是从window对象开始捕获事件的。 建议放心地使用事件冒泡，在有特殊需要的时候再使用事件捕获。 DOM事件流DOM2级事件规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。 首先发生的是事件捕获，为截获事件提供了机会。然后是实际的目标接收到事件。最后一个阶段是冒泡阶段，可以在这个阶段对事件做出响应。 在DOM事件流中，实际的目标在捕获阶段不会接收到事件。这意味着在捕获阶段，事件从document到&lt;html&gt;再到&lt;body&gt;后就停止了。下一个阶段是处于目标阶段，于是事件再&lt;div&gt;上发生，并在事件处理中被看成冒泡阶段的一部分。然后，冒泡阶段发生，事件又传播回文档。 多数支持DOM事件流的浏览器都实现了一种特定的行为，即使DOM2级事件规范明确要求捕获阶段不会涉及事件目标，但IE9、Safari、Chrome、Firefox和Opera9.5及更高版本都会在捕获阶段触发事件对象上的事件。结果，就是有两个机会在目标对象上面操作事件。 事件处理程序事件就是用户或浏览器自身执行的某种动作。如click、load和mouseover都是事件的名字。而响应某个事件的函数就叫事件处理程序（或事件侦听器）。事件处理程序的名字以on开头，因此click事件的事件处理程序就是onclick。 HTML事件处理程序某个元素支持的每种事件，都可以使用一个与相应事件处理程序同名的HTML特性来指定。这个特性的值应该是能够执行的JavaScript代码。 1&lt;input type="button" value="Click Me" onclick="alert('Clicked')"&gt; 123456&lt;input type="button" value="Click Me" onclick="showMessage()"&gt;&lt;script&gt; function showMessage() &#123; alert('hello'); &#125;&lt;/script&gt; 在HTML中定义的事件处理程序可以包含要执行的具体动作，也可以调用在页面其他地方定义的脚本。 包含具体动作时，是以JavaScript代码作为onclick的值来定义的。由于值是JavaScript，因此不能在其中使用未经转义的HTML语法字符，例如&amp;、&quot;&quot;、&lt;、&gt;。 事件处理程序中的代码在执行时，有权访问全局作用域中的任何代码。 这样指定事件处理程序具有一些独到之处。首先，这样会创建一个封装着元素属性值的函数。这个函数中有一个局部变量event，也就是事件对象： 1&lt;input type="button" value="Click Me" onclick="alert(event.type)"&gt; 通过event变量，可以直接访问事件对象，你不用自己定义它，也不用从函数的列表中读取。在这个函数内部，this值等于事件的目标元素： 1&lt;input type="button" value="Click Me" onclick="alert(this.value)"&gt; 关于这个动态创建的函数，另一个有意思的地方是它扩展作用域的方式。在这个函数内部，可以像访问局部变量一样访问document及该元素本身的成员。这个函数使用with像下面这样扩展作用域： 1234567function()&#123; with(document)&#123; with(this)&#123; //元素属性值 &#125; &#125;&#125; 这样，事件处理程序要访问自己的属性就简单多了，下面这行代码与前面的例子效果相同： 1&lt;input type="button" value="Click Me" onclick="alert(value)"&gt; 如果当前元素是一个表单输入元素，则作用域中还会包含访问表单元素（父元素）的入口，这个函数就变成了如下所示： 123456789function()&#123; with(document)&#123; with(this.form)&#123; with(this)&#123; // 元素属性值 &#125; &#125; &#125;&#125; 实际上，这样扩展作用域的方式，无非就是想让事件处理程序无需引用表单元素就能访问其他表单字段： 1234&lt;form method="post"&gt; &lt;input type="text" name="username" value=""&gt; &lt;input type="button" value="Echo Username" onclick="alert(username.value)"&gt;&lt;/form&gt; 不过，在HTML中指定事件处理程序有两个缺点。首先，存在一个时差问题，因为用户可能会在HTML元素一出现在页面上就触发相应的时间，但当时的事件处理程序可能尚不具备执行条件。假设上面的showMessage()函数是在按钮下方、页面最底部定义的。如果用户在页面解析showMessage()函数之前就单击了按钮，就会引发错误。为此，很多HTML事件处理程序都会被封装在一个try-catch块中，以便错误不会浮出水面： 1&lt;input type="button" value="Click Me" onclick="try&#123;showMessage();&#125;catch (ex)&#123;&#125;"&gt; 另一个缺点是，这样扩展事件处理程序的作用域链在不同浏览器中会导致不同的结果。不同JavaScript引擎遵循的标识符解析规则略有差异，很可能会在访问非限定对象成员时出错。 通过HTML指定事件处理程序的最后一个缺点是HTML与JavaScript代码紧密耦合。 DOM0级事件处理程序通过JavaScript指定事件处理程序的传统方式，就是将一个函数赋值给一个事件处理程序属性。这种方式比较简单，而且具有跨浏览器的优势。要使用JavaScript指定事件处理程序，首先必须取得一个要操作的对象的引用。 每个元素（包括window和document）都有自己的事件处理程序属性，这些属性通常全部小写。将这种属性的值设置为一个函数，就可以指定事件处理程序： 1234var btn = document.getElementById('mtBtn');btn.onclick = function () &#123; alert('clicked');&#125; 要注意的是，在这些代码运行前不会指定事件处理程序，因此如果这些代码在页面中位于按钮后面，就有可能在一段时间内怎么单击都没有反应。 使用DOM0级方法指定的事件处理程序被认为是元素的方法。因此，这时候的事件处理程序时在元素的作用域中运行；也就是，程序中的this引用当前元素： 1234var btn = document.getElementById('mtBtn');btn.onclick = function () &#123; alert(this.id);&#125;; 实际上可以在事件处理程序中通过this访问元素的任何属性和方法。以这种方式添加的事件处理程序会在事件流的冒泡阶段被处理。 也可以删除通过DOM0级方法指定的事件处理程序，只要像下面这样将事件处理程序属性的值设置为null即可： 1btn.onclick = null; 将事件处理程序设置为null后，再单击按钮将不会有任何动作发生。 DOM2级事件处理程序DOM2级事件定义了两个方法，用于处理指定和删除事件处理程序的操作：addEventListener()和removeEventListener()。所有DOM节点中都包含这两个方法，并且它们都接受3个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。 123btn.addEventListener('click', function () &#123; alert(this.id);&#125;,false); 与DOM0级方法一样，这里添加的事件处理程序也是在其依附的元素的作用域中运行。使用DOM2级方法添加事件处理程序的主要好处是可以添加多个事件处理程序： 1234567btn.addEventListener('click', function () &#123; alert(this.id);&#125;,false);btn.addEventListener('click',function () &#123; alert('hello');&#125;,false); 这里为按钮添加了两个事件处理程序。这两个事件处理程序会按照添加它们的顺序触发。 通过addEventListener()添加的事件处理程序只能使用removeEventListener()来移除，移除时传入的参数与添加处理程序时使用的参数相同。这也意味着通过addEventListener()添加的匿名函数将无法移除： 123456789101112btn.removeEventListener('click',function () &#123; //没有用 alert(this.id);&#125;,false);-------分割线-------var handle = function () &#123; alert(this.id);&#125;;btn.addEventListener('click', handle, false);btn.removeEventListener('click', handle, false); //有效 大多数情况下，都是将事件处理程序添加到事件流的冒泡阶段，这样可以最大限度地兼容各种浏览器。最好只在需要在事件到达目标之前截获它的时候将事件处理程序添加到捕获阶段。如果不是特别需要，不建议在事件捕获阶段注册事件处理程序。 IE事件处理程序IE实现了与DOM中类似的两个方法：attachEvent()和detachEvent()。这两个方法接受相同的两个参数：事件处理程序名与事件处理程序函数。由于IE8及更早版本只支持事件冒泡，所以通过attachEvent()添加的事件处理程序都会被添加到冒泡阶段。 123btn.attachEvent('onclick', function () &#123; alert('clicked');&#125;); 在IE中使用attachEvent()与使用DOM0级方法的主要区别在于事件处理程序的作用域。在使用DOM0级方法的情况下，事件处理程序会在其所属元素的作用域内运行；在使用attachEvent()方法的情况下，事件处理程序会在全局作用域中运行，因此this等于window。 123btn.attachEvent('onclick', function () &#123; alert(this === window);&#125;); attachEvent()方法也可以用来为一个元素添加多个事件处理程序： 1234567btn.attachEvent('onclick', function () &#123; alert(this === window);&#125;);btn.attachEvent('onclick', function () &#123; alert('hello');&#125;); 不过，与DOM方法不同的是，这些事件处理程序不是以添加它们的顺序执行，而是以相反的顺序被触发。 使用attachEvent()添加的事件可以通过detachEvent()来移除，条件是必须提供相同的参数。与DOM方法一样，这也意味着添加的匿名函数将不能被移除。不过，只要能够将对相同函数的引用传给detachEvent()，就可以移除相应的事件处理程序。 跨浏览器的事件处理程序要保证处理事件的代码能在大多数浏览器下一致地运行，只需要关注冒泡阶段。 第一个要创建的方法是addHandler()，它的职责是视情况分别使用DOM0级方法、DOM2级方法或IE方法来添加事件。addHandler()方法接受3个参数：要操作的元素、事件名称和事件处理程序函数。 与addHandler()对应的方法是removeHandler()，它也接受相同的参数。这个方法的职责是移除之前添加的事件处理程序—无论该事件处理程序是采取什么方式添加到元素中的，如果其他方法无效，默认采用DOM0级方法。 1234567891011121314151617181920212223242526var EventUtil = &#123; addHandler: function (element, type, handler) &#123; if (element.addEventListener)&#123; element.addEventListener(type, handler, false); &#125;else if (element.attachEvent)&#123; element.attachEvent('on'+type, handler); &#125;else &#123; element['on' + type] = handler; &#125; &#125;, removeHandler: function (element, type, handler) &#123; if (element.removeEventListener)&#123; element.removeEventListener(type, handler, false); &#125;else if (element.detachEvent)&#123; element.detachEvent('on' + type, handler); &#125;else &#123; element['on' + type] = null; &#125; &#125;&#125;;var handler = function () &#123; alert('clicked');&#125;;EventUtil.addHandler(btn, 'click', handler);EventUtil.removeHandler(btn, 'click', handler); 事件对象在触发DOM上的某个事件时，会产生一个事件对象event，这个对象中包含着所有与事件有关的信息。包括导致事件的元素、事件的类型以及其他与特定事件相关的信息。 DOM中的事件对象兼容DOM的浏览器会将一个event对象传入到事件处理程序中。无论指定事件处理程序时使用什么方法（DOM0级或DOM2级），都会传入event对象： 1234567btn.onclick = function (event) &#123; alert(event.type); //click&#125;;btn.addEventListener('click', function (event) &#123; alert(event.type); //click&#125;, false); 在通过HTML特性指定事件处理程序时，变量event中保存着event对象： 1&lt;input type="button" value="Click Me" onclick="alert(event.type)"&gt; 以这种方式提供event对象，可以让HTML特性事件处理程序与JavaScript函数执行相同的操作。 event对象包含与创建它的特定事件有关的属性和方法。触发的事件类型不一样，可用的属性和方法也不一样。不过，所有事件都会有下列成员： 在事件处理程序内部，对象this始终等于currentTarget的值，而target则只包含事件的实际目标。如果直接将事件处理程序指定给了目标元素，则this、currentTarget和target包含相同的值： 1234btn.onclick = function (event) &#123; alert(event.currentTarget === this); //true alert(event.target === this); //true&#125;; 由于click事件的目标是按钮，因此this、currentTarget和target这三个值是相等的。如果事件处理程序存在于按钮的父节点中，那么这些值是不相同的： 12345document.body.onclick = function (event) &#123; alert(event.currentTarget === document.body); //true alert(this === document.body); //true alert(event.target === document.getElementById('myBtn')); //true&#125;; 当单击上面例子中的按钮时，this和currentTarget都等于document.body，因为事件处理程序是注册到这个元素上的。然而，target元素却等于按钮元素，因为它是click事件真正的目标。由于按钮上并没有注册事件处理程序，结果click事件就冒泡到了document.body，在那里事件才得到了处理。 在需要通过一个函数处理多个事件时，可以使用type属性： 12345678910111213141516171819var handler = function (event) &#123; switch (event.type)&#123; case 'click': alert('clicked'); break; case 'mouseover': event.target.style.backgroundColor = 'red'; break; case 'mouseout': event.target.style.backgroundColor = ' '; break; &#125;&#125;;btn.onclick = handler;btn.onmousemove = handler;btn.onmouseout = handler; 这里通过检测event.type属性，让函数能够确定发生了什么事件，并执行相应的操作。 要阻止特定事件的默认行为，可以使用preventDefault()方法。例如，链接的默认行为就是在被单击时会被导航到其href特性指定的URL。如果想阻止链接导航这一默认行为，可以通过链接的onclick事件处理程序取消它： 1234var link = document.getElementById('myLink');link.onclick = function (event) &#123; event.preventDefault();&#125;; 只有cancelable属性设置为true的事件，才可以使用preventDefault()来取消其默认行为。 stopPropagation()方法用于立即停止事件在DOM层次中的传播，即取消进一步的事件捕获或冒泡。 12345678btn.onclick = function (event) &#123; alert('clicked'); event.stopPropagation();&#125;;document.body.onclick = function (event) &#123; alert('body clicked');&#125;; 上面例子如果不调用stopPropagation()，就会在单击按钮时出现两个警告框。可是，由于click事件根本不会传播到document.body，因此就不会触发注册在这个元素上的onclick事件处理程序。 事件对象的eventPhase属性可以用来确定事件当前正位于事件流的哪个阶段。如果是在捕获阶段调用的事件处理程序，那么eventPhase等于1；如果事件处理程序处于目标对象上，则eventPhase等于2；如果是在冒泡阶段调用的事件处理程序，eventPhase等于3。要注意的是，尽管处于目标发生在冒泡阶段，但eventPhase仍然一直等于2。 123456789btn.onclick = function (event) &#123; alert(event.eventPhase); //2&#125;;document.body.addEventListener('click', function (event) &#123; alert(event.eventPhase); //1&#125;,true);document.body.onclick = function (event) &#123; alert(event.eventPhase); //3&#125;; 只有在事件处理程序执行期间，event对象才会存在，一旦事件处理程序执行完成，event对象就会被销毁。 IE中的事件对象与访问DOM中的event对象不同，要访问IE中的event对象有几种不同的方式，取决于指定事件处理程序的方法。在使用DOM0级方法添加事件处理程序时，event对象作为window对象的一个属性存在： 1234btn.onclick = function () &#123; var event = window.event; alert(event.type); //'click'&#125; 如果事件处理程序是使用attachEvent()添加的，那么就会有一个event对象作为参数被传入事件处理程序函数中： 123btn.attachEvent('onclick', function (event) &#123; alert(event.type); //'click'&#125;); 如果是通过HTML特性指定的事件处理程序，那么还可以通过一个名叫event的变量来访问event对象（与DOM中的事件模型相同）。 IE的event对象也同样包含与创建它的事件相关的属性和方法。所有事件对象都包含下列属性和方法： 因为事件处理程序的作用域是根据指定它的方式来确定，所以不能认为this会始终等于事件目标。最好使用event.srcElement： 1234567btn.onclick = function () &#123; alert(window.event.srcElement === this); //true&#125;;btn.attachEvent('onclick', function (event) &#123; alert(event.srcElement === this); //false(在使用attachEvent()方法的情况下，事件处理程序会在全局作用域中运行，因此this等于window)&#125;); returnValue属性相当于DOM中的preventDefault()方法，它们的作用都是取消给定事件的默认行为。只要将returnValue设置为false，就可以阻止默认行为： 123link.onclick = function () &#123; window.event.returnValue = false;&#125;; cancelBubble属性与DOM中的stopPropagation()方法作用相同，都是用来停止事件冒泡的。由于IE不支持事件捕获，因此只能取消事件冒泡；但stopPropagation()可以同时取消事件捕获和冒泡： 12345678btn.onclick = function () &#123; alert('clicked'); window.event.cancelBubble = true;&#125;;document.body.onclick = function () &#123; alert('body clicked');&#125;; 跨浏览器的事件对象123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960var EventUtil = &#123; addHandler: function (element, type, handler) &#123; if (element.addEventListener)&#123; element.addEventListener(type, handler, false); &#125;else if (element.attachEvent)&#123; element.attachEvent('on'+type, handler); &#125;else &#123; element['on' + type] = handler; &#125; &#125;, removeHandler: function (element, type, handler) &#123; if (element.removeEventListener)&#123; element.removeEventListener(type, handler, false); &#125;else if (element.detachEvent)&#123; element.detachEvent('on' + type, handler); &#125;else &#123; element['on' + type] = null; &#125; &#125;, getEvent: function (event) &#123; return event?event : window.event; &#125;, getTarget: function (event) &#123; return event.target || event.srcElement; &#125;, preventDefault: function (event) &#123; if (event.preventDefault)&#123; event.preventDefault(); &#125;else &#123; event.returnValue = false; &#125; &#125;, stopPropagation: function (event) &#123; if (event.stopPropagation)&#123; event.stopPropagation(); &#125;else &#123; event.cancelBubble = true; &#125; &#125;&#125;;btn.onclick = function (event) &#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); EventUtil.stopPropagation(event);&#125;;link.onclick = function (event) &#123; event = EventUtil.getEvent(event); EventUtil.preventDefault(event);&#125;;document.body.onclick = function (event) &#123; alert('body clicked'); &#125;; 事件类型DOM3级事件规定了下列几类事件： UI（User Interface，用户界面）事件，当用户与页面上的元素交互时触发 焦点事件，当元素获得或失去焦点时触发 鼠标事件，当用户通过鼠标在页面上执行操作时触发 滚轮事件，当使用鼠标滚轮时触发 文本事件，当在文档中输入文本时触发 键盘事件，当用户通过键盘在页面上执行操作时触发 合成事件，当为IME（Input Method Editor，输入法编辑器）输入字符时触发 变动事件，当底层DOM结构发生变化时触发 变动名称事件，当元素或属性名变动时触发。此类事件已经被废弃，没有任何浏览器实现它们 除了这几类事件之外，HTML5页定义了一组事件，而有些浏览器还会在DOM和BOM中实现其他专有事件。这些专有事件一般都是根据开发人员需求定制的，没有什么规范，因此不同浏览器的实现可能不一致。 DOM3级事件模块在DOM2级事件模块基础上重新定义了这些事件，也添加了一些新事件。包括IE9在内的所有主流浏览器都支持DOM2级事件。IE9也支持DOM3级事件。 UI事件UI事件事件指的是那些不一定与用户操作有关的事件。这些事件在DOM规范出现之前，都是以这种或那种形式存在的，而在DOM规范中保留是为了向后兼容。现有的UI事件如下： DOMActive：表示元素已经被用户操作激活。这个事件再DOM3级事件中被废弃。 load：当页面完全加载后在window上面触发，当所有框架都加载完毕时在框架上面触发，当图像加载完毕时在&lt;img&gt;元素上面触发，或者当嵌入的内容加载完毕时在&lt;object&gt;元素上面触发。 unload：当页面完全卸载后在window上面触发，当所有框架都卸载后在框架集上面触发，或者当嵌入的内容卸载完毕后在&lt;object&gt;元素上面触发。 abort：在用户停止下载过程时，如果嵌入的内容没有加载完，则在&lt;object&gt;元素上面触发。 error：当发生JavaScript错误时在window上面触发，当无法加载图像时在&lt;img&gt;元素上面触发，当无法加载嵌入内容时在&lt;object&gt;元素上面触发，或者当有一或多个框架无法加载时在框架集上面触发。 select：当用户选择文本框中一或多个字符时触发。 resize：当窗口或框架的大小变化时在window或框架上面触发。 scroll：当用户滚动带滚动条的元素中的内容，在该元素上面触发。&lt;body&gt;元素中包含所加载页面的滚动条。 多数这些事件都与window对象或表单控件相关。 除了DOMActive之外，其他事件在DOM2级事件中都归为HTML事件。 load事件JavaScript中最常用的一个事件就是load。当页面完全加载后，就会触发window上面的load事件。有两种定义onload事件处理程序的方式。第一种方式是使用如下所示的JavaScript代码： 123EventUtil.addHandler(window, 'load', function (event) &#123; alert('loaded');&#125;); 这里也给事件处理程序传入了一个event对象。这个event对象不包含有关这个事件的任何附加信息，但在兼容DOM的浏览器中，event.target属性的值会被设置为document，而IE并不会为这个事件设置srcElement属性。 第二种方式是为&lt;body&gt;元素添加一个onload特性： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body onload="alert('loaded')"&gt;&lt;/body&gt;&lt;/html&gt; 一般来说，在window上面发生的任何事件都可以在&lt;body&gt;元素中通过相应的特性来指定，因为在HTML中无法访问window元素。但这只是为了保证向后兼容的权宜之计。建议尽可能使用JavaScript方式。 图像上面也可以触发load事件，无论是在DOM中的图像元素还是HTML中的图像元素。可以在HTML中为任何图像指定onload事件处理程序： 1&lt;img src="smile.gif" alt="img" onload="alert('image loaded')"&gt; 用JavaScript来实现： 12345var image = document.getElementById('myImage');EventUtil.addHandler(image, 'load', function (event) &#123; event = EventUtil.getEvent(event); alert(EventUtil.getTarget(event).src);&#125;); 在创建新的&lt;img&gt;元素时，可以为其指定一个事件处理程序，以便图像加载完毕后给出提示。此时，最重要的是要在指定src属性之前先指定事件： 123456789EventUtil.addHandler(window, 'load', function () &#123; var image = document.getElementById('img'); EventUtil.addHandler(image, 'load', function (event) &#123; event = EventUtil.getEvent(event); alert(EventUtil.getTarget(event).src); &#125;); document.body.appendChild(image); image.src = 'smile.gif';&#125;); 在上面例子中，首先为window指定了onload事件处理程序。原因是想向DOM中添加一个新元素，所以必须确定页面已经加载完毕，如果在页面加载前操作document.body会导致错误。 新图像元素不一定要从添加到文档后才开始下载，只要设置了src属性就会开始下载。 同样的功能也可以通过使用DOM0级的Image对象实现，在DOM出现之前，开发人员经常使用Image对象在客户端预先加载图像。可以像使用&lt;img&gt;元素一样使用Image对象，只不过无法将其添加到DOM树中： 1234567EventUtil.addHandler(window, 'load', function () &#123; var image = new Image(); EventUtil.addHandler(image, 'load', function (event) &#123; alert('Image loaded'); &#125;); image.src = 'smile.gif';&#125;); 还有一些元素也以非标准的方式支持load事件。在IE9+、Firefox、Opera、Chrome和Safari3+中，&lt;script&gt;元素也会被触发load事件，以便开发人员确定动态加载的JavaScript文件是否加载完毕。与图像不同，只有在设置了&lt;script&gt;元素的src属性并将该元素添加到文档后，才会开始下载JavaScript文件。对&lt;script&gt;元素而言，指定src属性和指定事件处理程序的先后顺序就不重要了： 12345678EventUtil.addHandler(window, 'load', function () &#123; var script = document.createElement('script'); EventUtil.addHandler(script, 'load', function (event) &#123; alert('loaded'); &#125;); script.src = 'example.js'; document.body.appendChild(script);&#125;); unload事件unload事件再文档被完全卸载后触发。只要用户从一个页面切换到另一个页面，就会发生unload事件。而利用这个事件最多的情况是清除引用，以免内存泄露。与load事件类似，也有两种指定onunload事件处理程序的方式。第一种方式是使用JavaScript： 123EventUtil.addHandler(window, 'unload', function (event) &#123; alert('unloaded');&#125;); 此时生成的event对象在兼容DOM的浏览器中只包含target属性（值为document）。 第二种方式是为&lt;body&gt;元素添加一个特写： 123456789&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body onunload="alert('Unloaded！')"&gt;&lt;/body&gt;&lt;/html&gt; unload事件是在一切都被卸载之后才触发，那么在页面加载后存在的那些对象，就不一定存在了，此时操作DOM节点或元素的样式就会导致错误。 resize事件当浏览器窗口被调整到一个新的高度或宽度时，就会触发resize事件。这个事件在window上触发，因此可以通过JavaScript或者&lt;body&gt;元素中的onresize特性来指定事件处理程序： 123EventUtil.addHandler(window, 'resize', function (event) &#123; alert('Resized');&#125;); 与其他发生在window上的事件类似，在兼容DOM的浏览器中，传入事件处理程序中的event对象有一个target属性，值为document。 关于何时会触发resize事件，不同浏览器有不同的机制。IE、Safari、Chrome和Opera会在浏览器窗口变化了1像素时就触发resize事件，然后随着变化不断重复触发。Firefox则只会在用户停止调整窗口大小时才会触发resize事件。由于存在这个差别，应该注意不要在这个事件的处理程序中加入大计算量的代码，因为这些代码可能被频繁执行，从而导致浏览器反应明显变慢。 scroll事件虽然scroll事件是在window对象上发生的，但它实际表示的则是页面中相应元素的变化。在混杂模式下，可以通过&lt;body&gt;元素的scrollLeft和scrollTop来监控到这一变化；而在标准模式下，除Safari之外的所有浏览器都会通过&lt;html&gt;元素来反映这一变化： 123456789EventUtil.addHandler(window, 'scroll', function (event) &#123; if (document.compatMode == 'CSS1Compat')&#123; alert(document.documentElement.scrollTop); &#125;else &#123; alert(document.body.scrollTop); &#125;&#125;);EventUtil.addHandler(window, 'resize', function (event) &#123; alert('Resized');&#125;); 与resize事件类似，scroll事件也会在文档被滚动期间重复被触发，所以有必要尽量保持事件处理程序的代码简单。 scroll事件只要页面滚动就触发，包括鼠标滚动引起的、键盘方向键引起的滚动以及拖动滚动条引起的 焦点事件焦点事件会在页面获得或失去焦点时触发。利用这些事件并与document.hasFocus()方法及document.activeElement属性配合，可以知晓用户在页面上的行踪。有以下6个焦点事件： blur：在元素失去焦点时触发。这个事件不会冒泡；所有浏览器都支持它。 DOMFocusIn：在元素获得焦点时触发。这个事件与HTML事件focus等价，但它冒泡。只有Opera支持这个事件。DOM3级事件废弃了DOMFocusIn，选择了focusin。 DOMFocusOut：在元素失去焦点时触发。这个事件是HTML事件blur的通用版本。只有Opera支持这个事件。DOM3级事件废弃了DOMFocusOut，选择了focusout。 focus：在元素获得焦点时触发。这个事件不会冒泡；所有浏览器都支持它。 focusin：在元素获得焦点时触发。这个事件与HTML事件focus等价，但它冒泡。支持这个事件的浏览器有IE5.5+、Safari5.1+、Opera11.5+和Chrome。 focusout：在元素失去焦点时触发。这个事件是HTML事件blur的通用版本。支持这个事件的浏览器有IE5.5+、Safari5.1+、Opera11.5+和Chrome。 这一类事件中最主要的两个是focus和blur，它们都是JavaScript早期就得到所有浏览器支持的事件。这些事件的最大问题是它们不冒泡。 当焦点从页面中的一个元素移动到另一个元素，会依次触发下列事件： focusout：在失去焦点的元素上触发 focusin：在获得焦点的元素上触发 blur：在失去焦点的元素上触发 DOMFocusOut：在失去焦点的元素上触发 focus：在获得焦点的元素上触发 DOMFocusIn：在获得焦点的元素上触发 其中，blur、DOMFocusOut和focusout的事件目标是失去焦点的元素；而focus、DOMFocusIn和focusin的事件目标是获得焦点的元素。 鼠标与滚轮事件DOM3级事件中定义了9个鼠标事件： click：在用户单击主鼠标按钮（一般是左键）或者按下回车键时触发。这一点对确保易访问性很重要，意味着onclick事件处理程序既可以通过键盘也可以通过鼠标执行。 dblclick：在用户双击主鼠标按钮（一般是左键）时触发。 mousedown：在用户按下任意鼠标按钮时触发。不能通过键盘触发这个事件。 mouseenter：在鼠标光标从元素外部首次移动到元素范围之内时触发。这个事件不冒泡，而且在光标移动到后代元素上不会触发。 mouseleave：在位于元素上方的鼠标光标移动到元素范围之外时触发。这个事件不冒泡，而且在光标移动到后代元素上不会触发。 mousemove：当鼠标指针在元素内部移动时重复地触发。不能通过键盘触发这个事件。 mouseout：在鼠标指针位于一个元素上方，然后用户将其移入另一个元素时触发。又移入的另一个元素可能位于前一个元素的外部，也可能是这个元素的子元素。不能通过键盘触发这个事件。 mouseover：在鼠标指针位于一个元素外部，然后用户将其首次移入另一个元素边界之内时触发。不能通过键盘触发这个事件。 mouseup：在用户释放鼠标按钮时触发。不能通过键盘触发这个事件。 只有在同一个元素上相继触发mousedown和mouseup事件，才会触发click事件；如果mousedown或mouseup中的一个被取消，就不会触发click事件。类似地，只有触发两次click事件，才会触发一次dblclick事件。这4个事件触发的顺序始终如下： mousedown mouseup click mousedown mouseup click dblclcik 鼠标事件中还有一类滚轮事件。而说是一类事件，其实就是一个mousewheel事件。这个事件跟踪鼠标滚轮。 客户区坐标位置鼠标事件都是在浏览器视口中的特定位置上发生的。这个位置信息保存在事件对象的clientX和clientY属性中。所有浏览器都支持这个属性，它们的值表示事件发生时鼠标指针在视口中（整个浏览器窗口中）的水平和垂直坐标。 可以使用下面代码获取鼠标事件的客户端坐标信息： 12345var div = document.getElementById('myDiv');EventUtil.addHandler(div, 'click', function (event) &#123; event = EventUtil.getEvent(event); alert('client coordinates: ' + event.clientX + ', ' + event.clientY);&#125;); 这些值不包括页面滚动的距离，因此这个位置并不表示鼠标在页面上的位置。 页面坐标位置通过客户区坐标能够知道鼠标是在视口中什么位置发生的，而页面坐标通过事件对象的pageX和pageY属性，能告诉你事件是在页面中的什么位置发生的。这两个属性表示鼠标光标在页面中的位置，因此坐标是从页面本身而非视口的左边和顶边计算的： 1234EventUtil.addHandler(div, 'click', function (event) &#123; event = EventUtil.getEvent(event); alert('page coordinates: ' + event.pageX + ', ' + event.pageY);&#125;); 在页面没有滚动的情况下，pageX和pageY的值与clientX和clientY的值相等。 屏幕坐标位置鼠标事件发生时，不仅会有相对于浏览器窗口的位置，还有一个相对于整个电脑屏幕的位置。通过screenX和screenY属性就可以确定鼠标事件发生时鼠标指针相对于整个屏幕的坐标信息： 1234EventUtil.addHandler(div, 'click', function (event) &#123; event = EventUtil.getEvent(event); alert('screen coordinates: ' + event.screenX + ', ' + event.screenY);&#125;); 修改键虽然鼠标事件主要是使用鼠标来触发的，但在按下鼠标时键盘上的某些键的状态也可以影响到说要采取的操作。这些修改键就是shift、ctrl、alt和meta（Windows中是windows键，在mac中是cmd键），它们经常被用来修改鼠标事件的行为。DOM为此规定了4个属性，表示这些修改键的状态：shiftKey、ctrlKey、altKey和metaKey。这些属性中包含的都是布尔值，如果相应的键被按下了，则值为true，否则为false。当某个鼠标事件发生时，通过检测这几个属性就可以确定用户是否同时按下了其中的键： 12345678910111213141516171819202122EventUtil.addHandler(div, 'click', function (event) &#123; event = EventUtil.getEvent(event); var keys = new Array(); if (event.shiftKey)&#123; keys.push('shift'); &#125; if (event.ctrlKey)&#123; keys.push('ctrl'); &#125; if (event.altKey)&#123; keys.push('alt'); &#125; if (event.metaKey)&#123; keys.push('meta'); &#125; alert('keys: ' + keys.join(','));&#125;); 相关元素在发生mouseover和mouseout事件时，还会涉及更多的元素。这两个事件都会涉及把鼠标指针从一个元素的边界之内移动到另一个元素的边界之内。对mouseover事件而言，事件的主目标是获得光标的元素，而相关元素就是那个失去光标的元素。对mouseout事件而言，事件的主目标是失去光标的元素，而相关元素则是获得光标的元素： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="myDiv" style="background-color: red; height: 100px;width: 100px"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 上面例子中，如果鼠标指针一开始位于&lt;div&gt;元素上，然后移出了这个元素，那么就会在&lt;div&gt;元素上触发mouseout事件，相关元素就是&lt;body&gt;元素。与此同时，&lt;body&gt;元素上面会触发mouseover事件，而相关元素就变成了&lt;div&gt;。 DOM通过event对象的relatedTarget属性提供了相关元素的信息。这个属性只对于mouseover和mouseout事件才包含值；对于其他事件，这个属性的值是null。 12345678910111213141516171819202122var EventUtil = &#123; //其他代码 getRelatedTarget: function (event) &#123; if (event.relatedTarget)&#123; return event.relatedTarget; &#125;else if (event.toElement)&#123; return event.toElement; &#125;else if (event.fromElement)&#123; return event.fromElement; &#125;else &#123; return null; &#125; &#125;&#125;;EventUtil.addHandler(div, 'mouseout', function (event) &#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); var relatedTarget = EventUtil.getRelatedTarget(event); alert('moused out of ' + target.tagName + ' to ' + relatedTarget.tagName);&#125;); 鼠标按钮只要在主鼠标按钮被单击（或键盘回车键被按下）时才会触发click事件，因此检测按钮的信息并不是必要的。但对于mousedown和mouseup事件来说，则在其event对象存在一个button属性，表示按下或释放的按钮。DOM的button属性可能有如下3个值：0表示主鼠标按钮，1表示中间鼠标按钮，2表示次鼠标按钮。在常规设置中，主鼠标按钮是左键，次鼠标按钮是右键。 更多的事件信息DOM2级事件规范在event对象中还提供了detail属性，用于给出有关事件的更多信息。对于鼠标事件来说，detail中包含了一个数值，表示在给定位置上发生了多少次单击。在同一个像素上相继地发生一次mousedown和一次mouseup事件算作一次单击。detail属性从1开始计数，每次单击后都会递增。如果鼠标在mousedown和mouseup之间移动了位置，则detail会被重置为0. IE也通过下列属性为鼠标事件提供了更多信息： altLeft：布尔值，表示是否按下了Alt键。如果altLeft值为true，altKey的值也为true。 ctrlLeft：布尔值，表示是否按下了Ctrl键。如果ctrlLeft的值为true，则ctrlKey的值为true。 offsetX：光标相对于目标元素边界的X坐标。 offsetY：光标相对于目标元素边界的Y坐标。 shiftLeft：布尔值，表示是否按下了Shift。如果shiftLeft的值为true，则shiftKey的值为true。 这个属性的用处并不大。 鼠标滚轮事件当用户通过鼠标滚轮与页面交互、在垂直方向上滚动页面时，就会触发mousewheel事件。这个事件可以在任何元素上面触发，最终会冒泡到document或window对象。与mousewheel事件对应的event对象除包含鼠标事件的所有标准信息外，还包含一个特殊的wheelDelta属性。当用户向前滚动鼠标滚轮时，wheelDelta是120的倍数；当用户向后滚动鼠标滚轮时，wheelDelta是-120的倍数。 将mousewheel事件处理程序指定给页面中的任何元素或document对象，既可处理鼠标滚轮的交互操作： 1234EventUtil.addHandler(document, 'mousewheel', function (event) &#123; event = EventUtil.getEvent(event); alert(event.wheelDelta);&#125;); Firefox支持一个名为DOMMouseScroll的类似事件，也是在鼠标滚轮滚动时触发。与mousewheel事件一样，DOMMouseScroll也被视为鼠标事件，因而包含与鼠标事件有关的所有属性。而有关鼠标滚轮的信息则保存在detail属性中，当向前滚动鼠标滚轮时，这个属性的值-3的倍数，当向后滚动鼠标滚轮时，这个属性的值是3的倍数。 可以将DOMMouseScroll事件添加到页面中的任何元素，而且该事件会冒泡到window对象。 下面给出了跨浏览器下的解决方案： 1234567891011var EventUtil = &#123; //其他代码 getWheelDelta: function (event) &#123; if (event.wheelDelta)&#123; return (client.engine.opera &amp;&amp; client.engine.opera &lt; 9.5? -event.wheelDelta : event.wheelDelta); &#125;else &#123; return -event.detail * 40; &#125; &#125;&#125;; 12345678910(function () &#123; function handleMouseWheel(event) &#123; event = EventUtil.getEvent(event); var delta = EventUtil.getWheelDelta(event); alert(delta); &#125; EventUtil.addHandler(document, 'mousewheel', handleMouseWheel); EventUtil.addHandler(document, 'DOMMouseScroll', handleMouseWheel);&#125;)(); 触摸设备在面向iPhone和iPod中的Safari开发时，要注意以下几点： 不支持dblclick事件。双击浏览器窗口会放大画面，而且没有办法改变该行为 轻击可单击元素会触发mousemove事件。如果此操作会导致内容变化，将不再有其他事件发生；如果屏幕没有因此变化，那么会依次发生mousedown、mouseup和click事件。轻击不可单击的元素不会触发任何事件。可单击的元素是指那些单击可产生默认操作的元素，或者那些已经被指定了onclick事件处理程序的元素 mousemove事件也会触发mouseover和mouseout事件 两个手指放在屏幕上且页面随手指移动而滚动时会触发mousewheel和scroll事件 无障碍性问题如果你的Web应用程序或网站要确保残疾人特别是那些使用屏幕阅读器的人都能访问，那么在使用鼠标事件时就要格外小心。前面提到过，可以通过键盘的回车键来触发click事件，但其他鼠标事件却无法通过键盘来触发，为此，不建议使用click之外的其他鼠标事件来展示功能或引发代码执行。 以下是在使用鼠标事件时应该注意的几个易访问性问题： 使用click事件执行代码。有人指出通过onmousedown执行代码会让人觉得速度更快，但是，在屏幕阅读器中，由于无法触发mousedown事件，结果就会造成代码无法执行 不要使用onmouseover向用户显示新的选项。 不要使用dblclick执行重要操作 键盘与文本事件有3个键盘事件： keydown：当用户按下键盘上的任意键时触发，而且如果按住不放的话，会重复触发此事件 keypress：当用户按下键盘上的字符键时触发，而且如果按住不放的话，会重复触发此事件。按下Esc键也会触发这个事件。 keyup：当用户释放键盘上的键时触发 只有一个文本事件：textInput。这个事件是对keypress的补充，用意是在将文本显示给用户之前更容易拦截文本。在文本插入文本框之前会触发textInput事件。 在用户按下了键盘上的字符键时，首先会触发keydown事件，然后紧跟着是keypress事件，最后会触发keyup事件。其中keydown和keypress都是在文本框发生变化之前被触发的；而keyup则是在文本框已经发生变化之后被触发的。 如果用户按下的是一个非字符键，那么首先会触发keydown事件，然后是keyup事件。 键码在发生keydown和keyup事件时，event对象的keyCode属性中会包含一个代码，与键盘上一个特定的键对应。对数字字母字符键，keyCode属性的值与ASCII码中对应小写字母或数字的编码相同。因此，数字键7的keyCode值为55，而字母A键的keyCode值为65—与shift键的状态无关。DOM和IE的event对象都支持keyCode属性。 12345var textbox = document.getElementById('myText');EventUtil.addHandler(textbox, 'keyup', function (event) &#123; event = EventUtil.getEvent(event); alert(event.keyCode);&#125;); 下面列出了所有非字符键的键码： 在Firefox和Opera中，按分号键时keyCode值为59，也就是ASCII中分号的编码；但IE和Safari返回186，即键盘中按键的键码。 字符编码发生keypress事件意味着按下的键会影响到屏幕中文本的显示。在所有浏览器中，按下能够插入或删除字符的键都会触发keypress事件；按下其他键能否触发此事件因浏览器而异。 IE9、Firefox、Chrome和Safari的event对象都支持一个charCode属性，这个属性只有在发生keypress事件时才包含值，而且这个值是按下的那个键所代表字符的ASCII编码。此时的keyCode通常等于0或者也可能等于所按键的键码。 12345678910111213141516var EventUtil = &#123; //其他代码 getCharCode: function (event) &#123; if (typeof event.charCode == 'number')&#123; return event.charCode; &#125;else &#123; return event.keyCode; &#125; &#125;&#125;;EventUtil.addHandler(textbox, 'keypress', function (event) &#123; event = EventUtil.getEvent(event); alert(EventUtil.getCharCode(event));&#125;); 在取得字符编码后，就可以使用String.fromCharCode()将其转换成实际的字符。 DOM3级变化DOM3级事件中的键盘事件不再包含charCode属性，而是包含了两个新属性：key和char。 其中，key属性是为了取代keyCode而增加的，它的值是一个字符串。在按下某个字符键时，key的值就是相应的文本字符；在按下非字符键时，key的值是相应键的名。而char属性在按下字符键时的行为与key相同，但在按下非字符键时值为null。 IE9支持key属性，但不支持char属性。Safari5和Chrome支持名为keyIndentifier的属性，在按下非字符键的情况下与key的值相同。对于字符键，keyIndentifier返回一个格式类似U+0000的字符串，表示Unicode值。 1234567EventUtil.addHandler(textbox, 'keypress', function (event) &#123; event = EventUtil.getEvent(event); var identifier = event.key || event.keyIdentifier; if (identifier)&#123; alert(identifier); &#125;&#125;); DOM3级事件还添加了一个名为location的属性，这是一个数值，表示按下了什么位置上的键：0表示默认键盘，1表示左侧位置（如左边的Alt键），2表示右侧位置（如右侧的shift键），3表示数字小键盘，4表示移动设备键盘，5表示手柄。IE9支持这个属性。Safari和Chrome支持名为keyLocation的等价属性，但既有bug—值始终是0，除非按下了数字键盘，否则，不会是1、2、4、5。 1234567EventUtil.addHandler(textbox, 'keypress', function (event) &#123; event = EventUtil.getEvent(event); var loc = event.location || event.keyLocation; if (loc)&#123; alert(loc); &#125;&#125;); 最后是给event对象添加了getModifierState()方法。这个方法接受一个参数，即等于Shift、Control、AltGraph或Meta的字符串，表示要检测的修改键。如果指定的修改键是活动的（也就是处于被按下的状态），这个方法返回true，否则返回false。 123456EventUtil.addHandler(textbox, 'keypress', function (event) &#123; event = EventUtil.getEvent(event); if (event.getModifierState)&#123; alert(event.getModifierState('Shift')); &#125;&#125;); textInput事件DOM3级事件规范中引入了一个新事件，叫textInput。根据规范，当用户在可以编辑区域中输入字符时，就会触发这个事件。这个用于替代keypress的textInput事件的行为稍有不同。区别之一就是任何可以获得焦点的元素都可以触发keypress事件，但只有可编辑区域才能触发textInput。区别之二是textInput事件只会在用户按下能够输入实际字符的键时才会被触发，而keypress事件则在按下那些能够影响文本显示的键时也会触发（如退格键）。 由于textInput事件主要考虑的是字符，因此它的event对象中包含一个data属性，这个属性的值就是用户输入的字符。 1234EventUtil.addHandler(textbox, 'textInput', function (event) &#123; event = EventUtil.getEvent(event); alert(event.data);&#125;); 另外，event对象上还有一个inputMethod属性，表示把文本输入到文本框中的方式： 复合事件复合事件是DOM3级事件中新添加的一类事件，用于处理IME的输入序列。IME（Input Method Editor，输入法编辑器）可以让用户输入在物理键盘上找不到的字符。IME通常需要同时按住多个键，但最终只输入一个字符。复合事件就是针对检测和处理这种输入而设计的。有下列三种复合事件： compositionstart：在IME的文本复合系统打开时触发，表示要开始输入了 compositionupdate：在向输入字段中插入新字符时触发 compositionend：在IME的文本复合系统关闭时触发，表示返回正常键盘输入状态 复合事件与文本事件再很多方面都很相似。在触发复合事件时，目标是接收文本的输入字段。但它比文本事件的事件对象多一个data属性，这个属性包含下列值中的一个： 如果在compositionstart事件发生时访问，包含正在编辑的文本 如果在compositionupdate事件发生时访问，包含正插入的新字符 如果在compositionend事件发生时访问，包含此次输入会话中插入的所有字符 变动事件DOM2级的变动（mutation）事件能在DOM中的某一部分发生变化时给出提示。变动事件是为XML或HTML DOM设计的，并不特定于某种语言。DOM2级定义了下列变动事件： DOMSubtreeModified：在DOM结构中发生任何变化时触发。这个事件在其他任何事件触发后都会触发 DOMNodeInserted：在一个节点作为子节点被插入到另一个节点中时触发 DOMNodeRemoved：在节点从其父节点中被移除时触发 DOMNodeInsertedIntoDocument：在一个节点被直接插入文档或通过子树间接插入文档后触发。这个事件再DOMNodeInserted之后触发 DOMNodeRemovedFromDocument在一个节点被直接从文档中移除或通过子树间接从文档中移除之前触发。这个事件在DOMNodeRemoved之后触发 DOMAttrModified：在特性被修改之后触发 DOMCharacterDataModified：在文本节点的值发生变化时触发 由于DOM3级事件模块作废了很多变动事件，所以只介绍那些将来仍会得到支持的事件。 删除节点在使用removeChild()或replaceChild()从DOM中删除节点时，首先会触发DOMNodeRemoved事件。这个事件的目标（event.target）是被删除的节点，而event.relatedNode属性中包含着对目标节点父节点的引用。在这个事件触发时，节点尚未从其父节点删除，因此其parentNode属性仍然指向父节点（与event.relatedNode相同）。这个事件会冒泡，因而可以在DOM的任何层次上面处理它。 如果被移除的节点包含子节点，那么在其所有子节点以及这个被移除的节点上会相继触发DOMNodeRemovedFromDocument事件。但这个事件不会冒泡，所以只有直接指定给其中一个子节点的事件处理程序才会被调用。这个事件的目标是相应的子节点或者那个被移除的节点，除此之外event对象中不包含信息。 DOMSubtreeModified事件的目标是被移除节点的父节点；此时的event对象也不会提供与事件相关的其他信息。 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul id="myList"&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;li&gt;Item 3&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 在这个例子中，假设要移除&lt;ul&gt;元素。此时，就会依次触发以下事件： 在&lt;ul&gt;元素上触发DOMNodeRemoved事件，relatedNode属性等于document.body 在&lt;ul&gt;元素上触发DOMNodeRemovedFromDocument事件 在身为&lt;ul&gt;元素子节点的每个&lt;li&gt;元素及文本节点上触发DOMNodeRemovedFromDocument事件 在document.body上触发DOMSubtreeModified事件，因为&lt;ul&gt;是document.body的直接子元素 运行下列代码可以验证上面事件发生的顺序： 123456789101112131415161718192021EventUtil.addHandler(window, 'load', function (event) &#123; var list = document.getElementById('myList'); EventUtil.addHandler(document, 'DOMSubtreeModified', function (event) &#123; alert(event.type); alert(event.target); &#125;); EventUtil.addHandler(document, 'DOMNodeRemoved', function (event) &#123; alert(event.type); alert(event.target); alert(event.relatedNode); &#125;); EventUtil.addHandler(list.firstChild, 'DOMNodeRemovedFromDocument', function (event) &#123; alert(event.type); alert(event.target); &#125;); list.parentNode.removeChild(list);&#125;); 插入节点在使用appendChild()、replaceChild()或insertBefore()向DOM中插入节点时，首先会触发DOMNodeInsert事件。这个事件的目标是被插入的节点，而event.relatedNode属性中包含一个对父节点的引用。在这个事件触发时，节点已经被插入到了新的父节点中。这个事件是冒泡的，因此可以在DOM的各个层次上处理它。 紧接着，会在新插入的节点上面触发DOMNodeInsertedIntoDocument事件。这个事件不冒泡，因此必须在插入节点之前为它添加这个事件处理程序。这个事件的目标是被插入的节点，除此之外event对象中不包含其他信息。 最后触发的事件是DOMSubtreeModified，触发于新插入节点的父节点。 可以通过下面代码验证上述事件的触发顺序： 1234567891011121314151617181920212223EventUtil.addHandler(window, 'load', function (event) &#123; var list = document.getElementById('myList'); var item = document.createElement('li'); item.appendChild(document.createTextNode('Item 4')); EventUtil.addHandler(document, 'DOMSubtreeModified', function (event) &#123; alert(event.type); alert(event.target); &#125;); EventUtil.addHandler(document, 'DOMNodeInsert', function (event) &#123; alert(event.type); alert(event.target); alert(event.relatedNode); &#125;); EventUtil.addHandler(list.firstChild, 'DOMNodeInsertedIntoDocument', function (event) &#123; alert(event.type); alert(event.target); &#125;); list.parentNode.removeChild(item);&#125;); HTML5事件contextmenu事件通过单击鼠标右键可以调出上下文菜单。为了实现上下文菜单，开发人员面临的主要问题是如何确定应该显示上下文菜单，以及如何屏蔽与该操作关联的默认上下文菜单。为解决这个问题，就出现了contextmenu事件，用以表示何时应该显示上下文菜单，以便开发人员取消默认的上下文菜单而提供自定义的菜单。 123456&lt;div id="myDiv"&gt;Right click or Ctrl+click me to get a custom context menu&lt;/div&gt;&lt;ul id="myMenu" style="position: absolute; visibility: hidden;background-color: silver"&gt; &lt;li&gt;&lt;a href="http://tc9011.com"&gt;tc9011&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://baidu.com"&gt;baidu&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://www.qq.com"&gt;qq&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 12345678910111213141516171819EventUtil.addHandler(window, 'load', function (event) &#123; var div = document.getElementById('myDiv'); EventUtil.addHandler(div, 'contextmenu', function (event) &#123; event = EventUtil.getEvent(event); EventUtil.preventDefault(event); var menu = document.getElementById('myMenu'); //确定放置&lt;ul&gt;的位置 menu.style.left = event.clientX + 'px'; menu.style.top = event.clientY + 'px'; menu.style.visibility = 'visible'; &#125;); //以便通过单击隐藏菜单 EventUtil.addHandler(document, 'click', function (event) &#123; document.getElementById('myMenu').style.visibility = 'hidden'; &#125;);&#125;); beforeunload事件之所以有发生在window对象上的beforeunload事件，是为了让开发人员有可能在页面卸载前阻止这一操作。这个事件会在浏览器卸载页面之前触发，可以通过它来取消卸载并继续使用原有页面。但是，不能彻底取消这个事件，因为这就相当于让用户无法离开当前页面了。为此，这个事件的意图是将控制权交给用户。显示的消息会告诉用户页面将被卸载，询问用户是否要真的关闭页面，还是希望继续留下来。 为了显示这个弹出框，必须将event.returnValue的值设置为要显示给用户的字符串，同时作为函数的值返回： 123456EventUtil.addHandler(window, 'beforeunload', function (event) &#123; event = EventUtil.getEvent(event); var message = "I'm really going to miss you if you go."; event.returnValue = message; return message;&#125;); DOMContentLoaded事件window的load事件会在页面中的一切都加载完毕时触发，但这个过程可能会因为要加载的外部资源过多而颇费周折。而DOMContentLoaded事件则在形成完整的DOM树之后就会触发，不理会图像、JavaScript文件、CSS文件或其他资源是否已经下载完毕。与load事件不同，DOMContentLoaded支持在页面下载的早期添加事件处理程序，这也意味着用户能够尽早地与页面进行交互。 要处理DOMContentLoaded事件，可以为document或window添加相应的事件处理程序（尽管这个事件会冒泡到window，但它的目标实际上是document）： 123EventUtil.addHandler(document, 'DOMContentLoaded', function (event) &#123; alert('content loaded');&#125;); DOMContentLoaded事件对象不会提供任何额外的信息（其target属性是document）。 通常这个事件既可以添加事件处理程序，也可以执行其他DOM操作。这个事件始终都会在load事件之前触发。 readystatechange事件IE为DOM文档中某些部分提供了readystatechange事件。这个事件的目的是提供与文档或元素的加载状态有关的信息，但这个事件的行为有时候也很难预料。支持readystatechange事件的每个对象都有一个readyState属性，可能包含下列5个值中的一个： uninitialized（未初始化）：对象存在但尚未初始化 loading（正在加载）：对象正在加载数据 loaded（加载完毕）：对象加载数据完成 interactive（交互）：可以操作对象了，但还没有完全加载 complete（完成）：对象已经加载完毕 这些状态看起来很直观，但并非所有对象都会经历readyState的这几个阶段。这意味着readystatechange事件经常会少于4次，而readyState属性的值也不总是连续的。 对于document而言，值为interactive的readyState会在与DOMContentLoaded大致相同的时刻触发readystatechange事件。此时，DOM树已经加载完毕，可以安全地操作它，因此就会进入交互interactive阶段。但与此同时，图像及其他外部文件不一定可用。 12345EventUtil.addHandler(document, 'readystatechange', function (event) &#123; if (document.readyState == 'interactive')&#123; alert('content loaded'); &#125;&#125;); 这个事件的event对象不会提供任何信息，也没有目标对象。 在与load事件一起使用时，无法预测两个事件触发的先后顺序。在包含较多或较大的外部资源的页面中，会在load事件触发之前先进入交互阶段；而在包含较少或较小的外部资源的页面中，则很难说readystatechange事件会发生在load事件前面。 让问题变得更复杂的是，交互阶段可能会早于也可能会晚于完成阶段出现，无法确保顺序。在包含较多或较大的外部资源的页面中，交互阶段更有可能早于完成阶段出现；而在页面中包含较少外部资源的情况下，完成阶段先于交互阶段出现的可能性更大。因此，为了尽可能抢到先机，有必要同时检测交互和完成阶段： 1234567EventUtil.addHandler(document, 'readystatechange', function (event) &#123; //是否已经进入交互阶段或完成阶段，是则移除相应事件处理程序以免在其他阶段再执行 if (document.readyState == 'interactive' || document.readyState == 'complete')&#123; EventUtil.removeHandler(document, 'readystatechange', arguments.callee); alert('content loaded'); &#125;&#125;); &lt;script&gt;（在IE和Opera中）和&lt;link&gt;（仅IE中）元素也会触发readystatechange事件，可以用来确定外部的JavaScript和CSS文件是否已经加载完成。与其他浏览器中一样，除非把动态创建的元素添加到页面中，否则浏览器不会开始下载外部资源。基于元素触发的readystatechange事件也存在同样的问题，即readyState属性无论等于loaded还是complete都可以表示资源已经可用。有时候，readyState会停在loaded阶段而永远不会complete；有时候又跳过loaded阶段直接complete。于是，还需要像对待document一样采取相同的编码方式： 123456789101112131415EventUtil.addHandler(window, 'load', function () &#123; var script = docuemnt.createElement('script'); EventUtil.addHandler(script, 'readystatechange', function (event) &#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); if (target.readyState == 'loaded' || target.readyState == 'complete')&#123; EventUtil.removeHandler(target, 'readystatechange', arguments.callee); alert('script loaded'); &#125; &#125;); script.src = 'example.js'; docuemnt.body.appendChild(script);&#125;); 最重要的是要一并检测readyState的两个状态，并在调用了一次事件处理程序后就将其移除。 pageshow和pagehide事件Firefox和Opera有一个特性叫往返缓存（back-forward cache，或bfcache），可以在用户使用浏览器的后退和前进按钮时加快页面的转换速度。这个缓存中不仅保存着页面数据，还保存了DOM和JavaScript的状态；实际上是整个页面都保存在了内存里。如果页面位于bfcache中，那么再次打开页面就不会触发load事件。Firefox提供了新事件来更形象地说明bfcache的行为。 第一个事件就是pageshow，这个事件在页面显示时触发，无论该页面是否来自bfcache。在重新加载的页面中，pageshow会在load事件触发后触发，而在bfcache中的页面，pageshow会在页面状态完全恢复的那一刻触发。虽然这个事件的目标是document，但必须将其事件处理程序添加到window： 123456789101112(function () &#123; var showCount = 0; EventUtil.addHandler(window, 'load', function () &#123; alert('load fired'); &#125;); EventUtil.addHandler(window, 'pageshow', function () &#123; showCount++; alert('show has been fired ' + showCount + ' times'); &#125;);&#125;)(); 这个例子使用了私有作用域，以防止变量showCount进入全局作用域。 除了通常的属性之外，pageshow事件的event对象还包含一个名为persisted的布尔值属性。如果页面被保存在了bfcache中，则这个属性为true，否则为false。 通过检测persisted属性，就可以根据页面在bfcache中的状态来确定是否需要采取其他操作。 pagehide事件会在浏览器卸载页面的时候触发，而且是在unload事件之前发生。与pageshow事件一样，pagehide在document上面触发，但其事件处理程序必须要添加到window对象。这个事件的event对象也包含persisted属性，不过用途稍有不同： 123EventUtil.addHandler(window, 'pagehide',function (event) &#123; alert('hide persisted? ' + event.persisted);&#125;); 有时候，可能需要在pagehide事件触发时根据persisted的值采取不同的操作。对于pageshow事件，如果页面是从bfcache中加载的，那么persisted的值就是true；对于persisted事件，如果页面在卸载之后会被保存在bfcache中，那么persisted的值也会被设置为true。因此，当第一次触发pageshow时，persisted的值一定是false，而在第一次触发persisted时，persisted就会变成true。 hashchange事件HTML5新增了hashchange事件，以便在URL的参数列表（及URL中#后面的所有字符串）发生变化时通知开发人员。之所以新增这个事件，是因为在Ajax应用中，开发人员经常要利用URL参数来保存状态或导航信息。 必须要把hashchange事件处理程序添加给window对象，然后URL参数列表只要发生变化就会调用它。此时的event对象应该额外包含两个属性oldURL和newURL。这两个属性分别保存着参数列表变化前后的完整URL： 123EventUtil.addHandler(window, 'hashchange', function (event) &#123; alert('Old URL: ' + event.oldURL + '\nNew URL: ' + event.newURL);&#125;); 设备事件设备事件可以让开发人员确定用户在怎样使用设备。 orientationchange事件苹果公司为移动Safari添加了orientationchange事件，以便开发人员能够确定用户何时将设备由横向查看模式切换为纵向查看模式。移动Safari的window.orientation属性中可能包含3个值：0表示肖像模式，90表示向左旋转模式，-90表示向右旋转模式。 只要用户改变了设备的查看模式，就会触发orientationchange事件。此时的event对象不包含任何有价值的信息，因为唯一相关的信息可以通过window.orientation访问到： 1234567EventUtil.addHandler(window, 'load', function (event) &#123; var div = document.getElementById('myDiv'); div.innerHTML = 'current orientation is ' + window.orientation; EventUtil.addHandler(window, 'orientationchange', function (event) &#123; div.innerHTML = 'current orientation is ' + window.orientation; &#125;);&#125;); MozOrientation事件Firefox3.6为检测设备的方向引入了MozOrientation事件（前缀Moz表示这是特定于浏览器开发商的事件，不是标准事件。）当设备的加速计检测到了设备方向改变时，就会触发这个事件。但这个事件与iOS中的orientationchange事件不同，该事件只能提供一个平面的方向变化。由于MozOrientation事件是在window对象上触发的，所以可以使用下面代码来处理： 123EventUtil.addHandler(window, 'MozOrientation', function (event) &#123; //响应事件&#125;); 此时的event对象包含三个属性：x，y和z。这几个属性的值都介于1到-1之间，表示不同坐标轴上的方向。在静止状态下，x值为0，y值为0，z值为1（表示设备处于竖直状态）。如果设备向右倾斜，x值会减小；反之，向左倾斜，x值会增大。类似地，如果设备向远离用户的方向倾斜，y值会减小，向接近用户的方向倾斜，y值会增大。z轴检测垂直加速度，1表示静止不动，在设备移动时值会减小。（失重状态下值为0）： 1234EventUtil.addHandler(window, 'MozOrientation', function (event) &#123; var output = document.getElementById('output'); output.innerHTML = 'x= ' + event.x + ', y= ' + event.y + ', z= ' + event.z;&#125;); 只有带加速计的设备才支持MozOrientation事件，这是一个实验性API，将来可能会变。 deviceorientation事件本质上，DeviceOrientation Event规范定义的deviceorientation事件与MozOrientation事件类似。它也是在加速计检测到设备方向变化时在window对象上触发，而且具有与MozOrientation事件相同的支持限制。不过deviceorientation事件的意图是告诉开发人员设备在空间中朝向哪儿，而不是如何移动。 设备在三维空间中是靠x、y和z轴来定位的。当设备静止放置在水平面上，这三个值都是0。x轴方向是从左往右，y轴方向是从下往上，z轴方向是从后往前。 触发deviceorientation事件时，事件对象中包含着每个轴相对于设备静止状态下发生变化的信息。事件对象包含下面5个属性： alpha：在围绕z轴旋转时，y轴的度数差；是一个介于0到360之间的浮点数 beta：在围绕x轴旋转时，z轴的度数差；是一个介于-180到180之间的浮点数 gamma：在围绕y轴旋转时，z轴的度数差；是一个介于-90到90之间的浮点数 absolute：布尔值，表示设备是否是返回一个绝对值 compassCalibrated：布尔值，表示设备的指南针是否校准过 1234EventUtil.addHandler(window, 'deviceorientation', function (event) &#123; var output = document.getElementById('output'); output.innerHTML = 'alpha= ' + event.alpha + ', beta= ' + event.beta + ', gamma= ' + event.gamma;&#125;); 通过这些信息，可以响应设备的方向，重新排列或修改屏幕上的元素。要响应设备方向的改变而旋转元素，可以参考下面代码： 1234EventUtil.addHandler(window, 'deviceorientation', function (event) &#123; var arrow = document.getElementById('arrow'); arrow.style.webkitTransform = 'rotate(' + Math.round(event.alpha) + 'deg)';&#125;); devicemotion事件DeviceOrientation Event规范还定义了一个devicemotion事件。这个事件要告诉开发人员设备什么时候移动，而不仅仅是设备方向如何改变。例如，通过devicemotion能够检测到设备是不是正在往下掉，或者是不是被走着的人拿在手里。 触发devicemotion事件时，事件对象包含下列属性： acceleration：一个包含x，y和z属性的对象，在不考虑重力的情况下，告诉你在每个方向上的加速度 accelerationIncludingGravity：一个包含x，y和z属性的对象，在考虑z轴自然重力加速度的情况下，告诉你在每个方向上的加速度 interval：以毫秒表示的时间值，必须在另一个devicemotion事件触发前传入。这个值在每个事件中应该是一个常量 rotationRate：一个包含表示方向的alpha、beta和gamma属性的对象。 如果读取不到acceleration、accelerationIncludingGravity和rotationRate值，则它们的值为null。因此，在使用这三个属性之前，应该先检测确定它们的值不是null： 123456EventUtil.addHandler(window, 'devicemotion', function (event) &#123; var output = document.getElementById('output'); if (event.rotationRate != null)&#123; output.innerHTML = 'alpha= ' + event.rotationRate.alpha + ', beta= ' + event.rotationRate.beta + ', gamma= ' + event.rotationRate.gamma; &#125;&#125;); 触摸与手势事件触摸事件触摸事件会在用户手指放在屏幕上面时、在屏幕上滑动时或从屏幕上移开时触发。具体来说，有以下几个触摸事件： touchstart：当手指触摸屏幕时触发；即使已经有一个手指放在了屏幕上也会触发 touchmove：当手指在屏幕上滑动时连续地触发。在这个事件发生期间，调用preventDefault()可以阻止滚动 touchend：当手指从屏幕上移开时触发 touchcancel：当系统停止跟踪触摸时触发 上面几个事件都会冒泡，也都可以取消。每个触摸事件的event对象都提供了在鼠标中常见的属性：bubbles、cancelable、view、clientX、clientY、screenX、screenY、detail、altKey、shiftKey、ctrlKey和metaKey。 除了常见的DOM属性之外，触摸事件还包含下列三个用于跟踪触摸的属性： touches：表示当前跟踪的触摸操作的Touch对象的数组 targetTouches：特定于事件目标的Touch对象数组 changeTouches：表示自上次触摸以来发了什么改变的Touch对象的数组 每个Touch对象包含下列属性： clientX：触摸目标在视口中的x坐标 clientY：触摸目标在视口中的y坐标 identifier：标识触摸的唯一ID pageX：触摸目标在页面中的x坐标 pageY：触摸目标在页面中的y坐标 screenX：触摸目标在屏幕中的x坐标 screenY：触摸目标在屏幕中的y坐标 target：触摸的DOM节点目标 使用这些属性可以跟踪用户对屏幕的触摸操作： 1234567891011121314151617181920212223function handleTouchEvent(event) &#123; //只跟踪一次触摸 if (event.touches.length == 1)&#123; var output = document.getElementById('output'); switch (event.type)&#123; case 'touchstart': output.innerHTML = 'touch started (' + event.touches[0].clientX + ',' + event.touches[0].clientY + ')'; break; case 'touchend': output.innerHTML = '&lt;br&gt;touch ended (' + event.changeTouches[0].clientX + ',' + event.changeTouches[0].clientY + ')'; break; case 'touchmove': event.preventDefault(); //阻止滚动 output.innerHTML = '&lt;br&gt;touch moved (' + event.changeTouches[0].clientX + ',' + event.changeTouches[0].clientY + ')'; break; &#125; &#125;&#125;EventUtil.addHandler(document,'touchstart', handleTouchEvent);EventUtil.addHandler(document, 'touchend', handleTouchEvent);EventUtil.addHandler(document, 'touchmove', handleTouchEvent); 在touchend事件发生时，touched集合中就没有任何Touch对象了，因为不存在活动的触摸操作；此时，就必须使用changeTouches集合。 这些事件就会在文档的所有元素上面触发，因而可以分别操作页面的不同的部分。在触摸屏幕上的元素时，这些事件（包括鼠标事件）发生顺序如下： touchstart mouseover mousemove（一次） mousedown mouseup click touchend 手势事件当两个手指触摸屏幕时就会产生手势，手势通常会改变显示项的大小，或者旋转显示项。有三个手势事件： gesturestart：当一个手指已经按在屏幕上而另一个手指又触摸屏幕时触发 gesturechange：当触摸屏幕的任何一个手指的位置发生变化时触发 gestureend：当任何一个手指从屏幕上面移开时触发 只有两个手指都触摸到事件的接收容器时才会触发这些事件。在一个元素上设置事件处理程序，意味着两个手指必须同时位于该元素的范围之内，才能触发手势事件（这个元素就是目标）。由于这些事件冒泡，所以将事件处理程序放在文档上也可以处理所有手势事件。此时，事件的目标就是两个手指都位于其范围内的那个元素。 触摸事件和手势事件之间存在某种关系。当一个手指放在屏幕上时，会触发touchstart事件。如果另一个手指又放在了屏幕上，则会先触发gesturestart事件，随后触发基于该手指的touchstart事件。如果一个或两个手指在屏幕上滑动，将会触发gesturechange事件。但只要有一个手指移开，就会触发gestureend事件，紧接着触发基于该手指的touchend事件。 与触摸事件一样，每个手势事件的event对象都包含着标准的鼠标事件属性：bubbles、cancelable、view、clientX、clientY、screenX、screenY、detail、altKey、shiftKey、ctrlKey和metaKey。此外，还包含两个额外的属性rotation和scale。其中，rotation属性表示手指变化引起的旋转角度，负值表示逆时针旋转，正值表示顺时针旋转（该值从0开始）。而scale属性表示两个手指间距离的变化情况，这个值从1开始，并随着距离拉大而增长，随距离缩短而减小： 123456789101112131415161718function handleGestureEvent(event) &#123; var output = document.getElementById('output'); switch (event.type)&#123; case 'gesturestart': output.innerHTML = 'gesture started (rotation=' + event.rotation + ',scale=' + event.scale + ')'; break; case 'gestureend': output.innerHTML = '&lt;br&gt;gesture ended (rotation=' + event.rotation + ',scale=' + event.scale + ')'; break; case 'gesturechange': output.innerHTML = '&lt;br&gt;gesture changed (rotation=' + event.rotation + ',scale=' + event.scale + ')'; break; &#125;&#125;document.addEventListener('gesturestart', handleGestureEvent,false);document.addEventListener('gestureend',handleGestureEvent,false);document.addEventListener('gesturechange',handleGestureEvent,false); 内存和性能由于事件处理程序可以为现代Web应用程序提供交互能力，因此许多开发人员会不分青红皂白地向页面中添加大量的处理程序。在JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能。导致这一问题的原因是多方面的。首先，每个函数都是对象，都会占用内存；内存中的对象越多，性能就越差。其次，必须事先指定所有事件处理程序而导致的DOM访问次数，会延迟整个页面的交互就绪时间。事实上，从如何利用好事件处理程序的角度出发，还是有一些方法能够提升性能的。 事件委托对事件处理程序过多问题的解决方案就是事件委托。事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。也就是说，可以为整个页面指定一个onclick事件处理程序，而不必给每个可单击的元素分别添加事件处理程序。 12345&lt;ul id="myLinks"&gt; &lt;li id="goSomewhere"&gt;Go somewhere&lt;/li&gt; &lt;li id="doSomething"&gt;Do something&lt;/li&gt; &lt;li id="sayHi"&gt;Say hi&lt;/li&gt;&lt;/ul&gt; 如果在一个复杂的Web应用程序中，对所有可单击的元素都采用这种方式，那么结果就会有数不清的代码用于添加事件处理程序。此时，可以利用事件委托技术解决这个问题。使用事件委托，只需要在DOM数中尽量最高的层次上添加一个事件处理程序： 123456789101112131415161718var list = document.getElementById('myLinks');EventUtil.addHandler(list, 'click', function (event) &#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(target); switch (target.id)&#123; case 'doSomething': document.title = "I changed the document's title"; break; case 'goSomewhere': location.href = 'http://tc9011.com'; break; case 'sayHi': alert('hi'); break; &#125;&#125;); 在这段代码里，使用事件委托只为&lt;ul&gt;元素添加了一个onclick事件处理程序。由于所有列表项都是这个元素的子节点，而且它们的事件会冒泡，所以单击事件最终会被这个函数处理。事件目标是被单击的列表项，故而可以通过检测id属性来决定采取适当的操作。与前面未使用事件委托的代码一比，这段代码的事前消耗更低，因为只取得了一个DOM元素，只添加了一个事件处理程序。虽然对用户来说最终结果相同，但这种技术需要占用的内存更少。所有用到按钮的事件都适合采用事件委托技术。 如果可行的话，也可以考虑为document对象添加一个事件处理程序，用以处理页面上发生的某种特定类型的事件。这样做与采取传统的做法相比有下列几个优点： document对象很快就可以访问，而且可以在页面生命周期的任何时点上为它添加事件处理程序。换句话说，只要可单击的元素呈现在页面上，就可以立即具备适当的功能 在页面中设置事件处理程序所需的时间更少。只添加一个事件处理程序所需的DOM引用更少，所花的时间也更少 整个页面占用的内存空间更少，能够提升整体性能 最适合采用事件委托技术的事件包括click、mousedown、mouseup、keyup和keypress。虽然mouseover和mouseout事件也冒泡，但要适当处理它们并不容易，而且经常需要计算元素的位置。 移除事件处理程序每当事件处理程序指定给元素时，运行中的浏览器代码与支持页面交互的JavaScript代码之间就会建立一个连接。这种连接越多，页面执行起来就越慢。可以采用事件委托技术，限制建立的连接数量。另外，在不需要的时候移除事件处理程序，也是解决这个问题的一种方案。内存中留有那些过时不用的空事件处理程序（dangling event handler），也是造成Web应用程序内存与性能问题的主要原因。 在两种情况下，可能会造成上述问题。第一种情况就是从文档中移除带有事件处理程序的元素时。这可能是通过纯粹的DOM操作，但更多地是发生在使用innerHTML替换页面中某一部分的时候。如果带有事件处理程序的元素被innerHTML删除了，那么原来添加到元素中的事件处理程序极有可能无法被当做垃圾回收： 123&lt;div id="myDiv"&gt; &lt;input type="button" value="click me" id="myBtn"&gt;&lt;/div&gt; 123456var btn = document.getElementById('myBtn');btn.onclick = function () &#123; //先执行某些操作 document.getElementById('myDIv').innerHTML = 'processing...'&#125;; 上面代码为了避免双击，单击按钮时就将按钮移除并替换成一条消息。在&lt;div&gt;元素上设置innerHTML可以把按钮移走，但事件处理程序仍然与按钮保持着引用关系。有的浏览器在这种情况下不会做出恰当地处理，它们很有可能会将对元素和对事件处理程序的引用都保存在内存中。如果你知道某个元素即将被移除，那么最好手工移除事件处理程序： 1234567var btn = document.getElementById('myBtn');btn.onclick = function () &#123; //先执行某些操作 btn.onclick = null; //移除事件处理程序 document.getElementById('myDIv').innerHTML = 'processing...'&#125;; 在事件处理程序中删除按钮也能阻止事件冒泡。目标元素在文档中是事件冒泡的前提。 导致空事件处理程序的另一种情况，就是卸载页面的时候。如果页面被卸载之前没有清理干净事件处理程序，那它们会滞留在内存中。每次加载完页面再卸载页面时，内存中滞留的对象数目就会增加，因为事件处理程序占用的内存并没有被释放。 一般来说，最好的做法是在页面卸载之前，先通过onunload事件处理程序移除所有事件处理程序。在此，事件委托技术再次表现出它的优势，需要跟踪的事件处理程序越少，移除它们就越容易。对这种类似撤销的操作，可以把它想象成：只要是通过onload事件处理程序添加的东西，最后都要通过onunload事件处理程序将它们移除。 模拟事件事件，就是网页中某个特别值得关注的瞬间。事件经常由用户操作或通过其他浏览器功能来触发。但很少人知道，可以使用JavaScript在任意时刻来触发特定的事件，而此时的事件就如同浏览器创建的事件一样。也就是说，这些事件该冒泡还会冒泡，而且照样能够导致浏览器执行已经指定的处理它们的事件处理程序。在测试Web应用程序，模拟触发事件是一种及其有用的技术。 DOM中的事件模拟可以在document对象上使用createEvent()方法创建event对象。这个方法接收一个参数，即表示要创建的事件类型的字符串。在DOM2级中，所有这些字符串都使用英文复数形式，而在DOM3级中都变成了单数。这个字符串可以是下列几个字符串之一： UIEvents：一般化的UI事件。鼠标事件和键盘事件都继承自UI事件。DOM3级中是UIEvent MouseEvents：一般化的鼠标事件。DOM3级中是MouseEvent MutationEvents：一般化的DOM变动事件。DOM3级中是MutationEvent HTMLEvents：一般化的HTML事件。没有对应的DOM3级事件 DOM2级事件并没有专门规定键盘事件，DOM3级事件中才正式将其作为一种事件给出规定。 在创建了event对象之后，还需要使用与事件有关的信息对其进行初始化。每种类型的event对象都有一个特殊的方法，为它传入适当的数据就可以初始化该event对象。不同类型的这个方法名字也不同，具体要取决于createEvent()中使用的参数。 模拟事件的最后一步就是触发事件。这一步需要使用dispatchEvent()方法，所有支持事件的DOM节点都支持这个方法。调用dispatchEvent()方法时，需要传入一个参数，即表示要触发事件的event对象。触发事件之后，该事件就跻身官方事件之列，因而能够照样冒泡并引发相应事件处理程序的执行。 模拟鼠标事件创建新的鼠标事件对象并为其指定必要的信息，就可以模拟鼠标事件。创建鼠标事件对象的方法是为createEvent()传入字符串MouseEvents。返回的对象有一个名为initMouseEvent()方法，这个方法接收15个参数，分别与鼠标事件中每个典型的属性一一对应： 显而易见，initMouseEvent()方法的这些参数是与鼠标事件的event对象所包含的属性一一对应。其中，前4个参数对正确地激发事件至关重要，因为浏览器要用到这些参数；而剩下的所有参数只有在事件处理程序中才会用到。当把event对象当把event对象传给dispathEvent()方法时，这个对象d target属性会自动设置。 12345678//创建事件对象var event = document.createEvent('MouseEvent');//初始化事件对象event.initMouseEvent('click', true, true, document.defaultView, 0, 0, 0, 0, 0, false, false, false, false, 0, null);//触发事件btn.dispatchEvent(event); 在兼容DOM的浏览器中，也可以通过相同的方式来模拟其他鼠标事件。 模拟键盘事件DOM2级事件中没有就键盘事件作出规定，因此模拟键盘事件并没有现成的思路可寻。 DOM3级规定，调用createEvent()并传入keyboardEvent就可以创建一个键盘事件。返回的事件对象会包含一个initKeyEvent()方法，这个方法接收下列参数： 由于DOM3级不提倡使用keypress事件，因此只能利用这种技术类模拟keydown和keyup事件。 12345678910111213var textbox = document.getElementById('myTextbox'), event;//以DOM3级方式创建事件对象if (document.implementation.hasFeature('keyboardEvents', '3.0'))&#123; event = document.createEventObject('keyboradEvent'); //初始化事件对象 event.initKeyboardEvent('keydown', true, true, document.defaultView, 'a', 0, 'shift', 0);&#125;//触发事件textbox.dispatchEvent(event); 这个例子模拟的是按住Shift的同时按下了A键。在使用document.createEvent(&#39;keyboardEvent&#39;)之前，应该先检测浏览器是否支持DOM3级事件；其他浏览器返回一个非标准的keyboardEvent对象。 在Firefox中，调用createEvent()并传入keyEvents就可以创建一个键盘事件。返回的事件对象包含一个initKeyEvent()方法，这个方法接受下列10个参数： 将创建的event对象传入到dispatchEvent()方法就可以触发键盘事件： 1234567891011//只适用Firefoxvar textbox = document.getElementById('myTextbox');//创建事件对象var event = document.createEvent('KeyEvents');//初始化事件对象event.initKeyEvent('keypress', true, true, document.defaultView, false, false, false, false, 65, 65);//触发事件textbox.dispatchEvent(event); 在其他浏览器中，则需要创建一个通用的事件，然后再向事件对象中添加键盘事件特有的信息： 123456789101112131415//创建事件对象var event = document.createEvent('Events');//初始化事件对象event.initEvent(type, bubbles, cancelable);event.view = document.defaultView;event.altKey = false;event.ctrlKey = false;event.shiftKey = false;event.metaKey = false;event.keyCode = 65;event.charCode = 65;//触发事件textbox.dispatchEvent(event); 上面代码中必须要使用通用事件，而不能使用UI事件，因为UI事件不允许向event对象中再添加新属性。像这样模拟事件虽然会触发键盘事件，但却不会向文本框中写入文本，这是由于无法精确模拟键盘事件所造成的。 模拟其他事件虽然鼠标事件和键盘事件是在浏览器中最经常模拟的事件，但有时候同样需要模拟变动事件和HTML事件。要模拟变动事件，可以使用createEvent(&#39;MutationEvents&#39;)创建一个包含initMutationEvent()方法的变动事件对象。这个方法接受的参数包括type、bubbles、cancelable、relatedNode、preValue、newValue、attrName和attrChange。 123var event = document.createEvent('MutationEvents');event.initMutationEvent('DOMNodeInserted', true, false, someNode, '', '', '', 0);target.dispatchEvent(event); 要模拟HTML事件，同样需要先创建一个event对象—-通过createEvent(&#39;HTMLEvents&#39;)，然后再使用这个对象的initEvent()方法来初始化它即可： 123var event = document.createEvent('HTMLEvents');event.initEvent('focus', true, false);target.dispatchEvent(event); 自定义DOM事件DOM3级还定义了自定义事件。自定义事件不是由DOM原生触发的，它的目的是让开发人员创建自己的事件。要创建新的自定义事件，可以调用createEvent(&#39;CustomEvent&#39;)。返回的对象有一个名为initCustomEvent()的方法，接受如下四个参数： 可以像分派其他事件一样在DOM中分派创建的自定义事件对象： 12345678910111213141516var div = document.getElementById('myDiv'), event;EventUtil.addHandler(div, 'myevent', function (event) &#123; alert('DIV: ' + event.detail);&#125;);EventUtil.addHandler(document, 'myevent', function (event) &#123; alert('DOCUMENT: ' + event.detail);&#125;);if (document.implementation.hasFeature('CustomEvents', '3.0'))&#123; event = document.createEvent('CustomEvent'); event.initCustomEvent('myevent', true, false, 'hello'); div.dispatchEvent(event);&#125; 上面代码中创建了一个冒泡事件myevent。而event.detail的值被设置成了hello字符串，然后在&lt;div&gt;和document上侦听这个事件。因为initCustomEvent()方法已经指定这个事件应该冒泡，所以浏览器会负责将事件向上冒泡到document。]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《JavaScript高级程序设计》学习笔记（四）]]></title>
    <url>%2F2017%2F09%2F10%2F%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[第十章：DOM 第十一章：DOM扩展 第十二章：DOM2和DOM3 DOMDOM是针对HTML和XML文档的一个API。DOM描绘了一个层次化的节点树，允许开发人员添加、移除和修改页面的某一部分。 节点层次DOM可以将任何HTML或XML文档描绘成一个由多层节点构成的结构。节点分为几种不同的类型，每种类型分别表示文档中不同的信息及标记。每个节点都拥有各自的特点、数据和方法，另外也与其他节点存在某种关系。节点之间的关系构成了层次，而所有页面标记则表现为一个以特定节点为根节点的树形结构。 文档（Document）节点是每个文档的根节点。文档节点下&lt;html&gt;元素称为文档元素。文档元素是文档的最外层元素，文档中的其他所有元素都包含在文档元素中。每个文档只能有一个文档元素。在HTML页面中，文档元素始终是&lt;html&gt;元素。在XML中，没有预定义的元素，因此任何元素都可能成为文档元素。 每一段标记都可以通过树中的一个节点来表示：HTML元素通过元素节点表示，特性（attribute）通过特性节点表示，文档类型通过文档类型节点表示，注释通过注释节点表示。总共有12种节点类型，这些类型都继承自一个基类型。 Node类型DOM1级定义了一个Node接口，该接口由DOM中的所有节点类型实现。这个Node接口在JavaScript中是作为Node类型实现。除了IE之外，在其他浏览器中都可以访问到这个类型。JavaScript中所有节点类型都继承自Node类型，因此所有节点类型都共享着相同的基本属性和方法。 每个节点都有一个nodeType属性，用于表明节点的类型。节点类型由在Node类型中定义的下列12个数值常量来表示，任何节点类型必居其一： Node.ELEMENT_NODE（1）—表示元素节点 Node.ATTRIBUTE_NODE（2）—表示属性节点 Node.TEXT_NODE（3）—表示文本节点 Node.CDATA_SECTION_NODE（4）—表示文档中的 CDATA 部分（不会由解析器解析的文本） Node.ENTITY_REFERENCE_NODE（5）—表示实体引用 Node.ENTITY_NODE（6）—表示实体 Node.PROCESSING_INSTRUCTION_NODE（7）—表示处理指令 Node.COMMENT_NODE（8）—表示注释 Node.DOCUMENT_NODE（9）—表示整个文档（DOM 树的根节点） Node.DOCUMENT_TYPE_NODE（10）—表示向为文档定义的实体提供接口 Node.DOCUMENT_FRAGMENT_NODE（11）—表示代表轻量级的 Document 对象，能够容纳文档的某个部分 Node.NOTATION_NODE（12）—表示DTD 中声明的符号 通过比较上面这些常量可以很容易地确定节点的类型。然而由于IE中没有公开Node类型的构造函数，因此最好还是将nodeType属性与数字值进行比较： 123if (someNode.nodeType == 1) &#123; console.log('Node is an element');&#125; nodeName和nodeValue属性用nodeName和nodeValue属性可以了解节点的具体信息，其值完全取决于节点的类型。在使用这两个值之前，最好像下面这样先检测一下节点类型： 123if (someNode.nodeType == 1) &#123; value = someNode.nodeName; //nodeName的值是元素的标签名&#125; 对于元素节点，nodeName中保存的始终都是元素的标签名，而nodeValue的值则始终为null。 节点关系每个节点都有一个childNodes属性，其中保存着一个NodeList对象。NodeList是一种类数组对象，用于保存一组有序的节点，可以通过位置来访问这些节点。 虽然可以用方括号语法来访问NodeList的值，而且这个对象也有length属性，但它并不是Array的实例。 NodeList对象的独特之处在于，它实际上是基于DOM结构动态执行查询的结果，因此DOM结构的变化能够自动反映在NodeList对象中。 可以通过方括号或者item()方法访问保存在NodeList中的节点： 12var firstChild = someNode.childNodes[0];var secondChild = someNode.childNodes.item(1); length属性表示的是访问NodeList的那一刻，其中包含的节点数量。 对arguments对象使用Array.prototype.slice()方法可以将其转换为数组。采用同样的方法，也可以将NodeList对象转换为数组： 12//在IE8及之前版本中无效var arrayOfNodes = Array.prototype.slice.call(someNode.children,0); 每个节点都有一个parentNode属性，该属性指向文档树中的父节点。在包含childNodes列表中的所有节点都具有相同的父节点，因此它们的parentNode属性都指向同一个节点。列表中第一个节点的previousSibling属性值为null，而列表中最后一个节点的nextSibling属性的值同样也为null。 父节点的firstChild和lastChild属性分别指向列表中的第一个和最后一个节点，someNode.firstChild的值和someNode.childNodes[0]始终相等，someNode.lastChild的值和someNode.childNodes[someNode.childNodes.length-1]的值始终相等。在只有一个子节点的情况下，firstChild和lastChild指向同一个节点，如果没有子节点，firstChild和lastChild的值均为null。 hasChildNodes()方法在节点包含一或多个子节点的情况下返回true。 所有节点都有一个ownerDocument属性，该属性指向整个文档的文档节点。这种关系表示的是任何节点都属于它所在的文档，任何节点都不能同时存在于两个或更多个文档中。通过这个属性，可以直接访问文档节点，而不必在节点层次中通过层层回溯到达顶端。 操作节点 appendChild()方法用于向childNodes列表的末尾添加一个节点。添加节点后，childNodes的新增节点、父节点以及以前的最后一个子节点的关系指针都会相应地得到更新。更新完成后，appendChild()返回新增的节点： 123var returnedNode = someNode.appendChild(newNode);console.log(returnedNode == newNode); //trueconsole.log(someNode.lastChild == newNode); //true 如果传入到appendChild()中的节点已经是文档的一部分，那结果就是将该节点从原来的位置转移到新位置。即使可以将DOM树看成由一系列指针连接起来，但任何DOM节点也不能同时出现在文档中的多个位置上。因此，如果在调用appendChild()时传入了父节点的第一个子节点，那么该节点就会成为父节点的最后一个子节点： 1234//someNode有多个子节点var returnedNode = someNode.appendChild(someNode.firstChild);console.log(returnedNode == someNode.firstChild); //falseconsole.log(returnedNode == someNode.lastChild); //true insertBefore()方法可以把节点放在childNodes列表中某个特定的位置上。这个方法接收两个参数：要插入的节点和作为参照的节点。插入节点后，被插入的节点会变成参照节点的前一个同胞节点（previousSibling），同时被方法返回。如果参照节点是null，则insertBefore()与appendChild()执行相同的操作： 123456789101112//插入后成为最后一个子节点returnedNode = someNode.insertBefore(newNode,null);console.log(newNode == someNode.lastChild); //true//插入后成为第一个子节点var returnedNode = someNode.insertBerfore(newNode,smeNode.firstChild);console.log(returnedNode == newNode); //trueconsole.log(newNode == someNode.firstChild); //true//插入到最后一个子节点前面returnedNode == someNode.insertBefore(newNode,someNode.lastChild);console.log(newNode == someNode.childNodes[someNode.childNodes.length-2]); //true replaceChild()方法接受两个参数：要插入的节点和要替换的节点。要替换的节点将由这个方法返回并从文档树中被移除，同时由要插入的节点占据其位置。 使用replaceChild()插入一个节点时，该节点的所有关系指针都会从被它替换的节点复制过来。尽管从技术上将，被替换的节点仍然还在文档中，但它在文档中已经没有了自己的位置。 removeChild()方法接受一个参数，即要移除的节点。被移除的节点将成为方法的返回值。通过removeChild()移除的节点仍然为文档所有，只不过在文档中已经没有了自己的位置。 上面这些方法都必须先取得父节点。另外，并不是所有类型的节点都有子节点，如果在不支持子节点的节点上调用了这些方法，将会导致错误发生。 其他方法cloneNode()方法用于创建调用这个方法的节点的一个完全相同的副本，它接收一个布尔值参数，表示是否执行深复制。在参数为true的情况下，执行深复制，也就是复制节点及整个子节点树；在参数为false的情况下，执行浅复制，即只复制节点本身。复制后返回的节点副本属于文档所有，但并没有为它指定父节点，因此，这个节点副本就成了一个孤儿，除非通过appendChild()、insertBerfore()或replaceChild()将它添加到文档中。 12345&lt;ul&gt; &lt;li&gt;item 1&lt;/li&gt; &lt;li&gt;item 2&lt;/li&gt; &lt;li&gt;item 3&lt;/li&gt;&lt;/ul&gt; 123456var myList = document.getElementsByTagName('ul');var deepList = myList.cloneNode(true);console.log(deepList.childNodes.length); //3（IE&lt;9）或7（其他浏览器）var shallowList = myList.cloneNode(false);console.log(shallowList.childNodes.length) //0 cloneNode()方法不会复制添加到DOM节点中的JavaScript属性，这个方法只会复制特性、（在明确指定的情况下也复制）子节点。 normalize()方法用于处理文档树中的文本节点。由于解析器的实现或DOM操作等原因，可能会出现文本节点不包含文本，或者接连出现两个文本节点的情况。当在某个节点上调用这个方法时，就会在该节点的后代节点中查找上述两种情况。如果找到了空文本节点，则删除它，如果找到相邻的文本节点，则将它们合并为一个文本节点。 Document类型JavaScript通过Document类型表示文档。在浏览器中，document对象是HTMLDocument（继承自Document类型）的一个实例，表示整个HTML页面。而且，document对象是window对象的一个属性，因此可以将其作为全局对象来访问。 Document节点具有下列特征： nodeType的值为9 nodeName的值为#document nodeValue的值为null parentNode的值为null ownerDocument的值null 其子节点可能是一个DocumentType（最多一个）、Element（最多一个）、ProcessingInstruction或Comment Document类型可以表示HTML页面或者其他基于XML的文档。最常见的应用是作为HTMLDocument实例的document对象。通过这个文档对象，不仅可以获得与页面相关的信息，而且还能操作页面的外观及其底层结构。 文档的子节点documentElement属性始终指向HTML页面中的&lt;html&gt;元素。 通过childNodes列表可以访问文档元素。 document.documentElement、document.firstChild和document.childNodes[0]的值相同，都指向&lt;html&gt;元素。 作为HTMLDocument的实例，document对象还有一个body属性，直接指向&lt;body&gt;元素。 所有浏览器都支持document.documentElement和document.body属性。 通常将&lt;!DOCTYPE&gt;标签看成一个与文档其他部分不同的实体，可以通过doctype（在浏览器中是document.doctype）属性来访问它的信息。 文档信息作为HTMLDocument的一个实例，document对象还有一些标准的Document对象所没有的属性。这些属性提供了document对象所表现的网页的一些信息。 其中第一个属性就是title，包含着&lt;title&gt;元素中的文本。通过这个属性可以取得当前页面的标题，也可以修改当前页面的标题并反映在浏览器的标题栏中。 12345//取得文档标题var originalTitle = document.title;//设置文档标题document.title = 'new title'; 接下来三个属性都与对网页的请求有关，它们是URL、domain和referrer。URL属性中包含页面完整的URL；domain属性中只包含页面的域名；referrer属性中保存着链接到当前页面的那个页面的URL，在没有来源页面的情况下，referrer属性中可能会包含空字符串。所有这些信息都存在于请求的HTTP头部，只不过这些属性让我们能够在JavaScript中访问它们而已。 12345678//取得完整的URLvar url = document.URL;//取得域名var domain = document.domain;//取得来源页面的URLvar referrer = document.referrer; 这三个属性中，只有domain是可以设置的。但由于安全方面的限制，也并非可以给domain设置任何值。如果URL中包含一个子域名，例如p2p.wrox.com，那么就只能将domain设置为wrox.com。不能将这个属性设置为URL中不包含的域。 当页面中包含来自其他子域的框架或内嵌框架时，能够设置document.domain就非常方便。由于跨域安全限制，来自不同子域的页面无法通过JavaScript通信。而通过将每个页面的document.domain设置为相同的值，这些页面就可以互相访问对方包含的JavaScript对象。 浏览器对domain属性还有一个限制，即如果域名一开始是松散的（loose），那么不能将它再设置为紧绷的（tight）。也就是说，在将document.domain设置为wrox.com之后，就不能再将其设置回p2p.wrox.com，否则将会导致错误。在所有浏览器中都存在这个限制。 123//假设页面来自于p2p.wrox.com域document.domain = 'wrox.com'; //松散的(成功)document.domain = 'p2p.wrox.com'; //紧绷的(出错) 查找元素getElementById()方法接收一个参数：要取得的元素的ID。如果找到相应的元素则返回该元素，如果不存在则返回null。这里的ID必须与页面中的id特性（attribute）严格匹配。 如果页面中多个元素的ID值相同，getElementById()只返回文档中第一次出现的元素。 getElementsByTagName()方法接收一个参数：即要取得元素的标签名，返回的是包含零或多个元素的NodeList。在HTML文档中，这个方法会返回一个HTMLCollection对象，作为一个动态集合，该对象与NodeList非常相似。可以使用方括号语法或item()方法来访问HTMLCollection对象中的项。这个对象中元素的数量则可以通过其length属性取得。 HTMLCollection对象还有一个方法叫namedItem()，使用这个方法可以通过元素的name特性取得集合中的项。 1&lt;img src='myimage.gif' name='myImage'/&gt; 12var images = document.getElementsByTagName('img');var myImage = images.namedItem('myImage'); 在提供索引访问的基础上，HTMLCollection还支持按名称访问项，对命名的项也可以使用方括号语法来访问，可以向方括号中传入数值或字符串形式的索引值，在后台，对数值索引就会调用item()，对字符索引就会调用namedIten()： 1var myImage = images['myImage']; 要想取得文档中所有元素，可以向getElementsByTagName()中传入*。在JavaScript及CSS中，*通常表示全部。 getElementsByName()方法是只有HTMLDocument类型才有的方法。这个方法会返回带有给定name特性的所有元素。最常使用getElementsBuName()方法的情况是取得单选按钮，为了确保发送给浏览器的值准确无误，所有单选按钮必须具有相同的name特性： 12345678&lt;div&gt; &lt;p&gt;which color do you prefer?&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;input type='radio' value='red' name='color' id='colorRed'&gt;&lt;label for='colorRed'&gt;Red&lt;/label&gt;&lt;/li&gt; &lt;li&gt;&lt;input type='radio' value='green' name='color' id='colorGreen'&gt;&lt;label for='colorGreen'&gt;Green&lt;/label&gt;&lt;/li&gt; &lt;li&gt;&lt;input type='radio' value='blue' name='color' id='colorBlue'&gt;&lt;label for='colorBlue'&gt;Blue&lt;/label&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 1var radio = document.getElementsByName('color'); getElementsByName()方法也会返回一个HTMLCollection。但对这里的单选按钮来说，nameItem()方法只会取得第一项（因为每一项的name特性都相同）。 特殊集合document对象还有一些特殊的集合，这些集合都是HTMLCollection对象，为访问文档常用的部分提供了快捷方式： document.anchors：包含文档中所有带name特性的&lt;a&gt;元素 document.forms：包含文档中所有的&lt;form&gt;元素 document.images：包含所有的&lt;img&gt;元素 document.links：包含文档中所有带href特性的&lt;a&gt;元素 这个特殊集合始终都可以通过HTMLDocument对象访问到，而且，与HTMLCollection对象类似，集合中的项也会随着当前文档内容的更新而更新。 DOM一致性检测由于DOM分为多个级别，也包含多个部分，因此检测浏览器实现了DOM的哪些部分就十分必要。document.implementation属性就是为此提供相应信息和功能的对象，与浏览器对DOM的实现直接对应。 DOM1级只为document.implementation规定了一个方法：hasFeature()。这个方法接收两个参数：要检测的DOM功能的名称及版本号。如果浏览器支持给定名称和版本功能，则该方法返回true： 1var hasXmlDom = document.implementation.hasFeature('XML','1.0'); 下边列出了可以检测的不同的值和版本号： hasFeature()返回true有时候不意味着实现与规范一致，建议在使用DOM某些特殊的功能之前，最好除了检测hasFeature()之外，还同时使用能力检测。 文档写入write()、writeln()、open()和close()方法将输出流写入到网页中。 write()和writeln()方法都接受一个字符串参数，即要写入到输出流中的文本。write()会原样写入，writeln()会在字符串的末尾添加一个换行符\n。在页面被加载过程中，可以使用这两个方法向页面中动态地加入内容。 使用write()和writeln()方法可以动态地包含外部资源。在包含JavaScript文件时，必须注意不能直接包含字符串&lt;/script&gt;，这会导致字符串被解释为脚本块的结束，它后面的代码将无法执行。为了避免这个问题，只要把这个字符串分开写即可： 123&lt;script&gt; document.write('&lt;script src="file.js"&gt;' + '&lt;\/script&gt;');&lt;/script&gt; 字符串&lt;\/script&gt;不会被当作外部&lt;script&gt;标签的关闭标签。 如果在文档加载结束后再调用document.write()，那么输出的内容将会重写整个页面： 12345678910111213&lt;html&gt;&lt;head&gt; &lt;title&gt;example&lt;/title&gt; &lt;/head&gt;&lt;body&gt; &lt;p&gt;this is some content that you won't get to see because it will be overwritten.&lt;/p&gt; &lt;script&gt; window.onload = function()&#123; document.write('hello world'); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; open()和close()方法分别用于打开和关闭网页的输出流。如果页面加载期间使用write()或writeln()方法，则不需要用到这两个方法。 Element类型Element类型用于表现XML或HTML元素，提供了对元素标签名、子节点及特性的访问。Element节点具有以下特征： nodeType的值为1 nodeName的值为元素的标签名 nodeValue的值为null parentNode可能是Document或Element 其子节点可能是Element、Text、Comment、ProcessingInstruction、CDATASection或EntityReference 要访问元素的标签名，可以使用nodeName属性，也可以使用tagName属性，这两个属性会返回相同的值： 1&lt;div id='myDiv'&gt;&lt;/div&gt; 123var div = document.getElementById('myDiv');console.log(div.tagName); //DIVconsole.log(div.tagName == div.nodeName); //true 在HTML中，标签名始终都以全部大写表示，在XML中，标签名始终会与源码中的保持一致。最好在比较之前将标签名转换为相同的大小写形式。 HTML元素所有HTML元素都由HTMLElement类型表示，不是直接通过这个类型，也是通过它的子类型来表示。HTMLElement类型直接继承自Element并添加了一些属性。添加的这些属性分别对应于每个HTML元素中都存在的下列标准特性： id：元素在文档中的唯一标识符 title：有关元素的附加说明信息，一般通过工具提示条显示出来 lang：元素内容的语言代码，很少使用 dir：语言的方向，值为ltr（left-to-right，从左至右）或rtl（right-to-left，从右至左） className：与元素的class特性对应，即为元素指定的CSS类。 上述这些属性都可以用来取得或修改相应的特性值： 1&lt;div id='myDiv' class='bd' title='Body text' lang='en' dir='ltr'&gt;&lt;/div&gt; 123456var div = document.getElementById('myDiv');console.log(div.id); //myDivconsole.log(div.title); //Body textconsole.log(div.lang); //enconsole.log(div.dir); //ltrconsole.log(div.className); //bd 取得特性每个元素都有一或多个特性，这些特性的用途是给出相应元素或其内容的附加信息。操作特性的DOM方法主要有三个，分别是getAttribute()、setAttribute()和removeAttribute()。这三个方法可以针对任何特性使用，包括那些以HTMLElement类型属性的形式定义的特性： 123456var div = document.getElementById('myDiv');console.log(div.getAttribute('id')); //myDivconsole.log(div.getAttribute('title')); //Body textconsole.log(div.getAttribute('lang')); //enconsole.log(div.getAttribute('dir')); //ltrconsole.log(div.getAttribute('class')); //bd 通过getAttribute()方法也可以取得自定义特性的值： 1&lt;div id="myDiv" my_special_attribute="hello"&gt;&lt;/div&gt; 1var value = div.getAttribute('my_special_attribute'); 特性（attribute）的名称是不区分大小写的，ID和id代表的都是同一个特性。 根据HTML5规范，自定义特性应该加上data-前缀以便验证。 任何元素的所有特性，也都可以通过DOM元素本身的属性来访问。不过，只有公认的（非自定义的）特性才会以属性的形式添加到DOM对象中： 1&lt;div id="myDiv" align='left' my_special_attribute="hello"&gt;&lt;/div&gt; 123console.log(div.id); //myDivconsole.log(div.my_special_attribute); //undefined(IE除外)console,log(div.align); //left 有两类特殊的特性，它们虽然有对应的属性名，但属性的值与通过getAttribute()返回的值并不相同： 第一类特性就是style，用于通过CSS为元素指定样式。在通过getAttribute()访问时，返回的style特性值中包含的是CSS文本，而通过属性来访问它则会返回一个对象。由于style属性是以编程方式访问元素样式，因此并没有直接映射到style特性。 第二类特性是onclick这样的事件处理程序。当在元素上使用时，onclick特性中包含的是JavaScript代码，如果通过getAttribute()访问，则会返回相应代码的字符串。而在访问onclick属性时，则会返回一个JavaScript函数（如果未在元素中指定相应特性，则返回null）。这是因为onclick及其他事件处理程序属性本身就应该被赋予函数值。 由于存在这些差别，在通过JavaScript以编程方式操作DOM时，开发人员经常不使用getAttribute()，而是使用对象的属性，只有在取得自定义特性值的情况下，才会使用getAttribute()方法。 设置特性setAttribute()方法接受两个参数：要设置的特性名和值。 如果特性已经存在，setAttribute()会以指定的值替换现有的值；如果特性不存在，setAttribute()则创建该属性并设置相应的值： 12345div.setAttribute('id','someOtherId');div.setAttribute('class','ft');div.setAttribute('title','Some other text');div.setAttribute('lang','fr');div.setAttribute('dir','rtl'); 通过setAttribute()方法既可以操作HTML特性也可以操作自定义特性。通过这个方法设置的特性名会被统一转换为小写形式。 因为所有特性都是属性，所以直接给属性赋值可以设置特性的值。 不过像下面这样为DOM元素添加一个自定义属性，该属性不会自动成为元素的特性： 12div.mycolor = 'red';console.log(div.getAttribute('mycolor')); //null(IE除外) removeAttribute()方法用于彻底删除元素的特性。调用这个方法不仅会清除特性的值，而且也会从元素中完全删除特性。 attribute属性Element类型是使用attributes属性的唯一一个DOM节点类型。attrubutes属性中包含一个NamedNodeMap，与NodeList类似，也是一个动态的集合。元素的每一个特性都由一个Attr节点表示，每个节点都保存在NamedNodeMap对象中。NamedNodeMap对象拥有下列方法： getNamedItem(name)：返回nodeName属性等于name的节点 removeNamedItem(name)：从列表中移除nodeName属性等于name的节点 setNamedItem(node)：向列表中添加节点，以节点的nodeName属性为索引 item(pos)：返回位于数字pos位置处的节点 attributes属性中包含一系列节点，每个节点的nodeName就是特性的名称，而节点的nodeValue就是特性的值。要取得元素的id特性，可以使用下面代码： 1var id = element.attributes.getNamedItem('id').nodeValue; 下面是使用方括号语法通过特性名称访问节点的简写方式： 1var id = element.attributes['id'].nodeValue; 也可以使用下面这种语法来设置特性的值，即先取得特性节点，然后再将其nodeValue设置为新值： 1element.attributes['id'].nodeValue = 'someOtherId'; 调用removeNamedItem()方法与在元素上调用removeAttribute()方法的效果相同：直接删除具有给定名称的特性。两个方法唯一的区别就是removeNamedItem()会返回表示被删除特性的Attr节点。 setNamedItem()是一个不常用的方法，通过这个方法可以为元素添加一个新特性，为此需要为它传入一个特性节点。 一般来说，attributes方法不够方便，因此开发人员会更多的使用getAttribute()、removeAttribute()和setAttribute()方法。 如果想要遍历元素的特性，attributes属性倒是可以派上用场。在需要将DOM结构序列化为XML或HTML字符串时，多数会涉及遍历元素特性。下面代码迭代元素的每个特性，然后将它们构造成name=&#39;value&#39; name=&#39;value&#39;这样的字符串格式： 1234567891011121314function outputAttributes(element)&#123; var pairs = new Array(), attrName, attrValue, i, len; for (i = 0, len = element.attributes.length; i &lt; len; i++)&#123; attrName = element.attributes[i].nodeName; attrValue = element.attributes[i].nodeValue; pairs.push(attrName + '="' + attrValue + '"'); &#125; return pairs.join(" ");&#125; 针对attributes对象中的特性，不同浏览器返回的顺序不同。这些特性在XML或HTML代码中出现的先后顺序，不一定与它们出现在attributes对象中的顺序一致。 创建元素使用document.createElement()方法可以创建新元素。这个方法只接受一个参数，即要创建元素的标签名。这个标签名在HTML文档中不区分大小写，而在XML文档中，则是区分大小写的。 在使用createElement()方法创建新元素的同时，也为新元素设置了ownerDocument属性。此时，还可以操作元素的特性，为它添加更多子节点以及执行其他操作： 123var div = document.createElement('div');div.id = 'myNewDiv';div.className = 'box'; 在新元素上设置这些特性只是给它们赋予了相应的信息。由于新元素尚未被添加到文档树中，因此设置这些特性不会影响浏览器的显示。要把新元素添加到文档树中，可以使用appendChild()、insertBefore()或replaceChild()方法。 一旦将元素添加到文档树中，浏览器就会立刻呈现该元素。 元素的子节点childNodes属性中包含了元素的所有子节点，这些子节点可能是元素、文本节点、注释或处理指令。不同浏览器在看待这些节点方面存在显著的不同。以下面代码为例： 12345&lt;ul id='myList'&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;li&gt;Item 3&lt;/li&gt;&lt;/ul&gt; 如果IE来解析上面代码，那么&lt;ul&gt;元素会有3个子节点，分别是3个&lt;li&gt;元素。但如果是在其他浏览器中，&lt;ul&gt;元素都会有7个元素，包括3个&lt;li&gt;元素和4个文本节点（表示&lt;li&gt;元素之间的空白符）。如果需要通过childNodes属性遍历子节点，一定不要忘记浏览器间的这一差别。这意味着在执行某项操作以前，通常都要先检查一下nodeType属性： 12345for (var i = 0; len = element.childNodes.length; i &lt; len; i++)&#123; if (element.childNodes[i].nodeType == 1) &#123; //执行某些操作 &#125;&#125; 元素也支持getElementsByTagName()方法。在通过元素来调用这个方法时，除了搜索起点是当前元素之外，其他方面都跟通过document调用这个方法相同，因此结果只会返回当前元素的后代。 Text类型文本节点由Text类型表示，包含的是可以照字面解释的纯文本内容。纯文本中可以包含转义后的HTML字符，但不能包含HTML代码。Text节点具有以下特征： nodeType的值为3 nodeName的值为#text nodeValue的值为节点所包含的文本 parentNode是一个Element 不支持子节点 可以通过nodeValue属性或data属性访问Text节点中包含的文本，这两个属性中包含的值相同。对nodeValue的修改也会通过data反映出来，反之亦然。使用下列方法可以操作节点中的文本： appendData(text)：将text添加到节点的末尾 deleteData(offset, count)：从offset指定的位置开始删除count个字符 insertData(offset, text)：在offset指定的位置插入text replaceData(offset, count, text)：用text替换从offset指定的位置开始到offset+count为止处的文本 splitText(offset)：从offset指定的位置将当前文本节点分成两个文本节点 substringData(offset, count)：提取从offset指定的位置开始到offset+count为止处的字符串 除了这些方法以外，文本节点还有一个length属性，保存着节点中字符的数目。而且nodeValue.length和data.length中也保存着同样的值。 在默认情况下，每个可以包含内容的元素最多只能有一个文本节点，而且必须确实有内容存在。 在修改文本节点时，字符串会经过HTML（或XML）编码。也就是，小于号、大于号或引号都会像下面一样被转义： 12//输出结果 'some &amp;lt;strong&amp;gt;other&amp;lt;/strong&amp;gt; message'div.firstChild.nodeValue = 'some &lt;strong&gt;other&lt;/strong&gt; message' 创建文本节点document.createTextNode()方法可以创建新文本节点，这个方法接受一个参数：要插入节点中的文本。与设置已有文本节点的值一样，作为参数的文本也将按照HTML或XML的格式进行编码。 创建新文本节点的同时，也会为其设置ownerDocument属性。不过，除非把新节点添加到文档树中已经存在的节点中，否则不会再浏览器窗口中看到新节点： 1234567var element = document.createElement('div');element.className = 'message';var textNode = document.createTextNode('hello world');element.appendChild(textNode);document.body.appendChild(element); 一般情况下，每个元素只有一个文本子节点，不过，在某些情况下也可能包含多个文本子节点： 12345678910var element = document.createElement('div');element.className = 'message';var textNode = document.createTextNode('hello world');element.appendChild(textNode);var anotherTextNode = document.createTextNode('yippee');element.appendChild(anotherTextNode);document.body.appendChild(element); 如果两个文本节点是相邻的同胞节点，那么这两个节点中的文本就会连起来显示，中间不会有空格。 规范化文本节点DOM文档中存在相邻的同胞文本节点很容易刀子混乱，因为分不清哪个文本节点表示哪个字符串。normalize()方法可以将相邻文本节点合并，这个方法由Node类型定义的（因而在所有节点类型中都存在）。如果在一个包含两个或多个文本节点的父元素上调用normalize()方法，则会将所有文本节点合并成一个节点，结果节点的nodeValue等于将合并前每个文本节点的nodeValue值拼接起来的值： 123456789101112131415var element = document.createElement('div');element.className = 'message';var textNode = document.createTextNode('hello world');element.appendChild(textNode);var anotherTextNode = document.createTextNode('yippee');element.appendChild(anotherTextNode);document.body.appendChild(element);console.log(element.childNodes.length); //2element.normalize();console.log(element.childNodes.length); //1console.log(element.firstChild.nodeValue); //hello worldyippee 分割文本节点Text类型提供了一个作用与normalize()相反的方法：splitText()。这个方法将一个文本节点分成两个文本节点，即按照指定的位置分割nodeValue值。原来的文本节点将包含从开始带指定位置之前的内容，新文本节点将包含剩下的文本。这个方法将会返回一个新文本节点，该节点与原节点的parentNode相同： 123456789101112var element = document.createElement('div');element.className = 'message';var textNode = document.createTextNode('hello world');element.appendChild(textNode);document.body.appendChild(element);var newNode = element.firstChild.splitText(5);console.log(element.firstChild.nodeValue); //'hello'console.log(newNode.nodeValue); //' world'console.log(element.childNodes.length); //2 Comment类型注释在DOM中是通过Comment类型来表示的。Comment节点具有以下特征： nodeType的值为8 nodeName的值为#comment nodeValue的值是注释的内容 parentNode可能是Document或Element 不支持子节点 Comment类型与Text类型继承自相同的基类，因此它拥有除splitText()之外的所有字符串操作方法。与Text类型相似，也可以通过nodeValue或data属性来取得注释的内容。 注释节点可以通过其父节点访问： 123&lt;div id='myDiv'&gt; &lt;!-- A comment --&gt;&lt;/div&gt; 123var div = document.getElementById('myDiv');var comment = div.firsrChild;console.log(comment.data); //A comment 使用createComment()方法可以创建注释节点。 CDATASection类型CDATASection类型只针对基于XML的文档，表示的是CDATA区域。与Comment类似，CDATASection类型继承自Text类型，因此拥有除splitText()之外的所有字符串操作方法。CDATASection节点具有以下特征： nodeType的值为4 nodeName的值为#cdata-section nodeValue的值是CDATA区域中的内容 parentNode可能是Document或Element 不支持子节点 CDATA区域只会出现在XML文档中，因此多数浏览器会把CDATA区域错误地解析为Comment或Element。 在真正的XML文档中，可以使用document.createCDataSection()来创建CDATA区域。 DocumentType类型DocumentType类型在web浏览器中并不常用。DocumentType包含着与文档的doctype有关的所有信息，它具有下列特征： nodeType的值为10 nodeName的值为doctype的名称 nodeValue的值为null parentNode是Document 不支持子节点 在DOM1级中，DocumentType对象不能动态创建，只能通过解析文档代码的方式来创建。支持它的浏览器会把DocumentType对象保存在document.doctype中。DOM1级描述了DocumentType对象的3个属性：name、entities和notations。其中，name表示文档类型的名称；entities是由文档类型描述的实体的NamedNodeMap对象；notations是由文档类型描述的符号的NamedNodeMap对象。通常，浏览器中的文档使用的都是HTML或XHTML文档类型，因而entities和notations都是空列表（列表中的项来自行内文档类型声明）。name属性保存着文档类型的名称，也就是出现在&lt;!DOCTYPE之后的文本。 DocumentFragment类型在所有节点类型中，只有DocumentFragment在文档中没有对应的标记。DOM规定文档片段（document fragment）是一种轻量级的文档，可以包含和控制节点，但不会像完整的文档那样占用额外的资源。DocumentFragment节点具有以下特征： nodeType的值为11 nodeName的值为#document-fragment nodeValue的值为null parentNode的值为null 子节点可以是Element、ProcessInstruction、Comment、Text、CDATASection或EntityReference。 虽然不能把文档片段直接添加到文档中，但可以将它作为一个仓库来使用，即可以在里面保存将来可能会添加到文档中的节点。要创建文档片段，可以使用document.createDocumentFragment()方法。 文档片段继承了Node的所有方法，通常用于执行那些针对文档的DOM操作。如果将文档中的节点添加到文档片段中，就会从文档树中移除该节点，也不会从浏览器中再看到该节点。添加到文档片段中的新节点同样也不属于文档树。可以通过appendChild()或insertBefore()将文档片段中内容添加到文档中。在将文档片段作为参数传递给这两个方法时，实际上只会将文档片段的所有子节点添加到相应位置上；文档片段本身永远不会成为文档树的一部分。 Attr类型元素的特性在DOM中以Attr类型来表示。在所有浏览器中，都可以访问Attr类型的构造函数和原型。从技术角度讲，特性就是存在与元素attributes属性中的节点。特性节点具有下列特征： nodeType的值为11 nodeName的值是特性的名称 nodeValue的值是特性的值 parentNode的值为null 在HTML中不支持子节点 在XML中子节点可以是Text或EntityReference 尽管它们也是节点，但特性却不被认为是DOM文档树的一部分。开发人员一般很少直接引用特性节点。 Attr对象有3个属性：name、value和specified。其中，name是特性名称（与nodeName的值相同），value是特性的值（与nodeValue的值相同），specified是一个布尔值，用于区别特性是在代码中指定的，还是默认的。 使用document.createAttribute()并传入特性的名称可以创建新的特性节点。 并不建议直接访问特性节点。使用getAttribute()、setAttribute()和removeAttribute()方法远比操作特性节点更为方便。 DOM操作技术动态脚本使用&lt;script&gt;元素可以向页面中插入JavaScript代码，一种方式是通过其src特性包含外部文件，另一种方式就是用这个元素本身来包含代码。 跟操作HTML元素一样，创建动态脚本也有两种方式：插入外部文件和直接插入JavaScript代码。 1234567891011121314151617181920212223//插入外部文件function loadScript(url)&#123; var script = document.createElement('script'); script.type = 'text/javascript'; script.src = url; document.body.appendChild(script);&#125;loadScript('xxx.js');//直接插入JavaScript代码function loadScriptString(code)&#123; var script = document.createElement('script'); script.type = 'text/javascript'; try &#123; script.appendChild(document.createTextNode(code)); &#125;catch (ex) &#123; //抛错说明是IE script.text = code; &#125; document.body.appendChild(script);&#125;loadScriptString('function sayHi()&#123; console.log("hi")&#125;'); 动态样式能够把CSS样式包含到HTML页面中的元素有两个：&lt;link&gt;元素用于包含来自外部的文件；&lt;style&gt;元素用于指定嵌入的样式。 与动态脚本类似，所谓动态样式指在页面刚加载时不存在的样式；动态样式是在页面加载完成后动态添加到页面中的。 1234567891011121314151617181920212223242526//&lt;link&gt;元素用于包含来自外部的文件function loadStyles(url) &#123; var link = document.createElement('link'); link.rel = 'stylesheet'; link.type = 'text/css'; link.href = url; var head = document.getElementByTagName('head')[0]; head.appendChild(link);&#125;loadStyles('xxx.css');//&lt;style&gt;元素用于指定嵌入的样式function loadStyleString(css)&#123; var style = document.createElement('style'); style.type = 'text/css'; try &#123; style.appendChild(document.createTextNode(css)); &#125; catch (ex) &#123; //抛错说明是IE style.styleSheet.cssText = css; &#125; var head = document.getElementsByTagName('head')[0]; head.appendChild(style);&#125;loadStyleString('body&#123;color: red&#125;'); 操作表格为了方便构件表格，HTMLDOM还为&lt;table&gt;、&lt;tbody&gt;和&lt;tr&gt;元素添加了一些属性和方法。 为&lt;table&gt;元素添加的属性和方法如下： caption：保存着对&lt;caption&gt;元素的指针 tBodies：是一个&lt;tbody&gt;元素的HTMLCollection tFoot：保存着对&lt;tfoot&gt;元素的指针 tHead：保存着对&lt;thead&gt;元素的指针 rows：是一个表格中所有行的HTMLCollection createTHead()：创建&lt;thead&gt;元素，将其放到表格中，返回引用 createTFoot()：创建&lt;tfoot&gt;元素，将其放到表格中，返回引用 createCaption()：创建&lt;caption&gt;元素，将其放到表格中，返回引用 deleteTHead()：删除&lt;thead&gt;元素 deleteTFoot()：删除&lt;tfoot&gt;元素 deleteCaption()：删除&lt;caption&gt;元素 deleteRow(pos)：删除指定位置的行 insertRow(pos)：向rows集合中的指定位置插入一行。 为&lt;tbody&gt;元素添加的属性和方法如下： rows：保存着&lt;tbody&gt;元素中行的HTMLCollection deleteRow(pos)：删除指定位置的行 insertRow(pos)：向rows集合中的位置插入一行，返回对新插入行的引用 为&lt;tr&gt;元素添加的属性和方法如下： cells：保存着&lt;tr&gt;元素中单元格的HTMLCollection deleteCell(pos)：删除指定位置的单元格 insertCell(pos)：向cells集合中的指定位置插入一个单元格，返回对新插入单元格的引用 使用这些属性和方法可以大大减少创建表格所需的代码数量。比如创建下面这样的HTML表格： 123456789101112&lt;table border='1' width='100%'&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;Cell 1,1&lt;/td&gt; &lt;td&gt;Cell 2,1&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Cell 1,2&lt;/td&gt; &lt;td&gt;Cell 2,2&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 12345678910111213141516171819202122232425//创建tablevar table = document.createElement('table');table.border = 1;table.width = '100%';//创建tbodyvar tbody = document.createElement('tbody');table.appendChild(tbody);//创建第一行tbody.insertRow(0);tbody.rows[0].insertCell(0);tbody.rows[0].cells[0].appendChild(dcument.createTextNode('Cell 1,1'));tbody.rows[0].insertCell(1);tbody.rows[0].cells[1].appendChild(dcument.createTextNode('Cell 2,1'));//创建第二行tbody.insertRow(1);tbody.rows[1].insertCell(0);tbody.rows[1].cells[0].appendChild(dcument.createTextNode('Cell 1,2'));tbody.rows[1].insertCell(1);tbody.rows[1].cells[1].appendChild(dcument.createTextNode('Cell 2,2'));//将表格添加到文档主体中document.body.appendChild(table); 使用NodeListNodeList、NamedNodeMap和HTMLCollection这三个集合都是动态的，每当文档结构发生变化时，它们都会得到更新。 从本质上说，所有NodeList对象都是在访问DOM文档时实时运行的查询。 1234567891011121314151617181920//下面代码会导致死循环var divs = document.getElementsByTagName('div'), i, div;for(i = 0; i &lt; divs.length; i++)&#123; div = document.createElement('div'); document.body.appendChild(div);&#125;//如果要迭代一个NodeList，最好使用length属性初始化第二个变量，然后将迭代器与该变量进行比较var divs = document.getElementsByTagName('div'), i, len, div;for(i = 0, len = divs.length; i &lt; len; i++)&#123; div = document.createElement('div'); document.body.appendChild(div);&#125; 一般来说，应该尽量减少访问NodeList的次数，因为每次访问NodeList，都会运行一次基于文档查询。所以可以考虑将从NodeList中取得的值缓存起来。 DOM扩展选择符APISelectors API是由W3C发起制定的一个标准，致力于让浏览器原生支持CSS查询。所有实现这一功能的JavaScript库都会写一个基础的CSS解析器，然后再使用已有的DOM方法查询文档并找到匹配的节点。 Selectors API Level1的核心方法是两个方法：querySelector()和querySelectorAll()。在兼容的浏览器中，可以通过document和element类型的实例调用它们。 querySelector()方法querySelector()方法接收一个CSS选择符，返回与该模式匹配的第一个元素，如果没有找到匹配的元素，返回null。 1234567891011//取得body元素var body = document.querySelector('body');//取得ID为‘myDiv’的元素var body = document.querySelector('#myDiv');//取得类为‘selected’的第一个元素var selected = document.querySelector('.selected');//取得类为‘button’的第一个图像元素var img = document.body.querySelector('img.button'); querySelectorAll()方法querySelectorAll()方法接收的参数与querySelector()方法一样，都是一个CSS选择符。但是返回的是所有匹配的元素而不仅仅是一个元素。这个方法返回的是一个NodeList的实例。 具体来说，返回的值实际上是带有所有属性和方法的NodeList，而底层实现则类似于一组元素的快照，而非不断对文档进行搜索的动态查询。这样实现可以避免使用NodeList对象通常会引起的大多数性能问题。 只要传给querySelectorAll()方法的CSS选择符有效，该方法都会返回一个NodeList对象，而且不管找到多少匹配的元素。如果没有找到匹配的元素，NodeList就是空。 能调用querySelectorAll()方法的类型包括Document、DocumentFragment和Element。 12345678//取得某&lt;div&gt;中所有&lt;em&gt;元素var ems = document.getElementById('myDiv').querySelectorAll('em');//取得类为selected的所有元素var selecteds = document.querySelectorAll('.selected');//取得&lt;p&gt;元素中的所有&lt;strong&gt;元素var strongs =document.querySelectorAll('p strong'); 要取得返回的NodeList中的每一个元素，可以使用item()方法，也可以使用方括号语法： 12345var i, len, strong;for (i = 0, len = strong.length; i &lt; len; i++)&#123; strong = strong[i]; //或者strong。item(i) strong.className = 'important';&#125; matchesSelector()方法Selectors API Level2规范为Element类型新增了一个matchesSelector()方法。这个方法接收一个参数，即CSS选择符，如果调用元素与该选择符匹配，返回true；否则，返回false。 123if (document.body.matchesSelector('body.page1'))&#123; //true&#125; 在取得某个元素引用的情况下，使用这个方法能够方便地检测它是否会被querySelector()或querySelectorAll()方法返回。 IE9+通过msMatchesSelector()支持该方法，Firefox3.6+通过mozMatchesSelector()支持该方法，Safari5+和Chrome通过webkitMatchesSelector()支持该方法。所以可以使用下面的包装函数： 1234567891011121314151617function matchesSelector(element, selector) &#123; if (element.matchesSelector)&#123; return element.matchesSelector(selector); &#125; else if (element.msMatchesSelector)&#123; return element.msMatchesSelector(selector); &#125; else if (element.mozMatchesSelector)&#123; return element.mozMatchesSelector(selector); &#125; else if (element.webkitMatchesSelector)&#123; return element.webkitMatchesSelector(selector); &#125; else &#123; throw new Error('Not supported'); &#125;&#125;if (matchesSelector(document.body, 'body.page1'))&#123; //执行操作&#125; 元素遍历对于元素间的空格，IE9及之前版本不会返回文本节点，而其他浏览器都会返回文本节点。这样，导致了在使用childNodes和firstChild等属性时的行为不一致。为了弥补这一差异，同时又保持DOM规范不变，Element Traversal规范新定义了一组属性。 Element Traversal API为DOM元素添加了以下5个属性： childElementCount：返回子元素（不包括文本节点和注释）的个数 firstElementChild：返回第一个子元素；firstChild的元素版 lastElementChild：返回最后一个子元素；lastChild的元素版 previousElementSibling：指向前一个同辈元素；previousSibling的元素版 nextElementSibling：指向后一个同辈元素；nextSibling的元素版 支持的浏览器为DOM元素添加了这些属性，利用这些元素不必担心空白文本节点，从而可以更方便地查找DOM元素。 123456789101112131415//不用Element Traversal新增元素遍历所有子元素var i, len, child = element.firstChild;while (child != element.lastChild) &#123; if (child.nodeType == 1) &#123; //检查是不是元素 processChild(child); &#125; child = child.nextSibling;&#125;//用Element Traversal新增元素遍历所有子元素var i, len, child = element.firstChild;while (child != element.lastElementChild) &#123; processChild(child); //已知其是元素 child = child.nextElementSibling;&#125; HTML5与类相关的扩充getElementsByClassName()方法getElementsByClassName()方法可以通过document对象及所有HTML元素调用该方法。 getElementsByClassName()方法接收一个参数，即一个包含一或多个类名的字符串，返回带有指定类的所有元素的NodeList。传入多个类名时，类名的先后顺序不重要。 1234// 取得所有类中包含username和current的元素，类名先后顺序无所谓var allCurrentUsernames = document.getElementsByClassName('username current');// 取得ID为myDiv的元素中带有类名selected的所有元素var selected = document.getElementById('myDiv').getElementsByClassName('selected'); 调用这个方法时，只有位于调用元素子树中的元素才会返回。在document对象上调用document对象上调用会返回与类名匹配的所有元素，在元素上调用该方法，只会返回后代元素中匹配的元素。 因为返回对象是NodeList，所有使用这个方法与使用getElementsByTagName()以及其他返回NodeList的DOM方法都具有同样的性能问题。 classList属性在操作类名时，需要通过className属性添加、删除和替换类名。因为className中是一个字符串，所以即使只修改字符串一部分，也必须每次都设置整个字符串的值。 1&lt;div class="bd user disabled"&gt;&lt;/div&gt; 1234567891011121314151617181920// 删除user类// 首先取得类名字字符串并拆分成数组var classNames = div.className.split(/\s+/);// 找到要删的类名var pos = 1, i, len;for (i = 0, len = classNames.length; i &lt; len; i++)&#123; if (classNames[i] == 'user')&#123; pos = i; break; &#125;&#125;// 删除类名classNames.splice(i, 1);// 把剩下的类名拼成字符串并重新设置div.className = classNames.join(' '); HTML5新增了一种操作类名的方式，可以让操作更简单也更安全，那就是为所有元素添加classList属性。这个classList属性是新集合类型DOMTokenList的实例。与其他DOM集合类似，DOMTokenList有一个表示自己包含多少元素的length属性，而要取得每个元素可以使用item()方法，也可以使用方括号语法。此外，这个新类型还定义如下方法： add(value)：将给定的字符串值添加到列表中。如果值已经存在，就不添加。 contains(value)：表示列表中是否存在给定的值，如果存在则返回true，否则返回false。 remove(value)：从列表中删除给定的字符串。 toggle(value)：如果列表中已经存在给定的值，删除它；如果列表中没有给定的值，添加它。 123456789101112131415161718// 删除disabled类div.classList.remove('disabled');//添加current类div.classList.add('current');//切换user类div.classList.toggle('user');//确定元素中是否包含既定的类名if (div.classList.contains('bd') &amp;&amp; !div.classList.contains('disabled') ) &#123; // 执行操作&#125;// 迭代类名for (var i = 0, len = div.classList.length; i &lt; len; i++)&#123; doSomething(div.classList[i]);&#125; 有了classList属性，除非你需要全部删除所有类名，或者完全重写元素的class属性，否则也就用不到className属性。 焦点管理HTML5也添加了辅助管理DOM焦点的功能。首先是document.activeElement属性，这个属性始终会引用DOM中当前获得了焦点的元素。元素获得焦点的方式有页面加载、用户输入（通常是通过按Tab键）和在代码中调用focus()方法。 123var button = document.getElementById('myButton');button.focus();alert(document.activeElement === button); // true 默认情况下，文档刚刚加载完成，document.activeElement中保存的是document.body元素的引用。文档加载期间，document.activeElement的值为null。 另外就是新增了document.hasFocus()方法，这个方法用于确定文档是否获得了焦点。 123var button = document.getElementById('myButton');button.focus();alert(document.hasFocus()); // true 通过检测文档是否获得了焦点，可以知道用户是不是正在与页面交互。 查询文档获知哪个元素获得了焦点，以及确定文档是否获得了焦点，这两个功能最重要的用途是提高Web应用的无障碍性。无障碍Web应用的一个主要标志就是恰当的焦点管理，而确切地知道哪个元素获得了焦点是一个极大的进步，至少我们不用再像过去那样靠猜测。 HTMLDocument的变化readyState属性Document的readyState属性有两个可能的值： loading：正在加载文档 complete：已经加载完文档 使用document.readyState的最恰当方式，就是通过它来实现一个指示文档已经加载完成的指示器。在这个属性得到广泛支持之前，要实现这样一个指示器，必须借助onload事件处理程序设置一个标签，表明文档已经加载完毕。document.readyState属性的基本用法如下。 123if (documen.readyState == 'complete') &#123; //执行操作&#125; 兼容模式IE为document添加了一个名为compatMode的属性，这个属性是为了告诉开发人员浏览器采用了哪种渲染模式。 在标准模式下，document.compatMode的值等于CSS1Compat，而在混杂模式下，document.compatMode的值等于BackCompat。 12345if (document.compatMode == 'CSS1Compat') &#123; alert('Standars mode');&#125; else &#123; alert('Quirks mode');&#125; 最终，HTML5把这个属性纳入标准，对其实现做出了明确规定。 head属性作为对document.body引用文档的&lt;body&gt;元素的补充，HTML5新增了document.head属性，引用文档的&lt;head&gt;元素。 字符集属性HTML5新增了几个与文档字符集有关的属性。其中，charset属性表示文档中实际使用的字符集，也可以用来指定新字符集。默认情况下，这个属性的值为UTF-16，但可以通过&lt;meta&gt;元素、响应头部或直接设置charset属性修改这个值。 12alert(document.charset); //'UTF-16'document.charset = 'UTF-8'; 另一个属性是defaultCharset，表示根据默认浏览器及操作系统的设置，当前文档默认的字符集应该是什么。如果文档没有使用默认的字符集，那charset和defaultCharset属性的值可能会不一样： 123if (document.charset != document.defaultCharset) &#123; alert('Custom character set being used');&#125; 通过这两个属性可以得到文档使用的字符编码的具体信息，也能对字符编码进行准确地控制。 自定义数据属性HTML5规定可以为元素添加非标准的属性，但要添加data-前缀，目的是为元素提供与渲染无关的信息，或者提供语义信息。这些属性可以任意添加、随便命名，只要以data-开头即可。 1&lt;div id='myDiv' data-appId='12345' data-myname='tangcheng'&gt;&lt;/div&gt; 添加了自定义属性之后，可以通过元素的dataset属性来访问自定属性的值。dataset属性的值是DOMStringMap的一个实例，也就是一个名值对的映射。 在这个映射中，每个data-name形式的属性都会有一个对应的属性，只不过属性名没有data-前缀： 1234567891011121314var div = document.getElementById('myDiv');//取得自定义属性的值var appId = div.dataset.appId;var myName = div.dataset.myname;//设置值div.dataset.appId = 23456;div.dataset.myname = 'tc';//有没有myname值呢if (div.dataset.myname) &#123; alert('hello, ' + div.dataset.myname);&#125; 如果需要给元素添加一些不可见的数据以便进行其他处理，那就要用到自定义数据属性。在跟踪链接或混搭应用中，通过自定义数据属性能方便地知道点击来自页面中的哪个部分。 插入标记innerHTML属性在读模式下，innerHTML属性返回与调用元素的所有子节点（包括元素、注释和文本节点）对应的HTML标记。 在写模式下，innerHTML会根据指定的值创建新的DOM树，然后用这个DOM树完全替换调用元素原先的所有子节点。 不同浏览器返回的文本格式会有所不同。IE和Opera会将所有标签转换为大写形式，而Safari、Chrome和Firefox则会原原本本地按照原先文档中的格式返回HTML，包括空格和缩进。 在写模式下，innerHTML的值会被解析为DOM子树，替换调用元素原来的所有子节点。因为它的值被认为是HTML，所以其中的所有标签都会按照浏览器处理HTML的标准方式转换为元素。如果设置的值仅是文本而没有HTML标签，那么结果就是设置纯文本。 为innerHTML设置的包含HTML的字符串值与解析后innerHTML的值大不相同： 1234div.innerHTML = 'Hello &amp; welcome, &lt;b&gt;\"reader\"!&lt;/b&gt;';//得到结果如下&lt;div id='content'&gt;Hello &amp;amp; welcome, &lt;b&gt;&amp;quot;reader&amp;quot;!&lt;/b&gt;&lt;/div&gt; 设置了innerHTML之后，可以像访问文档中的其他节点一样访问新创建的节点。 使用innerHTML属性也有一些限制。比如，在大多数浏览器中，通过innerHTML插入&lt;script&gt;元素并不会执行其中的脚本。IE8及更早版本是唯一能在这种情况下执行脚本的浏览器，但必须满足一些条件： 必须为&lt;script&gt;指定defer属性 &lt;script&gt;元素必须位于（微软所谓的）有作用域的元素（scoped element）之后。 &lt;script&gt;元素被认为是无作用域的元素，也就是在页面中看不到的元素，与&lt;style&gt;元素或注释类似。如果通过innerHTML插入的字符串开头就是一个无作用域的元素，那么IE会在解析这个字符串前先删除该元素。 大多数浏览器都支持以直观的方式通过innerHTML插入&lt;style&gt;元素。 并不是所有元素都支持innerHTML属性。不支持innerHTML的元素有：&lt;col&gt;、&lt;colgroup&gt;、&lt;frameset&gt;、&lt;head&gt;、&lt;html&gt;、&lt;style&gt;、&lt;table&gt;、&lt;tbody&gt;、&lt;thead&gt;、&lt;tfoot&gt;和&lt;tr&gt;。 无论什么时候，只要使用innerHTML从外部插入HTML，都应该首先以可靠的方式处理HTML。 outerHTML属性在读模式下，outerHTML返回调用它的元素及所有子节点的HTML标签。 在写模式下，outerHTML会根据指定的HTML字符串创建新的DOM子树，然后用这个DOM子树完全替换调用元素。 12345678&lt;div id="content"&gt; &lt;p&gt;this is a &lt;strong&gt;paragraph&lt;/strong&gt; with a list following it.&lt;/p&gt; &lt;ul&gt; &lt;li&gt;item 1&lt;/li&gt; &lt;li&gt;item 2&lt;/li&gt; &lt;li&gt;item 3&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 如果在&lt;div&gt;元素上调用outerHTML，会返回与上面相同的代码，包括&lt;div&gt;本身。不过，由于浏览器解析和解释HTML标记的不同，结果也会有所不同。 使用outerHTML属性以下面这种方式设置值： 1div.outerHTML = '&lt;p&gt;This is a paragraph&lt;/p&gt;'; 结果就是新创建的&lt;p&gt;元素会取代DOM树中的&lt;div&gt;元素。 insertAdjacentHTML()方法插入标记的最后一个新增方式是insertAdjacentHTML()方法。它接收两个参数：插入位置和要插入的HTML文本。第一个参数必须是下列值之一： beforebegin：在当前元素之前插入一个紧邻的同辈元素 afterbegin：在当前元素之下插入一个新的子元素或在第一个子元素之前再插入新的子元素 beforeend：在当前元素之下插入一个新的子元素或在最后一个子元素之后再插入新的子元素 afterend：在当前元素之后插入一个紧邻的同辈元素 注意，这些值都必须是小写形式。第二个参数是一个HTML字符串，如果浏览器无法解析该字符串，就会抛出错误。 1234567891011//作为前一个同辈元素插入element.insertAdjacentHTML('beforebegin','&lt;p&gt;hello&lt;/p&gt;');//作为第一个子元素插入element.insertAdjacentHTML('afterbegin','&lt;p&gt;hello&lt;/p&gt;');//作为最后一个子元素插入element.insertAdjacentHTML('beforeend','&lt;p&gt;hello&lt;/p&gt;');//作为后一个同辈元素插入element.insertAdjacentHTML('afterend','&lt;p&gt;hello&lt;/p&gt;'); 内存与性能问题使用本节介绍的方法替换子节点可能会导致浏览器的内存占用问题，尤其是在IE中。在删除带有事件处理程序或引用其他JavaScript对象子树时，就有可能导致内存占用问题。假设某个元素有一个事件处理程序（或者引用了一个JavaScript对象作为属性），在使用前述某个属性将该元素从文档树中删除后，元素与事件处理程序之间的绑定关系在内存中并没有一并删除。如果这种情况频繁出现，页面占用的内存数量就会明显增加，因此，在使用innerHTML、outerHTML属性和insertAdjacentHTML()方法时，最好先手工删除要被替换的元素的所有事件处理程序和JavaScript对象属性。 不过，使用这几个属性—特别是使用innerHTML属性与通过多次DOM操作先创建节点再指定它们之间的关系相比，效率要高很多。这是因为在设置innerHTML或outerHTML时，就会创建一个HTML解析器。这个解析器是在浏览器级别的代码基础上运行的，因此比执行JavaScript快得多。不可避免地，创建和销毁HTML解析器也会带来性能损失，所以最好能够将设置innerHTML或outerHTML的次数控制在合理的范围内。 1234567891011// 避免下面这样频繁操作for (var i = 0, len = values.length; i &lt; len; i++)&#123; ul.innerHTML += '&lt;li&gt;' + values[i] + '&lt;/li&gt;'; //每次循环访问两次innerHTML&#125;// 更改var itemsHtml = '';for (var i = 0, len = values.length; i &lt; len; i++)&#123; itemsHtml += '&lt;li&gt;' + values[i] + '&lt;/li&gt;';&#125;ul.innerHTML = itemsHtml; scrollIntoView()方法scrollIntoView()可以在所有HTML元素上调用，通过滚动浏览器窗口或某个容器元素，调用元素就可以出现在视口中。如果给这个方法传入true作为参数，或者不传入任何参数，那么窗口滚动之后会让调用元素的顶部与视口顶部尽可能平齐。如果传入false作为参数，调用元素会尽可能全部出现在视口中，（可能的话，调用元素的底部会与视口顶部平齐）不过顶部不一定平齐。 12//让元素可见document.forms[0].scrollIntoView(); 当页面发生变化时，一般会用这个方法来吸引用户的注意力。实际上，为某个元素设置焦点也会导致浏览器滚动并显示出获得焦点的元素。 专有扩展文档模式IE8引入了一个新的概念叫文档模式。页面的文档模式决定了可以使用什么功能。也就是说，文档模式决定了你可以使用哪个级别的CSS，可以在JavaScript中使用哪些API，以及如何对待文档类型（doctype）。到了IE9，总共有4种文档模式。 IE5：以混杂模式渲染页面。IE8及更高版本中的新功能都无法使用。 IE7：以IE7标准模式渲染页面。IE8及更高版本中的新功能都无法使用。 IE8：以IE8标准模式渲染页面。IE8中的新功能都可以使用，因此可以使用Selectors API、更多CSS2级选择符和某些CSS3功能，还有一些HTML5的功能。不过IE9中的新功能无法使用。 IE9：以IE9标准模式渲染页面。IE9中的新功能都可以使用，比如ECMAScript5、完整的CSS3以及更多HTML5功能。这个文档模式是最高级的模式。 要理解IE8及更高版本的工作原理，必须理解文档模式。 要强制浏览器以某种模式渲染页面，可以使用HTTP头部信息X-UA-Compatible，或通过等价的&lt;meta&gt;标签来设置： 1&lt;meta http-equiv='X-UA-Compatible' content='IE-IEVersion'&gt; 注意，这里IEVersion有以下不同的值，而且这些值不一定与上述4种文档模式对应： Edge：始终以最新的文档模式来渲染页面。忽略文档类型声明。对于IE8，始终保持以IE8标准模式渲染页面。对于IE9，则以IE9标准模式渲染页面。 EmulateIE9：如果有文档类型声明，则以IE9标准模式渲染页面，否则文档模式设置为IE5。 EmulateIE8：如果有文档类型声明，则以IE8标准模式渲染页面，否则文档模式设置为IE5。 EmulateIE7：如果有文档类型声明，则以IE7标准模式渲染页面，否则文档模式设置为IE5。 9：强制以IE9标准模式渲染页面，忽略文档类型声明。 8：强制以IE8标准模式渲染页面，忽略文档类型声明。 7：强制以IE7标准模式渲染页面，忽略文档类型声明。 5：强制将文档模式设置为IE5，忽略文档类型声明。 默认情况下，浏览器会通过文档类型声明来确定是使用最佳的可用文档模式，还是使用混杂模式。 通过document.documentMode属性可以知道给定页面使用的是什么文档模式。 children属性由于IE9之前的版本与其他浏览器在处理文本节点中的空白符时有差异，因此就出现了children属性。这个属性是HTMLCollection的实例，只包含元素中同样还是元素的子节点。 contains()方法在实际开发中，经常需要知道某个节点是不是另一个节点的后代。IE为此率先引入了contains()方法，以便不通过在DOM文档树中查找即可获得这个信息。调用contains()方法的应该是祖先节点，也就是搜索开始的节点，这个方法接收一个参数，即要检测的后代节点。如果被检测的节点是后代节点，该方法返回true；否则，返回false。 1console.log(document.documentElement.contains(document.body)); //true 使用DOM Level3 compareDocumentPosition()也能够确定节点间的关系，它返回一个表示该关系的位掩码（bitmask）。下表列出了这个位掩码的值： 掩码 节点关系 1 无关（给定的节点不在当前文档中） 2 居前（给定的节点在DOM树中位于参考节点之前） 4 居后（给定的节点在DOM树中位于参考节点之后） 8 包含（给定的节点是参考节点的祖先） 16 被包含（给定的节点是参考节点的后代） 为模仿contains()方法，应该关注的是掩码16.可以对compareDocumentPosition()的结果执行按位与，以确定参考节点（调用compareDocumentPosition()方法的当前节点）是否包含给定的节点（传入的节点）： 12var result = document.documentElement.compareDocumentPosition(document.body);console.log(!!(result &amp; 16)); //true 上面代码中result &amp; 16结果是20（表示居后的4加上表示被包含的16），两个逻辑非操作符会将该数值转换成布尔值。 使用一些浏览器及能力检测，就可以写出如下所示的一个通用的contains函数： 1234567891011121314151617function contains(refNode, otherNode) &#123; if (typeof refNode.contains == 'function' &amp;&amp; (!client.engine.webkit || client.engine.webkit &gt;= 522)) &#123; return refNode.contains(otherNode); &#125;else if (typeof refNode.compareDocumentPosition == 'function')&#123; return !!(refNode.compareDocumentPosition(otherNode) &amp; 16); &#125;else &#123; var node = otherNode.parentNode; do &#123; if (node === refNode)&#123; return true; &#125;else &#123; node = node.parentNode; &#125; &#125; while (node !== null); return false; &#125;&#125; 插入文本另外还有两个插入文本的专有属性没有被纳入HTML5规范。 innerText属性通过innerText属性可以操作元素中包含的所有文本内容，包括子文档树中的文本。 在通过innerText读取值时，它会安装由浅入深的顺序，将子文档树中的所有文本拼接起来。 在通过innerText写入值时，结果会删除元素的所有子节点，插入包含相应文本值的文本节点。 12345678&lt;div id="content"&gt; &lt;p&gt;this is a &lt;strong&gt;paragraph&lt;/strong&gt; with a list following it.&lt;/p&gt; &lt;ul&gt; &lt;li&gt;item 1&lt;/li&gt; &lt;li&gt;item 2&lt;/li&gt; &lt;li&gt;item 3&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 对于上面代码中的&lt;div&gt;来说，其innerText属性会返回下列字符串： 12345this is a paragraph with a list following it.item 1item 2item 3 由于不同浏览器处理空白符的方式不同，因此输出的文本可能会也可能不会包含原始HTML代码中的缩进。 使用innerText属性设置这个&lt;div&gt;元素的内容，则只需一行代码： 1div.innerText = 'hello world'; 执行这行代码后，页面的HTML代码就会变成如下所示： 1&lt;div id='content'&gt;hello world&lt;/div&gt; Firefox虽然不支持innerText，但支持作用类似的textContent属性。textContent是DOM Level3规定的一个属性。为了确保跨浏览器兼容，有必要编写一个类似于下面的函数来检测可以使用哪个属性。 1234567891011function getInnerText(element) &#123; return (typeof element.textContent == 'string') ? element.textContent : element.innerText;&#125;function setInnerText(element, text)&#123; if (typeof element.textContent == 'string') &#123; element.textConten = text; &#125; else &#123; element.innerText = text; &#125;&#125; outerText属性除了作用范围扩大到了包含调节它的节点之外，outerText与innerText基本上没有多大区别。 在读取文本值时，outerText与innerText的结果完全一样。 在写模式下，outerText就完全不同，outerText不只是替换调用它的元素的子节点，而是会替换整个元素（包括子节点）。 本质上，新的文本节点会完全取代调用outerText的元素。此后，该元素就从文档中被删除，无法访问。 由于这个属性会导致调用它的元素不存在，建议尽可能不要使用这个属性。 滚动还有其他几个页面滚动专有方法可以在不同浏览器中使用。下面列出的几个方法（Safari和Chrome适用）都是对HTMLElement类型的扩展，因此在所有元素中都可以调用。 scrollIntoViewIfNeeded(alignCenter)：只在当前元素在视口中不可见的情况下，才滚动浏览器窗口或容器元素，最终让它可见。如果当前元素在视口中可见，这个方法什么也不做。如果将可选的alignCenter参数设置为true，则表示尽量将元素显示在视口中部（垂直方向）。 scrollByLines(lineCount)：将元素的内容滚动指定的行高，lineCount值可以是正值，也可以是负值。 scrollByPages(pageCount)：将元素的内容滚动指定的页面高度，具体高度由元素的高度决定。 需要注意的是，scrollIntoView()和scrollIntoViewIfNeeded()的作用对象是元素的容器，而scrollByLined()和scrollByPages()影响的则是元素自身。 12345678// 将页面主题滚动5行document.body.scrollByLines(5);// 在当前元素不可见的时候，让它进入浏览器的视口document.images[0].scrollIntoViewIfNeeded();// 将页面主体往回滚动1页document.body.scrollByPages(-1); 由于scrollIntoView()是唯一一个所有浏览器都支持的方法，因此这个方法最常用。 DOM2和DOM3DOM1级主要定义的是HTML和XML文档的底层结构。DOM2和DOM3级则在这个结构的基础上引入了更多的交互能力，也支持更高级的XML特性。为此DOM2和DOM3级分为许多模块，分别描述了DOM的某个非常具体的子集： DOM2级核心（DOM Level 2 Core）：在1级核心的基础上构建，为节点添加了更多方法和属性 DOM2级视图（DOM Level 2 Views）：为文档定义了基于样式信息的不同视图 DOM2级事件（DOM Level 2 Events）：说明了如何使用事件与DOM文档交互 DOM2级样式（DOM Level 2 Style）：定义了如何以编程方式来访问和改变CSS样式信息 DOM2级遍历和范围（DOM Level 2 Traversal and Range）：引入了遍历DOM文档和选择其特定部分的新接口 DOM2级HTML（DOM Level 2 HTML）：在1级HTML基础上构建，添加了更多属性、方法和新接口 DOM变化DOM2级核心没有引入新类型，它只是在DOM1级的基础上通过增加新方法和新属性来增强既有类型。DOM3级核心同样增强了既有类型，但也引入了一些新类型。 类似地，DOM2级视图和DOM2级HTML模块也增强了DOM接口，提供了新的属性和方法。 可以通过下列代码来确定浏览器是否支持这些DOM模块： 12345var supportsDOM2Core = document.implementation.hasFeature('Core','2.0');var supportsDOM3Core = document.implementation.hasFeature('Core','3.0');var supportsDOM2HTML = document.implementation.hasFeature('HTML','2.0');var supportsDOM2Views = document.implementation.hasFeature('Views','2.0');var supportsDOM2XML = document.implementation.hasFeature('XML','2.0'); 针对XML命名空间的变化有了XML命名空间，不同XML文档的元素就可以混合在一起，共同构成格式良好的文档，而不必担心发生命名冲突。从技术上讲，HTML不支持XML命名空间，但XHTML支持XML命名空间。因此，本节给出的都是XHTML的示例。 命名空间要使用xmlns特性来指定。XHTML的命名空间是http://www.w3.org/1999/xhtml，在任何格式良好XHTML页面中，都应该将其包含在&lt;html&gt;元素中： 12345678&lt;html xmlns='http://www.w3.org/1999/xhtml'&gt; &lt;head&gt; &lt;title&gt;example xhtml page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; hello &lt;/body&gt;&lt;/html&gt; 上面代码中，所有元素默认都被视为XHTML命名空间中的元素。要想明确地为XML命名空间创建前缀，可以使用xmlns后跟冒号，再跟前缀： 12345678&lt;xhtml:html xmlns:xhtml='http://www.w3.org/1999/xhtml'&gt; &lt;xhtml:head&gt; &lt;xhtml:title&gt;example xhtml page&lt;/xhtml:title&gt; &lt;/xhtml:head&gt; &lt;xhtml:body&gt; hello &lt;/xhtml:body&gt;&lt;/xhtml:html&gt; 这里为XHTML的命名空间定义了一个名为xhtml的前缀，并要求所有XHTML元素都以该前缀开头。有时候为了避免不同语言间的冲突，也需要使用命名空间来限定特性： 12345678&lt;xhtml:html xmlns:xhtml='http://www.w3.org/1999/xhtml'&gt; &lt;xhtml:head&gt; &lt;xhtml:title&gt;example xhtml page&lt;/xhtml:title&gt; &lt;/xhtml:head&gt; &lt;xhtml:body xhtml:class='home'&gt; &lt;!--clas带有xhtml前缀--&gt; hello &lt;/xhtml:body&gt;&lt;/xhtml:html&gt; 在基于一种语言编写XML文档的情况下，命名空间实际上也没有什么用。不过，在混合使用两种语言的情况下，命名空间的用处就非常大了。下面是混合了XHTML和SVG语言的文档： 12345678910&lt;html xmlns='http://www.w3.org/1999/xhtml'&gt; &lt;head&gt; &lt;title&gt;example xhtml page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;svg xmlns='http://www.w3.org/2000/svg' version='1.1' viewBox='0 0 100 100' style='width:100%; height:100%'&gt; &lt;rect x='0' y='0' width='100' height='100' style='fill:red'/&gt; &lt;/svg&gt; &lt;/body&gt;&lt;/html&gt; 即使这个文档从技术上说是一个XHTML文档，但因为有了命名空间，其中的SVG代码仍然有效。 对于类似这样的文档来说，最有意思的事发生在调用方法操作文档节点的情况下。例如，在创建一个元素时，这个元素属于哪个命名空间？在查询一个特殊标签名时，应该将结果包含在哪个命名空间中？DOM2级核心通过为大多数DOM1级方法提供特定于命名空间的版本解决了这个问题。 node类型的变化在DOM2级中，Node类型包含下列特定于命名空间的属性。 localName：不带命名空间前缀的节点名称 namespaceURI：命名空间URI或者（在未指定的情况下是）null prefix：命名空间前缀或者（在未指定的情况下是）null 当节点使用了命名空间前缀时，其nodeName等于prefix+&quot;:&quot;+localName。 12345678910&lt;html xmlns='http://www.w3.org/1999/xhtml'&gt; &lt;head&gt; &lt;title&gt;example xhtml page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;s:svg xmlns:s='http://www.w3.org/2000/svg' version='1.1' viewBox='0 0 100 100' style='width:100%; height:100%'&gt; &lt;s:rect x='0' y='0' width='100' height='100' style='fill:red'/&gt; &lt;/s:svg&gt; &lt;/body&gt;&lt;/html&gt; 对于&lt;html&gt;元素来说，它的localName和tagName是html，namespaceURI是http://www.w3.org/1999/xhtml，而prefix是null。对于&lt;s:svg&gt;元素而言，它的localName是svg，tagName是s:svg，namespaceURI是http://www.w3.org/2000/svg，而prefix是s。 DOM3级在此基础上更进一步，又引入了下列与命名空间有关的方法： isDefaultNamespace(namespaceURI)：在指定的namespaceURI是当前节点的默认命名空间的情况下返回true lookupNamespaceURI(prefix)：返回给定prefix的命名空间 lookupPrefix(namespaceURI)：返回给定namespaceURI的前缀 在前面的例子，可以执行下列代码： 1console.log(document.body.isDefaultNamespace('http://www.w3.org/1999/xhtml')); //true Document类型的变化DOM2级中的Document类型也发生了变化，包含下列与命名空间有关的方法： createElementNS(namespaceURI, tagName)：使用给定的tagName创建一个属于命名空间namespaceURI的新元素 createAttributeNS(namespaceURI, attributeName)：使用给定的attributeName创建一个属于命名空间namespaceURI的新特性 getElementsByTagNameNS(namespaceURI, tagName)：返回属于命名空间namespaceURI的tagName元素的NodeList Element类型的变化DOM2级核心有关Element的变化，主要涉及操作特性。新增方法如下： getAttributeNS(namespaceURI, localName)：取得属于命名空间namespaceURI且名为localName的特性 getAttributeNodeNS(namespaceURI, localName)：取得属于命名空间namespaceURI且名为localName的特性节点 getElementsByTagNameNS(namespaceURI, tagName)：返回属于命名空间namespaceURI的tagName元素的NodeList hasAttributeNS(namespaceURI, localName)：确定当前元素是否有一个为localName的特性，而且该特性的命名空间是namespaceURI。注意，DOM2级核心也增加了一个hasAttribute()方法，用于不考虑命名空间的情况 removeAttributeNS(namespaceURI, localName)：删除属于命名空间namespaceURI且名为localName的特性 setAttributeNS(namespaceURI, qualifiedName, value)：设置属于命名空间namespaceURI且名为qualifiedName的特性的值为value setAttributeNodeNS(attNode)：设置属于命名空间namespaceURI的特性节点 NamedNodeMap类型的变化NamedNodeMap类型也新增了下列与命名空间有关的方法。由于特性是通过NamedNodeMap表示的，因此这些方法多数情况下只针对特性使用。 getNamedItemNS(namespaceURI, localName)：取得属于命名空间namespaceURI且名为localName的项 removeNamedItemNS(namespaceURI, localName)：移除属于命名空间namespaceURI且名为localName的项 setNamedItemNS(node)：添加node，这个节点已经事先指定了命名空间信息 由于一般都是用过元素访问特性，所以这些方法很少使用。 其他方面的变化DOM的其他部分在DOM2级核心中也发生了一些变化。这些变化与XML命名空间无关，而是更倾向于确保API的可靠性及完整性。 DocumentType类型的变化DocumentType类型新增了3个属性：publicId、systemId和internalSubset。其中，前两个属性表示的是文档类型声明中的两个信息段，这两个信息段在DOM1级中是没有办法访问到的。以下面的HTML文档类型声明为例： 1&lt;!DOCTYPE HTML PUBLIC '-//W3C//DTD HTML 4.01//EN' 'http://www.w3.org/TR/html4/strict.dtd'&gt; 对这个文档类型声明而言，publicId是-//W3C//DTD HTML 4.01//EN，而systemId是http://www.w3.org/TR/html4/strict.dtd。在支持DOM2级的浏览器中，可以运行： 12console.log(document.doctype.publicId);console.log(document.doctype.systemId); 实际上，很少需要在网页中访问此类信息。 internalSubset属性用于访问包含在文档类型声明中的额外定义，比如： 1&lt;!DOCTYPE HTML PUBLIC '-//W3C//DTD XHTML 1.0 Strict//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd' [&lt;!ELEMENT name (#PCDATA)&gt;]&gt; 访问document.doctype.internalSubset将得到&lt;!ELEMENT name (#PCDATA)&gt;。这种内部子集在HTML中极少用到，在XML中可能会更常见一些。 Document类型的变化Document类型的变化中唯一与命名空间无关的方法是importNode()。这个方法的用途是从一个文档中取得一个节点，然后将其导入到另一个文档，使其成为这个文档结构的一部分。需要注意的是，每个节点都有一个ownerDocument属性，表示所属的文档。如果调用appendChild()时传入的节点属于不同的文档（ownerDocument属性的值不一样），则会导致错误。但在调用importNode()时传入不同文档的节点则会返回一个新节点，这个新节点所有权归当前文档所有。 importNode()方法与Element的cloneNode()方法非常相似，它接受两个参数：要复制的节点和一个表示是否复制子节点的布尔值。返回的结果是原来节点的副本，但能够在当前文档中使用。 12var newNode = document.importNode(oldNode, true); //导入节点及其所有子节点document.body.appendChild(newNode); 这个方法在HTML文档中并不常用，在XML文档中用得比较多。 DOM2级视图模块添加了一个名为defaultView的属性，其中保存着一个指针。指向拥有给定文档的窗口。除此之外，视图规范没有提供什么时候其他视图可用的信息，因而这是唯一一个新增的属性。除IE之外所有浏览器都支持defaultFView属性。在IE中有一个等价的属性名叫parentWindow。 除了上述一个方法和一个属性之外，DOM2级核心还为document.implementation对象规定了两个新方法：createDocumentType()和createDocument()。 createDocumentType()用于创建一个新的DocumentType节点，接收3个参数：文档类型名称、publicId、systemId。由于既有文档的文档类型不能改变，因此createDocumentType()只在创建新文档时有用。 createDocument()用于创建新文档，它接收3个参数：针对文档中元素的namespaceURI、文档元素的标签名、新文档的文档类型。 DOM2级HTML模块也为document.implementation新增了一个createHTMLDocument()方法。这个方法的用途是创建一个完整的HTML文档，包括&lt;html&gt;、&lt;head&gt;、&lt;title&gt;和&lt;body&gt;元素。这个方法只接受一个参数，即新创建文档的标题（放在&lt;title&gt;元素中的字符串），返回新的HTML文档。通过createHTMLDocument()创建的文档是HTMLDocument类型的实例，因而具有该类型的所有属性和方法，包括title和body属性。 Node类型的变化Node类型中唯一与命名空间无关的变化，就是添加了isSupported()方法。与document.implementation引入的hasFeature()方法类似，isSupported()方法用于确定当前节点具有什么能力。这个方法也接受相同的两个参数：特性名和特性版本号。如果浏览器实现了相应特性，而且能够基于给定节点执行该特性，isSupported()就返回true。建议在确定某个特性是否可用时，最好还是使用能力检测。 DOM3级引入了两个辅助比较节点的方法：isSameNode()和isEqualNode()。这两个方法都接受一个节点参数，并在传入节点与引用节点相同或相等时返回true。所谓相同，指的是两个节点引用的是同一个对象。所谓相等，指的是两个节点是相同的类型，具有相等的属性，而且它们的attributes和childNodes属性也相等。 DOM3级还针对为DOM节点添加额外数据引入了新方法。其中setUserData()方法会将数据指定给节点，它接受3个参数：要设置的健、实际的数据（可以说任何数据类型）和处理函数。使用getUserData()并传入相同的健，就可以取得该数据。 12document.body.setUserData('name', 'tc', function () &#123;&#125;);var value = document.body.getUserData('name'); 传入setUserData()中的处理函数会在带有数据的节点被复制、删除、重命名或引入一个文档时调用，因而可以事先决定在上述操作发生时如何处理用户数据。处理函数接收5个参数：表示操作类型的数值（1表示复制，2表示导入，3表示删除，4表示重命名）、数据键、数据值、源节点和目标节点。在删除节点时，源节点是null，在复制节点时，目标节点时null。在函数内部，可以决定如何存储数据： 12345678var div = document.createElement('div');div.setUserData('name', 'tc', function (operation, key, value, src, dest) &#123; if (operation == 1)&#123; dest.setUserData(key, value, function () &#123;&#125;); &#125;&#125;);var newDiv = div.cloneNode(true);console.log(newDiv.getUserData('name')); 框架的变化框架和内嵌框架分别用HTMLFrameElement和HTMLFrameElement表示，它们在DOM2级中都有一个新属性，叫contentDocument。这个属性包含一个指针，指向表示框架内容的文档对象。 由于contentDocument属性是Document类型的实例，因此可以像使用其他HTML文档一样使用它，包括所有属性和方法。 样式在HTML中定义样式的方式有3种： 通过&lt;link&gt;元素包含外部样式表文件 使用&lt;style&gt;元素定义嵌入式样式 使用style特性定义针对特定元素的样式 DOM2级样式模块围绕这个3种应用样式的机制提供了一套API。要确定浏览器是否支持DOM2级定义的CSS能力，可以使用下列代码： 12var supportsDOM2CSS = document.implementation.hasFeature('CSS','2.0');var supportsDOM2CSS2 = document.implementation.hasFeature('CSS2','2.0'); 访问元素的样式任何支持style特性的HTML元素在JavaScript中都有一个对应的style属性。这个style对象是CSSStyleDeclaration的实例，包含着通过HTML的style特性指定的所有样式信息，但不包含与外部样式表或嵌入样式表经层叠而来的样式。在style特性中指定的任何CSS属性都将表现为这个style对象的相应属性。对于使用短划线（如background-image等）的CSS属性名，必须将其转换成驼峰大小写形式，才能通过JavaScript来访问。 多数情况下，都可以通过简单地转换属性名的格式来实现转换。其中一个不能直接转换的CSS属性就是float。由于float是JavaScript中的保留字，因此不能用作属性名。DOM2级样式规范规定样式对象上相应的属性名应该是cssFloat；Firefox、Safari、Opera和Chrome都支持这个属性，而IE支持的则是styleFloat。 只要取得一个有效的DOM元素的引用，就可以随时使用JavaScript为其设置样式。以这种方式改变样式时，元素的外观会自动被更新。在时间中最好始终都指定度量单位。 通过style对象同样可以取得在style特性中指定的样式。如果没有为元素设置style特性，那么style对象中可能会包含一些默认的值，但这些值并不能准确地反映该元素的样式信息。 DOM样式属性和方法DOM2级样式规范还为style对象定义了一些属性和方法。这些属性和方法在提供元素的style特性值的同时，也可以修改样式： cssText：通过它能够访问到style特性中的CSS代码 length：应用给元素的CSS属性的数量 parentRule：表示CSS信息的CSSRule对象 getPropertyCSSValue(propertyName)：返回包含给定属性值的CSSValue对象 getPropertyPriority(propertyName)：如果给定的属性使用了!important设置，则返回important；否则，返回空字符串 getPropertyValue(propertyName)：返回给定属性的字符串值 item(index)：返回给定位置的CSS属性的名称 removeProperty(propertyName)：从样式中删除给定属性 setProperty(propertyName,value,priority)：将给定属性设置为相应的值，并加上优先权标志（important或者一个空字符串） 通过cssText属性可以访问style特性中的CSS代码。在读取模式下，cssText返回浏览器对style特性中CSS代码的内部表示。在写入模式下，赋给cssText的值会重写整个style特性的值；也就是说，以前通过style特性指定的样式都将丢失，比如，如果通过style特性为元素设置了边框，然后再以不包含边框的规则重写cssText，那么就会抹去元素上的边框。 12myDiv.style.cssText = 'width: 25px; height: 100px; background: red;';console.log(myDiv.style.cssText); 设置cssText是为元素应用多项变化最快捷的方式，因为可以一次性地应用所有变化。 设计length属性的目的，就是将其与item()方法配套使用，以便迭代在元素中定义的CSS属性。使用length和item()时，style对象实际上就相当于一个集合，都可以使用方括号语法来代替item()来取得给定位置的CSS属性。 123for (var i = 0, len = myDiv.style.length; i &lt; len; i++)&#123; console.log(myDiv.style[i]); //或者myDiv.style.item(i);&#125; 无论是使用方括号语法还是使用item()方法，都可以取得CSS属性名（background-color，不是backgroundColor）。然后，就可以在getPropertyValue()中使用了取得的属性名进一步取得的属性的值： 123456var prop, value, i, len;for (i = 0, len = myDiv.style.length; i &lt; len; i++)&#123; prop = myDiv.style[i]; value = myDiv.style.getPropertyValue(prop); console.log(prop + ':' + value);&#125; getPropertyValue()方法取得的始终都是CSS属性值的字符串表示。如果你需要更多信息，可以使用getPropertyCSSValue()方法，它返回一个包含两个属性的CSSValue对象，这两个属性分别是cssText和cssValueType。其中cssText属性的值与getPropertyValue()返回的值相同，而cssValueType属性则是一个数值常量，表示值的类型：0表示继承的值，1表示基本的值，2表示值列表，3表示自定义的值。 123456var prop, value, i, len;for (i = 0, len = myDiv.style.length; i &lt; len; i++)&#123; prop = myDiv.style[i]; value = myDiv.style.getPropertyCSSValue(prop); console.log(prop + ':' + value.cssText + '(' + value.cssValueType + ')');&#125; 要从元素的样式中移除某个CSS属性，需要使用removeProperty()方法。使用这个方法移除一个属性，意味着将会为该属性应用默认的样式（从其他样式表经层叠而来）。在不确定某个给定的CSS属性拥有什么默认值的情况下，就可以使用这个方法。只要移除相应的属性，就可以为元素应用默认值。 计算的样式虽然style对象能够提供支持style特性的任何元素的样式信息，但它不包含那些从其他样式表层叠而来并影响到当前元素的样式信息。DOM2级样式增强了document.defaultView，提供了getComputedStyle()方法。这个方法接受两个参数：要取得计算样式的元素和一个伪元素字符串（例如:after）。如果不需要伪元素信息，第二个参数可以是null。getComputedStyle()方法返回一个CSSStyleDeclaration对象，其中包含当前元素的所有计算的样式。 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; #myDiv&#123; background-color: blue; width: 100px; height: 200px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="myDiv" style="background-color: red; border: 1px solid black"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 以下代码可以获得这个元素计算后的样式： 1234567var myDiv = document.getElementById('myDiv');var computedStyle = document.defaultView.getComputedStyle(myDiv, null);console.log(computedStyle.background); //redconsole.log(computedStyle.width); //100pxconsole.log(computedStyle.height); //200pxconsole.log(computedStyle.border); //在某些浏览器中是1px solid black 边框属性可能会也可能不会返回样式表中实际的border规则（Opera会返回，其他浏览器不会）。存在这个差别的原因是不同浏览器解释综合（rollup）属性（如border）的方式不同，因为设置这种属性实际上会涉及很多其他属性。在设置border时，实际上是设置了四个边的边框宽度、颜色、样式属性。因此，即使computedStyle.border不会在所有浏览器中都返回值，但computedStyle.borderLeftWidth则会返回值。 IE不支持getComputedStyle()方法，但它有一种类似的概念。在IE中，每个具有style属性的元素还有一个currentStyle属性。这个属性是CSSStyleDeclaration的实例，包含当前元素全部计算后的样式。取得这些样式的方式也差不多。 1234567var myDiv = document.getElementById('myDiv');var computedStyle = myDiv.currentStyle;console.log(computedStyle.background); //redconsole.log(computedStyle.width); //100pxconsole.log(computedStyle.height); //200pxconsole.log(computedStyle.border); //在某些浏览器中是1px solid black 无论在哪个浏览器中，最重要的一条是要记住所有计算的样式都是只读的；不能修改计算后样式对象中的CSS属性。此外，计算后的样式也包含属于浏览器内部样式表的样式信息，因此任何具有默认值的CSS属性都会表现在计算后的样式中。 操作样式表CSSStyleSheet类型表示的是样式表，包括通过&lt;link&gt;元素包含的样式表和在style元素中定义的样式表。这两个元素本身分别由HTMLLinkElement和HTMLStyleElement类型表示的。但是，CSSStyleSheet类型相对更加通用一些，它只表示样式表，而不管这些样式表在HTML中是如何定义的。此外，上述两个针对元素的类型允许修改HTML特性，但CSSStyleSheet对象则是一套只读的接口（有一个属性例外）。使用下面代码可以确定浏览器是否支持DOM2级样式表： 1var supportsDOM2StyleSheets = document.implementation.hasFeature('StyleSheets','2.0'); CSSStyleSheet继承自StyleSheet，后者可以作为一个基础接口来定义非CSS样式表。从StyleSheet接口继承而来的属性如下： disabled：表示样式表是否被禁用的布尔值。这个属性是可读写的，将这个值设置为true可以禁用样式表 href：如果样式表是通过&lt;link&gt;包含的，则是样式表的URL；否则，是null media：当前样式表支持的所有媒体类型的集合。与所有DOM集合一样，这个集合也有一个length属性和item()方法。也可以使用方括号语法取得集合中特定的项。如果集合是空列表，表示样式表适用于所有媒体。在IE中，media是一个反应&lt;link&gt;和&lt;style&gt;元素media特性值的字符串 ownerNode：指向拥有当前样式表的节点指针，样式表可能是在HTML中通过&lt;link&gt;或&lt;style&gt;引入的。如果当前样式表是其他样式表通过@import导入的，则这个属性值为null。IE不支持这个属性 parentStyleSheet：在当前样式表是通过@import导入的情况下，这个属性是一个指向导入它的样式表的指针 title：ownerNode中title属性的值 type：表示样式表类型的字符串。对CSS样式表而言，这个字符串是type/css 除disabled属性之外，其他属性都是只读。在支持以上所有这些属性的基础上，CSSStyleSheet类型还支持下列属性和方法： cssRules：样式表中包含的样式规则的合集。IE不支持这个属性，但有一个类似的rules属性。 ownerRule：如果样式表是通过@import导入的，这个属性就是一个指针，指向表示导入的规则，否则，值为null。IE不支持这个属性 deleteRule(index)：删除cssRules集合中指定位置的规则。IE不支持这个方法，但支持一个类似的removeRule()方法 insertRule(rule,index)：向cssRules集合中指定的位置插入rule字符串。IE不支持这个方法，但支持一个类似的addRule()方法 应用于文档的所有样式表是通过document.styleSheets集合来表示的。通过这个集合的length属性可以获知文档中样式表的数量，而通过方括号语法或item()方法可以访问每一个样式表。 12345var sheet = null;for (var i = 0, len =document.styleSheets.length; i &lt; len; i++)&#123; sheet = document.styleSheets[i]; console.log(sheet.href); //输出每一个样式表的href属性(&lt;style&gt;元素包含的样式表没有href属性)&#125; 不同浏览器的document.styleSheets返回的样式表也不同。所有浏览器都会包含&lt;style&gt;元素和rel特性被设置为styleSheet的&lt;link&gt;元素引入的样式表。IE和Opera也包含rel特性被设置为alternate stylesheet的&lt;link&gt;元素引入的样式表。 也可以直接通过&lt;link&gt;或style元素取得CSSStyleSheet对象。DOM规定了一个包含CSSStyleSheet对象的属性，名叫sheet；除了IE，其他浏览器都支持这个属性。IE支持的是styleSheet属性。要想在不同浏览器中都能取得样式表对象，可以使用下列代码： 1234567function getStyleSheet(element) &#123; return element.sheet || element.styleSheet;&#125;//取得第一个&lt;link/&gt;元素引入的样式表var link = document.getElementsByTagName('link')[0];var sheet = getStyleSheet(link); CSS规则CSSRule对象表示样式表中的每一条规则。实际上，CSSRule是一个供其他多种类型继承的基类型，其中最常见的就是CSSStyleRule类型，表示样式信息（其他规则还有@import、@font-face、@page和@charset，但这些规则很少有必要通过脚本来访问）。CSSStyleRule对象包含下列属性： cssText：返回整条规则对应的文本。由于浏览器对样式表的内部处理方式不同，返回的文本可能会与样式表中实际的文本不一样；Safari始终都会将文本转换成全部小写。IE不支持这个属性 parentRule：如果当前规则是导入的规则，这个属性引用的就是导入规则；否则，这个值为null。IE不支持这个属性 parentStyleSheet：当前规则所属的样式表。IE不支持这个属性 selectorText：返回当前规则的选择符文本。由于浏览器对样式表的内部处理方式不同，返回的文本可能会与样式表中实际的文本不一样。在Firefox、Safari、Chrome和IE中 这个属性是只读。Opera允许修改selectorText style：一个CSSStyleDeclaration对象，可以通过它设置和去的规则中特定的样式值 type：表示规则类型的常量值。对于样式规则，这个值是1。IE不支持这个属性 其中三个最常用的属性是cssText、selectorText和style。cssText属性与style.cssText属性类似，但并不相同。前者包含选择符文本和围绕样式信息的花括号，后者只包含样式信息。此外，cssText是只读的，而style.cssText也可以被重写。 大多数情况下，仅使用style属性就可以满足所有操作样式规则的需求了。这个对象就像每个元素上的style属性一样，可以通过它读取和修改规则中的样式信息。 12345div.box&#123; background-color: blue; width: 100px; height: 200px;&#125; 12345678var sheet = document.styleSheets[0]; var rules = sheet.cssRules || sheet.rules; //取得规则列表var rule = rules[0]; //取得第一条规则console.log(rule.selectorText); //div.boxconsole.log(rule.style.cssText); //完整的CSS代码console.log(rule.style.backgroundColor); //blueconsole.log(rule.style.width); //100pxconsole.log(rule.style.height); //200px 使用这种方式，可以像确定元素的行内样式信息一样，确定与规则相关的样式信息。与使用元素的方式一样，在这种方式下也可以修改样式信息： 1234var sheet = document.styleSheets[0];var rules = sheet.cssRules || sheet.rules;var rule = rules[0];rule.style.backgroundColor = 'red' 必须要注意的是，以这种方式修改规则会影响页面中适用于该规则的所有元素。换句话说，如果有两个带有box类的&lt;div&gt;元素，那么这两个元素都会应用修改后的样式。 创建规则DOM规定，要向现有样式表中添加新规则，需要使用insertRule()方法。这个方法接受两个参数：规则文本和表示在哪里插入规则的索引。 1sheet.insertRule('body &#123;background-color: red;&#125;', 0); 上面例子中，插入的规则会成为样式表中的第一条规则。 IE8及更早版本支持一个类似的方法，名叫addRule()，也接受两个必选参数：选择符文本和CSS样式信息；还有一个可选参数：插入规则的位置。 1sheet.addRule('body','background-color:silver',0); 有关这个方法的规定中说，最多可以使用addRule()添加4095条样式规则。 要以跨浏览器 的方式向样式表中插入规则，可以使用下面的函数。这个函数接受4个参数：要向其中添加规则的样式表以及与addRule()相同的3个参数： 1234567function insertRule(sheet, selectorText, cssText, position) &#123; if (sheet.insertRule) &#123; sheet.insertRule(selectorText + '&#123;' + cssText + '&#125;', position); &#125; else if (sheet.addRule)&#123; sheet.addRule(selectorText, cssText, position); &#125;&#125; 如果要添加的规则非常多，建议还是采用第十章中的动态加载样式表的技术。 删除规则从样式表中删除规则的方法是deleteRule()，这个方法接受一个参数：要删除的规则的位置。 1sheet.deleteRule(0); IE支持类似的方法叫removeRule()： 1sheet.removeRule(0); 删除规则可能会影响CSS层叠的效果，因此谨慎使用。 元素大小这部分内容并不属于DOM2级样式规范，但与HTML元素的样式息息相关。所有浏览器都支持这些属性。 偏移量首先要介绍的属性涉及偏移量，包括元素在屏幕上占用的所有可见空间。元素的可见大小由其高度和宽度决定，包括所有内边距、滚动条和边框大小（注意，不包括外边距）。通过下列4个属性可以取得元素的偏移量： offsetHeight：元素在垂直方向上占用的空间大小，以像素计。包括元素的高度、（可见的）水平滚动条的高度、上下边框的高度 offsetWidth：元素在水平方向上占用的空间大小，以像素计。包括元素的宽度、（可见的）垂直滚动条的宽度、左右边框的宽度 offsetLeft：元素的左外边框至包含元素的左内边框之间的像素距离 offsetTop：元素的上边框至包含元素的上内边框之间的像素距离 其中offsetLeft和offsetTop属性与包含元素有关，包含元素的引用保存在offsetParent属性中。offsetParent属性不一定与parentNode的值相等。 要想知道某个元素在页面上的偏移量，将这个元素的offsetLeft和offsetTop与其offsetParent的相同属性相加，如此循环直至根元素，就可以得到一个基本准确的值。 1234567891011121314151617181920212223function getElementLeft(element) &#123; var actualLeft = elemnet.offsetLeft; var current = element.offsetParent; while (current != null)&#123; actualLeft += current.offsetLeft; current = current.offsetParent; &#125; return actualLeft;&#125;function getElementTop(element) &#123; var actualTop = element.offsetTop; var current = element.offsetParent; while (current !== null)&#123; actualTop += current.offsetTop; current = current.offsetParent; &#125; return actualTop;&#125; 所有这些偏移量属性都是只读，而且每次访问它们都需要重新计算。因此，应该尽量避免重复访问这些属性。 客户区大小元素的客户区大小，指的是元素内容及其内边距所占据的空间大小。有关客户区大小的属性有两个：clientWidth和clientHeight。其中，clientWidth属性是元素内容区宽度加上左右内边距宽度；clientHeight属性是元素内容区高度加上上下内边距的高度。 客户区大小就是元素内部的空间大小，因此滚动条占用的空间不计算在内。最常用到这些属性的情况，就是像第八章讨论的确定浏览器视口大小的时候。 12345678910111213function getViewport() &#123; if (document.compatMode == 'BackCompat')&#123; return &#123; width: document.body.clientWidth, heigth: document.body.clientHeight &#125;; &#125; else &#123; return &#123; width: document.documentElement.clientWidth, height: document.documentElement.clientHeight &#125;; &#125;&#125; 客户区大小也是只读的，也是每次访问都要重新计算的。 滚动大小滚动大小指的是包含滚动内容的元素的大小。有些元素（&lt;html&gt;），即使没有执行任何代码也能自动地添加滚动条；但另一些元素，则需要通过CSS的overflow属性进行设置才能滚动。下面是4个与滚动大小相关的属性： scrollHeight：在没有滚动条的情况下，元素内容的总高度 scrollWidth：在没有滚动条的情况下，元素内容的总宽度 scrollLeft：被隐藏在内容区域左侧的像素数。通过设置这个属性可以改变元素的滚动位置 scrollTop：被隐藏在内容区域上方的像素数。通过设置这个属性可以改变元素的滚动位置 在确定文档的总高度时，必须取得scrollWidth/clientWidth和scrollHeight/clientHeight中的最大值，才能保证在跨浏览器的环境下得到精确的结果： 12var docHeight = Math.max(document.documentElement.scrollHeight,document.documentElement.clientHeight);var docWidth = Math.max(document.documentElement.scrollWidth,document.documentElement.clientWidth); 通过scrollLeft和scrollTop属性既可以确定元素当前的滚动状态，也可以设置元素的滚动位置。在元素尚未被滚动时，这两个属性的值都等于0。如果元素被垂直滚动了，那么scrollTop的值会大于0，且表示元素上方不可见内容的像素高度。如果元素被水平滚动了，那么scrollLeft的值会大于0，且表示元素上方不可见内容的像素宽度。这两个属性都可以设置，因此将scrollLeft和scrollTop设置为0，就可以重置滚动位置。 123456// 检测元素是否位于顶部，如果不是滚到顶部function scrollToTop(element) &#123; if (element.screenTop != 0)&#123; element.screenTop = 0; &#125;&#125; 确定元素大小IE、Firefox3+、Safari4+、Opera9.5及Chrome为每个元素都提供了一个getBoundingClientRect()方法。这个方法会返回一个矩形对象，包含4个属性：left、top·、right和bottom。这些属性给出了元素在页面中相对于视口的位置。但是，浏览器的实现稍有不同。IE8及更早版本认为文档的左上角坐标是(2,2)，而其他浏览器包括IE9则将传统的(0,0)作为七点坐标。因此，就需要在一开始检查一下位于(0,0)处的元素的位置，在IE8及更早版本中，会返回(2,2)，而在其他浏览器中会返回(0,0)。 123456789101112131415161718192021function getBoundingClientRect(element) &#123; if (typeof arguments.callee.offset != 'number')&#123; var scrollTop = document.documentElement.scrollTop; var temp = document.createElement('div'); temp.style.cssText = 'position: absolute; left: 0; top: 0;'; document.body.appendChild(temp); arguments.callee.offset = -temp.getBoundingClientRect().top - scrollTop; document.body.removeChild(temp); temp = null; &#125; var rect = element.getBoundingClientRect(); var offset = arguments.callee.offset(); return &#123; left: rect.left + offset, right: rect.right + offset, top: rect.top + offset, bottom: rect.bottom + offset &#125;;&#125; 这个函数使用了它自身的属性来确定是否要对坐标进行调整。第一步是检测属性是否有定义，如果没有定义就定义一个。最终的offset会被设置为新元素上坐标的负值，实际上就是在IE中设置为-2，在Firefox和Opera中设置为-0。为此需要创建一个临时的元素，将其位置设置在(0,0)，然后再调用其getBoundingClientRect()。而之所以要减去视口的scrollTop，是为了防止调用这个函数时窗口被滚动了。这样编写代码，就无需每次调用这个函数都执行两次getBoundingClientRect()。接下来，再在传入的元素上调用这个方法并基于新的计算公式创建一个对象。 对于不支持getBoundingClientRect()的浏览器，可以通过其他手段取得相同的信息。一般来说，right和left的差值与offsetWidth的值相等，而bottom和top的差值与offsetHeight相等。而且left和top属性大致等于使用本章前面定义的getElementLeft()和getElementTop()函数取得的值。综上就可以创建下面这个跨浏览器的函数： 123456789101112131415161718192021222324252627282930313233343536function getBoundingClientRect(element) &#123; var scrollTop = document.documentElement.scrollTop; var scrollLeft = document.documentElement.scrollLeft; if (element.getBoundingClientRect)&#123; if (typeof arguments.callee.offset != 'number')&#123; var scrollTop = document.documentElement.scrollTop; var temp = document.createElement('div'); temp.style.cssText = 'position: absolute; left: 0; top: 0;'; document.body.appendChild(temp); arguments.callee.offset = -temp.getBoundingClientRect().top - scrollTop; document.body.removeChild(temp); temp = null; &#125; var rect = element.getBoundingClientRect(); var offset = arguments.callee.offset(); return &#123; left: rect.left + offset, right: rect.right + offset, top: rect.top + offset, bottom: rect.bottom + offset &#125;; &#125;else &#123; var actualLeft = getElementLeft(element); var actualTop = getElementTop(element); return &#123; left: actualLeft - scrollLeft, right: actualLeft + element.offsetWidth - scrollLeft, top: actualTop - scrollTop, bottom: actualTop + element.offsetHeight - scrollTop &#125; &#125;&#125; 遍历DOM2级遍历和范围模块定义了两个用于辅助完成顺序遍历DOM结构的类型：NodeIterator和TreeWalker。这两个类型能够基于给定的起点对DOM结构执行深度优先的遍历操作。IE不支持DOM遍历，使用下列代码可以检测浏览器对DOM2级遍历能力的支持情况。 123var supportsTraversals = document.implementation.hasFeature('Traversal', '2.0');var supportsNodeIterator = (typeof document.createNodeIterator == 'function');var supportsTreeWalker = (typeof document.createTreeWalker == 'function'); DOM遍历是深度优先的DOM结构遍历，也就是说，移动的方向至少有两个。遍历以给定节点为根，不可能向上超出DOM树的根节点。 12345678910&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;&lt;b&gt;hello&lt;/b&gt;world&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 任何节点都可以作为遍历的根节点。如果假设&lt;body&gt;元素为根节点，那么遍历的第一步就是访问&lt;p&gt;元素，然后再访问同为&lt;body&gt;元素后代的两个文本节点。不过，这次遍历永远不会到达&lt;html&gt;、&lt;head&gt;元素，也不会到达不属于&lt;body&gt;元素子树的任何节点。而以document为根节点的遍历则可以访问到文档中的全部节点。上图展示了对以document为根节点的DOM树进行深度优先遍历的先后顺序。NodeIterator和TreeWalker都以这种方式进行遍历。 NodeIteratorNodeIterator类型是两者中比较简单的一个，可以使用document.createNodeIterator()方法创建它的新实例。这个方法接受下列4个参数： root：想要作为搜索起点的树中节点 whatToShow：表示要访问哪些节点的数字代码 filter：是一个NodeFilter对象，或者一个表示应该接受还是拒绝某种特定节点的函数 entityReferenceExpansion：布尔值，表示是否要扩展实体引用。这个参数在HTML页面中没有用，因为其中的实体引用不能扩展 可以通过createNodeIterator()方法的filter参数来指定自定义的NodeFilter对象，或者指定一个功能类似节点过滤器的函数。每个NodeFilter对象只有一个方法，即acceptNode()；如果应该访问给定的节点，该方法返回NodeFilter.FILTER_ACCEPT，如果不应该访问给定的节点，该方法返回NodeFilter.FILTER_SKIP。由于NodeFilter是一个抽象的类型，因此不能直接创建它的实例。在必要时，只要创建一个包含acceptNode()方法的对象，然后将这个对象传入createNodeIterator()中即可。 123456789var filter = &#123; acceptNode: function (node) &#123; return node.tagName.toLowerCase() == 'p' ? NodeFilter.FIlter_ACCEPT: NodeFilter.FILTER_SKIP; &#125;&#125;;var iterator = document.createNodeIterator(root, NodeFilter.SHOW_ELEMENT, filter, false); NodeIterator类型的主要两个方法是nextNode()和previousNode()。在深度优先的DOM子树遍历中，nextNode()方法用于向前前进一步，而previousNode()用于向后后退一步。在刚刚创建的NodeIterator对象中，有一个内部指针指向根节点，因此第一次调用nextNode()会返回根节点。当遍历到DOM子树的最后一个节点，且previousNode()返回根节点之后，再次调用它就会返回null。 12345678&lt;div id="div1"&gt; &lt;p&gt;&lt;b&gt;hello&lt;/b&gt; world&lt;/p&gt; &lt;ul&gt; &lt;li&gt;list item1&lt;/li&gt; &lt;li&gt;list item2&lt;/li&gt; &lt;li&gt;list item3&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132var div = document.getElementById('div1');var iterator = document.createNodeIterator(div, NodeFilter.SHOW_ELEMENT, null, false);var node = iterator.nextNode();while (node != null)&#123; console.log(node.tagName); /*DIV P B UL LI LI LI*/ node = iterator.nextNode();&#125;------------分割线------------var div = document.getElementById('div1');var filter = function(node)&#123; return node.tagName.toLowerCase() == 'li' ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;&#125;var iterator = document.createNodeIterator(div, NodeFilter.SHOW_ELEMENT, filter, false);var node = iterator.nextNode();while (node != null)&#123; console.log(node.tagName); /*LI LI LI*/ node = iterator.nextNode();&#125; TreeWalkerTreeWalker是NodeIterator的一个更高级的版本。除了nextNode()和previousNode()在内的相同的功能之外，这个类型还提供了下列用于在不同方向上遍历DOM结构的方法。 parentNode()：遍历到当前节点的父节点 firstChild()：遍历到当前节点的第一个子节点 lastChild()：遍历到当前节点的最后一个子节点 nextSibling()：遍历到当前节点的下一个同辈节点 previousSibling()：遍历到当前节点的上一个同辈节点 创建TreeWalker对象要使用document.createTreeWalker()方法，这个方法接收的4个参数与document.createNodeIterator()方法相同：作为遍历起点的根节点、要显示的节点类型、过滤器和一个表示是否扩展实体引用的布尔值。由于这两个创建方法很相似，所以很容易用TreeWalker来代替NodeIterator。 1234567891011121314var div = document.getElementById('div1');var filter = function (node) &#123; return node.tagName.toLowerCase() == 'li' ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;&#125;;var walker = document.createTreeWalker(div, NodeFilter.SHOW_ELEMENT, filter, false);var node = iterator.nextNode();while (node != null)&#123; console.log(node.tagName); node = iterator.nextNode();&#125; filter可以返回的值有所不同。除了NodeFilter.FILTER_ACCEPT和NodeFilter.FILTER_SKIP之外，还可以使用NodeFilter.FILTER_REJECT。在使用NodeIterator对象时，NodeFilter.FILTER_SKIP和NodeFilter.FILTER_REJECT的作用相同：跳过指定的节点。但在使用TreeWalker对象时，NodeFilter.FILTER_SKIP会跳过相应节点继续前进到子树中的下一个节点，而NodeFilter.FILTER_REJECT则会跳过相应节点及该节点的整个子树。 TreeWalker真正强大的地方在于能够在DOM结构中沿任何方向移动。使用TreeWalker遍历DOM树，即使不定义过滤器，也可以取得所有&lt;li&gt;元素： 1234567891011var div = document.getElementById('div1');var walker = document.createTreeWalker(div, NodeFilter.SHOW_ELEMENT, null, false);walker.firstChild(); // 转到&lt;p&gt;walker.nextSibling(); // 转到&lt;ul&gt;var node = walker.firstChild(); // 转到第一个&lt;li&gt;while (node !== null)&#123; console.log(node.tagName); node = walker.nextSibling();&#125; TreeWalker类型还有一个属性，叫currentNode，表示任何遍历方法在上一次遍历中返回的节点。通过设置这个属性也可以修改遍历继续进行的起点： 123var node = walker.nextNode();console.log(node === walker.currentNode); //truewalker.currentNode = document.body; //修改起点 由于IE中没有对应的类型和方法，所以使用遍历的跨浏览器解决方案非常少见。 范围为了让开发人员更方便地控制页面，DOM2级遍历和范围模块定义了范围接口。通过范围可以选择文档中的一个区域，而不必考虑节点的界限。 DOM中的范围DOM2级在Document类型中定义了createRange()方法。在兼容DOM的浏览器中，这个方法属于document对象。使用hasFeature()或者直接检测该方法，都可以确定浏览器是否支持范围。 12var supportsRange = document.implementation.hasFeature('Range', '2.0');var alsoSupportsRange = (typeof document.createRange == 'function'); 如果浏览器支持范围，就可以使用createRange()来创建DOM范围。 1var range = document.createRange(); 与节点类似，新创建的范围也直接与创建它的文档关联在一起，不能用于其他文档。创建了范围之后，接下来就可以使用它在后台选择文档中的特定部分。而创建范围并设置了其他位置之后，还可以针对范围的内容执行很多操作，从而实现对底层DOM树的更精细的控制。 每个范围由一个Range类型的实例表示，这个实例拥有很多属性和方法。下列属性提供了当前范围在文档中的位置信息。 startContainer：包含范围起点的节点（即选区中第一个节点的父节点） startOffset：范围在startContainer中起点的偏移量。如果startContainer是文本节点、注释节点或CDATA节点，那么startOffset就是范围起点之前跳过的字符数量。否则，startOffset就是范围中第一个子节点的索引 endContainer：包含范围终点的节点（即选区中最后一个节点的父节点） endOffset：范围在endContainer中终点的偏移量（与startContainer遵循相同的取值规则） commonAncestorContainer：startContainer和endContainer共同的祖先节点在文档树中位置最深的那个 在把范围放到文档中特定的位置时，这些属性都会被赋值。 用DOM范围实现简单选择要使用范围来选择文档中的一部分，最简单的方式就是使用selectNode()或selectNodeContents()。这两个方法都接收一个参数，即一个DOM节点，然后使用该节点中的信息来填充范围。其中，selectNode()方法选择整个节点，包括子节点，而selectNodeContent()方法则只选择节点的子节点。 123456&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;body&gt; &lt;p id="p1"&gt;&lt;b&gt;hello&lt;/b&gt;world&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 12345var range1 = document.createRange(), range2 = document.createRange(), p1 = document.getElementById('p1');range1.selectNode(p1);range2.selectNodeContents(p1); 在调用selectNode()时，startContainer、endContainer和commonAncestorContainer都等于传入节点的父节点。而startOffset属性等于给定节点在其父节点d childNodes集合中的索引，endOffset等于startOffset加1。 在调用selectNodeContents()时，startContainer、endContainer和commonAncestorContainer等于传入的节点。而startOffset属性始终等于0，因为范围从给定节点的第一个子节点开始。最后，endOffset等于子节点的数量（node.childNodes.length），在这个例子中是2。 此外，为了更精细地控制将哪些节点包含在范围内，还可以使用下列方法： setStartBefore(refNode)：将范围的起点设置在refNode之前，因此refNode也就是范围选区中的第一个子节点。同时会将startContainer属性设置为refNode.parentNode，将startOffset属性设置为refNode在其父节点的childNodes集合中的索引 setStartAfter(refNode)：将范围的起点设置在refNode之后，因此refNode也就不在范围之内了，其下一个同辈节点才是范围选区中的第一个子节点。同时会将startContainer属性设置为refNode.parentNode，将startOffset设置为refNode在其父节点的childNodes集合中的索引加1 setEndBefore(refNode)：将范围的终点设置在refNode之前，因此refNode也就不在范围之内了，其上一个同辈节点才是范围选区中的最后一个子节点。同时会将endContainer属性设置为refNode.parentNode，将endOffset属性设置为refNode在其父节点的childNodes集合中的索引 setEndAfter(refNode)：将范围的终点设置在refNode之后，因此refNode也就是范围选区中的最后一个子节点。同时会将endContainer属性设置为refNode.parentNode，将endOffset属性设置为refNode在其父节点的childNodes集合中的索引加1 在调用这些方法时，所有属性都会自动为你设置好。不过，想要创建复杂的范围选区，也可以直接指定这些属性的值。 用DOM范围实现复杂选择要创建复杂的范围就得使用setStart()和setEnd()方法。这两个方法都接受两个参数：一个参照节点和一个偏移量。 对setStart()来说，参照节点会变成startContainer，而偏移量会变成endOffset。 对setEnd()来说，参照节点会变成endContainer，而偏移量值会变成endOffset。 模仿selectNode()和setNodeContents()并不是setStart()和setEnd()主要用途，它们更胜一筹的地方在于能够选择节点的一部分。 123456&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;body&gt; &lt;p id="p1"&gt;&lt;b&gt;hello&lt;/b&gt;world&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 1234567var p1 = document.getElementById('p1'), helloNode = p1.firstChild.firstChild, //取得'hello' worldNode = p1.lastChild; //取得'world'var range = document.createRange();range.setStart(helloNode, 2); range.setEnd(worldNode, 3); 操作DOM范围中的内容在创建范围时，内部会为了这个范围创建一个文档片段，范围所属的全部节点都被添加到了这个文档片段中。为了创建这个文档片段，范围内容的格式必须正确。前面例子中，创建的选区分别开始和结束于两个文本节点的内部，因此不能算是格式良好的DOM结构，也就无法通过DOM来表示。但是，范围知道自身缺少哪些开标签和闭标签，它能够重新构建有效的DOM结构以便进行操作。 创建范围后，就可以使用各种方法对范围的内容进行操作了。 deleteContents()：从文档中删除范围包含的内容 123456789var p1 = document.getElementById('p1'), //&lt;p id="p1"&gt;&lt;b&gt;hello&lt;/b&gt;world&lt;/p&gt; helloNode = p1.firstChild.firstChild, worldNode = p1.lastChild;var range = document.createRange();range.setStart(helloNode, 2);range.setEnd(worldNode, 3);range.deleteContents(); //&lt;p&gt;&lt;b&gt;he&lt;/b&gt;rld&lt;/p&gt; extractContents()：返回范围内的文档片段。利用这个返回值，可以将范围的内容插入到文档中的其他地方。 1234var fragment = range.extractContents();p1.parentNode.appendChild(fragment);// &lt;p&gt;&lt;b&gt;he&lt;/b&gt;rld&lt;/p&gt;// &lt;b&gt;llo&lt;/b&gt; wo cloneContents()：创建范围对象的一个副本。返回文档片断，和extractContents()不同的是，cloneContents()返回的文档片断包含的是范围中节点的副本，而不是实际节点。 1234var fragment = range.cloneContents();p1.parentNode.appendChild(fragment);// &lt;p&gt;&lt;b&gt;hello&lt;/b&gt; world&lt;/p&gt;// &lt;b&gt;llo&lt;/b&gt; wo 调用上面方法之前，拆分的节点并不会产生格式良好的文档片断，原始的HTML在DOM被修改之前会始终保持不变。 插入DOM范围中的内容使用insertNode()方法可以向范围选区的开始处插入一个节点。 12345var span = document.createElement('span');span.style.color = 'red';span.appendChild(document.createTextNode('Inserted text'));range.insertNode(span);// &lt;p&gt;&lt;b&gt;he&lt;span style="color: red"&gt;Inserted text&lt;/span&gt;llo&lt;/b&gt;world&lt;/p&gt; &lt;span&gt;正好被插入到了hello中的llo前面，而该位置就是范围选区的开始位置。这里原始的HTML并没有添加或删除&lt;b&gt;元素。 除了向范围内部插入内容之外，还可以环绕范围插入内容，此时就要使用surroundContents()方法。这个方法接受一个参数，即环绕范围内容的节点。在环绕范围插入内容时，后台会执行下列步骤： 提取出范围中的内容 将给定节点插入到文档中原来范围所在的位置上 将文档片段的内容添加到给定节点中 可以使用这种技术来突显网页中某些词句： 12345range.selectNode(helloNode);var span = document.createElement('span');span.style.backgroundColor = 'yellow';range.surroundContents(span);// &lt;p&gt;&lt;b&gt;he&lt;/b&gt;&lt;span style="background-color: yellow"&gt;&lt;b&gt;llo&lt;/b&gt; wo&lt;/span&gt;rld&lt;/p&gt; 折叠DOM范围所谓折叠范围，就是指范围中未选择文档的任何部分。可以用文本框来描述折叠范围的过程。假设文本框中有一行文本，你用鼠标选择了其中一个完整的单词。然后，单击鼠标左键，选区消失，而光标则落在了其中两个字母之间。同样，在折叠范围时，其位置会落在文档中的两个部分之间，可能是范围选区的开始位置，也可能是结束位置。 使用collapse()方法来折叠范围，这个方法接受一个参数，一个布尔值，表示要折叠到范围的哪一端。参数true表示折叠到范围的起点，参数false表示折叠到范围的终点。要确定范围已经折叠完毕，可以检查collapsed属性。 12range.collapse(true); //折叠到起点console.log(range.collapsed); //输出true 检测某个范围是否处于折叠状态，可以帮我们确定范围中的两个节点是否紧密相邻。 比较DOM范围在有多个范围的情况下，可以使用compareBoundaryPoints()方法来确定这些范围是否有公共的边界。这个方法接受两个参数：表示比较方式的常量值和要比较的范围。表示比较方式的常量值如下所示： compareBoundaryPoints()方法可能的返回值如下：如果第一个范围中的点位于第二个范围中的点之前，返回-1；如果两个点相等，返回0；如果第一个范围中的点位于第二个范围中的点之后，返回1。 复制DOM范围可以使用cloneRange()方法复制范围。这个方法会创建调用它的范围的一个副本。 1var newRange = range.cloneRange(); 新建的范围与原来的范围包含相同的属性，而修改它的端点不会影响原来的范围。 清理DOM范围在使用完范围之后，最好是调用detach()方法，以便从创建范围的文档中分离出该范围。调用detach()之后，就可以放心地解除对范围的引用，从而让垃圾回收机制回收其内存。 12range.detach();range = null; 在使用范围的最后再执行这两个步骤是比较推荐的方式。一旦分离范围，就不能再恢复使用了。]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Google 的 Material Design]]></title>
    <url>%2F2017%2F08%2F04%2F%E5%85%B3%E4%BA%8EGoogle%20%E7%9A%84%20Material%20Design%2F</url>
    <content type="text"><![CDATA[上个月更新了Chrome（国内连不上Google的服务可以去这个地址更新），最新版本已经完全按照Google自己的Material Design来设计了。现在Google系的软件基本都是Material Design设计风格。 什么是Material DesignMaterial Design是Google提出来的一套设计语言，关于设计语言，我们听得比较多的是Apple的，比如之前的拟物化设计以及现在的扁平化设计（Flat Design）。 这些设计语言都带有品牌的鲜明个性，通过这些不同的设计语言，可以保证不同产品之间的设计风格和交互方式的一致性。 既然Apple推出了扁平化设计语言，Google也不敢落后，于是在2014年Google I/O 大会上推出了Material Design，Google想让Google平台上的开发者掌握这个新设计语言，从而让所有应用就有统一的外观，就像是苹果向开发者提出的设计原则一样。 Material Design的核心思想，就是把物理世界的体验带进屏幕。去掉现实中的杂质和随机性，保留其最原始纯净的形态、空间关系、变化与过渡，配合虚拟世界的灵活特性，还原最贴近真实的体验，达到简洁与直观的效果。 Material Design很重视跨平台体验，所以规范严格细致，保证它在各个平台使用体验高度一致。 Material Design简单介绍Material Design有一套详细的规范，D27在他的掘金专栏中翻译了这套规范。经过作者的授权，下面摘录了Material特性和Material动效这两章内容。 Material特性Material有一套属于自身固定不变的外在特征和内在行为逻辑。 物理特性 Material的尺寸沿x和y轴变化（单位：dp），并且其有着固定不变的厚度（1dp）。 ▼可行 ​ ▼不可行 投影的深浅效果跟Material对象之间的位置距离（z轴）相关。 ​ ▼可行 ​ ▼不可行 任何形状和颜色的内容都能在Material上面显示。添加内容不会增加Material的厚度。 在Material有限的范围内，内容能够随意变化。 Material是立体的。输入事件不能穿过当前被触发的Material对象。 ​ ▼可行 ​ ▼不可行 在空间内，多个Material对象不能同时占据同一个位置。 ​ ▼可行 ​ ▼不可行 一个Material对象不能穿过另一个Material对象。举例，就好比一张纸不能穿过另一张纸一样。 ​ ▼不可行 Material能改变形状 ​ ▼可行 Material沿水平方向放大缩小（沿x和y轴） ​ ▼可行 Material不能弯曲折叠。 ​ ▼不可行 多个Material对象能够合并成为一个Material对象。 ​ ▼可行 被分裂的Material对象能够再次合并。 ​ ▼可行 Material能够出现或消失在空间里的任何地方。 ​ ▼可行 Material能沿任何轴向移动。 ​ ▼可行 Z轴上发生的运动变化一般是用户与Material对象交互的反馈结果。 ​ ▼可行 Material动效动效向我们展示了一个应用是如何运作的，以及它能做什么。 动效的作用： 引导用户关注 当用户完成输入后暗示用户将会发生什么 强调组件之间的层次和空间关系 缓解用户等待焦虑（如内容抓取或加载下一个视图） 为用户带来个性、精良、愉悦的视觉感受 Material是如何运动的？整个Material环境的搭建灵感来源于现实世界，其中借鉴了现实中的重力和摩擦力。这些力在Material环境中主要体现在用户输入的方式对组件的影响和多个组件之间如何交互。 Material的动效具备以下特点： 响应 Material是充满活力的物质。当用户触发、输入的时候它能够迅速作出响应。 在移动端上，篇幅长的动效时长在300-400ms之间。篇幅短的动效时长在150-200ms之间。动效时长如果少于或者超过以上建议时长的话，用户就会感到动效运动缓慢或者动效运动太快导致肉眼难以捕捉： 墨水逐渐扩散的动效被用于确认用户输入。同时卡片（card）高度抬起暗示用户已经触发： 自然 因为参考了现实世界中力对物体的影响，所以Material的动效自然并贴近现实。 在现实世界中，一个物体运动不管加速还是减速都会受到重力和摩擦力的影响。同理，在Material Design中，对象的运动不会突然的启动和停止： 受重力影响，Material对象沿弧线运动： Material的变化同样沿弧线变化： 认知 Material具备认知周边环境（包括用户和其他Material对象）的能力。它能够联合其他Material对象一同回应用户需求。 当转场的时候，为了确定相互之间的关系，这些Material的动效按编排好的方式运动： 在拥挤的环境中变化大小，Material能够从中挤开合适的空间： Material对象间能够相互吸引并结合： 目的性 Material的动效能够引导用户在正确的时间上关注正确的点。 过渡动效有助于指导用户下一步的交互： 不同的动效可以帮助用户理解当前的活动。比如当前手势对组件是否可用： 动效可以引导用户关注他们需要关注的地方： 好的过渡是怎样的？成功的动效设计具备以下特点： 快速、流畅 一个快速、流畅的动效不会让用户觉得在等待时间： ​ ▼可行 ​ ▼不可行 清晰、连贯 过渡应清晰，简明和条理清楚，避免做得过多。 ​ ▼可行 ​ ▼不可行 当过渡的时候每个组件朝着不同的方向或交叉的路径变化，很容易使用户疑惑： 紧密、一致 在Material Design中，动效具备统一的速度、响应能力和目的。因此在你的应用中那些自定义的动效需要保持内在的连贯一致。 图中是三个不同功能的应用，但是因它们有着看起来相似的动效，令人觉得它们之间有着某种联系： 动效的暗示关于动效的好处请看下面两个例子。 通过过渡动效引导用户进入下一个视图。以生动的动效淡化数据加载带来的等待时间，能有效的减轻用户因等待而产生的焦虑感： 因为没有过渡动效发生和没有一个清晰焦点引导，所以用户不清楚上一个视图和下一个视图之间的联系。其中利用一个旋转的圆形icon代表数据加载的状态，这样做会使得等待在用户面前显得更加凸显，无疑增加了用户等待带来的焦虑感：]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>UX</tag>
        <tag>Material Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《JavaScript高级程序设计》学习笔记（三）]]></title>
    <url>%2F2017%2F07%2F26%2F%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[第八章：BOM 第九章：客户端检测 BOMwindow对象BOM的核心对象是window，它表示浏览器的一个实例。在浏览器中，window对象有双重角色，它既是通过JavaScript访问浏览器窗口的一个接口，又是ECMAScript规定的Global对象。这意味着在网页中定义的任何一个对象、变量和函数，都以window作为其Global对象，因此有权访问parseInt()等方法。 全局作用域由于window对象同时扮演者ECMAScript中Global对象的角色，因此所有在全局作用域中声明的变量、函数都会变成window对象的属性和方法。 1234567var age = 29;function sayAge()&#123; console.log(this.age);&#125;console.log(window.age); //29sayAge(); //29window.sayAge(); //29 定义全局变量与在window对象上直接定义属性还是有一点差别：全局变量不能通过delete操作符删除，而直接在window对象上的定义的属性可以： 1234567891011var age = 29;window.color = 'red';//在IE&lt;9时抛出错误，在其他所有浏览器中都返回falsedelete window.age;//在IE&lt;9时抛出错误，在其他所有浏览器中都返回truedelete window.color;console.log(window.age); //29console.log(window.color); //undefined 使用var语句添加的window属性都有一个名为[[Configurable]]的特性，这个特性的值被设置为false，因此这样定义的属性不可以通过delete 操作符删除。 尝试访问未声明的变量会抛出错误，但是通过查询window对象，可以知道某个可能未声明的变量是否存在： 123456//这里会抛出错误，因为oldValue没有定义var newValue = oldValue;//这里不会抛出错误，因为这是一次属性查询//newValue的值是undefinedvar newValue = window.oldValue; 窗口关系及框架如果页面中包含框架，则每个框架都拥有自己的window对象，并保存在frames集合中。在frames集合中，可以通过数值索引（从0开始，从左至右，从上到下）或者框架名称来访问相应的window对象。每个window对象都有一个name属性，其中包含框架的名称。下面是一个包含框架的页面： 12345678910111213&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;frameset rows="160,*"&gt; &lt;frame src="frame.html" name="topFrame"&gt; &lt;frameset cols="50%,50%"&gt; &lt;frame src="anotherframe.html" name="leftFrame"&gt; &lt;frame src="yetanotherframe.html" name="rightFrame"&gt; &lt;/frameset&gt;&lt;/frameset&gt;&lt;/html&gt; &lt;frame&gt;和&lt;frameset&gt;元素已经从web标准中删除虽然一些浏览器目前仍然支持它，但也许会在未来的某个时间停止支持，请尽量不要使用该特性。 对于上面例子，可以通过window.frames[0]或者window.frames[&#39;topFrame&#39;]来引用上方的框架。不过，最好使用top，而非window来引用这些框架（比如，通过top.frames[0]）。 top对象始终指向最高层（最外层）的框架，也就是浏览器窗口。使用它可以确保在一个框架中正确地访问另一个框架。因为对于在一个框架中编写的任何代码来说，其中的window对象指向的都是那个框架的特定实例，而非最高层的框架。 parent对象始终指向当前框架的直接上层框架。 除非最高层窗口是用过window.open()打开的，否则其window对象的name属性不会包含任何值。 与框架有关的最后一个对象是self，它始终指向window。实际上，window和self对象可以互换使用。引入self对象的目的是为了与top和parent对象对应起来，因此它不包含其他值。 所有这些对象都是window对象的属性，可以通过window.parent、window.top等形式访问。同时，也可以将不同层次的window对象连缀起来，比如window.parent.parent.frames[0]。 窗口位置IE、Safari、Opera和Chrome都提供了screenLeft和screenTop属性，分别用于表示窗口相对于屏幕左边和上边的位置。Firefox则在screenX和screenY属性中提供相同的窗口位置信息，Safari和Chrome也同时支持这两个属性。Opera虽然也支持，但与screenLeft和screenTop属性不对应，因此不建议在Opera中使用。 123var leftPos = (typeof window.screenLeft == 'number')?window.screenLeft:window.screenX;var topPos = (typeof window.screenTop == 'number')?window.screenTop:window.screenY; 在IE、Opera和Chrome中，screenLeft和screenTop中保存的是从显示器屏幕左边和上边到由window对象表示的页面可见区域（浏览器窗口的显示界面）的距离。如果window对象是最外层对象，而且浏览器窗口紧贴屏幕最上端（y轴坐标为0），那么screenTop的值就是位于页面可见区域上方的浏览器工具栏的像素高度。但是，在Firefox和Safari中，screenY或screenTop中保存的是整个浏览器窗口相对于屏幕的坐标值，即在窗口的y轴坐标为0时返回0。 Firefox、Safari和Chrome始终返回页面中每个框架的top.screenX和top.screenY值。即使在页面由于被设置了外边距而发生偏移的情况下，相对于window对象使用screenX和screenY每次也都会返回相同的值。而IE和Opera则会给出框架相对于屏幕边界的精确坐标值。 这样就无法在跨浏览器的条件下取得窗口左边和上边的精确坐标值。然而用moveTo()和moveBy()方法倒是有可能将窗口精确地移动到一个新位置。这两个方法都接收两个参数，其中moveTo()接收的是新位置的x和y坐标值，而moveBy()接收的是在水平和垂直方向上移动的像素数。 1234567891011//将窗口移动到屏幕的左上角window.moveTo(0,0);//将窗口向下移动100像素window.moveBy(0,100);//将窗口移动到（200，300）window.moveTo(200,300);//将窗口向左移动50pxwindow.moveBy(-50,0); 这两个方法可能会被浏览器禁用，在Opera和IE7（及更高版本）中默认就是禁用。而且这两个方法不适用与框架，只能对最外层的window使用。 窗口大小IE9+、Firefox、Safari、Opera和Chrome都为确定窗口大小提供了四个属性：innerWidth、innerHeight、outerWidth和outerHeight。 在IE9+、Safari和Firefox中，outerWidth和outerHeight返回浏览器窗口本身的尺寸。 在Opera中，outerWidth和outerHeight两个属性的值表示页面视图容器（Opera中单个标签页对应的浏览器窗口）的大小。而innerWidth和innerHeight表示该容器中页面视图区的大小（减去边框的宽度）。 在Chrome中，outerWidth、outerHeight和innerWidth、innerHeight返回相同的值，即视口（viewport）大小而非浏览器窗口大小。 IE8及更早版本没有提供取得当前浏览器窗口尺寸的属性，不过，它通过DOM提供了页面可见区域的相关信息。 在IE、Firefox、Safari、Opera和Chrome中，document.documentElement.clientWidth和document.documentElement.clientHeight中保存了页面视口的信息。在IE6中，这个属性必须在标准模式下才能有效，如果是混杂模式，就必须通过document.body.clientWidth和document.body.clientHeight取得相同信息。而对于混杂模式下的Chrome。document.documentElement.clientWidth、document.documentElement.clientHeight和document.body.clientWidth、document.body.clientHeight属性都可以取得视口的大小： 123456789101112var pageWidth = window.innerWidth, pageHeight = window.innerHeight;if (typeof pageWidth != 'number')&#123; //检查保存的是不是一个数值 if (document.cpmpatMode == 'CSS1Compat')&#123; //确定页面是否处于标准模式 pageWidth = document.documentElement.clientWidth; pageHeight = document.documentElement.clientHeight; &#125; else &#123; pageWidth = document.body.clientWidth; pageHeight = document.body.clientHeight; &#125;&#125; 对于移动设备，window.innerWidth和window.innerHeight保存着可见视口，也就是屏幕上可见页面区域的大小。 在移动浏览器中，document.documentElement度量的是布局视口，即渲染后页面的实际大小（与可见视口不同，可见视口只是整个页面中的一小部分）。 最好先检测一下用户是否在使用移动设备，然后再决定使用哪个属性。 使用resizeTo()和resizeBy()方法可以调整浏览器窗口的大小。这两个方法都接收两个参数，其中resizeTo()接收浏览器窗口的新宽度和新高度，而resizeBy()接收新窗口与原窗口的宽度和高度之差。 12345678//调整到100*100window.resizeTo(100,100);//调整到200*150window.resizeBy(100,50);//调整到300*300window.resizeTo(300,300); 这两个方法与移动窗口位置的方法类似，也有可能被浏览器禁用；在Opera和IE7（及更高版本）中默认就是禁用。而且这两个方法不适用与框架，只能对最外层的window使用。 导航和打开窗口使用window.open()方法既可以导航到特定的URL，也可以打开一个新的浏览器窗口。这个方法可以接收四个参数：要加载的URL、窗口目标、一个特性字符串以及一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值。通常只需传递第一个参数，最后一个参数只在不打开新窗口的情况下使用。 如果为window.open()传递第二个参数，而且该参数是已有窗口活框架的名称，那么就会在具有该名称的窗口或框架中加载第一个参数指定的URL： 12//等同于&lt;a href="http://www.google.com" target="topFrame"&gt;&lt;/a&gt;window.open('http://www.google.com','topFrame'); 此外。第二个参数也可以是下面任何一个特殊的窗口名称：_self、_parent、_top或_blank。 弹出窗口如果给window.open()传递的第二个参数并不是一个已经存在的窗口或框架，那么该方法就会根据第三个参数位置上传入的字符串创建一个新窗口或新标签页。如果没有传入第三个参数，那么就会打开一个带有全部默认设置（工具栏、地址栏和状态栏等）的新浏览器窗口（或打开一个新标签页—根据浏览器设置）。在不打开新窗口的情况下，会忽略第三个参数。 第三个参数是一个逗号分隔的设置字符串，表示在新窗口中都显示哪些特性。下面列出了出现在这个字符串中的设置选项： 1window.open('http://www.google.com','weoxWindow','heigh=400,width=400,top=10,left=10,resizeable=yes');//第三个参数中不允许出现空格 window.open()方法会返回一个指向新窗口的引用。引用的对象与其他window对象大致相似，但可以进行更多的控制。例如，有些浏览器在默认情况下可能不允许针对主浏览器窗口调整大小或移动位置，但允许针对通过window.open()创建的窗口大小或移动位置。通过这个返回对象。可以像操作其他窗口一样操作新打开的窗口： 1234567var wroxWin = window.open('http://www.google.com','weoxWindow','heigh=400,width=400,top=10,left=10,resizeable=yes');//调整大小wroxWin.resizeTo(500,500);//移动位置wroxWin.moveTo(100,100); 调用close()方法还可以关闭新打开的窗口。 1wroxWin.close(); 但是这个方法仅适用于通过window.open()打开的弹出窗口。对于浏览器主窗口，如果没有得到用户的允许是不能关闭它。不过，弹出窗口倒是可以调用top.close()在不经用户允许的情况下关闭自己。弹出窗口关闭以后，窗口的引用仍然还在，但除了像下面这样检测其closed属性之外，已经没有其他用处了， 12wroxWin.close();console.log(wroxWin.closed); //true 新创建的window对象有一个opener属性，其中保存着打开它的原始窗口对象。这个属性只在弹出窗口中的最外层window对象（top）中有定义，而且指向调用window.open()的窗口或框架： 123var wroxWin = window.open('http://www.google.com','weoxWindow','heigh=400,width=400,top=10,left=10,resizeable=yes');console.log(wroxWin.opener == window); //true 虽然弹出窗口中有一个指针指向打开它的原始窗口，但原始窗口中并没有这样的指针指向弹出窗口。窗口并不跟踪记录它们打开的弹出窗口，因此只能在必要的时候手动实现跟踪。 有些浏览器（如IE8和Chrome）会在独立的进程中运行每个标签页。当一个标签页打开另一个标签页时，如果两个window对象之间需要彼此通信，那么新标签页就不能在独立的进程中。在Chrome中，将新创建的标签页的opener属性设置为null，即表示在单独的进程中运行新标签页： 123var wroxWin = window.open('http://www.google.com','weoxWindow','heigh=400,width=400,top=10,left=10,resizeable=yes');wroxWin.opener = null; 将opener属性设置为null就是告诉浏览器新创建的标签页不需要与打开它的标签页通信，因此可以在独立的进程中运行。标签页之间的联系一旦切断，将无法恢复。 弹出窗口屏蔽程序如果是浏览器内置的屏蔽程序阻止的弹出窗口，那么window.open()很可能会返回null。此时，只要检测这个返回值就可以确定弹出窗口是否被屏蔽： 1234var wroxWin = window.open('http://www.google.com','_blank');if (wroxWin == null)&#123; console.log('the popup was blocked!');&#125; 如果是浏览器扩展或其他程序阻止的弹出窗口，那么window.open()通常会抛出一个错误。因此，想准确地检测出弹出窗口是否被屏蔽，必须在检测返回值的同时，将window.open()的调用封装在一个try-catch块中： 1234567891011121314var blocked = false;try &#123; var wroxWin = window.open('http://www.google.com','_blank'); if (wroxWin == null)&#123; blocked = true; &#125;&#125; catch (ex) &#123; blocked = true;&#125;if (blocked) &#123; console.log('the popup was blocked!');&#125; 间歇调用和超时调用JavaScript是单线程语言，但它允许通过设置超时值和间歇时间来调度代码在特定的时刻执行。前者是在指定的时间过后执行代码，而后者则是每隔指定的时间就执行一次代码。 超时调用需要使用window对象的setTimeout()方法，它接受两个参数：要执行的代码和以毫秒表示的时间（即在执行代码前需要等待多少毫秒）。其中，第一个参数可以是包含JavaScript代码的字符串，也可以是一个函数： 1234567//不推荐传递字符串，可能会导致性能损失setTimeout('alert("hello")',1000);//推荐的调用方式setTimeout(function()&#123; alert("hello");&#125;,1000); 第二个参数是一个表示等待多长时间的毫秒数，但经过该时间后指定的代码不一定会执行。JavaScript是一个单线程序的解释器，因此一定时间内只能执行一段代码。为了控制要执行的代码，就有一个JavaScript任务队列。这些任务会按照它们添加到队列的顺序执行。setTimeout()的第二个参数告诉JavaScript再过多长时间把当前任务添加到队列中。如果队列是空，那么添加的代码会立即执行；如果队列不是空，那么它就要等前面的代码执行完后再执行。 调用setTimeout()之后，该方法会返回一个数值ID，表示超时调用。这个超时调用ID是计划执行代码的唯一标识符，可以通过它来取消超时调用。要取消尚未执行的超时调用计划，可以调用clearTimeout()方法并将相应的超时调用ID作为参数传递给它： 1234567//设置超时调用var timeoutID = setTimeout(function()&#123; console.log('hello');&#125;,1000);//把它取消clearTimeout(timeoutID); 只要是在指定的时间尚未过去之前调用clearTimeout()，就可以完全取消超时调用。超时调用的代码是在全局作用域中执行的，因此函数中this的值在非严格模式下指向window对象，在严格模式下是undefined。 间歇调用会按照指定的时间间隔重复执行代码，直至间歇调用被取消或页面被卸载。设置间歇调用的方法是setInterval()，它接受的参数是：要执行的代码和每次执行之前需要等待的毫秒数： 1234567//不推荐传递字符串，可能会导致性能损失setInterval('alert("hello")',1000);//推荐的调用方式setInterval(function()&#123; alert("hello");&#125;,1000); 调用setInterval()方法同样会返回一个间歇调用ID，该ID可用于在未来某个时刻取消间歇调用。要取消尚未执行的间歇调用，可以使用clearInterval()方法并传入相应的间歇调用ID。取消间歇调用的重要性要远远高于取消超时调用，因为在不加干涉的情况下，间歇调用会一直执行到页面卸载。 12345678910111213141516171819202122232425262728293031var num = 0;var max = 10;var intervalID = null;function incrementNumber()&#123; num++; //如果执行次数达到了max设定的值，就取消后续尚未执行的调用 if (num == max)&#123; clearInterval(intervalID); console.log('done'); &#125;&#125;intervalID = setInterval(incrementNumber,500);--------------------------改成超时调用---------------------------var num = 0;var max = 10;function incrementNumber()&#123; num++; //如果执行次数未达到了max设定的值，则设置另一次超时调用 if (num &lt; max)&#123; setTimeout(incrementNumber,500); &#125; else&#123; console.log('done'); &#125;&#125;setTimeout(incrementNumber,500); 在使用超时调用时，没有必要跟踪超时调用ID，因为每次执行代码之后如果不再设置另一次超时调用，调用就会自动停止。一般认为，使用超时调用来模拟间歇调用是一种最佳模式。在开发环境下，很少使用真正的间歇调用，原因是后一个间歇调用可能会在前一个间歇调用结束之前启动。而像上面代码中这样使用超时调用，可以完全避免这点。所以，最好不要使用间歇调用。 系统对话框浏览器通过alert()、confirm()和prompt()方法可以调用系统对话框向用户显示消息。系统对话框与在浏览器中显示的网页没有关系，也不包含HTML。它们的外观由操作系统及浏览器设置决定，而不是CSS决定。此外，通过这几个方法打开的对话框都是同步和模态的。也就是说，显示这些对话框的时候代码会停止执行，而关掉这些对话框后代码又会恢复执行。 alert()方法接收一个字符串并将其显示给用户。调用alert()方法的结果就是向用户显示一个系统对话框，其中包含指定的文本和一个OK（‘‘确定’’）按钮。通常使用alert()生成的警告对话框向用户显示一些他们无法控制的消息，例如错误消息。而用户只能在看完消息后关闭对话框。 confirm()方法与alert()方法的主要区别在于对话框除了显示OK按钮外，还会显示一个Cancel（“取消”）按钮，两个按钮可以让用户决定是否执行给定的操作。confirm()方法返回true表示点击了OK，返回false表示点击了Cancel（‘取消’）或者右上角关闭按钮。 prompt()方法可以用于提示用户输入一些文本。提示框除了显示ok和Cancel之外，还会显示一个文本输入域，以供用户在其中输入内容。这个方法接收两个参数：要显示给用户的文本提示和文本输入域的默认值（可以是一个空字符串）。点击OK返回文本输入域的值，点击Cancel或没有单击OK而通过其他方法关闭了对话框，则返回null。 Chrome浏览器中，如果当前脚本在执行过程中会打开两个或多个对话框，那么从第二个对话框开始，每个对话框中都会显示一个复选框，以便用户阻止后续的对话框显示，除非用户刷新页面。 查找和打印对话框都是异步显示的，能够将控制权立即交还给脚本。这两个对话框与用户用过浏览器菜单的查找和打印命令打开的对话框相同。 12345//显示打印对话框window.print();//显示查找对话框window.find(); location对象location是最有用的BOM对象之一，它提供了与当前窗口中加载的文档有关的信息，还提供了一些导航功能。 location对象既是window对象的属性，也是document对象的属性，也就是window.location和document.location引用的是同一个对象。 location对象的用处不知表现在它保存着当前文档的信息，还表现在它将URL解析为独立的片段，让开发人员可以通过不同的属性访问这些片段。下面列出了location对象的所有属性： 查询字符串参数尽管location.search返回从问号到URL末尾的所有内容，但却没有办法逐个访问其中每个查询字符串参数。可以创建下面这样一个函数，用于解析查询字符串，然后返回包含所有参数的一个对象： 12345678910111213141516171819202122232425262728293031323334function getQueryStringArgs() &#123; //取得查询字符串并去掉开头的问号 var qs = (location.search.length &gt; 0 ? location.search.substring(1) : ""), //保存数据对象 args = &#123;&#125;, //取得每一项 items = qs.length ? qs.split("&amp;") : [], item = null, name = null, value = null, //在for循环中使用 i = 0, len = items.length; //逐个将每一项添加到args对象中 for (i = 0; i &lt; len; i++)&#123; item = items[i].split('='); name = decodeURIComponent(item[0]); value = decodeURIComponent(item[1]); if (name.length) &#123; args[name] = value; &#125; &#125; return args;&#125;//假设查询字符串是 ?q=javascript&amp;num=10var args = getQueryStringArgs(); //每个查询字符串都成了返回对象的属性console.log(args['q']); //javascriptconsole.log(args['num']); //10 位置操作使用location对象可以通过很多方式来改变浏览器的位置。 使用assign()方法并为其传递一个URL，就可以打开新URL并在浏览器的历史记录中生成一条记录。 1location.assign('http://www.google.com'); 如果是将location.href或window.href设置为一个URL值，也会以该值调用assign()方法。 在改变浏览器位置的方法中，最常用的是设置location.href属性。 修改location 对象的其他属性也可以改变当前加载的页面： 12345678910111213141516//假设初识URL为 http://www.wrox.com/WileyCDA//将URL修改为 http://www.wrox.com/WileyCDA/#section1location.hash = '#section1';//将URL修改为 http://www.wrox.com/WileyCDA/?q=javascriptlocation.search = '?q=javascript';//将URL修改为 http://www.yahoo.com/WileyCDA/location.hostname = 'www.yahoo.com';//将URL修改为 http://www.yahoo.com/mydir/location.pathname = 'mydir';//将URL修改为 http://www.yahoo.com:8080/WileyCDA/location.port = 8080; 每次修改location的属性（hash除外），页面都会以新URL重新加载。 当通过上述任何一种方式修改URL之后，浏览器的历史记录中就会生成一条新记录，因此可以通过后退按钮导航到前一个页面。要禁止这种行为，可以使用replace()方法。这个方法只接受一个参数，即要导航到的URL；结果虽然会导致浏览器位置改变，但不会在历史记录中生成新记录。在调用replace()方法之后，用户不能回到前一个页面： 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;enjoy this page for a second, because you won't be coming back here&lt;/p&gt;&lt;script&gt; setTimeout(function () &#123; location.replace('http://tc9011.com') &#125;,1000)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; reload()方法的作用是重新加载当前显示的页面。如果调用reload()时不传递任何参数，页面就会以最有效的方式重新加载。也就是说，如果页面上次请求以来并没有改变过，页面就会从浏览器缓存中重新加载，如果要强制从服务器重新加载，则需要像下面这样为该方法传递参数true： 12location.replace(); //重新加载(可能会从缓存中加载)location.reload(true); //重新加载(从服务器重新加载) 位于reload()调用之后的代码可能也可能不执行，这要取决于网络延迟或系统资源等因素。所以，最好将reload()放在代码的最后一行。 navigator对象通过navigator对象可以识别客户端浏览器。每个浏览器中的navigator对象都有一套自己的属性： 表中的navigator对象的属性通常用于检测显示网页的浏览器类型。 检测插件检测浏览器中是否安装了特定的插件是一种最常见的检测例程。对于非IE浏览器，可以使用plugins数组来达到这个目的。该数组中的每一项都包含下列属性： name：插件的名字 description：插件的描述 filename：插件的文件名 length：插件所处理的MIME类型数量 一般来说，name属性中会包含检测插件必需的所有信息，但有时候也不完全如此。在检测插件时，需要像下面这样循环迭代每个插件并将插件的name与给定的名字进行比较。 12345678910111213 //检测插件(在IE中无效)function hasPlugin(name) &#123; name = name.toLowerCase(); //转换为小写，便于比较 for (var i = 0; i &lt; navigator.plugins.length; i++)&#123; if (navigator.plugins[i].name.toLowerCase().indexOf(name) &gt; -1)&#123; return true; &#125; &#125; return false;&#125;console.log(hasPlugin('Flash'));console.log(hasPlugin('QuickTime')); 在Firefox、Safari、Opera和Chrome中可以使用上面的方法来检测插件。 检测IE中的插件比较麻烦，因为IE不支持Netscape式的插件。在IE中检测插件的唯一方式就是使用专有的ActiveXObject类型，并尝试创建一个特定的插件的实例。IE是以COM对象的方式实现插件的，而COM对象使用唯一标识符来标识。因此，想要检测特定的插件，就必须知道其COM标识符。例如，Flash的标识符是shockwaveFlash.shockwaveFlash。知道唯一标识符后，就可以编写类似下面的函数来检测IE中是否安装相应插件了。 123456789101112//检测IE中的插件function hasIEPlugin(name) &#123; try &#123; new ActiveXObject(name); return true; &#125;catch (ex) &#123; return false; &#125;&#125;console.log(hasIEPlugin('shockwaveFlash.shockwaveFlash'));console.log(hasIEPlugin('QuickTime.QuickTime')); 鉴于检测两种插件的方法差别太大，因此典型的做法是针对每个插件分别创建检测函数： 1234567891011121314151617181920//检测所有浏览器中的Flashfunction hasFlash() &#123; var result = hasPlugin('Flash'); if (!result)&#123; result = hasIEPlugin('shockwaveFlash.shockwaveFlash'); &#125; return result;&#125;//检测所有浏览器中的QuickTimefunction hasQuickTime() &#123; var result = hasPlugin('QuickTime'); if (!result)&#123; result = hasIEPlugin('QuickTime.QuickTime'); &#125; return result;&#125;console.log(hasFlash());console.log(hasQuickTime()); plugins集合有一个refresh()方法，用于刷新plugins以反映最新安装的插件。这个方法接收一个参数：表示是否应该重新加载页面的一个布尔值。如果将这个值设为true，则会重新加载包含插件的所有页面；否则，只更新plugins集合，不重新加载页面。 注册处理程序Firefox2为navigator对象新增了registerContentHandler()和registerProtocolHandler()方法（这两个方法是在HTML5中定义的）。这两个方法可以让一个站点指明它可以处理特定类型的信息。随着RSS阅读器和在线电子邮件程序的兴起，注册处理程序就为像使用桌面应用程序一样默认使用这些在线应用程序提供了一种方式。 registerContentHandler()方法接收三个参数：要处理的MIME类型、可处理该MIME类型的页面的URL以及应用程序的名称。比如，要将一个站点注册为处理RSS源的处理程序： 12navigator.registerContentHandler('application/rss+xml', 'http://www.somereader.com?feed=%s','Some Reader'); 第二个参数是应该接收RSS源URL的URL，其中%s表示RSS源URL，由浏览器自动插入。当下一个请求RSS源时，浏览器就会打开指定的URL，而相应的web应用程序将以适当的方式来处理该请求。 registerProtocolHandler()方法也接收三个参数：要处理的协议、处理该协议页面的URL和应用程序名称： 12navigator.registerProtocolHandler('mailto', 'http://www.somereader.com?cmd=%s','Some Mail Client'); screen对象screen对象基本上只用来表明客户端的能力，其中包括浏览器窗口外部的显示器的信息，如像素宽度和高度等。每个浏览器中screen对象都包含着不同的属性： 这些信息经常集中出现在测定客户端能力的站点跟踪工具中，但通常不会影响功能。不过，有时候也会用到其中的信息来调整窗口大小，使其占据屏幕的可用空间： 1window.resizeTo(screen.availWidth,screen.availHeight); 涉及移动设备屏幕时，运行IOS的设备始终会像把设备竖着拿在手里一样，因此返回值是768*1024。而Android设备会相应调用screen.width和screen.height的值。 history对象history对象保存着用户上网的历史记录，从窗口被打开的那一刻算起。因为history是window对象的属性，因此每个浏览器窗口、每个标签页乃至每个框架，都有自己的history对象与特定的window对象关联。出于安全考虑，开发人员无法得知用户浏览过的URL。不过，借由用户访问过的页面列表，同样可以在不知道实际URL的情况下实现后退和前进。 使用go()方法可以在用户的历史记录中任意跳转，可以向前也可以向后。这个方法接受一个参数，表示向后或向前跳转的页面数的一个整数值。负值表示向后跳转，正值表示向前跳转： 12345678//后退一页history.go(-1);//前进一页history.go(1);//前进两页history.go(2); 也可以给go()方法传递一个字符串参数，此时浏览器会跳转到历史记录中包含该字符串的第一个位置—可能后退或前进，具体看哪个位置最近。如果历史记录中不包含这个字符串，那么这个方法什么都不做： 12345//跳转到最近的wrox.com页面history.go('wrox.com');//跳转到最近的tc9011.com页面history.go('tc9011.com'); 可以使用两个简写方法back()和forward()来代替go()。这两个方法模仿浏览器的后退和前进按钮： 12345//后退一页history.back();//前进一页history.forward(); history对象还有一个length属性，保存着历史记录的数量。这个数量包括所有历史记录。对于加载到窗口、标签页或框架中的第一个页面而言，history.length等于0。通过像下面一样测试该属性值，可以确定用户是否一开始就打开了你的页面： 123if (history.length == 0)&#123; //这应该是用户打开窗口后的第一个页面&#125; 客户端检测先设计最通用的方案，然后再使用特定于浏览器的技术增强方案。 能力检测能力检测的目标不是识别特定的浏览器，而是识别浏览器的能力。采用这种方式不必顾及特定的浏览器如何，只要确定浏览器支持特定的能力，就可以给出解决方案。其基本模式如下： 123if (object.propertyInQuestion)&#123; //使用object.propertyInQuestion&#125; 要理解能力检测，首先必须理解两个重要的概念： 先检测达成目的的最常用的特性，保证代码最优化，因为多数情况下都可以避免测试多个条件。 必须测试实际要用到的特性。一个特性存在，不一定意味着另一个特性也存在。 更可靠的能力检测能力检测对于想知道某个特性是否会按照适当方式行事（而不仅仅是某个特性存在）非常有用。 下面函数用来确定一个对象是否支持排序： 1234//不要这样做，这不是能力检测---只检测了是否存在相应的方法function isSortable(object)&#123; return !!object.sort;&#125; 上面的方法对任何包含sort属性的对象也会返回true，比如： 1var result = isSortable(&#123;sort: true&#125;); 检测某个属性是否存在并不能够确定对象是否支持排序。更好的方式是检测sort是不是一个函数。 1234//这样更好，检测sort是不是函数function isSortable(object)&#123; return typeof object.sort == 'function';&#125; 在可能的情况下，要尽量使用typeof进行能力检测。特别是，宿主对象没有义务让typeof返回合理的值。 在浏览器环境下测试任何对象的某个特性是否存在，可以使用下面这个函数： 12345678function isHostMethod(object,property)&#123; var t = typeof object[property]; return t == 'function' || (!!(t == 'object' &amp;&amp; object[property])) || t=='unknown';&#125;var xhr = new ActiveXObject('Microsoft.XMLHttp');result = isHostMethod(xhr,'open'); //trueresult = isHostMethod(xhr,'foo'); //false 宿主对象没有义务保持目前的实现方式不变，也不一定会模仿已有宿主对象的行为，所以这个函数不能百分之百保证永远可靠。 能力检测，不是浏览器检测检测某个或几个特性并不能确定浏览器。 如果知道自己的应用程序需要使用某些特定的浏览器特性，那么最好一次性检测所有相关特性，而不是分别检测。 实际开发中，应该将能力检测作为确定一下步解决方案的依据，而不是用它来判断用户使用的是什么浏览器。 怪癖检测怪癖检测的目标是识别浏览器的特殊行为，与能力检测确认浏览器支持什么能力不同的是，怪癖检测是想要知道浏览器存在什么缺陷。这通常需要运行一小段代码，以确定某一特性不能正常工作。 一般来说，怪癖都是个别浏览器所独有的，而且通常被归为bug。在新版本中，这些问题可能会也可能不会被修复。建议只检测对你有直接影响的怪癖，而且最好在脚本一开始就执行此类检测。 用户代理检测用户代理检测通过检测用户代理字符串来确定实际使用的浏览器。在每一次HTTP请求过程中，用户代理字符串是作为响应首部发送的，而且该字符串可以通过JavaScript的navigator.userAgent属性访问。 在服务器端，通过检测用户代理字符串来确定用户使用的浏览器是一种常用而且广为接受的做法。 在客户端，用户代理检测一般被当做一种万不得已才用的做法，其优先级排在能力检测和怪癖检测之后。 用户代理字符串检测技术首先要确定的是你需要多么具体的浏览器信息。一般情况下，知道呈现引擎和最低限度的版本就足以决定正确的操作方法了。 识别呈现引擎如果Firefox、Camino和Netscape都使用的是同一个版本的Gecko，那么它们一定支持相同的特性。同样，不管什么浏览器，使用跟Safari3同一个版本的Webkit，那么该浏览器也和Safari3具有同样的功能。 因此，编写的脚本主要检测5大呈现引擎：IE、Gecko、Webkit、KHTML和Opera。 为了不在全局作用域中添加多余的变量，将使用模块增强模式来封装检测脚本： 12345678910111213141516171819var client = function () &#123; var engine = &#123; //呈现引擎 ie: 0, gecko: 0, webkit: 0, khtml: 0, opera: 0, //具体版本号 ver: null &#125;; //在此检测呈现引擎、平台和设备 return&#123; engine: engine &#125;;&#125;(); 在匿名函数的对象字面量中，每个呈现引擎都对应着一个属性，属性的值默认为0.如果检测到哪个呈现引擎，那么就以浮点数值形式将该引擎的版本号写入相应的属性。而呈现引擎的完全版本则被写入ver属性。这段代码用法如下： 1234567if (client.engine.ie) &#123; //如果是IE，client.ie的值应该大于0 //针对IE的代码&#125; else if (client.engine.gecko &gt; 1.5) &#123; if (client.engine.ver == '1.8.1')&#123; //针对这个版本进行某些操作 &#125;&#125; 要正确地识别呈现引擎，关键是检测顺序要正确。由于用户代理字符串存在诸多不一致的地方，如果检测顺序不对，很可能会导致检测结果不正确。 为此，第一步就是识别Opera，因为它的用户代理字符串有可能完全模仿其他浏览器。不相信Opera是因为任何情况下其用户代理字符串都不会将自己标识为Opera。 Opera 要识别Opera，必须得检测window.opera对象。Opera5及更高版本中都有这个对象，用以保存于浏览器相关的标识信息以及与浏览器直接交互。在Opera7.6及更高版本中，调用version()方法可以返回一个表示浏览器版本的字符串，而这也是确定Opera版本号的最佳方式。要检测更早的版本，可以直接检查用户代理字符串，因为那些版本还不支持隐藏身份： 1234if (window.opera) &#123; engine.ver = window.opera.version(); engine.opera = parseFloat(engine.ver);&#125; WebKit 放在第二位检测的呈现引擎是WebKit。因为WebKit的用户代理字符串包含Gecko和KHTML这两个子字符串。 WebKit的用户代理字符串中的AppleWebKit是独一无二的，因此检测这个字符串最合适： 123456789var ua = navigator.userAgent; //保存用户代理字符串if (window.opera) &#123; engine.ver = window.opera.version(); engine.opera = parseFloat(engine.ver);&#125; else if (/AppleWebKit\/(\S+)/.test(ua))&#123; engine.ver = RegExp['$1']; engine.webkit = parseFloat(engine.ver);&#125; 由于实际版本号中可能会包含数字、小数点和字母，所以捕获组中使用了表示非空格的特殊字符（\S）。用户代理字符串中的版本号与下一部分的分隔符是一个空格，因此这个模式可以保证捕获所有版本信息。 KHTML KHTML的用户代理字符串中也包含Gecko，因此，在排除KHTML之前，无法准确检测基于Gecko的浏览器。KHTML的版本号与WebKit的版本号在用户代理字符串中的格式差不多，因此可以使用类似的正则表达式。此外，由于Konqueror3.1及更早版本中不包含KHTML的版本，故而就要使用Konqueror的版本来代替： 123456789101112var ua = navigator.userAgent; if (window.opera) &#123; engine.ver = window.opera.version(); engine.opera = parseFloat(engine.ver);&#125; else if (/AppleWebKit\/(\S+)/.test(ua))&#123; engine.ver = RegExp['$1']; engine.webkit = parseFloat(engine.ver);&#125; else if (/KHTML\/(\S+)/.test(ua) || /Konqueror\/([^;]+)/.test(ua)) &#123; engine.ver = RegExp['$1']; engine.khtml = parseFloat(engine.ver);&#125; Gecko 在用户代理字符串中，Gecko的版本号不会出现在字符串Gecko的后面，而是会出现在字符串rv:的后面： 123456789101112131415var ua = navigator.userAgent; if (window.opera) &#123; engine.ver = window.opera.version(); engine.opera = parseFloat(engine.ver);&#125; else if (/AppleWebKit\/(\S+)/.test(ua))&#123; engine.ver = RegExp['$1']; engine.webkit = parseFloat(engine.ver);&#125; else if (/KHTML\/(\S+)/.test(ua) || /Konqueror\/([^;]+)/.test(ua)) &#123; engine.ver = RegExp['$1']; engine.khtml = parseFloat(engine.ver);&#125; else if (/rv:([^\)]+)\) Gecko\/\d&#123;8&#125;/.test(ua))&#123; engine.ver = RegExp['$1']; engine.gecko = parseFloat(engine.ver);&#125; IE IE的版本号位于字符串MSIE的后面、一个分号的前面： 123456789101112131415161718var ua = navigator.userAgent; if (window.opera) &#123; engine.ver = window.opera.version(); engine.opera = parseFloat(engine.ver);&#125; else if (/AppleWebKit\/(\S+)/.test(ua))&#123; engine.ver = RegExp['$1']; engine.webkit = parseFloat(engine.ver);&#125; else if (/KHTML\/(\S+)/.test(ua) || /Konqueror\/([^;]+)/.test(ua)) &#123; engine.ver = RegExp['$1']; engine.khtml = parseFloat(engine.ver);&#125; else if (/rv:([^\)]+)\) Gecko\/\d&#123;8&#125;/.test(ua))&#123; engine.ver = RegExp['$1']; engine.gecko = parseFloat(engine.ver);&#125; else if (/MSIE ([^;]+)/.test(ua)) &#123; engine.ver = RegExp['$1']; engine.ie = parseFloat(engine.ver);&#125; 识别浏览器123456789101112131415161718192021222324252627282930313233var client = function () &#123; var engine = &#123; //呈现引擎 ie: 0, gecko: 0, webkit: 0, khtml: 0, opera: 0, //具体版本号 ver: null &#125;; var browser = &#123; //浏览器 ie: 0, firefox: 0, safari: 0, konq: 0, opera: 0, chrome: 0, //具体版本号 ver: null &#125;; //在此检测呈现引擎、平台和设备 return&#123; engine: engine, browser: browser &#125;;&#125;(); 上面代码中添加了私有变量browser，用于保存每个主要浏览器的属性。除了当前使用的浏览器，其他属性的值将保持为0。如果是当前使用的浏览器，则这个属性保存的是浮点数值形式的版本号。ver属性中在必要时会包含字符串形式的浏览器完整版本号。由于大多数浏览器与其呈现引擎密切相关，所以检测浏览器的代码与检测呈现引擎的代码是混合在一起的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//检测呈现引擎及浏览器var ua = navigator.userAgent; if (window.opera) &#123; engine.ver = browser.ver = window.opera.version(); engine.opera = browser.opera = parseFloat(engine.ver);&#125; else if (/AppleWebKit\/(\S+)/.test(ua))&#123; engine.ver = RegExp['$1']; engine.webkit = parseFloat(engine.ver); //确定是chrome还是Safari if (/chrome\/(\S+)/.test(ua)) &#123; browser.ver = RegExp['$1']; browser.chrome = parseFloat(browser.ver); &#125; else if (/Version\/(\S+)/.test(ua)) &#123; browser.ver = RegExp['$1']; browser.safari = parseFloat(browser.ver); &#125;else &#123; //近似地确定版本号 var safariVersion = 1; if (engine.webkit &lt; 100)&#123; safariVersion == 1; &#125; else if (engine.webkit &lt; 312) &#123; safariVersion = 1.2; &#125; else if (engine.webkit &lt; 412) &#123; safariVersion = 1.3; &#125; else &#123; safariVersion = 2; &#125; browser.safari = browser.ver = safariVersion; &#125;&#125; else if (/KHTML\/(\S+)/.test(ua) || /Konqueror\/([^;]+)/.test(ua)) &#123; engine.ver = browser.ver = RegExp['$1']; engine.khtml = browser.konq = parseFloat(engine.ver);&#125; else if (/rv:([^\)]+)\) Gecko\/\d&#123;8&#125;/.test(ua))&#123; engine.ver = RegExp['$1']; engine.gecko = parseFloat(engine.ver); //确定是不是Firefox if (/Firefox\/(\S+)/.test(ua)) &#123; browser.ver = RegExp['$1']; browser.firefox = parseFloat(browser.ver); &#125;&#125; else if (/MSIE ([^;]+)/.test(ua)) &#123; engine.ver = browser.ver = RegExp['$1']; engine.ie = browser.ie = parseFloat(engine.ver);&#125; 对Opera和IE而言，browswe对象中的值等于engine对象中的值。 对Konqueror而言，browser.konq和browser.ver属性分别等于engine.khtml和engine.ver属性。 为了检测Chrome和Safari，在检测引擎的代码中添加了if语句。提取Chrome版本号时，需要查找字符串Chrome/并取得该字符串后面的数值。而提取Safari的版本号时，则需要查找字符串Version/并取得其后的数值。由于这种方式仅适用于Safari3及更高版本，因此需要一些备用的代码，将WebKit的版本号近似地映射为Safari的版本号。 在检测Firefox时，要找到字符串Firefox/并取得其后的数值。 有了上面代码后，可以这样用： 12345678910111213if (client.engine.webkit) &#123; //如果是webkit if (client.browser.chrome) &#123; //执行针对chrome的代码 &#125; else if (client.browser.safari) &#123; //执行针对Safari的代码 &#125;&#125; else if (client.engine.gecko) &#123; if (client.browser.firefox) &#123; //执行针对Firefox的代码 &#125; else &#123; //执行针对其他Gecko浏览器的代码 &#125;&#125; 识别平台目前三大主流平台是Windows、Mac和Unix（包括各种Linux）。为了检测这些平台，还需要像下面这样添加新对象： 123456789101112131415161718192021222324252627282930313233343536373839var client = function () &#123; var engine = &#123; //呈现引擎 ie: 0, gecko: 0, webkit: 0, khtml: 0, opera: 0, //具体版本号 ver: null &#125;; var browser = &#123; //浏览器 ie: 0, firefox: 0, safari: 0, konq: 0, opera: 0, chrome: 0, //具体版本号 ver: null &#125;; var system = &#123; win: false, mac: false, xll: false //表示Unix &#125; //在此检测呈现引擎、平台和设备 return&#123; engine: engine, browser: browser, system: system &#125;;&#125;(); 与呈现引擎不同，在不能访问操作系统或版本的情况下，平台信息是很有限的。对这三个平台而言，浏览器一般只报告Windows版本。为此，新变量system的每个属性最初都保存着布尔值false。 在确定平台时，检测navigator.platform要比检测用户代理字符串更简单，后者在不同浏览器中会给出不同的平台信息： 1234var p = navigator.platform;system.win = p.indexOf('Win') == 0;system.mac = p.indexOf('Mac') == 0;system.xll = (p.indexOf('Xll') == 0) || (p.indexOf('Linux') == 0); 识别Windows操作系统在Windows平台下，还可以从用户代理字符串中进一步取得具体的操作信息。 123456789101112131415161718192021222324252627if (system.win) &#123; if (/win(?:dows)?([^do]&#123;2&#125;)\s?(\d+\.\d+)?/.test(ua))&#123; if (RegExp['$1'] == 'NT')&#123; switch (RegExp['$2']) &#123; case '5.0': system.win = '2000'; break; case '5.1': system.win = 'XP'; break; case '6.0': system.win = 'Vista'; break; case '6.1': system.win = '7'; break; default: system.win = 'NT'; break; &#125; &#125; else if (RegExp['$1'] == '9x') &#123; system.win = 'ME'; &#125; else &#123; system.win = RegExp['$1']; &#125; &#125;&#125; /win(?:dows)?([^do]{2})\s?(\d+\.\d+)?/中win(?:dows)?([^do]{2})会匹配Windows95和Windows98这两个字符串。对这两个字符串，只有Gecko与其他浏览器不同，即没有dows，而且Win与版本号之间没有空格。(\d+\.\d+)?用于取得Gecko中 Windows NT的版本号。\s?表示在Opera中Windows NT的字符串中NT与4.0之间的空格。这个正则表达式第一个捕获组将会匹配95、98、9x、NT、ME或XP。第二个捕获组则只针对Windows ME及所有Windows NT的变体。 如果system.win的值是true，那么就用这个正则表达式从用户代理字符串中提取具体的信息： 1234567if (client.system.win) &#123; if (client.system.win == 'XP')&#123; //说明是XP &#125; else if (client.system.win == 'Vista') &#123; //说明是Vista &#125;&#125; 识别移动设备123456789101112131415161718192021222324252627282930313233343536373839404142434445464748var client = function () &#123; var engine = &#123; //呈现引擎 ie: 0, gecko: 0, webkit: 0, khtml: 0, opera: 0, //具体版本号 ver: null &#125;; var browser = &#123; //浏览器 ie: 0, firefox: 0, safari: 0, konq: 0, opera: 0, chrome: 0, //具体版本号 ver: null &#125;; var system = &#123; win: false, mac: false, xll: false, //移动设备 iphone: false, ipod: false, ipad: false, ios: false, android: false &#125;; //在此检测呈现引擎、平台和设备 return&#123; engine: engine, browser: browser, system: system &#125;;&#125;(); 通常简单地检测字符串iphone、ipod和ipad，就可以分别设置相应属性的值： 123456789101112system.iphone = ua.indexOf('iphone') &gt; -1;system.ipod = ua.indexOf('ipod') &gt; -1;system.ipad = ua.indexOf('ipad') &gt; -1;//检测IOS版本号if (system.mac &amp;&amp; ua.indexOf('Mobile') &gt; -1) &#123; if (/CPU(?:iphone)?OS(\d+_\d+)/.test(ua))&#123; system.ios = parseFloat(RegExp.$1.replace('_','.')); &#125;else &#123; system.ios = 2; //不能真正检测出来，只能猜测 &#125;&#125; IOS3之前，用户代理字符串只包含CPU like Mac OS，后来又改成CPU iphone OS 3_0 like Mac OS X，iPad中又改成CPU OS 3_2 like Mac OS X。检测系统是不是Mac OS、字符串是否存在Mobile，可以确保无论什么版本，system.ios中都不会是0。 所有Android都有版本值，检测Android： 1234//检测Android版本if (/Android(\d+\.\d+)/.test(ua))&#123; system.android = parseFloat(RegExp.$1);&#125; 识别游戏系统12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152var client = function () &#123; var engine = &#123; //呈现引擎 ie: 0, gecko: 0, webkit: 0, khtml: 0, opera: 0, //具体版本号 ver: null &#125;; var browser = &#123; //浏览器 ie: 0, firefox: 0, safari: 0, konq: 0, opera: 0, chrome: 0, //具体版本号 ver: null &#125;; var system = &#123; win: false, mac: false, xll: false, //移动设备 iphone: false, ipod: false, ipad: false, ios: false, android: false, //游戏系统 wii: false, ps: false &#125;; //在此检测呈现引擎、平台和设备 return&#123; engine: engine, browser: browser, system: system &#125;;&#125;(); 检测游戏系统代码如下： 12system.wii = ua.indexOf('wii') &gt; -1;system.ps = /playstation/i.test(ua); 完整的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166var client = function () &#123; var engine = &#123; //呈现引擎 ie: 0, gecko: 0, webkit: 0, khtml: 0, opera: 0, //完整的版本号 ver: null &#125;; //浏览器 var browser = &#123; //主要浏览器 ie: 0, firefox: 0, safari: 0, konq: 0, opera: 0, chrome: 0, //具体版本号 ver: null &#125;; //平台、设备和操作系统 var system = &#123; win: false, mac: false, xll: false, //移动设备 iphone: false, ipod: false, ipad: false, ios: false, android: false, //游戏系统 wii: false, ps: false &#125;; //检测呈现引擎及浏览器 var ua = navigator.userAgent; if (window.opera) &#123; engine.ver = browser.ver = window.opera.version(); engine.opera = browser.opera = parseFloat(engine.ver); &#125; else if (/AppleWebKit\/(\S+)/.test(ua))&#123; engine.ver = RegExp['$1']; engine.webkit = parseFloat(engine.ver); //确定是chrome还是Safari if (/chrome\/(\S+)/.test(ua)) &#123; browser.ver = RegExp['$1']; browser.chrome = parseFloat(browser.ver); &#125; else if (/Version\/(\S+)/.test(ua)) &#123; browser.ver = RegExp['$1']; browser.safari = parseFloat(browser.ver); &#125;else &#123; //近似地确定版本号 var safariVersion = 1; if (engine.webkit &lt; 100)&#123; safariVersion == 1; &#125; else if (engine.webkit &lt; 312) &#123; safariVersion = 1.2; &#125; else if (engine.webkit &lt; 412) &#123; safariVersion = 1.3; &#125; else &#123; safariVersion = 2; &#125; browser.safari = browser.ver = safariVersion; &#125; &#125; else if (/KHTML\/(\S+)/.test(ua) || /Konqueror\/([^;]+)/.test(ua)) &#123; engine.ver = browser.ver = RegExp['$1']; engine.khtml = browser.konq = parseFloat(engine.ver); &#125; else if (/rv:([^\)]+)\) Gecko\/\d&#123;8&#125;/.test(ua))&#123; engine.ver = RegExp['$1']; engine.gecko = parseFloat(engine.ver); //确定是不是Firefox if (/Firefox\/(\S+)/.test(ua)) &#123; browser.ver = RegExp['$1']; browser.firefox = parseFloat(browser.ver); &#125; &#125; else if (/MSIE ([^;]+)/.test(ua)) &#123; engine.ver = browser.ver = RegExp['$1']; engine.ie = browser.ie = parseFloat(engine.ver); &#125; //检测浏览器 browser.ie = engine.ie; browser.opera = engine.opera; //检测平台 var p = navigator.platform; system.win = p.indexOf('Win') == 0; system.mac = p.indexOf('Mac') == 0; system.xll = (p.indexOf('Xll') == 0) || (p.indexOf('Linux') == 0); //检测Windows系统 if (system.win) &#123; if (/win(?:dows)?([^do]&#123;2&#125;)\s?(\d+\.\d+)?/.test(ua))&#123; if (RegExp['$1'] == 'NT')&#123; switch (RegExp['$2']) &#123; case '5.0': system.win = '2000'; break; case '5.1': system.win = 'XP'; break; case '6.0': system.win = 'Vista'; break; case '6.1': system.win = '7'; break; default: system.win = 'NT'; break; &#125; &#125; else if (RegExp['$1'] == '9x') &#123; system.win = 'ME'; &#125; else &#123; system.win = RegExp['$1']; &#125; &#125; &#125; //移动设备 system.iphone = ua.indexOf('iphone') &gt; -1; system.ipod = ua.indexOf('ipod') &gt; -1; system.ipad = ua.indexOf('ipad') &gt; -1; //检测IOS版本号 if (system.mac &amp;&amp; ua.indexOf('Mobile') &gt; -1) &#123; if (/CPU(?:iphone)?OS(\d+_\d+)/.test(ua))&#123; system.ios = parseFloat(RegExp.$1.replace('_','.')); &#125;else &#123; system.ios = 2; //不能真正检测出来，只能猜测 &#125; &#125; //检测Android版本 if (/Android(\d+\.\d+)/.test(ua))&#123; system.android = parseFloat(RegExp.$1); &#125; //检测游戏系统 system.wii = ua.indexOf('wii') &gt; -1; system.ps = /playstation/i.test(ua); //返回这些对象 return&#123; engine: engine, browser: browser, system: system &#125;;&#125;(); 使用方法用户代理是客户端检测的最后一个选择。用户代理检测一般适用于下列情形： 不能直接准确地使用能力检测或怪癖检测。 同一款浏览器在不同平台下具备不同的能力。这时候，可能就有必要确定浏览器位于哪个平台下。 为了跟踪分析等目的需要知道确切的浏览器。]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《JavaScript高级程序设计》学习笔记（二）]]></title>
    <url>%2F2017%2F07%2F20%2F%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[第六章：面向对象的程序设计 第七章：函数表达式 面向对象的程序设计ECMA-262把对象定义为：无序属性的集合，其属性可以包含基本值、对象或者函数。严格来讲，这就相当于对象是一组没有特定顺序的值。 每个对象都是基于一个引用类型创建的。 理解对象属性类型ECMA-262第五版在定义只有内部才用的特性（attribute）时，描述了属性（property）的各种特征。ECMA-262定义这些特性是为了实现JavaScript引擎用的，因此在JavaScript中不能直接访问它们。为了表示特性是内部值，该规范把它们放在了两对方括号中，比如[[Enumerable]]。 ECMAScript中有两种属性：数据属性和访问属性。 数据属性数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有4个描述其行为的特性。 [[Configurable]]：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。直接在对象上定义的属性，它们的这个特性默认值为true。 [[Enumerable]]：表示能否通过for-in循环返回属性。直接在对象上定义的属性，它们的这个特性默认值为true。 [[writable]]：表示能否修改属性的值。直接在对象上定义的属性，它们的这个特性默认值为true。 [[value]]：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值时，把新值保存在这个位置。这个特性的默认值是undefined。 要修改属性默认的特性，必须使用ECMAScript5中的Object.defineProperty()方法。这个方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象。其中，描述符对象的属性必须是：Configurable、Enumerable、writable和value。设置其中一个或者多个值，可以修改对应的特性值。 1234567891011121314151617var person = &#123;&#125;;Object.defineProperty(person,'name',&#123; writable: false, value: 'tc'&#125;);console.log(person.name); //tcperson.name = 'zj'; //严格模式下会抛错误，非严格模式下，赋值操作会被忽略console.log(person.name); //tcvar person = &#123;&#125;;Object.defineProperty(person,'name',&#123; Configurable: false, value: 'tc'&#125;);console.log(person.name); //tcdelete person.name; //严格模式下会抛错误，非严格模式下，删除操作会被忽略console.log(person.name); //tc 可以多次调用Object.defineProperty()方法修改同一属性，但是把Configurable特性设置为false之后，不能再调用writable之外的特性，包括Configurable，也就是说一旦把属性定义为不可配置，就不能再把它变回可配置。 调用Object.defineProperty()方法时，如果不指定，Configurable、Enumerable、writable特性都默认为false。 访问器属性访问属性不包含数据值，它包含一对getter和setter函数。在读取访问器属性时，会调用getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter函数并传入新值，这个函数负责决定如果处理数据。访问器属性有如下4个特性： [[Configurable]]：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。直接在对象上定义的属性，它们的这个特性默认值为true。 [[Enumerable]]：表示能否通过for-in循环返回属性。直接在对象上定义的属性，它们的这个特性默认值为true。 [[Get]]：在读取属性时调用的函数。默认值为undefined。 [[Set]]：在写入属性时调用的函数。默认值为undefined。 访问器属性不能直接定义，必须使用Object.defineProperty()来定义。 1234567891011121314151617var book = &#123; _year: 2004, edition: 1&#125;;Object.defineProperty(book,'year',&#123; get: function () &#123; return this._year; &#125;, set: function (newValue) &#123; if (newValue &gt; 2004)&#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125;&#125;);book.year = 2005;console.log(book.edition); //2 不一定非要同时指定getter和setter。只指定getter意味着属性是不能写，尝试写入属性会被忽略，在严格模式下，则会抛出错误。没指定getter函数的属性不能读，反正会返回undefined，在严格模式下会抛出错误。 定义多个属性Object.defineProperties()方法可以通过描述一次定义多个属性。这个方法接收两个对象参数：第一个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应。 1234567891011121314151617181920var book = &#123;&#125;;Object.defineProperties(book,&#123;//定义了两个数据属性(_year和edition)和一个访问器属性(year) _year: &#123; value: 2004 &#125;, edition: &#123; value: 1 &#125;, year: &#123; get: function () &#123; return this._year; &#125;, set: function (newValue) &#123; if (newValue &gt; 2004)&#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125; &#125;&#125;); 读取属性的特性Object.getOwnPropertyDescriptor()方法可以取得给定属性的描述符。这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象，如果是访问器属性，这个对象的属性有configurable、enumerable、get和set；如果是数据属性，这个对象的属性有configurable、enumerable、writable和value。 123456789101112131415161718192021222324252627282930var book = &#123;&#125;;Object.defineProperties(book,&#123; _year: &#123; value: 2004 &#125;, edition: &#123; value: 1 &#125;, year: &#123; get: function () &#123; return this._year; &#125;, set: function (newValue) &#123; if (newValue &gt; 2004)&#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125; &#125;&#125;);var descriptor = Object.getOwnPropertyDescriptor(book,'_year');console.log(descriptor.value); //2004console.log(descriptor.configurable); //falseconsole.log(typeof descriptor.get); //undefinedvar descriptor = Object.getOwnPropertyDescriptor(book,'year');console.log(descriptor.value); //undefinedconsole.log(descriptor.enumerable); //falseconsole.log(typeof descriptor.get); //function 创建对象虽然Object构造函数或对象字面量都可以用来创建单个对象，但这些方式有个明显的缺点：使用同一个接口创建很多对象，会产生大量的重复代码。 工厂模式工厂模式是一种设计模式，它抽象了创建具体对象的过程。可以用函数封装以特定接口创建对象的细节： 12345678910111213function createPerson(name, age, job)&#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function ()&#123; console.log(this.name); &#125;; return 0&#125;var person1 = createPerson('tc',27,'SE');var person2 = createPerson('zj',23,'Designer'); 工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）。 构造函数模式ECMAScript中构造函数可用来创建特定类型的对象。 可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法。 123456789101112131415161718function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = function ()&#123; console.log(this.name); &#125;;&#125;var person1 = new Person('tc',27,'SE');var person2 = new Person('zj',23,'Designer');console.log(person1.constructor == Person); //trueconsole.log(person2.constructor == Person); //trueconsole.log(person1 instanceof Person); //trueconsole.log(person2 instanceof Person); //trueconsole.log(person1 instanceof Object); //trueconsole.log(person2 instanceof Object); //true 与工厂模式相比，有以下不同： 没有显式地创建对象 直接将属性和方法赋给了this对象 没有return语句 构造函数始终应该以一个大写字母开头，而非构造函数应该以一个小写字母开头。 要创建Person的新实例，必须使用new操作符。使用这种方式调用构造函数实际上会经历以下4个步骤： 创建一个新对象； 将构造函数的作用域赋给新对象（因此this就指向了这个新对象）； 执行构造函数中的代码（为这个新对象添加属性）； 返回新对象。 上面例子中创建的所有对象既是Object的实例，同时也是Person的实例。 以这种方式定义的构造函数是定义在Global对象（在浏览器中是window对象）中的。 将构造函数当作函数构造函数与其他函数的唯一区别在于调用它们的方式不同。任何函数，只要通过new操作符来调用，它就可以作为构造函数；而任何函数，如果不通过new操作符来调用，那它和普通函数一样。 前面定义的Person()函数可以通过下列任何一种方式来调用： 123456789101112//当作构造函数使用var person = new Person('tc',27,'SE');person.sayName() //tc//作为普通函数调用Person('tc',27,'SE'); //添加到windowwindow.sayName(); //tc//在另一个对象的作用域中调用var o = new Object();Person.call(o,'tc',27,'SE');o.sayName(); //tc 构造函数的问题使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。 不同实例上的同名函数是不相等的。 像上面例子中sayName()创建两个完成相同任务的Function实例是没必要的。况且有this对象在，根本不用在执行代码前就把函数绑定到特定对象上面。因此可以把函数定义转移到构造函数外部来解决这个问题： 12345678910111213function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = sayName;&#125;function sayName ()&#123; console.log(this.name);&#125;;var person1 = new Person('tc',27,'SE');var person2 = new Person('zj',23,'Designer'); 全局作用域中定义的sayName()函数被person1和person2共享。这样解决了两个函数做同一件事情的问题，但是这个全局函数实际上只能被某个对象调用，而且如果对象需要定义很多方法，那么就要定义很多全局函数，这样自定义的引用类型就没有封装性可言。这个问题可以通过原型模式来解决。 原型模式创建的每一个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。 使用原型对象的好处就是可以让所有对象实例共享它所包含的属性和方法，也就是不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中。 12345678910111213141516function Person()&#123;&#125;Person.prototype.name = 'tc';Person.prototype.age = 27;Person.prototype.job = 'se';Person.prototype.sayName = function ()&#123; console.log(this.name);&#125;;var person1 = new Person();person1.sayName(); //tcvar person2 = new Person();person2.sayName(); //tcconsole.log(person1.sayName == person2.sayName) //true 理解原型对象无论什么时候，只要创建一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。 在默认情况下。所有原型对象都会自动获得一个constructor（构造函数）属性。这个属性包含一个指向prototype属性所在函数的指针。比如，之前的例子中，Person.prototype.constructor指向Person。通过这个构造函数还可以继续为原型对象添加其他属性和方法。 创建自定义的构造函数之后，其原型对象默认只会取得constructor属性；至于其他方法，则都是从Object继承而来。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。ECMA-262第五版中管这个指针叫[[prototype]]。虽然在脚本中没有标准的方式访问[[prototype]]，但Firefox、Safari和Chrome在每个对象上都支持一个属性_proto_；而在其他实现中，这个属性对脚本是完全不可见的。不过，最重要的是，这个连接存在于实例与构造函数的原型对象之间，而不是存在与实例与构造函数之间。 以上面Person构造函数和person.prototype创建实例的代码为例： 虽然person1和person2两个实例都不包含属性和方法，但是却可以调用person1.sayName()。这是通过查找对象属性的过程来实现的。 虽然在所有实现中都无法访问到[[prototype]]，但可以通过isPrototypeOf()方法来确定对象之间是否存在这种关系。从本质上将，如果[[prototype]]指向调用isprototypeOf()方法的对象（Person.prototype，即构造函数的原型对象），那么这个方法就返回true。 12console.log(Person.prototype.isPrototypeOf(person1)); //trueconsole.log(Person.prototype.isPrototypeOf(person2)); //true 在ECMAScript5中，增加了Object.getPrototypeOf()方法，在所有支持的实现中，这个方法返回[[prototype]]的值。 12console.log(Object.getPrototypeOf(person1) == Person.prototype); //trueconsole.log(Object.getPrototypeOf(person1).name); //tc 使用Object.getPrototypeOf()方法可以方便地取得一个对象的原型，而这在利用原型实现继承的情况下是非常重要的。 每当代码读取某个对象的属性时，都会执行一次搜索。目标是具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例中找到具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到这个属性，则返回该属性的值。这正是多个对象实例共享原型所保存的属性和方法的基本原理。 虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。如果在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那就会在实例中创建该属性，该属性将会屏蔽原型中的那个属性。 123456789101112131415function Person()&#123;&#125;Person.prototype.name = 'tc';Person.prototype.age = 27;Person.prototype.job = 'se';Person.prototype.sayName = function ()&#123; console.log(this.name);&#125;;var person1 = new Person();var person2 = new Person();person1.name = 'zj';console.log(person1.name); //zj -- 来自实例console.log(person2.name); //tc -- 来自原型 当为对象实例添加一个属性时，这个属性只会阻止访问原型中的同名属性，但不会修改原型中的同名属性。即使把这个属性设置为null，也只会在实例中设置这个属性，而不会恢复其指向原型的连接。 使用delete操作符可以完全删除实例属性，从而能够重新访问原型中的属性： 123456789101112131415161718function Person()&#123;&#125;Person.prototype.name = 'tc';Person.prototype.age = 27;Person.prototype.job = 'se';Person.prototype.sayName = function ()&#123; console.log(this.name);&#125;;var person1 = new Person();var person2 = new Person();person1.name = 'zj';console.log(person1.name); //zj -- 来自实例console.log(person2.name); //tc -- 来自原型delete person1.name;console.log(person1.name); //tc -- 来自原型 hasOwnProperty()方法可以检测一个属性是存在于实例中，还是存在于原型中。这个方法（它是从Object继承来的）只在给定属性存在于对象实例中时，才会返回true。 123456789101112131415161718192021function Person()&#123;&#125;Person.prototype.name = 'tc';Person.prototype.age = 27;Person.prototype.job = 'se';Person.prototype.sayName = function ()&#123; console.log(this.name);&#125;;var person1 = new Person();var person2 = new Person();console.log(person1.hasOwnProperty('name')); //falseperson1.name = 'zj';console.log(person1.name); //zjconsole.log(person1.hasOwnProperty('name')); //truedelete person1.name;console.log(person1.name); //tcconsole.log(person1.hasOwnProperty('name')); //false 通过使用hasOwnProperty()方法，什么时候访问的是实例属性，什么时候访问的是原型属性就一清二楚了。下图展示了上面例子在不同情况下的实现与原型的关系（图中省略了与Person构造函数的关系）： ECMAScript5的Object.getOwnPropertyDescriptor()方法只能用于实例属性，要取得原型属性的描述符，必须直接在原型对象上调用Object.getOwnPropertyDescriptor()方法。 原型与in操作符有两种方式使用in操作符：单独使用和在for-in循环中使用。在单独使用时，in操作符会在通过对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中。 12345678910111213141516171819202122232425262728function Person()&#123;&#125;Person.prototype.name = 'tc';Person.prototype.age = 27;Person.prototype.job = 'se';Person.prototype.sayName = function ()&#123; console.log(this.name);&#125;;var person1 = new Person();var person2 = new Person();console.log(person1.hasOwnProperty('name')); //falseconsole.log('name' in person1); //trueperson1.name = 'zj';console.log(person1.name); //zj -- 来自实例console.log(person1.hasOwnProperty('name')); //trueconsole.log('name' in person1); //trueconsole.log(person2.name); //tc -- 来自原型console.log(person2.hasOwnProperty('name')); //falseconsole.log('name' in person2); //turedelete person1.name;console.log(person1.name); //tc -- 来自实例console.log(person1.hasOwnProperty('name')); //falseconsole.log('name' in person1); //true 无论属性存在于实例中还是存在于原型中，同时使用hasOwnProperty()和in操作符，就可以确定该属性到底是存在于对象中，还是存在于原型中。 123456789101112131415161718function hasPrototypeProperty(object, name) &#123; return !object.hasOwnProperty(name) &amp;&amp; (name in object);&#125;function Person()&#123;&#125;Person.prototype.name = 'tc';Person.prototype.age = 27;Person.prototype.job = 'se';Person.prototype.sayName = function ()&#123; console.log(this.name);&#125;;var person = new Person();console.log(hasPrototypeProperty(person,'name')); //trueperson.name = 'zj';console.log(hasPrototypeProperty(person,'name')); //false 在使用for-in循环时，返回的是所有能够通过对象访问的、可枚举的属性，其中既包括存在于实例中的属性，也包括存在于原型中的属性。屏蔽了原型中不可枚举属性（即将[[Enumerable]]标记的属性）的实例属性也会在for-in循环中返回。因为根据规定，所有开发人员定义的属性都是可枚举的——只有IE8及更早版本中例外。在IE8及更早版本中的这个bug会影响默认不可枚举的所有属性和方法，包括hasOwnProperty()、propertyIsEnumerable()、toLocaleString()、toString()和valueOf()。 1234567891011var o = &#123; toString: function () &#123; return 'myObject'; &#125;&#125;;for (var prop in o)&#123; if (prop == 'toString')&#123; console.log('found toString'); //IE8及更早版本中不会显示 &#125;&#125; 要取得对象上所有可枚举的实例属性，可以使用ECMAScript5的Object.keys()方法。这个方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。 1234567891011121314151617function Person()&#123;&#125;Person.prototype.name = 'tc';Person.prototype.age = 27;Person.prototype.job = 'se';Person.prototype.sayName = function ()&#123; console.log(this.name);&#125;;var keys = Object.keys(Person.prototype);console.log(keys); //["name", "age", "job", "sayName"]var p1 = new Person();p1.name = 'zj';p1.age = 28;var p1keys = Object.keys(p1);console.log(p1keys); //["name", "age"] 如果想要得到所有实例属性，无论是否可以枚举，都可以使用Object.getOwnPropertyNames()方法。 12var keys = Object.getOwnPropertyNames(Person.prototype);console.log(keys); //["constructor", "name", "age", "job", "sayName"] 更简单的原型语法为了减少不必要的输入以及从视觉上更好地封装原型的功能，更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象： 12345678910function Person()&#123;&#125;Person.prototype = &#123; name: 'tc', age: 27, job: 'se', sayName: function () &#123; console.log(this.name); &#125;&#125; 上面代码中这样定义时，constructor属性不再指向Person。这样的语法，本质上完全重写了默认的prototype对象，因此constructor属性也就变成了新对象的constructor属性（指向Object构造函数），不再指向Person函数。此时，尽管instanceof操作符还能返回正确结果，但通过constructor已经无法确定对象的类型。 123456var friend = new Person();console.log(friend instanceof Object); //trueconsole.log(friend instanceof Person); //trueconsole.log(friend.constructor == Person); //falseconsole.log(friend.constructor == Object); //true 如果想让constructor的值指向Person，可以这样设置： 123456789Person.prototype = &#123; constructor: Person, name: 'tc', age: 27, job: 'se', sayName: function () &#123; console.log(this.name); &#125;&#125;; 以这样方式重新设置constructor属性会导致它的[[Enumerable]]特性被设置为true。默认情况下，原生的constructor属性是不可枚举的。这个特性可以用Object.defineProperty()来设置： 1234567891011121314Person.prototype = &#123; constructor: Person, name: 'tc', age: 27, job: 'se', sayName: function () &#123; console.log(this.name); &#125;&#125;;Object.defineProperty(Person.prototype,'constructor',&#123; enumerable: false, value: Person&#125;); 原型的动态性由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上反映出来——即使是先创建了实例后修改原型也照样如此。 12345var friend = new Person();Person.prototype.sayHi = function () &#123; console.log('hi');&#125;;friend.sayHi(); //hi 上面代码中，在Person.prototype中添加一个方法sayHi()。即使person实例是在添加新方法之前创建的，但它仍然可以访问这个新方法。其原因可以归结为实例与原型之间的松散关系。实例与原型之间的连接不过是一个指针，而非一个副本。 尽管可以随时为原型添加属性和方法，并且修改能够立即在所有对象实例中反应出来，但如果是重写整个原型对象，那么情况就不一样了。调用构造函数时会为实例添加一个指向最初原型的[[prototype]]指针，而把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系。实例中的指针仅指向原型，而不是指向构造函数。 1234567891011var friend = new Person();Person.prototype = &#123; constructor: Person, name: 'tc', age: 27, job: 'se', sayName: function () &#123; console.log(this.name); &#125;&#125;;friend.sayName(); //error，friend指向的原型中不包含该属性 重写原型对象切断了现有原型与任何之前已经存在的对象实例之间的联系；它们的引用的仍然是最初的原型。（重写原型对象时，friend的[[prototype]]还是指向最初的原型对象，而这个对象中没有不包含name、age等属性，这些属性保存在新的原型对象中。而如果没有重写原型对象，person构造函数的原型对象中包括了这些属性。） 原生对象的原型原型模式的重要性不仅体现在创建自定义类型当面，就连所有原生的引用类型，都是采用这种模式创建的。所有原生引用类型都在其构造函数的原型上定义了方法。 12console.log(typeof Array.prototype.sort); //functionconsole.log(typeof String.prototype.substring); //function 通过原生对象的原型，不仅可以取得所有默认方法的引用，而且也可以定义新方法。可以像修改自定义对象的原型一样修改原生对象的原型，因此可以随时添加方法。 12345String.prototype.startWith = function (text) &#123; return this.indexOf(text) == 0;&#125;;var msg = 'hello world';console.log(msg.startWith('hello')); //true 不推荐修改原生对象的原型，这样做不仅可能导致命名冲突，也可能会意外地重新原生方法。 原型对象的问题原型模式省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值。虽然这会在某种程度上带来一些不方便，但还不是原型的最大问题。原型模式的最大问题是由其共享的本性所导致的。 原型所有属性是被很多实例共享的，这种共享对于函数非常合适。对于那些包含基本值的属性倒也说得过去，毕竟，通过在实例上添加一个同名属性，可以隐藏原型中的对应属性。然而，对于包含引用类型值的属性来说，问题就比较突出： 12345678910111213141516171819function Person()&#123;&#125;Person.prototype = &#123; constructor: Person, name: 'tc', age: 27, job: 'se', friends: ['zj','tc'], sayName: function () &#123; console.log(this.name); &#125;&#125;;var person1 = new Person();var person2 = new Person();person1.friends.push('wcx');console.log(person1.friends); //["zj", "tc", "wcx"]console.log(person2.friends); //["zj", "tc", "wcx"]console.log(person1.friends === person2.friends); //true 上面例子中，person1和person2的friend属性都指向同一个数组。 组合使用构造函数模式和原型模式创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。这样，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。另外，这种混成模式还支持向构造函数传递参数；可谓是集两种模式之长。 12345678910111213141516171819202122function Person(name,age,job) &#123; this.name = name; this.age = age; this.job = job; this.friends = ['tc','zj'];&#125;Person.prototype = &#123; constructor: Person, sayName: function () &#123; console.log(this.name); &#125;&#125;;var person1 = new Person('tc',29,'se');var person2 = new Person('zj',24,'art');person1.friends.push('wcx');console.log(person1.friends); //["tc", "zj", "wcx"]console.log(person2.friends); //["tc", "zj"]console.log(person1.friends === person2.friends); //falseconsole.log(person1.sayName === person2.sayName); //true 这种构造函数与原型混成的模式，是目前ECMAScript中使用最广泛。认同度最高的一种创建自定义类型的方法。可以说，这是用来自定义引用类型的一种默认模式。 动态原型模式动态原型模式把所有信息都封装在构造函数中，而通过在构造函数中初始化原型（仅在必要的情况下），又保持了同时使用构造函数和原型的优点。也就是可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。 12345678910111213141516function Person(name,age,job) &#123; //属性 this.name = name; this.age = age; this.job = job; //方法 if (typeof this.sayName != 'function')&#123; Person.prototype.sayName = function () &#123; console.log(this.name); &#125;; &#125;&#125;var friend = new Person('tc',27,'se');friend.sayName(); //tc 上面代码中，只会在sayName()不存在的情况下，才会将他添加到原型中。Person中，注释方法下面的这段代码只会在初次调用构造函数时才会执行，此后，原型已经完成初始化，不需要再做什么修改。这里对原型做的修改，能够立即在所有实例中得到反映。对于这种模式创建的对象，还可以使用instanceof操作符确定它的类型。 使用动态原型模式时，不能使用对象字面量重写原型。如果在已经创建了实例的情况下重写原型，那么就会切断现有实例与新原型之间的联系。 寄生构造函数模式通常，在前面几种模式都不适用的情况下，可以使用寄生（parasitic）构造函数模式。这种模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象；但从表面上看，这个函数又很像是典型的构造函数。 12345678910111213function Person(name,age,job) &#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function () &#123; console.log(this.name); &#125;; return o;&#125;var friend = new Person('tc',27,'se');friend.sayName(); //tc 这个模式可以在特殊情况下用来为对象创建构造函数。假设想创建一个具有额外方法的特殊数组。由于不能直接修改Arrary构造函数，因此可以使用这个模式： 123456789101112131415161718function SpecialArrary() &#123; //创建数组 var values = new Array(); //添加值 values.push.apply(values,arguments); //添加方法 values.toPipedString = function () &#123; return this.join('|'); &#125;; //返回数组 return values;&#125;var colors = new SpecialArrary('red','blue','green');console.log(colors.toPipedString()); //red|blue|green 寄生构造函数模式中，返回的对象与构造函数或者与构造函数的原型属性之间没有关系，也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。所以不能依赖instanceof操作符来确定对象类型。建议在可以使用其他模式的情况下，不要使用这种模式。 稳妥构造函数模式所谓稳妥对象（durable objects），指的是没有公共属性，而且其方法也不引用this对象。稳妥对象最适合在一些安全环境中（这些环境中会禁止使用this和new），或者在防止数据被其他应用程序（如Mashup程序）改动时使用。稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：一是新创建对象的实例方法不引用this；二是不使用new操作符调用构造函数。 123456789101112131415function Person(name,age,job) &#123; //创建要返回的对象 var o = new Object(); //可以在这里定义私有变量和函数 //添加方法 o.sayName = function () &#123; console.log(name); &#125;; return o;&#125;var friend = Person('tc',27,'se');friend.sayName(); 在这种模式下，除了使用sayName()方法之外，没有别的方法访问name值。变量friend中保存的是一个稳妥对象，除了调用sayName()方法外，没有别的方式可以访问其数据成员。即使有其他代码会给这个对象添加方法或数据成员，但也不可能有别的办法访问传入到构造函数中的原始数据。稳妥构造函数模式提供的这种安全性，使得它非常适合在某些安全执行环境下使用。 与寄生构造函数模式类似，使用稳妥构造函数模式创建的对象与构造函数之间也没有什么关系，因此instanceof操作符对这种对象也没有意义。 继承许多OO语言都支持两种继承方式：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。由于函数没有签名，在ECMAScript中无法实现接口继承。ECMAScript只支持实现继承，而且其实现继承主要是依靠原型链来实现的。 原型链ECMAScript将原型链作为实现继承的主要方法。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。 每一个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。如果让原型对象等于另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是所谓原型链的基本概念。 实现原型链有一种基本模式，代码大致如下： 12345678910111213141516171819function SuperType()&#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function ()&#123; return this.property;&#125;;function SubType()&#123; this.subproperty = false;&#125;//继承了SuperTypeSubType.prototype = new SuperType();//相当于重写了SubType的原型对象SubType.prototype.getSubValue = function()&#123; return this.subproperty;&#125;;var instance = new SubType();console.log(instance.getSuperValue()); //true 上面代码定义了两个类型：SuperType和SubType。每个类型分别有一个属性和一个方法。它们的主要区别是SubType继承了SuperType，而继承是通过创建SuperType的实例，并将该实例赋给SubType.prototype实现的。实现的本质是重写原型对象，代之以一个新类型的实例。也就是说，原来存在于SuperType的实例中的所有属性和方法，现在也存在与SubType.prototype中。在确立了继承关系后，给SubType.prototype添加了一个方法，这样就在继承了SuperType的属性和方法的基础上又添加了一个新方法。这个例子中的实例以及构造函数和原型之间的关系如下图： 上面代码中，没有使用SubType默认提供的原型，而是给它换一个新原型；这个新原型就是SuperType的实例。于是，新原型不仅具有作为一个SuperType的实例所拥有的全部属性和方法，而且其内部还有一个指针，指向SuperType的原型。最终结果就是：instance指向SubType的原型，Subtype的原型又指向SuperType的原型。getSuperValue()方法仍然还在SuperType.prototype中，但property则位于SubType.prototype中。这是因为prototype是一个实例属性，而getSuperValue()则是一个原型方法。既然SubType.prototype现在是SuperType的实例，那么property当然就该位于该实例中。此外，要注意instance.constructor现在指向的是SuperType，这是因为原来SubType.prototype中的constructor被重写了的缘故（实际上，不是Subtype的原型的constructor属性被重写了，而是Subtype的原型指向了另一个对象——SuperType的原型，而这个原型对象的constructor属性指向的是SuperType）。 通过实现原型链，本质上扩展了原型搜索机制。当以读取模式访问一个实例属性时，首先会在实例中搜索该属性，如果没有找到该属性，则会继续搜索实例的原型。在通过原型链实现继承的情况下，搜索过程就得沿着原型链继续向上。就上面的例子来说，调用instance.getSuperValue()会经历三个搜索步骤： 搜索实例； 搜索SubType.prototype； 搜索SuperType.prototype 最后一步才会找到该方法。在找不到属性或方法的情况下，搜索过程总是要一环环地前行到原型链末端才会停下来。 别忘记默认的原型事实上，前面例子中展示的原型链还少一环。所有引用类型默认都继承了Object，而这个继承也是通过原型链实现的。所有函数默认原型都是Object的实例，因此默认原型都会包含一个内部指针，指向Object.prototype。这也正是所有自定义类型都会继承toString()、valueof()等默认方法的根本原因。所以，上面例子展示的原型链中还应该包括另外一个继承层次： SubType继承了SuperType，而SuperType继承了Object。当调用instance.toString()时，实际上调用的是保存在Object.prototype中的那个方法。 确定原型和实例的关系可以通过两种方式来确定原型与实例之间的关系。第一种是使用instanceof操作符，只要用这个操作符来测试实例与原型链中出现过的构造函数，结构就会返回true。 123console.log(instance instanceof Object); //trueconsole.log(instance instanceof SuperType); //trueconsole.log(instance instanceof SubType); //true 由于原型链的关系，可以说instance是Object、SuperType、SubType中任何一个类型的实例。因此测试三个构造函数的结果都返回了true。 第二种方式是使用isPrototypeOf()方法。只要是原型链中出现过的原型，都可以说是该原型链所派生的实例的原型，因此isPrototypeOf()方法也会返回true。 123console.log(Object.prototype.isPrototypeOf(instance)); //trueconsole.log(SubType.prototype.isPrototypeOf(instance)); //trueconsole.log(SuperType.prototype.isPrototypeOf(instance));//true 谨慎地定义方法子类型有时候需要重写超类型中的某个方法，或者需要添加超类型中不存在的某个方法。但是给原型添加方法的代码一定要放在替换原型的语句之后。 1234567891011121314151617181920212223242526function SuperType() &#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function () &#123; return this.property;&#125;;function SubType() &#123; this.subproperty = false;&#125;//继承了SuperTypeSubType.prototype = new SuperType();//添加新方法SubType.prototype.getSubValue = function () &#123; return this.subproperty;&#125;;//重写超类型中的方法SubType.prototype.getSuperValue = function () &#123; return false;&#125;;var instance = new SubType();console.log(instance.getSuperValue()); //false 重写的方法会屏蔽原来的方法。当通过SubType的实例调用getSuperValue()时，调用的是重新定义的方法；但通过SuperType的实例调用getSuperValue()时，还会调用原来的那个方法。这里需要格外注意的是，必须在用SuperType的实例替换原型之后，再定义两个方法。 在通过原型链实现继承时，不能使用对象字面量创建原型方法。因为这样会重写原型链。 123456789101112131415161718192021222324252627function Supertype() &#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function () &#123; return this.property;&#125;;function SubType() &#123; this.subproperty = false;&#125;//继承了SuperTypeSubType.prototype = new SuperType();//使用字面量添加新方法，会导致上一行代码无效SubType.prototype = &#123; getSubValue: function () &#123; return this.subproperty &#125;, someOtherMethod: function () &#123; return false; &#125;&#125;;var instance = new SubType();console.log(instance.getSuperValue()); //Uncaught TypeError: instance.getSuperValue is not a function 上面例子中，用字面量添加新的方法时，SubType和SuperType之间的原型链已经被切断，SubType的原型包含的是一个Object的实例，而非SuperType的实例。 原型链的问题最主要的问题来自包含引用类型值的原型。包含引用类型值的原型属性会被所有实例共享；而这也是为什么要在构造函数中，而不是原型对象中定义属性的原因。在通过原型来实现继承时，原型实际上会变成另一个类型的实例。于是，原先的实例属性也会变成现在的原型属性。 12345678910111213141516function SuperType() &#123; this.color = ['red','blue','green'];&#125;function SubType() &#123;&#125;//继承了SuperTypeSubType.prototype = new SuperType();var instance1 = new SubType();instance1.color.push('black');console.log(instance1.color);//["red", "blue", "green", "black"]var instance2 = new SubType();console.log(instance2.color);//["red", "blue", "green", "black"] 原型链的第二个问题是：在创建子类型的实例时，不能向超类型的构造函数中传递参数。实际上，应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。因此，加上原型中包含引用类型值所带来的问题，实践中很少会单独使用原型链。 借用构造函数在解决原型中包含引用类型值所带来问题的过程中，开发人员开始使用一种叫借用构造函数的技术（也叫伪造对象或经典继承）。它会在子类型构造函数的内部调用超类型构造函数。因为函数只不过是在特定环境中执行代码的对象，所以通过使用apply()和call()方法也可以在新创建的对象上执行构造函数。 123456789101112131415function SuperType() &#123; this.color = ['red','blue','green'];&#125;function SubType() &#123; //继承了SuperType SuperType.call(this);&#125;var instance1 = new SubType();instance1.color.push('black');console.log(instance1.color);//["red", "blue", "green", "black"]var instance2 = new SubType();console.log(instance2.color);//["red", "blue", "green"] 通过使用call()方法（或apply()方法也可以），实际上是在（未来将要）新创建的SubType实例的环境下调用了SuperType构造函数。这样就会在新SubType对象上执行SuperType()函数中定义的所有对象初始化代码。结果，SubType的每个实例就会具有自己的color属性的副本。 传递参数相对于原型而言，借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函数传递参数。 123456789101112131415function SuperType(name) &#123; this.name = name;&#125;function SubType() &#123; //继承了SuperType，同时还传递了参数 SuperType.call(this,'tc');//this指向instance对象，表示instance对象调用SuperType方法，并传入tc这个参数 //实例属性 this.age = 29;&#125;var instance = new SubType();console.log(instance.name); //tcconsole.log(instance.age); //29 在SubType调用构造函数时，实际上是为SubType实例设置了name属性（SuperType中的this指向调用SuperType的对象，即instance实例对象，通过this.name给instance实例对象创建了一个name属性）。为了确保SuperType构造函数不会重写子类型的属性，可以在调用超类型构造函数后，再添加应该在子类型中定义的属性。 借用构造函数的问题如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题—-方法都在构造函数中定义，因此函数复用就无从谈起。而且在超类型的原型中定义的方法，对子类型而言是不可见的，结果所有类型都只能使用构造函数模式。所以借用构造函数的技术也很少单独使用。 组合继承组合继承有时候也叫做伪经典继承，指的是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。 123456789101112131415161718192021222324252627282930313233function SuperType(name) &#123; this.name = name; this.colors = ['red','blue','green'];&#125;SuperType.prototype.sayName = function () &#123; console.log(this.name);&#125;;function SubType(name, age) &#123; //继承属性 SuperType.call(this,name); this.age = age;&#125;//继承方法SubType.prototype = new SuperType();SubType.prototype.sayAge = function () &#123; console.log(this.age);&#125;;var instance1 = new SubType('tc',27);instance1.colors.push('black');console.log(instance1.colors); //["red", "blue", "green", "black"]instance1.sayName(); //tcinstance1.sayAge(); //27var instance2 = new SubType('zj',23);console.log(instance2.colors); //["red", "blue", "green"]instance2.sayName(); //zjinstance2.sayAge(); //23 组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为JavaScript中最常用的继承模式。而且instanceof和isPrototypeOf()也能够用于识别基于组合继承创建的对象。 原型式继承道格拉斯·克罗克福德介绍了一种实现继承的方法，这种方法并没有使用严格意义上的构造函数。他的想法是借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。为了达到这个目的，他给出了如下函数。 12345function object(o) &#123; function F() &#123; &#125; F.prototype = o; return new F();&#125; 在object()函数内部，先创建一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回这个临时类型的一个新实例。从本质上讲，object()对传入其中的对象执行了一次浅复制。 1234567891011121314151617181920function object(o) &#123; function F() &#123; &#125; F.prototype = o; return new F();&#125;var person = &#123; name: 'tc', friend: ['syx','wcx','zj']&#125;;var anotherPerson = object(person);anotherPerson.name = 'zz';anotherPerson.friend.push('cc');var yetAnotherPerson = object(person);yetAnotherPerson.name = 'jj';yetAnotherPerson.friend.push('tt');console.log(person.friend); //["syx", "wcx", "zj", "cc", "tt"] 这种原型继承，要求必须有一个对象可以作为另一个对象的基础。如果有这么一个对象的话，可以把它传递给object()函数，然后再根据具体需求得到的对象加以修改即可。在这个例子中，可以作为另一个对象基础的是person对象，于是把它传入到object()函数中，然后该函数就会返回一个新对象。这个新对象将person作为原型，所以它的原型中包含一个基本类型值属性和一个引用类型值属性。这意味着person.friend不仅属于person所有，而且也会被anotherPerson以及yetAnotherPerson共享。实际上，这就相当于创建了person对象的两个副本。 ECMAScript5通过新增Object.create()方法规范化了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。在传入一个参数的情况下，Object.create()与object()方法的行为相同。 1234567891011121314var person = &#123; name: 'tc', friend: ['syx','wcx','zj']&#125;;var anotherPerson = Object.create(person);anotherPerson.name = 'zz';anotherPerson.friend.push('cc');var yetAnotherPerson = Object.create(person);yetAnotherPerson.name = 'jj';yetAnotherPerson.friend.push('tt');console.log(person.friend); //["syx", "wcx", "zj", "cc", "tt"] Object.create()方法的第二个参数与Object.defineProperties()方法的第二个参数格式相同：每个属性都是通过自己的描述符定义的。以这种方式指定的任何属性都会覆盖原型对象上的同名属性。 123456789101112var person = &#123; name: 'tc', friend: ['syx','wcx','zj']&#125;;var anotherPerson = Object.create(person,&#123; name: &#123; value: 'zj' &#125;&#125;);console.log(anotherPerson.name); //zj 在没有必要兴师动众地创建构造函数，而只想让一个对象与另一个对象保持类似的情况下，原型式继承完全可以胜任。但是包含引用类型值的属性始终都会共享相应的值，就像使用原型模式一样。 寄生式继承寄生式继承是与原型式继承紧密相关的一种思路。寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。 1234567function createAnother(original) &#123; var clone = object(original); //通过调用函数创建一个新对象 clone.sayHi = function () &#123; //以某种方式来增强这个对象 console.log('hi'); &#125;; return clone; //返回这个对象&#125; createAnother()函数接收一个参数，也就是将要作为新对象基础的对象。然后，把这个对象（original）传递给object()函数，将返回结果赋给clone。再为clone对象添加一个新方法sayHi()，最后返回clone对象。 123456789101112131415161718192021function object(o) &#123; function F() &#123; &#125; F.prototype = o; return new F();&#125;function createAnother(original) &#123; var clone = object(original); clone.sayHi = function () &#123; console.log('hi'); &#125;; return clone;&#125;var person = &#123; name: 'tc', friend: ['syx','wcx','zj']&#125;;var anotherPerson = createAnother(person);anotherPerson.sayHi(); //hi 上面代码基于person返回一个新对象anotherPerson。新对象不仅具有person的所有属性和方法，而且还有sayHi()方法。 在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。前面示范继承模式时使用的object()函数不是必须的，任何能够返回新对象的函数都适用于此模式。 使用寄生式继承为对象添加函数，会由于不能做到函数复用而降低效率。 寄生组合式继承组合继承是JavaScript最常用的继承模式，组合继承最大的问题就是无论什么情况下，都会调用两次超类型构造函数：一次在创建子类型原型的时候，另一次是在子类型构造函数内部。子类型最终会包含超类型对象的全部实例属性，但不得不在调用子类型构造函数时重写这些属性： 1234567891011121314151617181920function SuperType(name) &#123;this.name = name;this.colors = ['red','blue','green'];&#125;SuperType.prototype.sayName = function () &#123;console.log(this.name);&#125;;function SubType(name,age) &#123;SuperType.call(this,name); //第二次调用SuperType()this.age = age;&#125;subType.prototype = new SuperType();//第一次调用SuperType()SubType.prototype.constructor = SubType;SubType.prototype.sayAge = function () &#123;console.log(this.age);&#125;; 在第一次调用SuperType构造函数时，SubType.prototype会得到两个属性：name和colors；它们都是SuperType的实例属性，只不过现在位于SubType的原型中。当调用SubType构造函数时，又会调用一次SuperType构造函数，这一次又在新对象上创建了实例属性name和colors。于是，这两个属性就屏蔽了原型中两个同名属性。如下图所示： 在上图中，有两组name属性和color属性：一组在实例上，一组在SubType原型中。这就是调用两次SuperType构造函数的结果。这个问题可以使用寄生组合式继承。 寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。其背后的基本思路是：不必为了指定子类型的原型而调用超类型的构造函数，所需要的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。寄生组合式继承的基本模式如下所示： 12345function inheritPrototype(subType, superType) &#123; var prototype = object(superType.prototype); //创建对象 prototype.constructor = subType; //增强对象 subType.prototype = prototype; //指定对象&#125; inheritPrototype()函数实现了寄生组合式继承的最简单形式。这个函数接收两个参数：子类型构造函数和超类型构造函数。在函数内部，第一步是创建超类型的一个副本。第二步是为创建的副本添加constructor属性，从而弥补因重写原型而失去的默认constructor属性。最后一步，将新创建的对象赋值给子类型的原型。这样我们就可以调用inheritPrototype()函数的语句，去替换前面例子中为子类型原型赋值的语句，例如： 12345678910111213141516171819function SuperType(name) &#123; this.name = name; this.colors = ['red','blue','green'];&#125;SuperType.prototype.sayName = function () &#123; console.log(this.name);&#125;;function SubType(name,age) &#123; SuperType.call(this,name); this.age = age;&#125;inheritPrototype(SubType,SuperType);SubType.prototype.sayAge = function () &#123; console.log(this.age);&#125;; 这个例子的高效率体现在它只调用一次SuperType构造函数，并且因此避免了在SubType.prototype上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此还能正常使用instanceof和isPrototypeOf()。普遍认为寄生组合式继承是引用类型最理想的继承范式。 函数表达式定义函数的方法有两种： 函数声明 函数声明的重要特征是函数声明提升，在执行代码之前会先读取函数声明。 函数表达式 这种情况下创建的函数叫匿名函数，因为function关键字后没有标识符。匿名函数的name属性是空字符串。函数表达式在使用前必须先赋值。 递归递归函数是在一个函数听过名字调用自身的情况下构成的。 下面代码调用递归阶乘函数调用会报错， 1234567891011121314function factorial(num) &#123; if (num &lt;= 1)&#123; return 1; &#125; else &#123; return num * factorial(num - 1); &#125;&#125;var anotherFactorial = factorial;factorial = null;console.log(anotherFactorial(4)); //Uncaught TypeError: factorial is not a function--------------------------------var anotherFactorial = factorial;console.log(anotherFactorial(4)); //24 可以使用arguments.callee解决这个问题，arguments.callee是一个指向正在执行的函数的指针，因此可以用它来实现对函数的递归调用： 1234567function factorial(num) &#123; if (num &lt;= 1)&#123; return 1; &#125; else &#123; return num * arguments.callee(num - 1); &#125;&#125; 但是在严格模式下，不能通过脚本访问arguments.callee，还可以使用命名函数表达式来达到相同的目的： 1234567var factorial = (function f(num) &#123; //f函数用()括起来 if (num &lt;= 1)&#123; return 1; &#125; else &#123; return num * f(num - 1); &#125;&#125;); 上面代码创建了一个名为f()的命名函数表达式，然后把它赋值给变量factorial。即便把函数赋值给了另一个变量，函数的名字仍然有效。 这种方式在严格模式和非严格模式下都可以。 闭包闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数： 1234567891011121314function createComparisonFunction(propertyName)&#123; return function (object1,object2)&#123; var value1 = object1(propertyName); var value2 = object2(propertyName); if (value1 &lt; value2)&#123; return -1; &#125; else if (value1 &gt; value2)&#123; return 1; &#125; else &#123; return 0; &#125; &#125;;&#125; 当某个函数第一次被调用时，会创建一个执行环境及相应的作用域链，并把作用域链赋值给一个特殊的内部属性[[Scope]]。然后，使用this、arguments和其他命名参数的值来初始化函数的活动对象。但在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位，。。。直至作用域链终点的全局执行环境。 在函数执行过程中，为读取和写入变量的值，就需要在作用域链中查找变量，比如下面这个例子： 1234567891011function compare(value1, value2)&#123; if (value1 &lt; value2)&#123; return -1; &#125;else if (value1 &gt; value2)&#123; return 1; &#125;else &#123; return 0; &#125;&#125;var result = compare(5, 10); 当第一次调用compare()时，会创建一个包含this、arguments、value1和value2的活动对象。全局执行环境的变量对象（包含this、result和compare）在compare()执行环境的作用域链中则处于第二位。如下图所示： 后台的每个执行环境都有一个表示变量的对象，即变量对象。全局环境的变量对象始终存在，而像compare()函数这样的局部环境的变量对象，则只在函数执行的过程中存在。在创建compare()函数时，会为函数创建一个预先包含全局变量对象的作用域链，这个作用域链保存在内部的[[scope]]属性中。当调用compare()函数时，会为函数创建一个执行环境，然后通过复制函数的[[scope]]属性中的对象构建起执行环境的作用域链。此后，又有一个活动对象（在此作为变量对象使用）被创建并被推入执行环境作用域链的前端。对于这个例子中compare()函数的执行环境而言，其作用域链中包含两个变量对象：本地活动对象和全局变量对象。显然，作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。 无论什么时候在函数中访问一个变量时，就会从作用域链中搜索具有相应名字的变量。一般当函数执行完毕后，局部活动对象就会销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。但是闭包情况又有所不同。 在另一个函数内部定义的函数将会包含函数（即外部函数）的活动对象添加到它的作用域链中。因此，在createComparisonFunction()函数内部定义的匿名函数的作用域中，实际上会包含外部函数createComparisonFunction()的活动对象。如下图所示： 12var compare = createComparisonFunction('name');var result = compare(&#123;name: 'tc'&#125;,&#123;name: 'zj'&#125;); 在匿名函数从createComparisonFunction()中被返回后，它的作用域链被初始化为包含createComparisonFunction()函数的活动对象和全局变量对象。这样，匿名函数就可以访问在createComparisonFunction()中定义的所有变量。更重要的是，createComparisonFunction()函数在执行完毕后，其活动对象也不会被销毁，因为匿名函数的作用域链仍然在引用这个活动对象。也就是说，当createComparisonFunction()函数返回后，其执行环境的作用域就会被销毁，但它的活动对象仍然会留在内存中，直到匿名函数被销毁，比如： 12345678//创建函数var compareNames = createComparisonFunction('name');//调用函数var result = compareNames(&#123;name: 'tc'&#125;,&#123;name: 'zj'&#125;);//解除对匿名函数的引用（以便释放内存）compareNames = null; 由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。过度使用闭包可能会导致内存占用过多，建议只在绝对必要时再考虑使用闭包。 闭包与变量作用域链的这种配置引出了一个值得注意的副作用，即闭包只能取得包含函数中任何变量的最后一个值。闭包所保存的是整个变量对象，而不是某个特殊的变量（由于闭包会携带包含它的函数的作用域，外部函数的作用域即使被销毁，但它的活动对象仍存在，除非闭包被销毁），比如： 12345678910function createFunctions()&#123; var result = new Array(); for(var i = 0; i &lt; 10; i++)&#123; result[i] = function()&#123; return i; &#125;; &#125; return result;&#125; 这个函数会返回一个函数数组。表面上看，似乎每个函数都应该返回自己的索引值，即位置0的函数返回0，位置1的函数返回10，以此类推。但实际上，每个函数都返回10。因为每个函数的作用域链中都保存着createFunctions()函数的活动对象，所以它们引用的都是同一个变量i（作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象）。当createFunctions()函数返回后，变量的值是10，此时每个函数都保存着变量i的同一个变量对象（因为是引用同一个变量i，返回时i的值都会被修改成最后一个i的值，也就是10）。但是，可以通过创建另一个匿名函数强制让闭包的行为符合预期： 123456789101112function createFunctions()&#123; var result = new Array(); for(var i = 0; i &lt; 10; i++)&#123; result[i] = function(num)&#123; return function () &#123; return num; &#125;; &#125;(i); &#125; return result;&#125; 上面代码中没有直接把闭包赋值给数组，而是定义了一个匿名函数，并将立即执行该匿名函数的结果赋给数组。这里的匿名函数有一个参数num，也就是最终的函数要返回的值。在调用每个匿名函数时，传入了变量i。由于函数参数是按值传递，所以变量i就会把当前值复制给num。而在这个匿名函数内部，又创建并返回了一个访问num的闭包（返回的num属于每个result数组函数，而上上面的那段代码中的返回i是属于createFunctions()的，所以所有的result数组函数都引用的是同一个i）。这样一来，result数组中的每个函数都有自己num变量的一个副本，因此就可以返回各自不同的数值了。 关于this对象this对象是在运行时基于函数的执行环境绑定的：在全局函数中，this等于window，而当函数被作为某个对象的方法调用时，this等于那个对象。不过，匿名函数的执行环境具有全局性，因此其this对象通常指向window（匿名函数的this指向为什么是window），通过call()或apply()可以使this指向其他对象。但有时候由于编写闭包的方式不同，这一点可能不会那么明显，比如： 12345678910111213var name = 'the window';var object = &#123; name: 'my object', getNameFunc: function()&#123; return function()&#123; return this.name; //指向window对象 &#125;; &#125;&#125;;console.log(object.getNameFunc()()); //the window (在非严格模式下) 每个函数在被调用时，其活动对象都会自动取得两个特殊变量：this和arguments。内部函数在搜索这两个变量时，只会搜索到其活动对象为止，因此永远不可能直接访问外部函数中的这两个变量（匿名函数的执行环境具有全局性，因此其this对象通常指向window，这里this指向window）。 当函数作为单纯的函数调用时（即该函数不属于某一对象的方法），this指向全局对象；当函数作为某一对象的方法调用时，this指向该对象；作为构造函数调用时（用new调用），this指向新创建的对象；当通过call或者apply调用时，this指向call和apply第一个传进来的参数，如果参数为空，则this指向全局对象。 不过，把外部作用域中的this对象保存在一个闭包能够访问到的变量里，就可以让闭包访问该对象了，比如： 1234567891011121314var name = 'the window';var object = &#123; name: 'my object', getNameFunc: function()&#123; var that = this; //指向调用此方法的对象，即object return function()&#123; return that.name; &#125;; &#125;&#125;;console.log(object.getNameFunc()()); //my object 如果想访问作用域中的arguments对象，必须将该对象的引用保存到另外一个闭包能够访问的变量中。 在几种特殊情况下，this的值可能会意外地改变。比如： 12345678910111213var name = 'the window';var object = &#123; name: 'my object', getName: function()&#123; return this.name; &#125;&#125;;object.getName(); //"my object"(object.getName)(); //"my object"(object.getName = object.getName)(); //"the window" 上面代码中。第一次调用object.getName()时，this指向object。 第二次调用时，在调用这个方法前先给它加上了括号，虽然加上括号后，就像只是在引用一个函数，但是this的值得到了维持，因为object.getName和(object.getName)的定义是相同的。 第三次调用时，代码先执行一条赋值语句，然后再调用赋值后的结果。因为这个赋值表达式的值是函数本身（这个函数是一个匿名函数，匿名函数的this指向window对象），所以this的值不能得到维持，结果就返回the window。 内存泄露在IE9之前的版本对JScript对象和COM对象（Component Object Model，组件对象模型）使用不同的垃圾收集例程（标记清除和引用计数）。因此闭包在IE的这些版本中会导致一些特殊的问题。具体来说，如果闭包的作用域链中保存着一个HTML元素，那么就意味着该元素将无法被销毁。 123456function assignHandler()&#123; var element = document.getElementByID('someElement'); element.onclick = function()&#123; console.log(element.id); &#125;;&#125; 上面代码创建了一个作为element元素事件处理程序的闭包，而这个闭包则又创建了一个循环引用。由于匿名函数保存了一个对assignHandler()的活动对象的引用，因此就会导致无法减少element的引用数。只要匿名函数存在，element的引用数至少也是1，因此它所占用的内存就永远不会被回收。这个问题可以这样解决： 12345678910function assignHandler()&#123; var element = document.getElementByID('someElement'); var id= element.id; element.onclick = function()&#123; console.log(id); &#125;; element = null;&#125; 上面代码通过把element.id的一个副本保存在一个变量中，并且在闭包中引用该变量消除循环引用。闭包会引用包含函数的整个活动对象，而其中包含着element。即使闭包不直接引用element，包含函数的活动对象中也会保存一个引用。因此，需要把element变量设置为null。这样就能解除对DOM对象的引用，顺利减少其引用数，确保正常回收其占用的内存。 模仿块级作用域JavaScript没有块级作用域的概念。这意味着在块语句中定义的变量，实际上是在包含函数中而非语句中创建的： 123456function outputNumbers (count)&#123; for (var i = 0; i &lt; count; i++)&#123; console.log(i) //0,1,2 &#125; console.log(i); //3&#125; 在JavaScript中，变量i是定义在outputNumbers()的活动对象中的，因此从它有定义开始，就可以在函数内部随处访问它，即使像下面这样错误地重新声明同一个变量，也不会改变它的值： 1234567function outputNumbers (count)&#123; for (var i = 0; i &lt; count; i++)&#123; console.log(i) //0,1,2 &#125; var i; console.log(i); //3&#125; JavaScript不会告诉你是否多次声明了同一个变量；遇到这种情况，它只会对后续的声明视而不见（不过，它会执行后续声明中的变量初始化，例如，把上面的var i;变成var i = 1;，这时第二个console.log(i);就会打印出1）。匿名函数可以用来模仿块级作用域并避免这个问题。 用作块级作用域（通常称为私有作用域）的匿名函数的语法如下： 123(function()&#123; //这里是块级作用域&#125;)(); 以上代码定义并立即调用了一个匿名函数。将函数声明包含在()中，表示它实际上是一个函数表达式。而紧随其后的另一对()会立即调用这个函数。举个例子： 12var count = 5;outputNumbers(count); 这里初始化了变量count，将其值设置为5。当然这个变量是没有必要的，因为可以直接把值传递给函数： 1outputNumbers(5); 这样做之所以可行，是因为变量只不过是值的另一种表现形式，因此用实际的值替换变量没有问题。再看下面的例子： 1234var someFunction = function()&#123; //这里是块级作用域&#125;；someFunction(); 这个例子先定义了一个函数，然后立即调用它，定义函数的方式是创建一个匿名函数，并把匿名函数赋值给变量someFunction。而调用函数的方式是在函数名称后面添加一对()，通过前面的例子我们知道，可以使用实际的值来取代变量count，这里如果用函数值直接取代函数名，会导致错误： 123function()&#123; //这里是块级作用域 &#125;(); //出错 这是因为JavaScript将function关键字当作一个函数声明的开始，而函数声明后面不能跟()。但是函数表达式后面可以跟()。要将函数声明转换成函数表达式，只要像下面这样加上()就可以： 123(function()&#123; //这里是块级作用域&#125;)(); 无论在什么地方，只要零时需要一些变量，就可以使用私有作用域，比如： 12345678function outputNumbers(count)&#123; (function()&#123; for (var i=0; i &lt; count; i++)&#123; console.log(i); &#125; &#125;)(); console.log(i) //Uncaught ReferenceError: i is not defined&#125; 在匿名函数中定义的任何变量，都会在执行结束时被销毁。因为这个匿名函数是一个闭包，它能够访问包含作用域中的所有变量。 这种技术经常在全局作用域中被用在函数外部，从而限制像全局作用域中添加过多的变量和函数。一般应该尽量少向全局作用域中添加变量和函数。 这样做法可以减少闭包占用的内存问题，因为没有指向匿名函数的引用，只要函数执行完毕，就可以立即销毁其作用域链。 私有变量严格来说，JavaScript没有私有成员的概念，所有对象的属性都是公有的。不过，倒是有一个私有变量的概念。任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数外部访问这些变量。私有变量包括函数的参数、局部变量和在函数内部定义的其他函数。比如： 1234function add(num1,num2)&#123; var sum = num1 + num2; return sum;&#125; 上面函数内部有三个私有变量：num1、num2和sum。在函数内部可以访问这几个变量，但在函数外部则不能访问它们。如果在这个函数内部创建一个闭包，那么闭包通过自己的作用域链也可以访问这些变量。利用这一点，就可以创建用于访问私有变量的公有方法。 把有权访问私有变量和私有函数的公有方法称为特权方法。有两种在对象上创建特权方法的方式。第一种是在构造函数中定义特权方法，基本模式如下： 12345678910111213function MyObject()&#123; //私有变量和私有函数 var privateVariable = 10; function privateFunction()&#123; return false; &#125; //特权方法 this.publicMethod = function ()&#123; //this指向该构造函数的实例对象，并给这个实例对象创建一个publicMethod方法 privateVariable++; return privateFunction(); &#125;&#125; 能够在构造函数中定义特权方法，是因为特权方法作为闭包有权访问在构造函数中定义的所有变量和函数。上面例子中，privateVariable和privateFunction()只能通过特权方法publicMethod()来访问。 利用私有和特权成员，可以隐藏不应该被直接修改的数据，比如： 12345678910111213function Person(name)&#123; this.getName = function()&#123; return name; &#125;; this.setName = function(value)&#123; name = value; &#125;;&#125;var person = new Person('tc');console.log(person.getName()); //tcperson.setName('zj');console.log(person.getName()); //zj 上面代码在构造函数中定义了两个特权方法：getName()和setName()。这两个方法都可以在构造函数外部使用，而且都有权访问私有变量name。但在构造函数外部，没有任何办法访问name。由于这两个方法是在构造函数内部定义的，它们作为闭包能够通过作用域链访问name。私有变量name在Person的每一个实例中都不同，因为每次调用构造函数都会创建这两个方法。 在构造函数中定义特权方法有一个缺点，就是必须使用构造函数模式来达到这个目的。而构造函数模式的缺点是针对每个实例都会创建一组新的方法，而使用静态私有变量来实现特权方法就可以避免这个问题。 静态私有变量通过在私有作用域中定义私有变量或函数，同样也可以创建特权方法： 1234567891011121314151617(function()&#123; //私有变量和私有函数 var privateVariable = 10; function privateFunction()&#123; return false; &#125; //构造函数 MyObject = function()&#123;&#125;; //公有/特权方法 MyObject.prototype.publicMethod = function()&#123; privateVariable++; return privateFunction(); &#125;;&#125;)(); 这个模式创建了一个私有作用域，并在其中封装了一个构造函数及相应的方法。在私有作用域中，首先定义了私有变量和私有函数，然后又定义了构造函数及其方法。公有方法是在原型上定义的，这一点体现了典型的原型模式。这个模式在定义构造函数时并没有使用函数声明，而是使用了函数表达式。函数声明只能创建局部函数。出于同样原因，也没有在声明MyObject时使用var关键字。因为未经声明的变量，总是会创建一个全局变量。这样MyObject就能在私有作用域之外被访问到。但是在严格模式下给未经声明的变量赋值会导致错误。 这个模式与在构造函数中定义特权方法的主要区别在于，私有变量和函数是由实例共享的。由于特权方法是在原型上定义的，因此所有实例都使用同一个函数。而这个特权方法，作为闭包，总是保存着对包含作用域的引用。 123456789101112131415161718192021222324(function () &#123; var name = ''; Person = function (value) &#123; name = value; &#125;; Person.prototype.getName = function () &#123; return name; &#125;; Person.prototype.setName = function (value) &#123; name = value; &#125;;&#125;)();var person1 = new Person('tc');console.log(person1.getName()); //tcperson1.setName('zj');console.log(person1.getName()); //zjvar person2 = new Person('wcx');console.log(person1.getName()); //wcxconsole.log(person2.getName()); //wcx 在这个模式下，变量name就变成了静态的、所有实例共享的属性。也就是说，在一个实例上调用setName()会影响所有实例。 以这种方式创建静态私有变量会因为使用原型而增进代码复用，但每个实例都没有自己的私有变量。 模块模式前面的模式是用于为自定义类型创建私有变量和特权方法。而模块模式则是为单例创建私有变量和特权方法。所谓单例指的是只有一个实例的对象。按惯例，JavaScript是以对象字面量的方式来创建单例对象的。 123456var singleton = &#123; name: value, method: function()&#123; //这里是方法的代码 &#125;&#125; 模块模式通过为单例添加私有变量和特权方法能够使其得到增强： 123456789101112131415161718var singleton = function()&#123; //私有变量和私有函数 var privateVariable = 10; function privateFunction()&#123; return false; &#125; //特权/公有方法和属性 return &#123; //对象字面量定义了单例的公共接口 publicProperty: true, publicMethod: function()&#123; privateVariable++; return privateFunction(); &#125; &#125;;&#125;(); //()表示调用这个匿名函数 这个模块模式使用了一个返回对象的匿名函数。在这个匿名函数内部，首先定义了私有变量和函数。然后将一个对象字面量作为函数的值返回。返回的对象字面量中只包含可以公开的属性和方法。由于这个对象是在匿名函数内部定义的。因此它的公有方法有权访问私有变量和函数。从本质上讲，这个对象字面量定义的是单例的公共接口。这种模式在需要对单例进行某些初始化，同时又需要维护其私有变量时非常有用，比如： 1234567891011121314151617181920var application = function()&#123; //私有变量和函数 var components = new Array(); //初始化 components.push(new BaseComponent()); //公共 return &#123; getComponentCount: function()&#123; return components.length; &#125;, registerComponent: function(component)&#123; if(typeof component == 'object')&#123; components.push(component); &#125; &#125; &#125;;&#125;(); 如果必须创建一个对象并以某些数据对其进行初始化，同时还要公开一些能够访问这些私有数据的方法，那么就用模块模式。以这种模式创建的每个单例都是Object的实例，因为最终要通过一个对象字面量来表示它。 增强的模块模式这种增强的模块模式适合那些单例必须是某种类型的实例，同时还必须添加某些属性和方法对其加以增强的情况。 12345678910111213141516171819202122var singleton = function()&#123; //私有变量和私有函数 var privateVariable = 10; function privateFunction()&#123; return false; &#125; //创建对象 var object = new CustomType(); //添加特权/公有属性和方法 object.publicProperty = true; object.publicMethod = function()&#123; privateVariable++; return privateFunction(); &#125;; //返回这个对象 return object;&#125;(); 如果前面演示模块模式的例子中的application对象必须是BaseComponent的实例，那么就可以使用下面代码： 1234567891011121314151617181920212223var application = function()&#123; //私有变量和函数 var components = new Array(); //初始化 components.push(new BaseComponent()); //创建application的一个局部副本 var app = new BaseComponent(); //公共接口 app.getComponentCount = function()&#123; return components.length; &#125;; app.registerComponent = function(component)&#123; if(typeof component == 'object')&#123; components.push(component); &#125; &#125;; //返回这个副本 return app;&#125;();]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Github的敏捷开发]]></title>
    <url>%2F2017%2F07%2F12%2F%E5%9F%BA%E4%BA%8EGithub%E7%9A%84%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[Git和Github简介Git是由 Linux 之父 Linus Tovalds 创立的代码版本控制系统。你可以简单地把Git理解为管理代码历史记录的工具。比如，以前我管理需要反复修改的文档时，一般都是手动以日期加版本号来备份文档，有了git以后，我只需要一份文档，随时查看更改的内容，如果写错了，可以随时回退到之前的任意版本，即使删除了，也可以恢复。 而Github是基于Git的项目托管平台。Github现在已经是全球最大的社交编程及代码托管平台，经常被人调侃成全球最大的同性交友网站，简称Gayhub。 下面是知乎上关于Github界面的一张经典图片： 基于Github，你可以做很多事情，比如写书、搭建博客、多人协作翻译、项目管理，政府文件管理（日本政府已经把宪法放上去了，英国政府也在上面提供了很多政府项目的源代码或者设计原则之类的东西。）、科研项目和数据管理等等。 基于Github的敏捷开发发现这个技巧是在翻Angular仓库的时候发现的，熟悉基于JIRA的Scrum敏捷开发的人应该对下面几张截图比较熟悉： 参考Angular团队，就可以利用Github进行个人项目的敏捷开发或者学习。 关于敏捷开发：一般敏捷开发以两周为一个周期，称为一个迭代。在一个迭代中快速完成预估的工作量。我们团队的Scrum敏捷开发的步骤如下：1.需求澄清会：搞清楚用户需求。2.迭代会：提炼出核心需求，把每个工作分解，并估算完成点数（人数×天数），开完会后录入Jira中管理。3.站会：每天早上开一个短会，每个人讲一下昨天做了什么、今天要做什么、遇到了什么困难。根据站会的内容，同步Jira中对应任务的进度。4.回顾会：让领导对这个迭代内做的产品进行评估，提出问题，同时每个人说一下这个迭代收获或者需要改进的地方。 一个简单的案例比如我现在Github上有一个叫Professional-JavaScript-Demo的仓库，这是我用来学习《JavaScript高级程序设计》的，这本书有25章节，共730页。假设现在我把每一章算作是一个迭代（也就是两周）任务，这个任务又分成读完整章和整理整章的知识点两部分。基于这个前提，下面我们就利用Github进行敏捷学习。 首先，在Projects标签页中创建一个项目： 创建完后就可以看到这个界面： 此时点击Add column，创建三个列：准备，进行中和完成： 创建完了以后如下图所示，是不是感觉有点像jira了，哈哈哈。 接下来就是要创建卡片任务了，点击准备一列中右上角的+号，创建卡片任务，创建完了，点击卡片右上角的下拉符号，选择convert to issue，创建关联的issue。 这时候在issue标签页中就能看到关联的issue了，如下图所示。按照同样的步骤，创建一个叫第六章知识点整理的卡片。 在上图鼠标的上方有个Milestones按钮，没错，这相当于Jira里面的里程碑，在里程碑中，我们把第六章知识点整理和读完第六章作为一个里程碑，表示整个第六章完成了。 首先点击创建里程碑： 然后在这边可以选择里程碑结束日期，比如我选16号： 创建完如图所示： 然后我们需要把两个issue和这个里程碑关联起来，点击进入之前创建的issue，在右边栏中关联里程碑： 这时候类似于Jira的敏捷开发的管理工具就创建完成了。 假设我已经读完第六章了，也就是完成了卡片任务中的一个，这时候你可以在projects中把读完第六章的卡片拖到完成： 然后在issue中，点击下方白色的close issue按钮，把读完第六章这个issue关闭： 这时候你的里程碑会自动同步进度： 以上就是基于Github的敏捷开发流程的一个简单例子。 参考文章 怎样使用 GitHub？ 基于JIRA的Scrum敏捷开发的项目管理]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Github</tag>
        <tag>敏捷开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《JavaScript高级程序设计》学习笔记（一）]]></title>
    <url>%2F2017%2F07%2F03%2F%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[第一章：JavaScript简介 第二章：在HTML中使用JavaScript 第三章：基本概念 第四章：变量、作用域和内存问题 第五章：引用类型 JavaScript简介JavaScript简史JavaScript最早是Netscape为处理简单验证而开发的。 JavaScript实现一个完整的JavaScript实现应该由下列三个不同的部分组成： 核心（ECMAScript） 文档对象模型（DOM） 浏览器对象模型（BOM） ECMAScript由ECMA-262定义的ECMAScript与Web浏览器没有依赖关系。实际上，这门语言本身并不包含输入和输出定义。ECMA-262定义的只是这门语言的基础，在此基础之上可以构建更完善的脚本语言。我们常见的Web浏览器只是ECMAScript实现可能的宿主环境之一。宿主环境不仅提供基本的ECMAScript实现，同时也会提供该语言的扩展，以便语言与环境之间对接交互。而这些扩展（如DOM），则利用ECMAScript的核心类型和语法提供更多更具体的功能，以便实现针对环境的操作。其他宿主环境包括Node.js和Adobe Flash。 ECMAScript规定了下列组成部分： 语法 类型 语句 关键字 保留字 操作符 对象 ECMAScript就是对实现该标准的各个方面内容的语言的描述。JavaScript实现了ECMAScript，Adobe ActionScript同样也实现了ECMAScript。 文档对象模型（DOM）文档对象模型（DOM）是针对XML但经过扩展用于HTML的应用程序编程接口（是提供操作和访问网页内容的方法和接口）。DOM把整个页面映射为一个多层节点结构。 DOM1级由两个模块组成：DOM核心和DOM HTML。DOM核心规定的是如何映射基于XML的文档结构，以便简化对文档中任意部分的访问和操作。DOM HTML模块则在DOM核心的基础上加以扩展，添加了针对HTML的对象和方法。 DOM2级引入了下列新模块： DOM视图：定义了跟踪不同文档视图的接口 DOM事件：定义了事件和事件处理的接口 DOM样式：定义了基于CSS为元素应用样式的接口 DOM遍历和范围：定义了遍历和操作文档树的接口 DOM3级引入了下列新模块，并对DOM核心进行了扩展，开始支持XML1.0规范，涉及XML Infoset、XPath和XML Base。 DOM加载和保存模块：以统一方式加载和保存文档的方法 DOM验证模块：验证文档的方法 浏览器对象模型（BOM）BOM提供与浏览器交互的方法和接口。从根本上讲，BOM只处理浏览器窗口和框架；但人们习惯把所有针对浏览器的JavaScript扩展算作BOM的一部分，比如： 弹出新浏览器窗口的功能 移动、缩放和关闭浏览器窗口的功能 提供浏览器详细信息的navigator对象 提供浏览器所加载页面的详细信息的location对象 提供用户显示器分辨率详细信息的screen对象 对cookie的支持 像XMLHttpRequest和IE的ActiveXObject这样的自定义对象 在HTML中使用JavaScriptscript标签HTML4.0.1中为&lt;script&gt;定义了下列6个属性： async：可选。表示应该立即下载脚本，但不应该妨碍页面中的其他操作，比如下载其他资源或等待加载其他脚本，只对外部脚本文件有效。 charset：可选。表示通过src属性指定的代码的字符集。由于大多数浏览器会忽略它的值，所以很少用。 defer：可选。表示脚本可以延迟到文档完全被解析和显示之后再执行，只对外部脚本文件有效。 language：已废弃。 src：可选。表示包含要执行代码的外部文件。 type：可选。可以看成是language的代替属性；表示编写代码使用的脚本语言的内容类型。虽然text/javascript和text/ecmascript都已经不推荐使用，但人们一直以来使用的都还是text/javascript。实际上，服务器在传送JavaScript文件时使用的MIME类型通常是application/x-javascript，但在type中设置这个值却可能导致脚本被忽略。如果没有指定这个属性，则其默认值仍为text/javascript。 包含在&lt;script&gt;元素内部的JavaScript代码将从上至下依次解释。比如下面代码中，解释器会先解释到一个函数的定义，然后将该定义保存在自己的环境中。在解释器对&lt;script&gt;元素内部的所有代码求值完毕以前，页面中的其余内容都不会被浏览器加载或显示。 12345&lt;script&gt; function sayHi() &#123; alert('Hi'); &#125;&lt;/script&gt; 在使用&lt;script&gt;嵌入JavaScript代码时，不要在代码的任何地方出现&lt;/script&gt;字符串。比如，浏览器加载下面代码就会输出&quot;) }。因为浏览器遇到&lt;/script&gt;时，就会认为是结束的&lt;/script&gt;标签。可以通过转义字符把字符串分隔成两个部分来解决这个问题。 1234567891011&lt;script&gt; function sayScript() &#123; alert("&lt;/script&gt;") &#125;&lt;/script&gt;&lt;!--解决办法--&gt;&lt;script&gt; function sayScript() &#123; alert("&lt;\/script&gt;") &#125;&lt;/script&gt; 在解析外部JavaScript文件（包括下载该文件）时，页面的处理会暂时停止。 标签位置现代web应用程序一般都会把全部JavaScript引用放在&lt;body&gt;元素中页面的内容后面，这样在解析包含的JavaScript代码之前，页面的内容将完全呈现在浏览器中。 延迟脚本defer属性的用途是表明脚本在执行时不会影响页面的构造。也就是说，脚本会被延迟到整个页面都解析完毕后再运行。相当于告诉浏览器立即下载，但延迟执行。 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type="text/javascript" defer="defer" src="test1.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" defer="defer" src="test2.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!--内容--&gt;&lt;/body&gt;&lt;/html&gt; 上面代码中的脚本会延迟到浏览器遇到&lt;/html&gt;标签后再执行。根据HTML5规范要求，第一个延迟脚本会先于第二个延迟脚本执行，而两个脚本会先于DOMContentLoaded事件执行。但现实中，延迟脚本不一定会按照顺序执行，也不一定会在DOMContentLoaded事件触发前执行，因此最好最包含一个延迟脚本。 延迟脚本只适用于外部脚本文件，这点在HTML5中明确规定，支持HTML5的实现的浏览器会忽略嵌入脚本的defer属性。不支持defer属性的浏览器会忽略这个属性，因此把延迟脚本放在页面底部仍然是最佳选择。 异步脚本async属性只适用于外部脚本文件，并告诉浏览器立即下载文件，但是async属性并不保证按照它们的先后顺序执行。 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type="text/javascript" async src="test1.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" async src="test2.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!--内容--&gt;&lt;/body&gt;&lt;/html&gt; 上面代码中，第二个脚本文件可能会在第一个脚本文件之前执行。因此，要确保两者之间互不依赖。指定async属性的目的是不让页面等待两个脚本下载和执行，从而异步加载页面其他内容。因此，异步脚本尽量不要在加载期间修改DOM。 异步脚本一定会在页面的load事件之前执行，但可能会在DOMContentLoaded事件触发之前或之后执行。 基本概念语法区分大小写ECMAScript中的一切（变量、函数名和操作符）都是区分大小写的。 标识符标识符是指变量、函数、属性的名字，或者函数的参数。第一个字符必须是字母、下划线_或一个美元符号$。 标识符推荐使用驼峰大小写方式。 严格模式严格模式是ECMAScript5为JavaScript定义的一种不同的解析与执行模型。在严格模式下，ECMAScript3中一些不确定的行为将得到处理，而且对某些不安全的操作也会抛出错误。在整个脚本中启用严格模式，可以在顶部添加如下代码： 1"use strict" 在函数内部的上方包含这条编译指示，也可以指定函数在严格模式下执行： 1234function doSomething&#123; "use strict" //函数体&#125; 语句虽然语句结尾的分号不是必须的，但是建议任何时候都不要省略它。因为分号可以避免错误，并且在某些情况下增加代码性能（解析器不必花时间推测应该在哪里插入分号）。 始终在控制语句中使用代码块{}符号。 变量var message = &#39;hi&#39;，像这样初始化变量并不会把变量标记为字符串类型，因此，可以在修改变量值的同时修改值的类型，但不建议修改变量所保存值的类型。 使用var操作符定义的变量将成为定义该变量的作用域中的局部变量。如果省略var操作符，就会创建一个全局变量。 123456789function test() &#123; var message = 'hi'; message1 = 'hi'&#125;test();alert(message); //Uncaught ReferenceError: message is not definedalert(message1); //hi 在严格模式下，不能定义名为eval或arguments的变量，否则会导致语法错误。 数据类型ECMAScript有5种简单数据类型：Undefined、Null、Boolean、Number和String。还有一种复杂数据类型Object，Object本质上是由一组无序的名值对组成。 typeof操作符typeof负责检测给定变量的数据类型。返回值如下： undefined：值未定义 boolean：布尔值 string：字符串 number：数值 object：对象或null（null被认为是一个空对象的引用） function：函数 1234var message = 'hi';alert(typeof message); //stringalert(typeof (message)); //stringalert(typeof 95) //number Undefined类型在使用var声明变量但未对其加以初始化时，这个变量的值是undefined。 12345var message;alert(message == undefined); //truevar message = undefined;alert(message == undefined); //true 包含undefined值的变量和尚未定义的变量是不一样的： 1234var tang;alert(tang); //undefinedalert(cheng) //Uncaught ReferenceError: cheng is not defined 但是typeof操作符对未初始化的变量会返回undefined值，对未定义的变量也会返回undefined值。因为虽然这两种变量从技术角度看有本质区别，但实际上无论对哪种变量也不可能执行真正的操作。 1234var tang;alert(typeof tang); //undefinedalert(typeof cheng) //undefined Null类型null值表示一个空对象指针。 如果定义的变量准备要保存对象，最好将变量初始化为null而不是其他值，这样只要直接检查null的值就可以知道相应变量是否已经保存一个对象的引用： 123if (car != null)&#123; //对car对象的操作&#125; undefined值是派生自null值，因此ECMA-262规定对它们的相等性测试要返回true（null和undefined之间的相等操作符==总是返回true）： 12alert(null == undefined) //truealert(null === undefined) //false 无论什么情况下都没有必要把一个变量的值显式地设置为undefined。 如果保存对象的变量还没有真正保存变量前，就应该明确地让变量保存null值。 Boolean类型Boolean类型有两个值：true和false。 ECMAScript中所有类型的值都有与这两个Boolean值等价的值。要将一个值转换为其对应的Boolean值，可以调用转型函数Boolean()： 123var message = 'hi';var messageBoolean = Boolean(message);alert(messageBoolean); //true 转型函数Boolean()返回的是true还是false，取决于转换值的数据类型及其实际值。下表给出了各种数据类型及其对应转换规则： 数据类型 转换为true的值 转换为false的值 Boolean true false String 任何非空字符串 空字符串 Number 任何非零数字值（包括无穷大） 0和NaN Object 任何对象 null Undefined 不适用 undefined 这些规则对理解流控制语句（如if语句）自动执行相应的Boolean转换非常重要： 1234var message = 'hi';if (message)&#123; alert("value is true"); &#125; Number类型为了支持各种数值类型，ECMA-262定义了不同的数值字面量格式。 八进制第一位必须是0，八进制数字序列为0~7，如果字面值中的数值超过这个范围，前面导零会被忽略，后面数字被解析为十进制。八进制在严格模式下死无效的。 十六进制字面值的前两位必须是0x，后跟任何十六进制数字（0~9及A~F）。其中，字母不区分大小写。 浮点数值由于保存浮点数值需要的内存空间是保存整数值的两倍，因此ECMAScript会不失时机地将浮点数值转换为整数值。当小数点后面没有跟任何数字，那么这个数值就可以作为整数值来保存。当浮点数值本身表示一个整数（如1.0），那么该值也会转换为整数。 对于极大或极小数值，可以用科学计数法表示浮点数值，例如：var floatNum = 3.2e7;表示32000000。 浮点数值的最高精度是17位小数，但在进行算术计算时其精度远远不如整数。例如0.1加0.2的结果不是0.3，而是0.30000000000000004，但是0.05和0.25，或者0.15和0.15都不会有问题。这个小小的舍入误差会导致无法测试特定的浮点数值。因此，永远不要测试某个特定的浮点数值。 1234567if (0.1 + 0.2 == 0.3)&#123; //false alert("get 0.3");&#125;if (0.05 + 0.25 == 0.3)&#123; //true alert("get 0.3");&#125; 数值范围ECMAScript能够表示的最小数值保存在Number.MIN_VALUE中，在大多数浏览器是5e-324。能够表示的最大数值保存在Number.MAX_VALUE中，在大多数浏览器是1.7976931348623157e+308。 如果超出了这个范围，当数值为负数，会转化为-Infinity，当数值为正数，会转化为Infinity。 如果某次计算返回了正或负的Infinity值，那么该值将无法继续参与下一次计算。想要确定一个数值是不是位于最大值和最小值之间的，可以用isFinite()函数。如果位于最大值和最小值之间，返回true。 NaNNaN表示非数值（Not a Number），是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况。例如，任何数除以0会返回NaN，不会影响其他代码的执行。 NaN本身有两个非同寻常的特点： 任何涉及NaN的操作都会返回NaN NaN与任何值都不相等，包括NaN本身 ECMAScript定义了isNaN()函数，该函数会判断一个数是不是NaN。isNaN()接受到一个值之后，会尝试将这个值转换为数值。某些不是数值的值会直接转换为数值，而任何不能被转换为数值的值都会导致这个函数返回true。 12345alert(isNaN(NaN)); //truealert(isNaN(10)); //false(10是一个数值)alert(isNaN("10")); //false(可以被转化成数值10)alert(isNaN("blue")); //true(blue不能转化成数值)alert(isNaN(true)); //false(可以被转化为数值1) 数值转换有3个函数可以把非数值转换为数值：Number()、parseInt()和parseFloat()。 转型函数Number()可以用于任何数据类型，另外两个函数则专门用于把字符串转化成数值。 Number()函数的转换规则如下： 如果是Boolean值，true和false将分别被转换为1和0 如果是数字值，只是简单的传入和返回 如果是null，返回0 如果是undefined，返回NaN 如果是字符串，遵循下列规则 如果字符串只包含数字，则将其转换成十进制数值 如果字符串中包含有效的浮点格式，则将其转换成对应的浮点数值 如果字符串中包含有效的十六进制格式，则将其转换成相同大小的十进制整数 如果字符串是空，则将其转换成0 如果字符串中包含除上述格式之外的字符串，则将其转换成NaN。 如果是对象，则调用对象的valueof()方法，然后依照前面的规则转换成返回值。如果返回值是NaN，则调用对象的toString()方法，然后再次依照前面的规则转换返回的字符串值。 1234alert(Number('hello')); //NaNalert(Number('')); //0alert(Number('000011')); //11alert(Number(true)); //1 parseInt()函数在转换字符串时，更多的是看其是否符合数值模式。它会忽略字符串前面的空格，直到找到第一个非空格字符。如果第一个字符不是数字字符或负号，parseInt()就会返回NaN。parseInt()解析完第一个字符就会解析第二个字符，直到解析完所有后续字符或遇到一个非数字字符。parseInt()也能识别出各种整数格式（十进制、八进制、十六进制）。 123456alert(parseInt('123hello')); //123alert(parseInt('')); //NaN alert(parseInt('0xA')); //10(十六进制数)alert(parseInt(22.5)); //22alert(parseInt('70')); //70(十进制数)alert(parseInt('0xf')); //15(十六进制数) 在使用parseInt()解析八进制字面量的字符串时，ECMAScript5不具有解析八进制的能力，而在ECMAScript3中会被当成八进制字面量解析。 1alert(parseInt('070')); //ECMAScript5中输出70，ECMAScript3中输出56 这时候可以为parseInt()提供第二个参数：转换时使用的基数： 12alert(parseInt('070',8)); //输出56alert(parseInt('070',10)); //输出70 建议在无论什么情况下都指明基数。 parseFloat()和parseInt()类似，不过在parseFloat()中只有第一个小数点是有效的，第二个小数点及其后面的字符串都会被忽略。 parseInt()始终会忽略前导的0，因此它只解析十进制值。 String类型字符字面量String类型包含了一些特殊的字符字面量，也叫转义序列。 字面量 含义 \n 换行 \t 制表 \b 空格 \r 回车 \f 进纸 \\ 斜杠 \&#39; 单引号（在用单引号表示的字符串中使用） \&quot; 双引号（在用双引号表示的字符串中使用） \xnn 以十六进制代码nn表示的一个字符 \unnnn 以十六进制代码nnnn表示的一个Unicode字符 任何字符串的长度都可以通过访问其length属性取得。任何转义字符都只表示一个字符。 字符串的特点ECMAScript中的字符串是不可变的，字符串一旦创建，其值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量（这个过程是在后台发生的）。 转换为字符串 toString() 数值、布尔值、对象和字符串值都有toString()方法，但null和undefined值没有这个方法。toString()方法会返回相应值的字符串表现。 默认情况下，toString()方法以十进制返回数值的字符串表示，可以通过传递基数让toString()方法输出二进制、八进制、十六进制乃至其他任意有效进制格式表示的字符串值： 12345 var num = 10;console.log(num.toString()); //10console.log(num.toString(2)); //1010console.log(num.toString(8)); //12console.log(num.toString(16)); //a String() 在不知道转换的值是不是null或undefined的情况下，可以使用转型函数String()，这个函数能把任何类型的值转换为字符串。如果值是null，则返回null；如果值是undefined，则返回undefined；如果值有toString()方法，则调用该方法并返回相应的结果。 12345var a;var b = null;console.log(String(2)); //2console.log(String(b)); //nullconsole.log(String(a)); //undefined Object类型ECMAScript中的对象其实就是一组数据和功能的集合。Object类型所具有的任何属性和方法也同样存在于更具体的对象中。Object的每个实例都具有下列属性和方法： Constructor：保存着用于创建当前对象的函数。 hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中是否存在，其中，作为参数的属性名必须以字符串的形式指定。 isPrototypeof(object)：用于检查传入的对象是否是另一个对象的原型。 propertyIsEnumerable(propertyName)：用于检查给定的属性是否能使用for-in语句来枚举。 toLocaleString()：返回对象的字符串表示，该字符串与执行环节的地区对应。 toString()：返回对象的字符串表示。 valueOf()：返回对象的字符串、数值或布尔值表示。通常与toString()方法的返回值相同。 ECMA-262中对象的行为不一定适用于JavaScript中的其他对象。浏览器环境中的对象，比如BOM和DOM中的对象，都属于宿主对象，ECMA-262不负责定义宿主对象，因此宿主对象可能会也可能不会继承Object。 操作符一元操作符只能操作一个值的操作符叫一元操作符。 递增和递减操作符前置型：++i、--i；后置型：i++、i-- 在应用不同的值时，递增和递减操作符遵循下列规则： 在应用于一个包含有效数字字符的字符串时，先将其转换为数字值，在执行加减1操作 在应用于一个不包含有效数字字符的字符串时，将变量的值设置为NaN。 在应用于布尔值false时，先将其转换为0再执行加减1操作 在应用于布尔值true时，先将其转换为1再执行加减1操作 在应用于对象时，先调用valueOf()方法以取得一个可供操作的值。 123456789101112131415var s1 = "2";var s2 = "z";var m = false;var f = 1.1;var o = &#123; valueOf: function () &#123; return -1; &#125;&#125;;console.log(++s1); //3console.log(++s2); //NaNconsole.log(++m); //1console.log(--f); //0.1000000000000009console.log(--o); //-2 布尔操作符 逻辑非：由!表示 逻辑与：由&amp;&amp;表示，是短路操作符，第一个操作数求值为fasle就不会对第二个操作数求值 逻辑或：由||表示，是短路操作符，第一个操作数求值为true就不会对第二个操作数求值 乘性操作符 乘法：由*表示。如果一个操作数是NaN，结果是NaN；如果Infinity与0相乘，结果是NaN；如果Infinity与非零数值相乘，结果是Infinity或-Infinity；如果Infinity与Infinity相乘，结果是Infinity。 除法：由/表示。如果一个操作数是NaN，结果是NaN；如果0被0除，结果是NaN；如果非零有限数被0除，结果是Infinity或-Infinity；如果Infinity被Infinity除，结果是NaN；如果Infinity被任何非零数值除，结果是Infinity或-Infinity。 求模（余数）：由%表示。 加性操作符 加法：由+表示。 123456789var res = 5 + 5;console.log(res); //10var res2 = 5 + '5';console.log(res2); //55var num1 = 5; var num2 = 10; console.log("5 and 10 is " + num1 + num2); // 5 and 10 is 510console.log("5 and 10 is " + (num1 + num2)); //5 and 10 is 15 减法：由-表示。 12345console.log(5 - true); //4 ,true转换成1console.log(NaN - 1); //NaNconsole.log(5 - ""); //5，""转换成0console.log(5 - "2"); //3，"2"转换成2console.log(5 - null); //5，null转换成0 关系操作符&lt;、&gt;·、&lt;=和&gt;=这几个关系操作符用于两个值进行比较。 当关系操作符使用了非数值时，应用下列规则： 如果两个值都是数值，则进行数值比较 如果两个操作数是字符串，则比较两个字符串对应的字符编码值（大写字母的字符编码小于小写字母的字符编码，如果是字符串数字之间的比较，也会转换成字符编码进行比较） 如果一个操作数是数值，则将另一个操作数转换为一个数值，然后进行比较 如果操作数是对象，则调用这个对象的valueOf()方法，然后进行比较 任何与NaN比较的结果都是fasle。 1console.log('a' &lt; 3); //fasle 相等操作符ECMAScript提供两组操作符： 相等和不相等：先转换成相似的类型再比较 全等和全不等：仅比较不转换 相等和不相等相等操作符由==表示；不相等操作符由!=表示。这两个操作符都会先转换操作数（通常叫强制转型），然后再比较它们的相等性。 在转换不同数据类型时，相等和不相等操作符遵循下列规则： 如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值（false转换成0，true转换成1） 如果一个操作数是字符串，另一个操作数是数值，在比较前先将字符串转换为数值 如果一个操作数是对象，另个不是，则调用对象的valueOf()方法，用得到的基本类型数值进行比较 null和undefined是相等的 要比较相等性之前，不能将null和undefined转换成其他任何值 如果有一个操作数是NaN，则相等操作符返回false，不相等操作符返回true 即使两个操作数都是NaN，相等操作符也返回false，因为按规则NaN不等于NaN 如果两个操作数都是对象，则比较它们是不是同一个对象。如果指向同一个对象，则相等操作符返回true；否则返回false 表达式 值 null == undefined true &quot;NaN&quot; == NaN false 5 == NaN false NaN == NaN false NaN != NaN true false == 0 true true == 1 true true == 2 false undefined == 0 false null == 0 false &quot;5&quot; == 5 true false == &quot;&quot; true 全等和全不等全等由===表示；不全等由!==表示。除了在比较之前不转换操作数之外，全等和不全等操作符没什么区别。 null == undefined会返回true，因为它们是类似的值，但null === undefined会返回false，因为它们是不同类型的值。 条件操作符1variable = boolean_expression? true_value : false_value; 赋值操作符由=表示。等号前面添加乘性操作符、加性操作符或位操作符，就可以完成复合赋值操作。 *=：乘/赋值 /=：除/赋值 %=：模/赋值 +=：加/赋值 -=：减/赋值 &lt;&lt;=：左移/赋值 &gt;&gt;=：有符号右移/赋值 &gt;&gt;&gt;=：无符号右移/赋值 使用它们不会带来任何性能提升。 语句if语句if语句中的条件可以是任意表达式，而且对这个表达式的结果求值不一定是布尔值。ECMAScript会自动调用Boolean()转换函数将这个表达式结果转换为一个布尔值。 do-while语句只有在循环体中的代码执行后，才会测试出口条件。循环体中的代码至少会被执行一次。 while语句在循环体内代码执行之前，就会对出口条件求值。 for语句由于ECMAScript中不存在块级作用域，因此在循环内部定义的变量在外部也可以访问。 12345var count = 10;for (i = 0; i &lt; count; i++)&#123; console.log(i);&#125;alert(i); //10 for-in语句for-in语句是一种精准的迭代语句，可以用来枚举对象的属性。 1for (property in expression) statement ECMAScript对象的属性没有顺序，因此，用for-in循环输出的属性名的顺序是不可预测的。 如果表示要迭代的对象的变量值为null 或undefined，for-in语句会抛出错误。在ECMAScript5中对这种情况不会抛出错误，而是不执行循环体。 label语句使用label语句可以在代码中添加标签，以便将来使用。 1234567label: statement-----示例-----start: for(var i=0; i &lt; count; i++)&#123; alert(i);&#125; 加标签的语句一般都要与for语句等循环语句配合使用，这样将来可以由break或continue语句引用。 break和continue语句break语句会立即退出循环，强制继续执行循环后面的语句。 continue语句也会立即退出循环，但是退出循环后会从循环的顶部继续执行。 break和continue语句都可以与label语句联合使用，从而返回代码中的特定位置。 123456789101112131415161718192021var num = 0;outermost: for (var i = 0; i &lt; 10; i++)&#123; for (var j = 0; j &lt; 10; j++)&#123; if (i == 5 &amp;&amp; j == 5)&#123; break outermost; &#125; num++; &#125;&#125;console.log(num); //55----------------------------------------------var num1 = 0;outermost: for (var i = 0; i &lt; 10; i++)&#123; for (var j = 0; j &lt; 10; j++)&#123; if (i == 5 &amp;&amp; j == 5)&#123; continue outermost; &#125; num1++; &#125;&#125;console.log(num1); //95 with语句with语句的作用是将代码的作用域设置到一个特定的对象中。严格模式下不允许使用with语句。with语句会导致性能下降，并且很难调试。 switch语句在switch语句中可以使用任何数据类型。case的值可以是常量、变量或者表达式。 switch语句在比较值时使用的是全等操作符，因此不会发送类型转换 函数位于return之后的任何代码都不会被执行。 在严格模式中不能把函数命名为eval或arguments，不能把参数命名为eval或arguments，不能出现两个命名参数同名的情况。 理解参数ECMAScript函数不介意传递进来多少个参数，也不在乎传进来参数是什么数据类型。因为ECMAScript中的参数在内部是用一个数组来表示的。函数接收到的始终是这个数组，而不关心数组中包含哪些参数。 在函数体内部可以通过arguments对象来访问这个参数数组，从而获取传递给函数的每一个参数。arguments对象只是与数组类似，因为可以用方括号语法访问它的每一个元素，使用length属性来确定传递进来多少个参数。 123456function sayHi() &#123; alert("heollo " + arguments[0] + ',' + arguments[1]); //hello tang,cheng&#125;window.onload = function () &#123; this.sayHi("tang","cheng");&#125; 通过访问arguments对象的length属性可以获知有多少个参数传递给了函数，利用这点可以让函数接受任意个参数并分别实现适当的功能： 123456789function doAdd() &#123; if (arguments.length == 1)&#123; alert(arguments[0] + 10); &#125; else if (arguments.length == 2)&#123; alert(arguments[0] + arguments[1]); &#125;&#125;doAdd(10);doAdd(30,20); arguments对象可以与命名参数一起互换使用。 arguments的值永远与对应命名参数的值保持同步。修改了arguments对象中的值会自动反应到对应的命名参数中，但是这两个值的内存空间是独立的，只是值会同步，但这种影响是单向的，修改命名参数不会改变arguments中对应的值。 如果只传入一个参数，arguments[1]设置的值不会反应到命名参数中，这是因为arguments对象的长度是由传入的参数个数决定，不是由定义函数时的命名参数的个数决定的。 没有传递值的命名参数将被自动赋予undefined值。 在严格模式中，对如何使用arguments对象作出了以下限制： arguments值与对应命名参数的值不同步，比如即使把arguments[1]设置为10，num2的值还是undefined 重写arguments值会导致语法错误 没有重载在ECMAScript中定义了两个名字相同的函数，则该名字只属于后定义的函数。 通过检查传入函数中参数的类型和数量并作出不同的反应，可以模仿方法的重载。 变量、作用域和内存问题基本类型和引用类型的值ECMAScript变量包含两种不同数据类型的值：基本类型值和引用类型值。在将一个值赋给变量时，解析器必须确定这个值是基本类型值还是引用类型值。 基本类型指的是简单的数据段，基本数据类型包括：Undefined、Null、Boolean、Number和String。这五种基本数据类型是按值访问的，因此可以操作保存在变量中的实际值。 引用类型值指的是那些可能由多个值构成的保存在内存中的对象。JavaScript不允许直接访问内存中的位置（不能操作对象的内存空间），在操作对象时是在操作对象的引用而不是实际的对象，因此引用类型是按引用访问的。 动态属性对引用类型的值，可以为其动态添加属性和方法，也可以删除和修改其属性和方法。 但不能给基本类型添加属性和方法。 复制变量值如果一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到新变量分配的位置上。这两个变量可以参与任何操作而不会相互影响。 如果一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份到新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，这个指针指向存储在堆内存中的一个对象。复制结束后，两个变量实际上引用同一个对象。因此改变其中一个变量，就会影响另一个变量。 传递参数ECMAScript中所有函数的参数都是按值传递的（把函数外部的值复制给函数内部的参数，和把值从一个变量复制到另一个变量一样）。 在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量。 在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数外部（注：复制的是指针，两个引用指向同一个对象）。因为对象在参数中是按值传递的，所以下面第三个例子中，在函数内部重写obj时，这个变量引用的就是一个局部对象，而这个局部对象会在函数执行完毕后立即销毁。 123456789101112131415161718192021222324function addTen(num) &#123; num += 10; return num;&#125;var count = 20;var result = addTen(count);console.log(count); //20console.log(result); //30------------分割线------------function setName(obj) &#123; obj.name = 'tc';&#125;var person = new Object();setName(person);console.log(person.name); //tc------------分割线------------function setname(obj) &#123; obj.name = 'tc'; obj = new Object(); obj.name = 'cheng';&#125;var person2 = new Object();setname(person2);console.log(person2.name); //tc 函数内重写obj前后内存示意图如下图： 可以把ECMAScript函数的参数想象成局部变量 检测类型instanceof操作符可以检测对象的类型，如果变量是给定引用类型的实例，instanceof操作符会返回true。 1234567var person = new Object();var colors = new Array;var pattern = new RegExp();console.log(person instanceof Object); //trueconsole.log(colors instanceof Array); //trueconsole.log(pattern instanceof RegExp); //true instanceof操作符检测基本类型的值时，会返回false。 执行环境及作用域执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。 全局执行环境是最外围的一个执行环境。在web浏览器中，全局执行环境被认为是window对象。因此所有全局变量和函数都是作为window对象的属性和方法创建的。 某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁。 每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境会被推入一个环境栈中。在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。 当代码在一个环境中执行时，会创建变量对象的一个作用域链。作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问。 作用域链的前端始终是当前执行的代码所在环境的变量对象。如果这个环境是函数，则其活动对象作为变量对象。活动对象在最开始时只包含一个变量-arguments对象（这个对象在全局环境中不存在）。作用域链中的下一个变量对象来自外部环境，而再下一个对象则来自于下一个外部环境。这样一直延续到全局执行环境，全局执行环境的变量对象始终都是作用域中的最后一个对象。 标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直到找到标识符为止。 在局部作用域中定义的变量可以在局部环境下与全局变量互换使用。 1234567891011121314151617181920212223242526var color = 'blue';function changeColor() &#123; if (color === 'blue')&#123; color = 'red'; &#125;else &#123; color = 'blue'; &#125;&#125;changeColor();console.log('color is '+ color); //color is red------------分割线------------var color = 'blue';function changeColor() &#123; var anotherColor = 'red'; function swapColors() &#123; var tempColor = anotherColor; anotherColor = color; color = tempColor; &#125; swapColors();&#125;changeColor();console.log('color is '+ color); //color is red 内部环境可以通过作用域链访问所有的外部环境，但是外部环境不能访问内部环境中的任何变量和函数。每个环境都可以向上搜索作用域链，以查询变量和函数名，但任何环境都不能通过向下搜索作用域链而进入另一个执行环境。 延长作用域链有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除。在下面两种情况下会发生这种现象，当执行流进入下列任何一个语句时，作用域链会得到加长： try-catch语句的catch块，它会创建一个新的变量对象，其中包含的是被抛出的错误对象声明。 with语句，它会将指定的对象添加到作用域链中。 123456789function buildUrl() &#123; var qs = '?debug=true'; with (location)&#123; //with接受的location对象被添加到作用域链的前端 var url = href + qs; &#125; return url; //url成为函数执行环境的一部分，所以可以被返回&#125; 没有块级作用域JavaScript没有块级作用域，所以在下面例子中，if语句中定义的变量声明会将变量添加到当前的执行环境中。for语句中创建的变量i即使在for循环执行结束后，依旧会存在于循环外部的执行环境中。 123456789if (true)&#123; var color = 'blue';&#125;console.log(color); //blue------------分割线------------for (var i = 0; i &lt; 10; i++)&#123; doSomething(i);&#125;console.log(i) //10 声明变量使用var声明的变量会自动被添加到最接近的环境中。在函数内部，最接近的环境是函数的局部环境。如果初始化变量时没有使用var声明，该变量会自动被添加到全局环境中。 12345678910111213function add(num1,num2) &#123; var sum = num1 + num2; //sum只存在于add函数的局部环境中 return sum;&#125;var result = add(10,20);console.log(sum);//Uncaught ReferenceError: sum is not defined------------分割线------------function add2(num1,num2) &#123; sum = num1 + num2; //sum存在于全局环境中 return sum;&#125;var result2 = add(10,20);console.log(sum);//30 查询标识符当在某个环境中为了读取或写入而引用一个标识符时，必须通过搜索来确定该标识符实际代表什么，搜索过程从作用域链的前端（即当前环境）开始，闲上逐级查询与给定名字匹配的标识符。 下面例子中，在搜索过程中，如果存在一个局部的变量的定义，则搜索停止，不会再进入另外一个变量对象。任何位于局部变量color之后的代码，不使用window.color都无法访问全局变量color。如果有一个操作数是对象，而另一个不是，就会在对象上调用valueOf()方法取得基本类型的值，在进行比较。 12345678910111213141516171819var color = 'blue';function getColor() &#123; return color;&#125;console.log(getColor()); //blue------------分割线------------var color = 'blue';function getColor() &#123; var color = 'red'; return color;&#125;console.log(getColor()); //red------------分割线------------var color = 'blue';function getColor() &#123; var color = 'red'; return window.color;&#125;console.log(getColor()); //blue 访问局部变量要比访问全局变量更快，JavaScript引擎在优化标识符查询方面做得不错，这个差距可以忽略。 垃圾收集JavaScript具有自动垃圾收集机制，执行环境会负责管理代码执行过程中使用的内存。 函数中局部变量只在函数执行过程中存在，在这个过程中，会为全局变量在栈（或者堆）内存上分配相应的空间，以便存储它们的值。函数执行后，垃圾收集器会跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存。在浏览器中，用于表示无用变量的策略通常有两种：标记清除和引用计数。 标记清除JavaScript中最常用的垃圾收集方式是标记清除。当变量进入环境时，就将变量标记为进入环境。永远不能释放进入环境的变量所占用的内存。当变量离开环境时，将其标记为离开环境。 垃圾收集器在运行时会给存储在内存中的所有变量都加上标记，然后去掉环境中的变量以及被环境中的变量引用的变量的标记。在此之后再被加上标记的变量将会被视为准备删除的变量，最后垃圾收集器销毁那些带标记的值并回收它们所占用的内存空间。 引用计数另一种不常见的垃圾收集策略是引用计数。其含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，这个值的引用次数是1。如果同一个值又被赋给另一个变量，则引用次数加1。如果包含对这个值引用的变量又取得另外一个值，则这个值引用次数减1.当这个值引用次数变成0时，则说明没有办法再访问这个值，因此在垃圾收集器运行时会释放其占用的内存空间。 如果一个函数中两个对象互相引用各自属性，它们的引用次数永远不会是0，如果这个函数被多次调用，会导致大量内存得不到回收。 在IE9以下版本中，BOM和DOM中的对象是使用C++以COM（Component Object Model，组件对象模型）对象的形式实现。而COM对象的垃圾收集机制就是引用计数。所以只要在IE9以下版本中涉及COM对象，就会存在循环引用问题。 管理内存确保占用最少内存可以让页面获得更好的性能。一旦数据不再有用，最好通过将其值设置为null来释放其引用（这个方法叫解除引用）。这一做法适用于大多数全局变量和全局对象的属性。局部变量会在它们离开执行环境时自动被解除引用。 解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。 引用类型引用类型的值（对象）是引用类型的实例。新对象是使用new操作符后跟一个构造函数来创建的。 object类型创建Object实例的方式有两种： 使用new操作符后跟Object构造函数: 123var person = new Object();person.name = 'tc';person.age = 27; 使用对象字面量表示法： 1234var person = &#123; name: 'tc', age: 27&#125;; 使用对象字面量定义对象时，实际上不会调用Object构造函数。 访问对象属性时可以使用点表示法或方括号表示法。 方括号语法可以通过变量来访问属性。 如果属性名中包含会导致语法错误的字符，或者属性名使用的是关键字或保留字，也可以使用方括号表示法。 除非必须使用变量访问属性，否则推荐使用点表示法。 12345678910var person = &#123; 'name': 'tc', 'age': 27, 5: true&#125;;console.log(person['name']); //tcconsole.log(person.name); //tcvar myName = 'name';console.log(person[myName]); //tc Array类型ECMAScript数组的每一项可以保存任何类型的数据，数组的大小是可以动态调整的。 创建数组的基本方法有两种： 使用Array构造函数 12345var colors = new Array();var colors = new Array(20);var colors = new Array('red','blue','green');var colors = Array(3);var colors = Array('green'); 使用数组字面量表示法 12var colors = ['red','green','blue'];var colors = []; 使用对象字面量定义数组时，实际上不会调用Array构造函数。 在读取和设置数组的值时，要使用方括号并提供相应的基于0的数字索引。 如果设置某个值的索引超过了数组现有项数，数组就会自动增加到该索引值加1的长度。 数组的项数保存在其length属性中。数组的length属性不是只读的，通过设置这个属性，可以从数组的末尾移除项或向数组中添加新项。 检测数组Array.isArray()方法的目的是最终确定某个值是不是数组。 转换方法调用数组的toString()方法会返回由数组中每个值的字符串形式拼接而成的一个逗号分隔的字符串。 调用数组的valueOf()方法返回的还是数组。 alert()要接受字符串参数，后台会调用toString()，得到的结果与直接调用toString()方法输出相同。 123456var colors = ['red','blue','green'];console.log(colors.toString());//red,blue,greenconsole.log(colors.valueOf());//Array(3),打印出来的数组console.log(colors);//Array(3)，打印出来的数组alert(colors);//red,blue,green toLocaleString()方法经常也会返回与toString()和valueOf()方法相同的值，但也不总是如此。当调用数组的toLocaleString()方法时，它也会创建一个数组值的以逗号分隔的字符串。不同之处是，调用的是每一项的toLocaleString()方法，而不是toString()方法。 12345678910111213141516171819202122var person1 = &#123; toLocaleString: function () &#123; return 'tc'; &#125;, toString: function () &#123; return 'zj'; &#125;&#125;;var person2 = &#123; toLocaleString: function () &#123; return '11'; &#125;, toString: function () &#123; return '22'; &#125;&#125;;var people = [person1,person2];console.log(people); //(2) [Object, Object]console.log(people.toString()); //zj,22console.log(people.toLocaleString()); //tc,11 使用join()方法可以使用不同的分隔符来构建字符串。 如果数组中某一项是null 或者undefined，那么该值在join()、toString()、toLocaleString()、valueOf()方法返回的结果中以空字符串表示。 栈方法栈是一种LIFO（Last-In-First-Out，后进先出）的数据结构。栈中项的插入和移除，只发生在一个位置—栈的顶部。 ECMAScript为数组提供了push()和pop()方法，可以实现类似栈的行为。 push()方法可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。 pop()方法从数组末尾移除最后一项，减少数组的length值，然后返回移除项。 12345678var colors = ['red','blue'];colors.push('black'); colors[3] = 'yellow';console.log(colors.length); //4var item = colors.pop(); //取得最后一项console.log(item); //yellowconsole.log(colors.length); //3 队列方法队列数据结构的访问规则是FIFO（First-In-First-Out，先进先出）。队列在列表的末端添加项，在列表的前端移除项。 shift()方法能移除数组中的第一个项并返回该项，同时数组长度减1。 shift()和push()方法结合使用，就可以像使用队列一样使用数组。 123456789var colors = [];var count = colors.push('red','green');console.log(count); //2，push返回数组长度count = colors.push('black');console.log(count); //3var item = colors.shift();console.log(colors.length); //2 unshift()方法能在数组前端添加任意个项并返回新数组的长度。 同时使用unshift()和pop()方法，可以从相反的方向来模拟队列。 123456789var colors = [];var count = colors.unshift('red','green');console.log(count); //2count = colors.unshift('black');console.log(count); //3var item = colors.pop();console.log(item); //greenconsole.log(colors.length); //2 重排序方法reverse()方法会反转数组项的顺序。 123var values = [1,2,3,4,5];values.reverse();console.log(values); //5,4,3,2,1 sort()方法在默认情况下按升序排列数组项—即最小值在最前面，最大值在最后面。sort()方法会调用每个数组项的toString()方法，然后比较得到的字符串，以确定如何排序。即使数组中每一项是数值，sort()方法比较的也是字符串。 123var values = [0,1,5,10,15];values.sort();console.log(values); //0, 1, 10, 15, 5] 上面例子中，sort()方法在字符串比较时10位于5前面，所以得到上述顺序。 sort()方法可以接收一个比较函数作为参数，以便我们指定哪个值位于哪个值的前面。 比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等返回0，如果第一个参数应该位于第二个之后则返回一个正数。 12345678910111213var values = [0,1,5,10,15];function compare(value1,value2) &#123; if (value1 &lt; value2)&#123; return -1; &#125;else if (value1 &gt; value2) &#123; return 1; &#125;else &#123; return 0; &#125;&#125;values.sort(compare);console.log(values); //0, 1, 5, 10, 15 对于数值类型或者valueOf()方法会返回数值类型的对象类型，可以使用一个更简单的比较函数： 123function compare(value1,value2) &#123; return value2 - value1;&#125; 操作方法concat()方法可以基于当前数组中的所有项创建一个新数组，原数组的值不变。该方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。如果没有传递参数，该方法只是复制当前数组并返回副本。 12345var colors = ['red','green','blue'];var colors2 = colors.concat('yellow',['black','pink']);console.log(colors); //["red", "green", "blue"]console.log(colors2); //["red", "green", "blue", "yellow", "black", "pink"] slice()方法能基于当前数组中的一或多个项创建一个新数组。slice()方法可以接受一或两个参数，即要返回项的起始位置和结束位置。在只有一个参数的情况下，slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法会返回起始位置和结束位置之间的项—但不包括结束位置的项。slice()方法不会影响原始数组。 1234567var colors = ['red','green','blue','yellow','pink'];var colors2 = colors.slice(1);var colors3 = colors.slice(1,4);console.log(colors); //["red", "green", "blue", "yellow", "pink"]console.log(colors2); //["green", "blue", "yellow", "pink"]console.log(colors3); //["green", "blue", "yellow"] 如果slice()方法的参数中有一个负数，则利用数组长度加上该数来确定相应的位置。例如，在一个包含5项的数组中，slice(-2,-1)与slice(3,4)结果相同。 splice()方法主要用途是向数组的中部插入项，但是该方法有下面三种使用方式： 删除：可以删除任意数量的项，只需要指定两个参数：要删除的第一项的位置和要删除的项数。 插入：可以向指定位置插入任意数量的项，只需要提供3个参数：起始位置、0（要删除的项数）和要插入的项。如果要插入多个项，可以再传入第四、第五，以至任意多项。 替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定3个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。 splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项。 12345678910111213var colors = ['red','blue','green'];var remove = colors.splice(0,1); //删除第一项console.log(colors); //["blue", "green"]console.log(remove); //["red"]remove = colors.splice(1,0,'yellow','pink');//从位置1开始插入两项console.log(colors); //["blue", "yellow", "pink", "green"]console.log(remove); //[]remove = colors.splice(1,1,'red','purple');//插入两项，删除一项console.log(colors); //["blue", "red", "purple", "pink", "green"]console.log(remove); //["yellow"] 位置方法indexOf()和lastIndexOf()方法都接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。indexOf()方法从数组的开头开始向后查找，lastIndexOf()方法则从数组的末尾开始向前查找。 这两个方法都要返回要查找的项在数组中的位置，或者在没有找到时返回-1。在比较第一个参数与数组中每一项时，会用全等操作符。 123456789101112var numbers = [1,2,3,4,5,4,3,2,1];console.log(numbers.indexOf(4)); //3console.log(numbers.lastIndexOf(4));//5console.log(numbers.indexOf(4,4)); //5console.log(numbers.lastIndexOf(4,4));//3var person = &#123;'name':'tc'&#125;;var people = [&#123;'name':'tc'&#125;];var morePeople = [person];console.log(people.indexOf(person)); //-1console.log(morePeople.indexOf(person));//0 迭代方法ECMAScript5为数组定义了5个迭代方法。每个方法都接收两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域对象—影响this的值。传入这些方法的函数会接收三个参数：数组项的值、该项在数组中的位置和数组对象本身。根据使用的方法不同，这个函数执行后的返回值可能会也可能不会影响访问的返回值。 every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true。 filter()：对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组。 forEach()：对数组中的每一项运行给定函数。这个方法没有返回值，本质上与使用for循环迭代数组一样。 map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。 some()：对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true。 以上方法都不会修改数组中的包含值。 123456789101112131415161718192021222324252627282930313233343536var numbers = [1,2,3,4,5,4,3,2,1];var everyResult = numbers.every(function (item, index, array) &#123; return (item &gt; 2)&#125;);console.log(everyResult); //falsevar someResult = numbers.some(function (item, index, array) &#123; return (item &gt; 2);&#125;);console.log(someResult); //truevar filterResult = numbers.filter(function (item, index, array) &#123; return (item &gt; 2);&#125;);console.log(filterResult); //[3, 4, 5, 4, 3]var mapResult = numbers.map(function (item, index, array) &#123; return (item * 2);&#125;);console.log(mapResult); //[2, 4, 6, 8, 10, 8, 6, 4, 2]numbers.forEach(function (item, index, array) &#123; console.log('item=' + item + ' index=' + index + ' array=' + array);&#125;);/* *item=1 index=0 array=1,2,3,4,5,4,3,2,1 *item=2 index=1 array=1,2,3,4,5,4,3,2,1 *item=3 index=2 array=1,2,3,4,5,4,3,2,1 *item=4 index=3 array=1,2,3,4,5,4,3,2,1 *item=5 index=4 array=1,2,3,4,5,4,3,2,1 *item=4 index=5 array=1,2,3,4,5,4,3,2,1 *item=3 index=6 array=1,2,3,4,5,4,3,2,1 *item=2 index=7 array=1,2,3,4,5,4,3,2,1 *item=1 index=8 array=1,2,3,4,5,4,3,2,1 */ 缩小方法reduce()和reduceRight()方法都会迭代数组的所有项，然后构建一个最终返回的值。 reduce()方法从数组的第一项开始，逐个遍历到最后。reduceRight()则从数组的最后一项开始，向前遍历到第一项。 这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为缩小基础的初始值。这两个方法参数中的调用函数都接收四个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传递给下一项。第一个迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数是数组的第二项。 12345var values = ['1','2','3','4','5'];var sum = values.reduce(function (prev, cur, index, array) &#123; return prev + cur;&#125;)console.log(sum); //15 Date类型Date类型使用自UTC（国际协调时间）1970年1月1日零时开始经过的毫秒数来保存日期。date类型保存的日期能精确到1970年1月1日之前或之后的285616年。 在调用Date构造函数而不传递参数的情况下，新创建的对象自动获得当前日期和时间。如果想根据特定的日期和时间创建日期对象，必须传入表示该日期的毫秒数。为了简化这一计算过程，ECMAScript提供了Date.parse()和Date.UTC()方法。 Date.parse()方法接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日期的毫秒数。这个方法的行为实现因地区而异（以地区为美国为例）： 月/日/年 英文月名 日,年 英文星期几 英文月名 日 年 时:分:秒 时区 ISO 8601 扩展模式 YYYY-MM-DDTHH:mm:ss:sssZ，只有兼容ECMAScript5的实现支持这种格式 实际上如果直接将表示日期的字符串传递给Date构造函数，也会在后台调用Date.parse()。 12345var someDate = new Date(Date.parse('May 25,2017'));var someDate2 = new Date('May 25,2017');console.log(someDate); //Thu May 25 2017 00:00:00 GMT+0800 (CST)console.log(someDate2); //Thu May 25 2017 00:00:00 GMT+0800 (CST) Date.UTC()方法同样也返回表示日期的毫秒数，但它与Date.parse()在构建值时使用不同的信息。Date.UTC()的参数分别是年份、基于0的月份、月中的哪一天、小时数、分钟、秒及毫秒数。在这些参数中只有前两个参数是必须的。 Date构造函数也会模仿Date.UTC()，但日期和时间都基于本地时间而非GMT来创建。Date构造函数接收的参数仍然与Date.UTC()相同。 1234567891011var y2k = new Date(Date.UTC(2000,0));var y2k2 = new Date(2000,0);var allFives = new Date(Date.UTC(2005,4,5,17,55,55));var allFives2 = new Date(2005,4,5,17,55,55);console.log(y2k);//Sat Jan 01 2000 08:00:00 GMT+0800 (CST)console.log(y2k2);//Sat Jan 01 2000 00:00:00 GMT+0800 (CST)console.log(allFives);//Fri May 06 2005 01:55:55 GMT+0800 (CST)console.log(allFives2);//Thu May 05 2005 17:55:55 GMT+0800 (CST) Date.now()方法返回表示调用这个方法时的日期和时间的毫秒数。 1234567var start = Date.now();setTimeout(function () &#123; var stop = Date.now(); result = stop - start; console.log(result); //10002&#125;,10000); 继承的方法Date类型也重写了toLocaleString()、toString()和valueOf()方法。 Date类型的toLocaleString()方法会按照与浏览器设置的地区相适应的格式返回日期和时间。这大致意味着时间格式中会包含AM和PM，但不会包含时区信息。 toString()方法通常返回带有时区信息的日期和时间，时间一般是24小时制。 valueOf()返回日期的毫秒表示，因此可以方便使用比较操作符来比较日期值。 日期格式化方法 toDateString()：以特定于实现的格式显示星期几、月、日和年 toTimeString()：以特定于实现的格式显示时、分、秒和时区 toLocaleString()：以特定于地区的格式显示星期几、月、日和年 toLocaleTimeString()：以特定于地区的格式显示时、分、秒 toUTCString()：以特定于实现的格式完整的UTC日期 日期/时间组件方法 RegExp类型通过下面语法，可以创建一个正则表达式： 1var expression = / pattern / flags; 其中pattern（模式）是任何简单或复杂的正则表达式，可以包括字符类、限定符、分组、向前查找以及反向引用。每个正则表达式都可以带有一或多个flags，以标明正则表达式的行为。正则表达式的匹配模式支持下列3个标志： g：表示全局模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止 i：表示不区分大小写模式 m：表示多行模式 在pattern中使用的所有元字符都必须转义。正则表达式中的元字符包括 1( [ &#123; \ ^ $ | ) ? * + . ] &#125; 还可以使用RegExp构造函数创建正则表达式，它接受两个参数：一个是匹配的字符串模式，另一个是可选的标志字符串。 123//下面两个创建正则表达式的方式等价var pattern = /[bc]at/i;var pattern1 = new RegExp('[bc]at','i'); 要注意的是，传递给RegExp构造函数的两个参数都是字符串，所以在某些情况下要对字符进行双重转义。所有元字符必须双重转义，转义过的字符也是如此。 使用正则表达式字面量和使用RegExp构造函数创建的正则表达式不一样。在ECMAScript3中，正则表达式字面量始终会共享同一个RegExp实例，而使用构造函数创建的每一个新RegExp实例都是一个新的实例。在下面例子中，第一个循环只为/cat/创建了一个RegExp实例。由于实例属性不会重置，所以在循环中再次调用test()方法会失败。这个是因为第一次调用test()找到了“cat”，但第二次调用是从索引为3的字符（上次匹配的末尾）开始，所以找不到它。由于会测试到字符串末尾，所以下次再调用test()就又从开头开始了。第二个循环中，每个迭代都会创建一个新的RegExp实例，所以每次调用test()都会返回true。 123456789101112var re = null, i;for (i = 0; i &lt; 10; i++)&#123; re = /cat/g; re.test('catastrophe');&#125;for (i = 0; i &lt; 10; i++)&#123; re = new RegExp('cat','g'); re.test('catastrophe');&#125; ECMAScript5明确规定，使用正则表达式字面量必须像调用RegExp构造函数一样，每次都创建新的RegExp实例。 RegExp实例属性 global：布尔值，表示是否设置了g标志 ignoreCase：布尔值，表示是否设置了i标志 lastIndex：整数，表示开始搜索下一个匹配项的字符位置，从0算起 multiline：布尔值，表示是否设置了m标志 source：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回 RegExp实例方法exec()方法是专门为捕获组而设计的。exec()方法接收一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组；或者在没有匹配项的情况下返回null。返回的数组虽然是Array的实例，但包含两个额外的属性：index和input。index表示匹配项在数组中的位置，而input表示应用正则表达式的字符串。数组中第一项是整个模式匹配的字符串，其他项是与模式中捕获组匹配的字符串（如果模式中没有捕获组，则该数组只包含一项）。 123456789var text = 'mom and dad and baby';var pattern = /mom( and dad( and baby)?)?/gi;var matches = pattern.exec(text);console.log(matches.index); //0console.log(matches.input); //mom and dad and babyconsole.log(matches[0]); //mom and dad and babyconsole.log(matches[1]); //and dad and babyconsole.log(matches[2]); //and baby 对exec()方法而言，即使在模式中设置了全局标志g，它每次只会返回一个匹配项。在不设置全局标志的情况下，同一个字符串上多次调用exec()将始终返回第一个匹配项的信息。在设置全局标志的情况下，每次调用exec()都将会在字符串中继续查找新匹配项。 1234567891011121314151617181920212223var text = 'cat, bat , sat , fat';var pattern1 = /.at/;var matches = pattern1.exec(text);console.log(matches.index); //0console.log(matches[0]); //catconsole.log(pattern1.lastIndex); //0matches = pattern1.exec(text);console.log(matches.index); //0console.log(matches[0]); //catconsole.log(pattern1.lastIndex); //0var pattern2 = /.at/g;matches = pattern2.exec(text);console.log(matches.index); //0console.log(matches[0]); //catconsole.log(pattern2.lastIndex); //3matches = pattern2.exec(text);console.log(matches.index); //5console.log(matches[0]); //batconsole.log(pattern2.lastIndex); //8 test()方法接收一个字符串参数，在模式与该参数匹配的情况下返回true，否则，返回false。test()经常被用在if语句中。 123456var text = '000-00-0000';var pattern = /\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;/;if (pattern.test(text))&#123; console.log('matched'); //matched&#125; RegExp实例继承的toLocaleString()和toString()方法都会返回正则表达式的字面量。 RegExp构造函数属性RegExp构造函数的属性适用于作用域中所有的正则表达式，并且基于所执行的最近一次正则表达式操作而变化。可以通过两种方式访问这些属性，短属性名可以通过[]访问，长属性名可以通过.访问。 长属性名 短属性名 说明 input $_ 最近要匹配的字符串。Opera未实现此属性 lastMatch $&amp; 最近一次的匹配项。Opera未实现此属性 lastParen $+ 最近一次匹配的捕获组。Opera未实现此属性 leftContext $` input字符串中lastMatch之前的文本 mutiline $* 布尔值，表示是否所有表达式都使用多行模式。IE和Opera未实现此属性 rightContext $’ Input字符串中lastMatch之后的文本 1234567891011var text = 'this has been a short summer';var pattern = /(.)hort/g;if (pattern.test(text))&#123; console.log(RegExp.input); //this has been a short summer console.log(RegExp.leftContext); //this has been a console.log(RegExp.rightContext); // summer console.log(RegExp.lastMatch); //short console.log(RegExp.lastParen); //s console.log(RegExp.multiple); //undefined(这个属性好像不存在了)&#125; Function类型每个函数都是Function类型的实例，函数名实际上是一个指向函数对象的指针，不会与某个函数绑定。定义函数的方式有下面几种： 用函数声明语法定义 123function sum (num1, num2) &#123; return num1 + num2;&#125; 用函数表达式语法定义 123var sum = function (num1, num2) &#123; return num1 + num2;&#125;; 用Function构造函数（不推荐） 1var sum = new Function('num1','num2','return num1 + num2') 函数声明与函数表达式解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会先读取函数声明，并使其在执行任何代码之前可用。而函数表达式必须等到解析器执行到它所在的代码行，才会真正被解释执行。 123456789console.log(sum(10,10)); //20function sum(num1,num2) &#123; return num1 + num2; &#125;console.log(sum1(10,10)); //sum1 is not a functionvar sum1 = function (num1, num2) &#123; return num1 + num2;&#125; 第一个例子中，在代码开始执行之前，解析器就已经通过一个名为函数声明提升的过程，读取并将函数声明添加到执行环境中，对代码求值时，JavaScript引擎在第一遍会声明函数并将它们放到源代码树的顶部。所以，即使声明函数的代码在调用它的代码后面，JavaScript引擎也能把函数声明提升到顶部。 第二个例子中，在执行到函数所在语句之前，变量sum不会保存对函数的引用。 作为值的函数ECMAScript中函数名本身就是变量，所以函数也可以作为值来使用。不仅可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。 1234567891011121314151617function callSomeFunction(someFunction,someArgument) &#123; return someFunction(someArgument);&#125;function add10(num) &#123; return num + 10;&#125;var result = callSomeFunction(add10,10);console.log(result); //20function getGreeting(name) &#123; return 'hello ' + name;&#125;var result2 = callSomeFunction(getGreeting,'nicholas');console.log(result2); //hello nicholas 还可以从一个函数中返回另一个函数，这是极为有用的一种技术： 12345678910111213141516171819202122232425262728function createComparisonFunction(propertyName) &#123; return function (object1, object2) &#123; var value1 = object1[propertyName]; var value2 = object2[propertyName]; if (value1 &lt; value2)&#123; return -1; &#125;else if (value1 &gt; value2)&#123; return 1; &#125;else &#123; return 0; &#125; &#125;;&#125;var data = [&#123; name: 'tc', age: 27&#125;,&#123; name: 'zj', age: 23&#125;];data.sort(createComparisonFunction('name'));console.log(data[0].name); //tcdata.sort(createComparisonFunction('age'));console.log(data[0].name); //zj 函数内部属性函数内部有两个特殊的对象：arguments和this。 arguments是一个类数组对象，包含传入函数中的所有参数。这个对象还有一个叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。 在严格模式下arguments.callee会导致错误。 123456789101112131415161718function factorial(num) &#123; if (num &lt;= 1)&#123; return 1; &#125;else &#123; return num * factorial(num - 1); &#125;&#125;function factorial1(num) &#123; if (num &lt;= 1)&#123; return 1; &#125;else &#123; return num * arguments.callee(num - 1); //用callee属性解除函数执行与函数名的高耦合 &#125;&#125;console.log(factorial(5)); //120console.log(factorial1(5)); //120 this引用的是函数据以执行的环境对象，当在全局作用域中调用函数时，this对象引用的就是windows。 1234567891011window.color = 'red';var o = &#123;color:'blue'&#125;;function sayColor() &#123; console.log(this.color);&#125;sayColor(); //red,全局作用域调用sayColor，this指向window对象o.sayColor = sayColor;o.sayColor(); //blue，对象o调用sayColor，this指向对象o ECMAScript也规范化了另一个函数对象的属性：caller。这个属性中保存着调用当前函数的函数引用，如果在全局作用域中调用当前函数，它的值为null。 1234567891011121314function outer() &#123; inner();&#125;function inner() &#123; console.log(inner.caller); console.log(arguments.callee.caller);&#125; outer(); /**function outer() &#123;*inner();*&#125;*/ 严格模式下，不能为函数的caller属性赋值。 函数属性和方法每个函数都包含两个属性：length和prototype。 length属性表示函数希望接收的命名参数的个数。 123456789101112131415function sayName(name) &#123; console.log(name);&#125;function sum(num1,num2) &#123; return num1 + num2;&#125;function sayHi() &#123; console.log('hi');&#125;console.log(sayName.length); //1console.log(sum.length); //2console.log(sayHi.length); //0 对于ECMAScript中的引用类型而言，prototype是保存它们所有实例方法的真正所在。诸如toString()和valueOf()等方法实际上都保存在prototype名下，只不过是通过各自对象的实例访问。在ECMAScript5中，prototype属性是不可枚举的。 每个函数都包含两个非继承而来的方法：apply()和call()。这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。apply()方法接收两个参数：一个是其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是Array的实例，也可以是arguments对象。 1234567891011121314function sum(num1,num2) &#123; return num1 + num2;&#125;function callSum1(num1,num2) &#123; return sum.apply(this,arguments);//全局作用域中，this指window对象&#125;function callSum2(num1,num2) &#123; return sum.apply(this,[num1,num2]);&#125;console.log(callSum1(10,10)); //20console.log(callSum2(10,10)); //20 call()方法与apply()方法相同，区别在于接收参数的方式不同。使用call()方法时，传递给函数的参数必须逐个列举出来。 123456789function sum(num1,num2) &#123; return num1 + num2;&#125;function callSum3(num1,num2) &#123; return sum.call(this,num1,num2);&#125;console.log(callSum3(10,10)); //20 apply()和call()真正强大的地方是能够扩充函数赖以运行的作用域。 123456789window.color = 'red';var o = &#123;color: 'blue'&#125;;function sayColor() &#123; console.log(this.color);&#125;sayColor(); //red,this.color转换成window.colorsayColor.call(this); //red，显式地在全局作用域调用函数sayColor.call(window); //red，显式地在全局作用域调用函数sayColor.call(o); //blue，this指向o 使用call()或者apply()来扩充作用域的最大好处是，对象不需要与方法有任何耦合关系。 ECMAScript5还定义了一个方法：bind()。这个方法会创建一个函数的实例，其this值会被绑定到传给bind()函数的值。 123456789window.color = 'red';var o = &#123;color: 'blue'&#125;;function sayColor() &#123; console.log(this.color);&#125;var objectSayColor = sayColor.bind(o);objectSayColor(); //blue 基本包装类型ECMAScript提供了3个特殊的引用类型：Boolean、Number和String。每当读取一个基本类型值的时候，后台都会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。 12var s1 = 'tc';var s2 = s1.substring(2); 当上面例子访问第二行代码时，访问过程处于一种读取模式，而在读取模式中，后台会自动完成下列处理： 创建string类型的一个实例； 在实例上调用指定的方法； 销毁这个实例 以上三个步骤可以想象成下面代码： 123var s1 = new String('some text');var s2 = s1.substring(2);s1 = null; 经过上述处理，字符串值就变得跟对象一样。 引用类型与基本包装类型的主要区别就是对象的生存期。使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。这意味着不能在运行时为基本类型值添加属性和方法。 对基本包装类型的实例调用typeof会返回true，而且所有基本包装类型的对象都会被转换为布尔值true。 Object构造函数会像工厂方法一样，根据传入值的类型返回相应基本包装类型的实例。把字符串传给Object构造函数，就会创建String的实例。 12var obj = new Object('tc');console.log(obj instanceof String); //true 使用new调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的。 123456var value = '25';var number = Number(value); //转型函数console.log(typeof number); //numbervar obj = new Number(value); //构造函数console.log(typeof obj); //object 不建议显式地创建基本包装类型的对象，但它们操作基本类型值的能力还是相当重要的。而每个基本包装类型都提供了操作相应值的便捷方法。 Boolean类型Boolean类型是与布尔值对应的引用类型。要创建Boolean对象，可以像下面这样调用Boolean构造函数并传入true或者false值。 1var booleanObject = new Boolean(true); Boolean类型的实例重写了valueOf()方法，返回基本类型值true或false；重写了toString()方法，返回字符串true和false。Boolean对象在ECMAScript中用处不大，因为常会造成误解： 1234567var falseObject = new Boolean(false);var result = falseObject &amp;&amp; true;//对falseObject求值，布尔表达式中所有对象都会被转换为trueconsole.log(result); //truevar falseObject = false;result = falseObject &amp;&amp; true;console.log(result); //false 基本类型与引用类型的布尔值还有下列两个区别： typeof操作符对基本类型返回boolean，而对引用类型返回object Boolean对象是Boolean类型的实例，使用instanceof操作符测试Boolean对象会返回true，而测试基本类型的布尔值会返回false Number类型Number类型是与数字值对应的引用类型。要创建Number对象，可以在调用Number构造函数时向其中传递相应的数值： 1var numberObject = new Number(10); Number类型也重写了valueOf()、toLocaleString()和toString()方法。重写后的valueOf()方法返回对象表示的基本类型的数值，另外两个方法则返回字符串形式的数值。 Number类型的toFixed()方法会按照指定的小数位返回数值的字符串表示，如果数值本身包含的小数位比指定的还多，接近指定的最大小数位的值会舍入： 12345var num = 10;console.log(num.toFixed(2)); //10.00num = 10.0005;console.log(num.toFixed(2)); //10.01 toExponential()方法返回以指数表示发表示的数值的字符串形式。它接收一个参数，该参数指定输出结果中的小数位数： 12var num = 10;console.log(num.toExponential(1)) //1.0e+1 toPrecision()方法会根据数字的位数返回一个合适的格式，它可能会返回固定大小的格式，也会返回指数格式，这个方法接收一个参数，该参数表示数值的所有数字的位数： 1234var num = 99;console.log(num.toPrecision(1)); //1e+2console.log(num.toPrecision(2)); //99console.log(num.toPrecision(3)); //99.0 String类型String类型是字符串的对象包装类型，可以像下面这样使用String构造函数来创建： 1var stringObject = new String('hello'); String对象的方法也可以在所有基本的字符串值中访问到。其中，继承的valueOf()、toLocaleString()和toString()方法，都返回对象所表示的基本字符串值。 String类型的每个实例都有一个length属性，表示字符串中包含多少个字符。 字符方法charAt()和charCodeAt()方法用于访问字符串中特定字符。两个方法都接收一个参数，即基于0的字符位置。 charAt()方法以单字符字符串的形式返回给定位置的那个字符： 12var stringValue = 'hello';console.log(stringValue.charAt(1)); //e charCodeAt()方法则返回给定位置的字符的字符编码： 12var stringValue = 'hello';console.log(stringValue.charCodeAt(1)); //101 在ECMAScript5中，还定义了用方括号加数字索引访问个别字符的方法： 12var stringValue = 'hello';console.log(stringValue[1]); //e 字符串操作方法 concat()方法用于将一或多个字符串拼接起来，返回拼接得到的新字符串。 1234var stringValue = 'hello ';var result = stringValue.concat('world');console.log(result); //hello worldconsole.log(stringValue); //hello concat()方法接受任意多个参数。 实际使用中用+来拼接字符串比较多，这样更简便易行。 slice()、substr()、substring()方法都会返回被操作字符串的一个子字符串，它们接收一或两个参数，第一个参数指定子字符串的开始位置，第二个参数表示子字符串到哪里结束。 具体来说，slice()和substing()的第二个参数指定的是子字符串最后一个字符后面的位置。而substr()`的第二个参数指定的是返回的字符个数。如果没有传第二个参数，则将字符串的长度作为结束位置。这三个方法不会修改字符串本身的值，它们只是返回一个基本类型的字符串值，对原始字符串没有任何影响。 1234567var stringValue = 'hello world';console.log(stringValue.slice(3)); //lo worldconsole.log(stringValue.substring(3)); //lo worldconsole.log(stringValue.substr(3)); //lo worldconsole.log(stringValue.slice(3,7)); //lo wconsole.log(stringValue.substring(3,7)); //lo wconsole.log(stringValue.substr(3,7)); //lo worl 在传递给这些方法的参数是负值的情况下，slice()方法会将传入的负值与字符串的长度相加；substr()方法将负的第一个参数加上字符串的长度，负的第二个参数转换为0；substring()方法会把所有负值参数都转换为0，且这个方法会将两个参数中较小的数作为开始位置，将较大的数作为结束位置。 1234567var stringValue = 'hello world';console.log(stringValue.slice(-3)); //rldconsole.log(stringValue.substring(-3)); //hello worldconsole.log(stringValue.substr(-3)); //rldconsole.log(stringValue.slice(3,-4)); //lo wconsole.log(stringValue.substring(3,-4));//hel，相当于stringValue.substring(0,3)console.log(stringValue.substr(3,-4)); //''(空字符串) 字符串位置方法indexOf()和lastIndexOf()方法都是从一个字符串中搜索给定的字符串，然后返回子字符串的位置（如果没有找到，返回-1）。 其中，indexOf()是从头开始向后搜索子字符串，而lastIndexOf()方法是从后向前搜索子字符串。这两个方法都可以接收可选的第二个参数，表示从字符串的哪个位置开始搜索。indexOf()会从指定位置向后搜索，忽略位置之前的所有字符，而lastIndexOf()则会从指定的位置向前搜索，忽略该位置之后所有字符。 123456789101112131415var stringValue = 'hello world';console.log(stringValue.indexOf('o')); //4console.log(stringValue.lastIndexOf('o')); //7console.log(stringValue.indexOf('o',6)); //7console.log(stringValue.lastIndexOf('o',6));//4var positions = new Array();var pos = stringValue.indexOf('o');while (pos &gt; -1)&#123; positions.push(pos); pos = stringValue.indexOf('o',pos + 1);&#125;console.log(positions); //[4,7] trim()方法ECMAScript5为所有字符串定义了trim()方法，这个方法会创建一个字符串的副本（原始字符串不变），删除前置及后缀的所有空格，然后返回结果。 1234var stringValue = ' hello world ';var trimmedStringValue = stringValue.trim();console.log(stringValue); //' hello world 'console.log(trimmedStringValue);//'hello world' 字符串大小写转换方法toLowerCase()、toLocaleLowerCase()、toUpperCase()和toLocaleUpperCase()用于字符串大小写转换。toLocaleLowerCase()和toLocaleUpperCase()方法是针对特定地区的实现，比如，少数语言（如土耳其语）会为Unicode大小写转换应用特殊的规则。一般来说，不知道自己的代码将在哪种语言环境下运行，还是用针对地区的方法更稳妥一点。 字符串的模式匹配方法 match()方法本质上和调用RegExp的exec()方法相同。match()方法只接受一个参数，要么是正则表达式，要么是一个RegExp对象。 1234567var text = 'cat bat sat fat';var pattern = /.at/;var mateches = text.match(pattern);console.log(mateches.index); //0console.log(mateches[0]); //catconsole.log(pattern.lastIndex); //0 search()方法的唯一参数与match()方法的参数相同，由字符串或RegExp对象指定的一个正则表达式。search()方法返回字符串中第一个匹配项的索引，如果没找到匹配项，返回-1，并且，search()方法始终是从字符串开头向后查找。 123var text = 'cat bat sat fat';var pos = text.search(/at/);console.log(pos); //1 replace()方法接收两个参数：第一个参数可以是一个RegExp对象或一个字符串（这个字符串不会被转换成正则表达式），第二个参数可以是一个字符串或者函数。如果第一个参数是字符串，那么只会替换第一个子字符串。要想替换所有子字符串，唯一的办法是提供一个正则表达式，而且要指定全局（g）标志。 123456var text = 'cat bat sat fat';var result = text.replace('at','ond');console.log(result); //cond bat sat fatresult = text.replace(/at/g,'ond');console.log(result); //cond bond sond fond 如果第二个参数是字符串，还可以使用一些特殊的字符序列，将正则表达式操作得到的值插入到结果字符串中。 字符序列 替换文本 $$ $ $&amp; 匹配整个模式的子字符串。与regExp.lastMatch的值相同 $’ 匹配的子字符串之前的子字符串。与regExp.leftContext的值相同 $` 匹配的子字符串之后的子字符串。与regExp.rightContext的值相同 $n 匹配第n个捕获组的子字符串，其中n等于0-9。例如，$1是匹配第一个捕获组的子字符串，\$2是匹配第二个捕获组的子字符串，以此类推。如果正则表达式中没有定义捕获组，则使用空字符串 $nn 匹配第nn个捕获组的子字符串，其中nn等于00-99。例如，$01是匹配第一个捕获组的子字符串，\$02是匹配第二个捕获组的子字符串，以此类推。如果正则表达式中没有定义捕获组，则使用空字符串 通过这些特殊的字符序列，可以使用最近一次匹配结果中的内容： 123var text = 'cat bat sat fat';result = text.replace(/(.at)/g,'word ($1))');console.log(result); //word (cat)) word (bat)) word (sat)) word (fat)) replace()方法的第二个参数也可以是一个函数。在只有一个匹配项时，会向这个函数传递3个参数：模式的匹配项、模式匹配项在字符串中的位置和原始字符串。在正则表达式中定义多个捕获组时，传递给函数的参数依次是模式的匹配项、第一个捕获组的匹配项、第二个匹配项…….，但最后两个参数依然分别是模式的匹配项在字符串中的位置和原始字符串。这个函数应该返回一个字符串，表示应该被替换的匹配项使用函数作为replace()方法的第二个参数可以实现更加精细的替换操作。 12345678910111213141516function htmlEscape(text) &#123; return text.replace(/[&lt;&gt;"&amp;]/g,function (match,pos,originalText) &#123; switch (match)&#123; case "&lt;": return '&amp;lt;'; case "&gt;": return '&amp;gt;'; case "&amp;": return '&amp;amp;'; case "\"": return '&amp;quot;'; &#125; &#125;);&#125;console.log(htmlEscape("&lt;p class='greeting'&gt;hello&lt;/p&gt;"));//&amp;lt;p class='greeting'&amp;gt;hello&amp;lt;/p&amp;gt; split()方法可以基于指定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中。分隔符可以是字符串，也可以是RegExp对象（这个方法不会将字符串看成正则表达式）。split()方法可以接收可选的第二个参数，用于指定数组的大小，以便确保返回的数组不会超过既定大小。 12345678var colorText = 'red,blue,green,yellow';var colors = colorText.split(',');var colors2 = colorText.split(',',2);var colors3 = colorText.split(/[^\,]+/);console.log(colors); //["red", "blue", "green", "yellow"]console.log(colors2); //["red", "blue"]console.log(colors3); //["", ",", ",", ",", ""] localeCompare()方法localeCompare()方法会比较两个字符串，并返回下列值中的一个： 如果字符串在字母表中应该排在字符串参数之前，则返回一个负数（大多数情况下是-1，具体的值要视实现而定） 如果字符串等于字符串参数，则返回0 如果字符串在字母表中应该排在字符串参数之后，则返回一个正数（大多数情况下是1，具体的值要视实现而定） 1234var stringValue = 'yellow';console.log(stringValue.localeCompare('brick')); //1console.log(stringValue.localeCompare('yellow')); //0console.log(stringValue.localeCompare('zoom')); //-1 localeCompare()方法的返回值取决于实现，所有最好像下面这样使用这个方法： 1234567891011121314function determineOrder(value)&#123; var result = stringValue.localeCompare(value); if (result &lt; 0)&#123; console.log('the string "yellow" comes before the string "' + value + '".'); &#125; else if (result &gt; 0)&#123; console.log('the string "yellow" comes after the string "' + value + '".'); &#125;else &#123; console.log('the string "yellow" is equal to the string "' + value + '".'); &#125;&#125;determineOrder('brick'); //the string "yellow" comes after the string "brick".determineOrder('yellow'); //the string "yellow" is equal to the string "yellow".determineOrder('zoom'); //the string "yellow" comes before the string "zoom". localeCompare()方法实现所支持的地区决定了这个方法的行为。比如，美国以英文为ECMAScript实现的标准语言，因此这个方法就是区分大小写的，于是大写字母在字母表中排在小写字母前头就成为一项决定性的比较规则。 fromCharCode()方法fromCharCode()方法的任务是接收一或多个字符编码，然后把它们转换成一个字符串。从本质上来看，这个方法与实例方法charCodeAt()执行的是相反的操作。 单体内置对象ECMA-262对内置对象的定义是：由ECMAScript实现提供的、不依赖于宿主环境对象，这些对象在ECMAscript程序执行之前就已经存在了。也就是开发人员不必显式地实例化内置对象。 内置对象除了Object、Array和String，还有Global和Math。 Global对象Global对象可以说是ECMAScript中最特别的一个对象了，因为不管从什么角度看，这个对象都是不存在的。ECMAScript中的Global对象在某种意义上是作为一个终极的兜底对象来定义的。也就是不属于任何其他对象的属性和函数，最终都是它的的属性和方法。 事实上，没有全局变量或全局函数，所有在全局作用域中定义的属性和函数，都是Global对象的属性。 上面介绍的isNaN()、isFinite()、parseInt()以及parseFloat()实际上都是Global对象的方法。除此之外，Global对象还包含其他一些方法。 URI编码方法Global对象的encodeURI()和encodeURIComponent()方法可以对URI（通用资源标识符）进行编码，以便发送给浏览器。有效的URI中不能包含某些字符，比如空格。而这两个URI编码方法就可以对URI进行编码，它们用特殊的UTF-8编码替换所有无效的字符，从而让浏览器能够接受和理解。 encodeURI()主要用于整个URI，且不会对本身属于URI的特殊字符进行编码，比如，冒号、正斜杠、问好和井字号；而encodeURIComponent()主要用于对URI中某一段进行编码，且会对它发现的任何非标准字符进行编码。 1234var uri = 'http://tc9011.com/illegal value.htm#start';console.log(encodeURI(uri)); //http://tc9011.com/illegal%20value.htm#startconsole.log(encodeURIComponent(uri)); //http%3A%2F%2Ftc9011.com%2Fillegal%20value.htm%23start 与encodeURI()和encodeURIComponent()方法对应的是decodeURI()和decodeURIComponent()。其中decodeURI()只能对使用encodeURI()替换的字符进行解码，decodeURIComponent()能解码使用encodeURIComponent()编码的所有字符，即可以解码任何特殊字符的编码。 123456var uri = 'http%3A%2F%2Ftc9011.com%2Fillegal%20value.htm%23start';console.log(decodeURI(uri));//http%3A%2F%2Ftc9011.com%2Fillegal value.htm%23startconsole.log(decodeURIComponent(uri));//http://tc9011.com/illegal value.htm#start eval()方法eval()方法是整个ECMAScript中最强大的一个方法，它就像是一个完整的ECMAScript解析器，它只接受一个参数，即要执行的ECMAScript字符串。 123eval('alert("hi")');----------等价于----------alert("hi"); 当解析器发现代码中调用eval()方法时，它会将传入的参数当作实际的ECMAScript语句来解析，然后把执行结果插入到原位置。通过eval()执行的代码被认为是包含该次调用的执行环境的一部分，因此被执行的代码具有与该执行环境相同的作用域链。这意味着通过eval()执行的代码可以引用在包含环境中定义的变量。 12345var msg = 'hello';eval('alert(msg)'); //helloeval('function sayHi()&#123;alert(msg)&#125;');sayHi(); //hello 在eval()中创建的任何变量或函数都不会被提升，因为在解析代码的时候，它们被包含在一个字符串中；它们只在eval()执行的时候创建。 在严格模式下，在外部访问不到eval()中创建的任何变量或函数，同样在严格模式下，为eval()赋值也会导致错误。 使用eval()必须极为谨慎，特别是在用它执行用户输入数据的情况下，因为可能会有恶意的代码注入。 Global对象的属性undefined、NaN、Infinity都是Global对象的属性，此外，所有原生引用类型的构造函数，也都是Global对象的属性。下面是Global对象的所有属性。 属性 说明 undefined 特殊值undefined NaN 特殊值NaN Infinity 特殊值Infinity Object 构造函数Object Array 构造函数Array Function 构造函数Function Boolean 构造函数Boolean String 构造函数String Number 构造函数Number Date 构造函数Date RegExp 构造函数RegExp Error 构造函数Error EvalError 构造函数EvalError RangError 构造函数RangError ReferenceError 构造函数ReferenceError SyntaxError 构造函数SyntaxError TypeError 构造函数TypeError URIError 构造函数URIError window对象ECMAScript虽然没有指出如何直接访问Global对象，但是浏览器都是将这个全局对象作为window对象的一部分加以实现。因此，在全局作用域中声明的所有变量和函数，都成为window对象的属性。 Math对象与在Javascript中直接编写的计算功能相比，Math对象提供的计算功能执行起来要快得多。 Math对象的属性 属性 说明 Math.E 自然对数的底数，即常量e的值 Math.LN10 10的自然对数 Math.LN2 2的自然对数 Math.LOG2E 以2为底e的对数 Math.LOG10E 以10为底e的对数 Math.PI π的值 Math.SQRT1_2 1/2的平方根 Math.SQRT2 2的平方根 min()和max()方法min()和max()方法用于确定一组数值中的最大值和最小值，这两个方法都可以接收任意多个数值参数。 要找到数组中的最大值或最小值，可以像下面这样使用apply()方法，将Math对象作为apply()的第一个参数，从而正确地设置this值，然后可以将任何数组作为第二个参数： 123var values = [1,2,3,4,5,6,7,8];var max = Math.max.apply(Math,values);console.log(max); //8 舍入方法 Math.cell()执行向上舍入，即它总是将数值向上舍入为最接近的整数 Math.floor()执行向下舍入，即它总是将数值向下舍入为最接近的整数 Math.round()执行标准舍入，即它总是将数值四舍五入为最接近的整数 random()方法Math.random()方法返回介于0和1之间一个随机数，不包括0和1。 套用下面公式，可以从某个整数范围内随机选择一个值： 1值 = Math.floor(Math.random()*可能值的总数 + 第一个可能的值) 可以通过下面函数来计算可能值的总数和第一个可能的值： 1234567function selectFrom(lowerValue,upperValue) &#123; var choices = upperValue - lowerValue + 1; return Math.floor(Math.random()*choices + lowerValue);&#125;var num = selectFrom(2,10);console.log(num); //介于[2,10]之间的一个数值 其他方法 方法 说明 Math.abs(num) 返回num的绝对值 Math.exp(num) 返回Math.E的num次幂 Math.log(num) 返回num的自然对数 Math.pow(num,power) 返回num的power次幂 Math.sqrt(num) 返回num的平方根 Math.acos(x) 返回x的反余弦值 Math.asin(x) 返回x的反正弦值 Math.atan(x) 返回x的反正切值 Math.tan2(y,x) 返回y/x的反正切值 Math.cos(x) 返回x的余弦值 Math.sin(x) 返回x的正弦值 Math.tan(x) 返回x的正切值]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vertical-align和line-heigh搞基那些事儿]]></title>
    <url>%2F2017%2F06%2F28%2Fvertical-align%E5%92%8Cline-heigh%E6%90%9E%E5%9F%BA%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%2F</url>
    <content type="text"><![CDATA[起因项目中在应用Angular/Material的card组件的时候遇到如下问题： 它的代码大概是这样的： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;ul&gt; &lt;li&gt; &lt;md-card&gt; &lt;img md-card-image src="X.png" alt="img"&gt; &lt;md-card-title&gt;汤诚汤诚汤诚汤诚&lt;/md-card-title&gt; &lt;md-card-subtitle&gt;汤诚汤诚汤诚汤诚&lt;/md-card-subtitle&gt; &lt;button&gt;查看详情&lt;/button&gt; &lt;/md-card&gt; &lt;/li&gt; &lt;li&gt; &lt;md-card&gt; &lt;img md-card-image src="X.png" alt="img"&gt; &lt;md-card-title&gt;汤诚汤诚汤诚汤诚&lt;/md-card-title&gt; &lt;md-card-subtitle&gt;汤诚汤诚汤诚汤诚&lt;/md-card-subtitle&gt; &lt;button&gt;查看详情&lt;/button&gt; &lt;/md-card&gt; &lt;/li&gt; &lt;li&gt; &lt;md-card&gt; &lt;img md-card-image src="X.png" alt="img"&gt; &lt;md-card-title&gt;汤诚汤诚汤诚汤诚&lt;/md-card-title&gt; &lt;md-card-subtitle&gt;汤诚汤诚汤诚汤诚&lt;/md-card-subtitle&gt; &lt;button&gt;查看详情&lt;/button&gt; &lt;/md-card&gt; &lt;/li&gt; &lt;li&gt; &lt;md-card&gt; &lt;img md-card-image src="X.png" alt="img"&gt; &lt;md-card-title&gt;汤诚汤诚汤诚汤诚&lt;/md-card-title&gt; &lt;md-card-subtitle&gt;汤诚汤诚汤诚汤诚汤诚汤诚汤诚汤诚汤诚汤诚汤诚汤诚&lt;/md-card-subtitle&gt; &lt;button&gt;查看详情&lt;/button&gt; &lt;/md-card&gt; &lt;/li&gt; &lt;li&gt; &lt;md-card&gt; &lt;img md-card-image src="X.png" alt="img"&gt; &lt;md-card-title&gt;汤诚汤诚汤诚汤诚&lt;/md-card-title&gt; &lt;md-card-subtitle&gt;汤诚汤诚汤诚汤诚&lt;/md-card-subtitle&gt; &lt;button&gt;查看详情&lt;/button&gt; &lt;/md-card&gt; &lt;/li&gt;&lt;/ul&gt; 1234567891011121314ul&#123; width: 1200px; margin: 0 auto; margin-top: 40px;&#125;li&#123; display: inline-block; margin-right: 70px; margin-bottom: 60px; &amp;:nth-child(3n)&#123; margin-right: 0; &#125;&#125; 我一开始以为是li标签之间空隙导致的，于是就按照常规方法，把font-size设置为0，but，最后一个元素好像很固执，一动不动，这就让我很尴尬。 原因参考张鑫旭的CSS深入理解vertical-align和line-height的基友关系。 vertical-align默认值是baseline, 也就是基线对齐。而基线是什么，基线就是字母X的下边缘（参见“字母’x’在CSS世界中的角色和故事”一文）。而文字高度是由line-height决定的。卡片上面留白行为表现，本质上，就是vertical-align和line-height背地里搞基造成的。这里借用一下张鑫旭文章中的图片可能更好理解一点： 在这里li元素display:inline-block，而在CSS2的可视化格式模型文档中，一个inline-block元素，如果里面没有inline内联元素，或者overflow不是visible，则该元素的基线就是其margin底边缘，否则，其基线就是元素里面最后一行内联元素的基线。 可以从下图看出，在li的基线是最后一行文字的基线（查看详情按钮不计入，因为已经脱离文档流了）。而倒数第二个li的文字折行了，最后一个li文字只有一行，但是最后一个li元素要像它的好基友看齐，于是它把自己变矮了（和基友是真爱）。此时也可以说明为什么font-size设置为0，因为我给那段文字手动设置了font-size，按照优先级来说，li的font-size当然不起作用。 知道原因后，我们可以试下把li的line-height设置为0，得到下面的效果： 此时图片下面那两行字的行高就会受到影响，两行文字会叠在一起，这样我需要手动为文字加一个line-height，但是对于我这样的懒人来说，太麻烦了。 此时还有一种方法就是修改vertical-align的值，让li元素的vertical-align变成top/bottom/middle。这时候同样会得到下图的效果，但是卡片里面的文字却还是正常显示，恩，简直完美。 vertical-align的top/bottom/middle这三个值到底是啥东西咧，可以看MDN上vertical-align的解释，并结合张鑫旭那篇文章给出的图理解： middle：元素中线与父元素的小写x中线对齐。 top：元素及其后代的顶端与整行的顶端对齐。 bottom：元素及其后代的底端与整行的底端对/assets/images/windows下几款好用的免费软件/assets/images/windows下几款好用的免费软件齐。 还有一篇老外的文章写得也蛮好的Deep dive CSS: font metrics, line-height and vertical-align 类似问题的解决方案 将图片转换为块级对象 图片默认是inline水平的，而vertical-align对块状水平的元素无感。因此，我们只要让图片display水平为block就可以了，我们可以直接设置display或者浮动、绝对定位等（如果布局允许）。 1img &#123; display: block &#125; 使用其他vertical-align值 比方说bottom/middle/top都是可以的。 直接修改line-height值 只要行高足够小，实际文字占据的高度的底部就会在x的上面，下面没有了高度区域支撑，自然，图片就会有容器底边贴合在一起了。 line-height为相对单位，font-size间接控制 如果line-height是相对单位，例如line-height:1.6或者line-height:160%之类，也可以使用font-size间接控制，比方说来个狠的，font-size设为0, 本质上还是改变line-height值。 参考文章 CSS深入理解vertical-align和line-height的基友关系 vertical-align li和img标签之间空隙解决办法 Deep dive CSS: font metrics, line-height and vertical-align]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次前端重构]]></title>
    <url>%2F2017%2F06%2F07%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%89%8D%E7%AB%AF%E9%87%8D%E6%9E%84%2F</url>
    <content type="text"><![CDATA[前段时间公司项目中的用户组管理的部分交给了西安研发中心的小伙伴们做，端午前看到他们提交的代码，我内心是崩溃的，复制了我之前的css文件到各个css文件中，没用的代码全部没有删，各种html无用代码嵌套，ts文件中一大块一大块的if-else。顶着项目快要出版本的压力，我还是选择了重构，其实与其说重构还不如说重写，除了bootstrap-table配置部分和后端接口部分代码，其他都重新写了一遍。 服务根据Angular官方的风格指南，数据交互和处理的部分应该放到服务中，这样方便复用，首先将项目中增删改查的接口交互都单独放在服务中，然后根据用户管理部分常用的数据处理部分提炼出来，放在服务中以便多个组件使用。 HTML、CSS优化html、css部分真的是全部重写的，已经无力吐槽了，重写后html代码行数基本上减少了一半吧、css代码估计减少了有60%以上。减少了不必要的标签和css代码，一些组件引用了公司内部的组件库，页面更加符合ux的设计。 算法优化最头疼的就是代码中的大块大块的if-else，其实这个优化的话要仔细分析一下数据结构。因为和后端交互的数据结构是类似于这样的： 123456789101112131415161718192021222324&#123; "a": [ &#123; "id": "string1", "name1": "string2", "c": [ &#123; "name2": "string3", "name3": [ "string4", "string5" ] &#125;, &#123; "name2": "string6", "name3": [ "string7", "string8" ] &#125; ] &#125; ]&#125; 其中name1是用户组名称，c表示的是权限，name2表示不同项目名称，name3表示项目中的角色名称。 主显示界面是不同用户组名称；增加界面罗列了几个不同项目，每个项目下面有不同的角色；查询页面显示用户组在这几个项目中有哪些权限。咋一看上去数据交互还是蛮复杂的，也难怪西安的小伙伴都是大片的if-else。 这里用增加和修改用户组为例，讲一下我自己的优化方法。 增加用户组增加页面是用户勾选多选框，然后提交。所以我在增加用户组的组件中，先定义了一个与提交给后端数据结构一样的对象，并额外定义了一个记录多选框的对象： 123456789101112131415161718192021addGroup = &#123; "a":[ &#123; "id":"" "name": c, "c":[], &#125; ]&#125;;isSelected = &#123; "string3": [&#123; 'string4': false, 'string5' :false &#125;], "string6": [&#123; 'string7' : false, 'string8' : false &#125;]&#125;&#125; 这样记录多选框的对象可以通过双向绑定和html进行交互： 1&lt;input type="checkbox" [(ngModel)]="isSelect.string3[0].string4" /&gt; 用户提交时，执行一个数据处理函数，把之前定义的对象作为参数传入这个函数。数据处理时，按照后端的要求，c这个对象数组中，如果任何一个对象中name3是空，这个对象是不需要增加到c数组中的，而name3中存放和name2对应的isSelected中为true的字符串名称（这段话有点绕，可以参考上面和后端交互的数据结构来理解）。 123456789101112131415161718192021setAddGroup(isSelect:any,addGroup:any)&#123; let isSelectArray = Object.keys(isSelect); for( let i = 0; i &lt; isSelectArray.length; i++)&#123; let group = &#123; //把c数组拆成单个对象。 name2: "", name3: [] &#125;; let tc = isSelect[isSelectArray[i]][0]; let tcArray = Object.keys(project); group.name2 = isSelectArray[i]; for (let j = 0; j &lt; tcArray.length; j++)&#123; if (tc[tcArray[j]])&#123; //选中的角色放在rolename中 group.name3.push(tcArray[j]) &#125; &#125; if (group.name3.length != 0)&#123; addGroup.a[0].c.push(group); //name3不为空时把group加到addGroup中 &#125; &#125;&#125; 这个函数应该还有优化空间，不过比100多行的if-else还是要好很多。 编辑用户组编辑用户组稍微麻烦一点，先从后端取得数据（后端获取的数据结构见算法优化最开始的地方），然后根据获得的数据去改变isSelect中对应的布尔值。 我写了两个函数来处理： dealData函数用来遍历c数组，并把data中的name2字符串和name3数组传递给resetIsSelectData函数。 resetIsSelectData函数中，isSelected用传入的name2为下标，定位到isSelected对应的name2数组，然后对这个数组用传入的name3为下标修改对应的布尔值为true。这样做相当于把isSelected对象的下标由后端获取的数据控制，存在的数据就修改isSelected中对应的布尔值。 12345678910111213dealData()&#123; let data = this.backEndData.a[0].c for (let i = 0; i &lt; this.data.length; i++)&#123; this.resetIsSelectData(this.data[i].name2,this.data[i].name3); &#125;&#125;resetIsSelectData(name2:string,name3:any)&#123; for (let j = 0; j &lt; name3.length; j++)&#123; let roleName = this.isSelect[name2][0]; roleName[name3[j]] = true; &#125;&#125; 这几行代码又压缩了100多行代码，写完了还是蛮爽的，哈哈。 最后这次重构其实蛮心累的，表格组件一开始用的是公司内部组件库的组件，因为刚开发完成，文档也不是很全，我摸索了两天，因为bug比较多，最后还是使用bootstrap-table来做表格，也算是一个坑吧。 写代码还是要认真一点，多想一下，不是完成功能就行，毕竟title上印的是工程师而不是码农。]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《精通CSS 高级Web标准解决方案》学习笔记]]></title>
    <url>%2F2017%2F05%2F21%2F%E3%80%8A%E7%B2%BE%E9%80%9ACSS%20%E9%AB%98%E7%BA%A7Web%E6%A0%87%E5%87%86%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[基础知识设计代码的结构标记简史 有意义的标记的重要性 ID和类名 ID可以用于标识页面上的特定元素（比如站点导航），或者用来标识持久的结构性元素，例如主导航或内容区域，还可以用来标识一次性元素，例如某个链接或表单元素。 类非常适合标识内容的类型或其他相似条目。 为元素命名 根据“它们是什么”来为元素命名，而不应该根据“它们外观如何”来命名。 ID还是类 一般原则是：类应该应用于概念上相似的元素，这些元素可以出现在同一页面上的多个位置，而ID应该是应用于不同的唯一的元素，只有绝对确定某个元素只会出现一次的情况下才可以使用。 不需要给每个元素用类来标识，可以给某个容器赋予一个类名，然后用层叠（即利用层叠的优先级顺序）来识别其中的一些内容。 div和span div实际上代表部分（division），它可以将文档分割为几个有意义的区域。为了避免不必要的标记，应该只在没有元素能够实现区域分割的情况下使用div元素。 div可以用来对块级元素进行分组，而span用来对行内元素进行分组或标识。 微格式 一套标准的命名约定和标记模式来表示人、地点或日期等类型的信息，基于vCard和iCalendar等现有数据格式。 目前有9个正式的微格式：用于日期、日历和事件的hCalendar；用于人和组织的hCard；用于人之间的关系的XFN；用于产品说明的hProduct；用于原料和烹饪步骤的hRecipe；用于产品和事件审查的hReview；用于博客帖子等片段式内容的hAtom。 不同的HTML和CSS版本 文档类型和DOCTYPEDTD（文档类型定义）是一组机器可读的规则，定义了XML或者HTML的特定版本中允许有什么，不允许有什么。 DOCTYPE描述了使用哪个DTD。 DOCTYPE有两种风格，严格和过渡。严格模式不允许使用已废弃的元素。 浏览器模式和DOCTYPE切换浏览器模式主要包括混杂模式和标准模式。标准模式浏览器根据规范呈现页面；混杂模式页面以向后兼容的方式呈现，通常模拟老式浏览器的行为以防止老站点无法工作。 根据DOCTYPE是否存在呈现模式，被称为DOCTYPE切换。浏览器根据DOCTYPE是否存在以及使用哪种DTD来选择要使用的呈现方法。 为样式找到应用目标常用的选择器 类型选择器 类型选择器用来寻找特定类型的元素，只需指定希望应用样式的元素的名称。比如： 1p&#123;color: black;&#125; 后代选择器 后代选择器用来寻找特定元素或元素组的后代。后代选择器由其他两个选择器之间的空格表示。比如： 1h1 p&#123;padding-left: 2em;&#125; ID选择器 ID选择器寻找具有特定ID的元素。ID选择器由#字符表示。比如： 1#intro &#123;font-weight: bold;&#125; 类选择器 类选择器寻找具有特定类名的元素。类选择器有.表示。比如： 1.date-posted&#123;color: #ccc;&#125; 不要随意给元素指定不同的类，而应该将一个类或ID应用于祖先元素，然后尽可能先用后代选择器定位不同的元素。 伪类:linked和:visited称为链接伪类，只能应用于锚元素。 :hover、:active和:focus称为动态伪类，理论上可以应用于任何元素。 通用选择器通用选择器由*表示，它可以作用于所有可用元素，一般用来对页面上的所有元素应用样式。 高级选择器子选择器和相邻同胞选择器子选择器用&gt;表示，它只选择元素的直接后代（即子元素）。IE7中如果父元素和子元素之间有注释，子选择器会有问题。 123456789101112131415161718li&#123; color: red;&#125;#nav&gt;li&#123; color: yellow;&#125;&lt;ul id="nav"&gt; &lt;li&gt;&lt;a href="#"&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;3&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="#"&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt;&lt;/ul&gt; 相邻同胞选择器用+表示，可用于定位一个父元素下某个元素之后的元素。IE7总目标元素之间有注释会出问题。 12345678910h1&#123; color: red;&#125;h1+p&#123; color: yellow;&#125;&lt;h1&gt;h1&lt;/h1&gt;&lt;p&gt;p&lt;/p&gt;&lt;p&gt;p&lt;/p&gt; 属性选择器属性选择器可以根据某个属性是否存在或属性的值来寻找元素。 12345678910111213141516171819/*给有title属性的abbr标签赋样式*/abbr[title]&#123; border-bottom: 1px dotted #999;&#125;abbr[title]:hover,abbr[title]:focus&#123; cursor: help;&#125;/*给rel属性值为"nofollow"的a标签赋样式*/a[rel="nofollow"]&#123; padding-right: 20px;&#125;/*给rel属性值中有"cool"的a标签赋样式*/a[rel~="cool"]&#123; background: red;&#125;&lt;a rel="met cool"&gt;a&lt;/a&gt;&lt;a rel="met"&gt;a&lt;/a&gt; 层叠和特殊性同一元素可能有2个或更多规则。CSS通过层叠的过程处理冲突。层叠给每个规则分配一个重要度。 层叠采用以下重要度次序： 标有!important的用户样式 标有!important的作者样式 作者样式 用户样式 浏览器或者用户代理应用的样式 层叠的重要度只是层叠规则的一部分，CSS2.1中的层叠规则如下：1. 找出所有相关的规则，这些规则都包含与一个给定元素匹配的选择器。2. 按显示权重对应用到的所有声明排序。标志!important的规则的权重高于没有!important标志的规则。3. 按来源对应用到给定元素的所有声明排序。共有三种来源：创作人员、读者、用户代理。正常情况下，创作人员的样式要胜过读者的样式。有!important标示的读者样式要强于所有其他样式。创作人员样式和读者样式都比用户代理的默认样式要强。4. 按特殊性对应用到给定元素的所有声明排序。有较高特殊性的元素权重大于有较低特殊性的元素。5. 按出现顺序对应用到给定元素的所有声明排序。一个声明在样式表或文档中越后出现，它的权重就越大。如果样式表中有导入的样式表，一般认为出现在导入样式表中的声明在前，主样式表中的所有声明在后。 特殊性为了确保非常特殊的选择器（比如ID选择器）不会被大量一般选择器（比如类型选择器）超越，特殊性的计算采用一个比10更高的未指定的基数。但是为了简化，如果在一个特定选择器中的选择器数量少于10个，那么可以以10为基数计算特殊性： 行内样式，特殊性加1000 每有一个ID选择器，特殊性加100 每有一个类、伪类或者属性选择器，特殊性加10 每有一个类型选择器或伪元素选择器，特殊性加1 在样式表中使用特殊性对一般元素应用一般样式，然后在更特殊的元素上覆盖它们。 尽量保持一般性样式非常一般，特殊性样式尽可能特殊。 继承应用样式的元素的后代会继承样式的某些属性。 继承而来的样式的特殊性为0。 规划、组织和维护样式表对文档应用样式导入外部样式表的两种方法： &lt;link href=&quot;/css/basic.css&quot; rel =&quot;stylesheet&quot; type=&quot;text/css&quot;/&gt; &lt;style&gt;@import url(/css/basic.css);&lt;style&gt; 用@import方法还可以从一个样式表钟导入另一个样式表，但是和&lt;link&gt;相比导入速度慢。 设计代码的结构为了便于维护，最好把样式表划分为几大块。 一般样式 主体样式 reset样式 链接 标题 其他元素 辅助样式 表单 通知和错误 一致的条目 页面结构 标题、页脚和导航 布局 其他页面结构元素 页面组件 各个页面 覆盖 删除注释和优化样式表注释会使CSS文件显著加大。 减小文件大小的最好方法可能是启用服务器端压缩，比如Apache服务器中用mod_gzip或者mod_deflate进行GZIP压缩。 可视化格式模型盒模型概述 盒模型指定元素如何显示以及（在某种程度上）如何相互交互，它由元素的内容、内边距 、边框和外边距组成。 CSS2.1还包括了outline属性，它的轮廓绘制在元素边框之上，不影响元素的大小和定位。 在CSS中，width和height指的是内容区域的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。 IE和盒模型IE6及更早的IE版本在混杂模式中使用了非标准盒模型，width属性不是内容的宽度，而是内容、内边距和边框的宽度总和。 用CSS3的box-sizing属性可以定义使用哪种盒模型。 外边距叠加 当两个或者更多垂直外边距相遇时，它们将形成一个外边距，这个外边距的高度等于两个发生叠加的外边距的高度重的较大者。 当一个元素包含在另一个元素中时，它们的顶或底外边距也会发生叠加。叠加后的外边距如果碰到另一个元素的外边距，它还会发生叠加。 只有普通文档流中块框（块级元素）的垂直外边距才会发生外边距叠加。行内框（行内元素）、浮动框或绝对定位框之间的外边距不会叠加。 定位概述可视化格式模型CSS中三种基本的定位机制：普通流、浮动和绝对定位。 块级元素从上到下一个接一个排列，元素之间的垂直距离由元素的垂直外边距计算出来。 行内元素在一行中水平排列，可以使用水平内边距、边框和外边距调整行内元素之间的水平间距，但是垂直内边距、边框和外边距不影响行内的高度。 行内元素不能设置宽度或高度，修改行内元素尺寸的唯一办法是修改行高或者水平边框、内边距、外边距。 display: inline-block可以让元素像行内元素一样水平排列，并且元素可以设置宽度、高度、垂直外边距和内边距。 相对定位如果对一个元素进行相对定位，它将出现在它所在的位置上。然后可以通过设置水平或者垂直位置，让这个元素“相对于”它的起点移动。 12345#mybox&#123; position: relative; left: 20px; top:20px;&#125; 在使用相对定位时，无论是否移动，元素仍然占据原来的空间。 相对定位实际上被看做普通流定位模型的一部分，因为元素的位置是相对于它在普通流中的位置。 绝对定位绝对定位使元素的位置与文档流无关，因此不占据空间。普通文档流中其他元素的布局就像绝对定位元素不存在一样。 绝对定位元素的位置是相对于距离它最近的那个已定位的祖先元素确定的。如果没有已定位的祖先元素，那么它的位置是相对于初始包含块的。 绝对定位不仅可以覆盖页面上的其他元素，还可以设置z-index属性来控制元素的叠放次序。 固定定位固定定位（position: fixed）是绝对定位的一种，差异在于固定元素的包含块是视口，这使得能够创建总是出现在窗口中相同位置的浮动元素。 浮动浮动的元素可以左右移动，直到它的外边缘碰到包含元素或另一个浮动元素的边缘。 浮动元素不在普通文档流中，所以普通文档流中的块级元素表现得就像浮动元素不存在一样。 行框和清理浮动的元素后面有一个文档流中的元素，那么这个元素会表现得就像浮动元素不存在一样，但是元素内的文本内容会受到浮动元素的影响，会移动以留出空间。也就是浮动元素旁边的行框被缩短，从而给浮动元素留出空间。 比如： 123456789101112131415161718&lt;style&gt; .test&#123; background: yellow; float: left; &#125; .test1&#123; background: red; &#125;&lt;/style&gt;&lt;div class="test1"&gt; &lt;p class="test"&gt;content&lt;/p&gt; contentcontentcontentcontentcontentcontentcontent contentcontentcontentcontentcontentcontentcontentcontentcontentcontentcontent contentcontentcontentcontentcontentcontentcontentcontentcontentcontent contentcontentcontentcontentcontentcontentcontentcontentcontentconten tcontentcontentcontentcontentcontentcontentcontentcontentcontentcontent&lt;/div&gt; 想要阻止行框围绕在浮动框的外边，需要对包含这些行框的元素应用clear属性。 clear属性可以是left、right、both或none。它表示框的哪边不应该挨着浮动框。 在清理元素时，浏览器在元素顶上添加足够的外边距，使元素的顶边缘垂直下降到浮动框下面，本质上是为元素留出了垂直空间来达到清理浮动的目的。 浮动和清理示例1234567891011121314151617181920212223&lt;style&gt; .news&#123; background: gray; border: 1px solid black; &#125; .news img&#123; float: left; &#125; .news p&#123; float: right; &#125;&lt;/style&gt;&lt;div class="news"&gt; &lt;img src="img.png" alt="img"&gt; &lt;p&gt; contentcontentcontentcontentcontentcontentcontent contentcontentcontentcontentcontentcontentcontentcontentcontentcontentcontent contentcontentcontentcontentcontentcontentcontentcontentcontentcontent contentcontentcontentcontentcontentcontentcontentcontentcontentconten tcontentcontentcontentcontentcontentcontentcontentcontentcontentcontent &lt;/p&gt;&lt;/div&gt; 通过应用clear属性，使包围元素在视觉上包围浮动元素。 123456789101112131415161718192021222324252627&lt;style&gt; .news&#123; background: gray; border: 1px solid black; &#125; .news img&#123; float: left; &#125; .news p&#123; float: right; &#125; .clear&#123; clear:both; &#125;&lt;/style&gt;&lt;div class="news"&gt; &lt;img src="img.png" alt="img"&gt; &lt;p&gt; contentcontentcontentcontentcontentcontentcontent contentcontentcontentcontentcontentcontentcontentcontentcontentcontentcontent contentcontentcontentcontentcontentcontentcontentcontentcontentcontent contentcontentcontentcontentcontentcontentcontentcontentcontentconten tcontentcontentcontentcontentcontentcontentcontentcontentcontentcontent &lt;/p&gt; &lt;br class="clear"/&gt;&lt;/div&gt; 这种方法需要添加不必要的HTML代码。 还可以选择浮动容器div的方法实现同样效果： 123456789101112131415161718192021222324&lt;style&gt; .news&#123; background: gray; border: 1px solid black; float:left; &#125; .news img&#123; float: left; &#125; .news p&#123; float: right; &#125;&lt;/style&gt;&lt;div class="news"&gt; &lt;img src="img.png" alt="img"&gt; &lt;p&gt; contentcontentcontentcontentcontentcontentcontent contentcontentcontentcontentcontentcontentcontentcontentcontentcontentcontent contentcontentcontentcontentcontentcontentcontentcontentcontentcontent contentcontentcontentcontentcontentcontentcontentcontentcontentconten tcontentcontentcontentcontentcontentcontentcontentcontentcontentcontent &lt;/p&gt;&lt;/div&gt; 但是下一个元素会受到这个浮动元素的影响。 应用值为hidden或者auto的overflow属性有一个副作用，会自动清理包含的任何浮动元素。这种方法在某些情况下会产生滚动条或截断内容。 结合使用:after伪类和内容声明在指定的现有内容的末尾添加新的内容： 1234567891011121314151617181920212223242526272829&lt;style&gt; .news&#123; background: gray; border: 1px solid black; &#125; .news img&#123; float: left; &#125; .news p&#123; float: right; &#125; .clear:after&#123; content: ''; height: 0; visibility: hidden; display: block; clear: both; &#125;&lt;/style&gt;&lt;div class="news clear"&gt; &lt;img src="img.png" alt="img"&gt; &lt;p&gt; contentcontentcontentcontentcontentcontentcontent contentcontentcontentcontentcontentcontentcontentcontentcontentcontentcontent contentcontentcontentcontentcontentcontentcontentcontentcontentcontent contentcontentcontentcontentcontentcontentcontentcontentcontentconten tcontentcontentcontentcontentcontentcontentcontentcontentcontentcontent &lt;/p&gt;&lt;/div&gt; 背景图像效果背景图像基础默认情况下，浏览器水平和垂直地重复显示背景图像，让图像平铺在整个页面上。 background-position不仅可以使用例如left、right、center等关键字设置背景图像的位置，还可以使用像素或百分数等单位设置背景图像的位置。 background-position使用像素为单位设置背景图像的位置时，是图像左上角到元素左上角的距离为指定像素。而使用百分数为单位时，是图像上距离图像左上角的指定百分数的点到父元素上距离父元素左上角为指定百分数距离的位置。 最好不要混合使用单位和关键字。 圆角框山顶角border-image工作原理是把图片分成9块，然后把他们应用到元素边框的边和角。 1234.box&#123; /*border-image里面参数分别 对应background-image-source、border-image-slice、border-image-width、border-image-outset、border-image-repeat五个参数*/ border-image: url(image.png) 25% 25% 25% 25% /25px round round;&#125; border-image-slice规定图像边框的向内偏移，从而可以精确地把图片划分成9块。border-image-width可以定义划分边框的宽度。border-image-outset可以定义在边框外部绘制border-image-area的数量 不透明度 css不透明度 css不透明度除了对背景生效之外，应用它的元素的内容也会继承它。 123456.alert&#123; background: #000; border-radius: 2em; opacity: 0.8; filter: alpha(opacity=80); /*IE适配*/&#125; RGBa RGBa是一种同时设置颜色和不透明度的机制。RGB代表红色、绿色和蓝色，a代表alpha透明度。 上面的例子可以写成： 1234.alert&#123; background: rgba(0,0,0,0.8);/*0.8表示不透明度是80%，也就是透明度是20%*/ border-radius: 2em;&#125; PNG透明度 PNG文件格式支持alpha透明度。 图像替换图像替换（image replacement）可以像平常一样将文本添加到文档中，然后使用CSS隐藏文本并在它的位置上显示一个背景图像，这样搜索引擎仍然可以搜索HTML文本，而且如果禁用CSS，文本仍然会显示。 FIRFIR（Fahrner图像替换）是最早的图像替换技术。但这个方法有一些严重的可访问性问题，应该避免使用。 1234567891011121314&lt;style&gt; h2&#123; background: url("image.png") no-repeat; width: 150px; height: 35px; &#125; span&#123; display: none; &#125;&lt;/style&gt;&lt;h2&gt; &lt;span&gt;Hello&lt;/span&gt;&lt;/h2&gt; display值为none或visibility为hidden的元素会被屏幕阅读器忽略。 Phark12345678910&lt;/style&gt;h3&#123; text-indent: -5000px; background: url("image.png") no-repeat; width: 150px; height: 35px;&#125;&lt;/style&gt;&lt;h3&gt;hello&lt;/h3&gt; sIFR用JavaScript搜索文档，找到特定元素或者具有特定类名的元素中的所有文本。然后，JavaScript把文本替换为Flash文件。 对链接应用样式简单的链接样式:link伪类选择器用来寻找没有被访问过的链接，:visited伪类选择器用来寻找被访问过的链接。 :hover动态伪类选择器用来寻找鼠标悬停处的元素，:active动态伪类选择器用来寻找被激活的元素（对于链接来说，激活发生在链接被单击时）。 在定义鼠标悬停状态时，最好添加上:focus伪类，这样再通过键盘移动到链接上时，这让链接显示的样式与鼠标悬停时相同。 为了确保后定义的伪类覆盖之前定义的伪类，应用链接样式的顺序为：a:link、a:visited、a:hover、a:focus、a:active（可以记为LVHFA）。 为链接目标设置样式用:target伪类为目标元素设置样式。 123456789101112131415&lt;style&gt;:target&#123;border: 2px solid #D4D4D4;background-color: #e5eecc;&#125;&lt;/style&gt;&lt;p&gt;&lt;a href="#news1"&gt;跳转至内容 1&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="#news2"&gt;跳转至内容 2&lt;/a&gt;&lt;/p&gt;&lt;p&gt;请点击上面的链接，:target 选择器会突出显示当前活动的 HTML 锚。&lt;/p&gt;&lt;p id="news1"&gt;&lt;b&gt;内容 1...&lt;/b&gt;&lt;/p&gt;&lt;p id="news2"&gt;&lt;b&gt;内容 2...&lt;/b&gt;&lt;/p&gt; 突出显示不同类型链接用[att^=val]属性选择器寻找以文本http:开头的所有链接： 123a[href^="http:"]&#123; /*样式*/&#125; 突出显示可下载的文档和提要使用[att$=val]属性选择器寻找以特定值结尾的属性： 123a[href$=".pdf"]&#123; /*样式*/&#125; 创建类似按钮的链接12345678910a&#123; display: block; width: 6.6em; line-height: 1.4;/*垂直居中，文本换行时，高度是所需高度的两倍*/ text-align: center; text-decoration: none; background-color: #8cca12; color: #ffffff; border: 1px solid #66a300;&#125; 链接应该只用于GET请求，决不要用于POST请求。 简单的翻转使用伪类创建翻转效果： 1234a:focus&#123; background-color: #f7a300; border: #ff7400;&#125; CSS spiritCSS spirit是包含许多不同图标、按钮或图形的单个图像，这样可以减少请求数量。 用CSS3实现翻转-webkit-box-reflect属性可以创建对象的倒影，这个属性包含倒影的位置和距离以及蒙版图像这几个参数。可以使用-webkit-gradient值自动生成这个蒙版。 123456789101112131415a&#123; display: block; width: 6.6em; line-height: 1.4; text-align: center; text-decoration: none; background-color: #8cca12; color: #ffffff; border: 1px solid #66a300; border-radius: 6px; background-image: linear-gradient(to bottom, #abe142,#67a400); text-shadow: 2px 2px 2px #66a300; box-shadow: 2px 2px 2px #ccc; -webkit-box-reflect: below 2px -webkit-gradient(linear, left top,left bottom,from(transparent),color-stop(0.52,transparent),to(white));&#125; 纯CSS工具提示12345678910111213141516171819202122&lt;style&gt;a.tooltip&#123; position: relative;&#125;a.tooltip span&#123; display: none;&#125;a.tooltip:hover span,a.tooltip:focus span&#123; display: block; position: absolute; top: 1em; left: 2em; padding: 0.2em 0.6em; border: 1px solid #996633; background-color: #ffff66; color: #000000;&#125;&lt;/style&gt;&lt;p&gt; &lt;a href="#" class="tooltip"&gt;aaaaa&lt;span&gt;bbbb&lt;/span&gt;rrrrrr&lt;/a&gt;&lt;/p&gt; 对列表应用样式和创建导航条基本列表样式用list-style-image属性可以添加定制的项目符号。但是，这种方法对项目符号图像的位置控制能力不强。 更常用的方法是关闭项目符号，并将定制的项目符号作为背景添加到元素上，然后可以使用背景图像的定位属性精确地控制自定义项目符号的对准方式。 123456789ul&#123; margin: 0; padding: 0; list-style-type: none;&#125;li&#123; background: url("img.png") no-repeat 0 50%; padding-left: 30px;&#125; 创建基本的垂直导航条12345678910111213141516171819202122232425262728293031323334353637&lt;style&gt; ul.nav&#123; /*去除默认的项目符号和内外边距*/ margin: 0; padding: 0; list-style-type: none; /*设置样式*/ width: 8em; background-color: #8bd400; border: 1px solid #486b02; &#125; ul.nav a&#123; display: block; color: #2b3f00; text-decoration: none; border-top: 1px solid #e4ffd3; border-bottom: 1px solid #486b02; background: url("img.png") no-repeat 5% 50%; padding: 0.3em 1em; &#125; ul.nav .last a&#123; /*去掉最后一个列表的底边框*/ border-bottom: 0; &#125; ul.nav a:hover,ul.nav a:focus,ul.nav .selected a&#123; color: #e4ffd3; background-color: #6da203; &#125;&lt;/style&gt;&lt;ul class="nav"&gt; &lt;li&gt;&lt;a href="#"&gt;aaa&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;bbb&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;ccc&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;ddd&lt;/a&gt;&lt;/li&gt; &lt;li class="last"&gt;&lt;a href="#"&gt;eee&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 创建简单的水平导航条12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;style&gt; ol.pagination&#123; margin: 0; padding: 0; list-style-type: none; &#125; ol.pagination li&#123; float: left; margin-right: 0.6em; &#125; ol.pagination a,ol.pagination a.selected&#123; display: block; padding: 0.2em 0.5em; border: 1px solid #cccccc; text-decoration: none; &#125; ol.pagination a:hover,ol.pagination a:focus,ol.pagination a.selected&#123; color: white; background-color: blue; &#125; /*去除prev和next的边框*/ ol.pagination a[rel="prev"],ol.pagination a[rel="next"]&#123; border: none; &#125; /*添加箭头*/ ol.pagination a[rel="prev"]:before&#123; content: '\00AB'; padding-right: 0.5em; &#125; ol.pagination a[rel="next"]:after&#123; content: '\00BB'; padding-left: 0.5em; &#125;&lt;/style&gt;&lt;ol class="pagination"&gt; &lt;li&gt;&lt;a href="#" rel="prev"&gt;Prev&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#" class="selected"&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;4&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;5&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#" rel="next"&gt;Next&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt; 创建图形化导航条显式的设置宽度和高度会导致可维护性问题，所以不显式的设置宽度，每个按钮的宽度由&lt;a&gt;文本的尺寸决定，而是给每个&lt;a&gt;元素的左边和右边设置3em的内边距，并使用行高让&lt;a&gt;元素垂直居中。 123456789101112131415161718192021222324252627282930313233&lt;style&gt; ul.nav&#123; margin: 0; padding: 0; list-style: none; width: 72em; background: linear-gradient(to right, #faa819,yellow) repeat-x; overflow: hidden;/*清除浮动*/ &#125; ul.nav li&#123; float: left; &#125; ul.nav a&#123; display: block; padding: 0.3em; line-height: 2.1em; text-decoration: none; color: #ffffff;; &#125; ul.nav a:hover,ul.nav a:focus&#123; color: #333; &#125;&lt;/style&gt;&lt;ul class="nav"&gt; &lt;li&gt;&lt;a href="#" rel="prev"&gt;Prev&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#" class="selected"&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;4&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;5&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#" rel="next"&gt;Next&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; Suckerfish下拉菜单123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;style&gt; ul&#123; margin: 0; padding: 0; list-style: none; float: left; border: 1px solid #486b02; background-color: #8bd400; &#125; ul.nav li&#123; float: left; background: #8bd400; &#125; ul.nav li ul&#123; width: 8em; position: absolute; left: -999em; /*把下拉菜单隐藏到屏幕左边之外*/ &#125; .nav li:hover ul&#123; left: auto; /*把下拉菜单改回正常位置*/ &#125; ul.nav a&#123; display: block; color: #2b3f00; text-decoration: none; padding: 0.3em 1em; border-right: 1px solid #486b02; border-left: 1px solid #e4ffd3; &#125; ul.nav li li a&#123; border: 0; border-top: 1px solid #e4ffd3; border-bottom: 1px solid#486b02; &#125; ul.nav li:last-child a&#123; border-right: 0; border-bottom: 0; &#125; ul a:hover,ul a:focus&#123; color: #e4ffd3; background-color: #6da203; &#125;&lt;/style&gt;&lt;ul class="nav"&gt; &lt;li&gt;&lt;a href="#"&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;2&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="#"&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;2&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;3&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="#"&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;2&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;4&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;5&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; CSS图像映射1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;style&gt;.imagemap&#123; width: 33px; height: 50px; position: relative;&#125;.imagemap ul&#123; margin: 0; padding: 0;&#125;.imagemap a&#123; position: absolute; display: block; width: 10px; height: 20px; text-indent: -100em; /*通过大的负数缩进，让a元素文本从屏幕上上消失*/&#125;.imagemap .rich a&#123; top: 10px; left: 30px;&#125;.imagemap .aa a&#123; top: 30px; left: 30px;&#125;.imagemap .bb a&#123; top: 40px; left: 30px;&#125;.imagemap .cc a&#123; top: 70px; left: 30px;&#125;.imagemap .dd a&#123; top: 90px; left: 30px;&#125;.imagemap a:hover,.imagemap a:focus&#123; border: 1px solid #ffffff;&#125;&lt;/style&gt;&lt;div class="imagemap"&gt; &lt;img src="img.png" alt="image" height="161" width="159"&gt; &lt;ul&gt; &lt;li class="rich"&gt; &lt;a href="#"&gt;a&lt;/a&gt; &lt;/li&gt; &lt;li class="aa"&gt; &lt;a href="#"&gt;aa&lt;/a&gt; &lt;/li&gt; &lt;li class="bb"&gt; &lt;a href="#"&gt;bb&lt;/a&gt; &lt;/li&gt; &lt;li class="cc"&gt; &lt;a href="#"&gt;cc&lt;/a&gt; &lt;/li&gt; &lt;li class="dd"&gt; &lt;a href="#"&gt;dd&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; Flickr风格的图像映射1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;style&gt; .imagemap&#123; width: 33px; height: 50px; position: relative; &#125; .imagemap ul&#123; margin: 0; padding: 0; list-style: none; &#125; .imagemap a&#123; position: absolute; display: block; width: 30px; height: 20px; color: #000000; border: 1px solid transparent; &#125; .imagemap a .outer&#123; display: block; border: 1px solid #000000; &#125; .imagemap a .inner&#123; display: block; width: 30px; height: 20px; border: 1px solid #ffffff; &#125; .imagemap .rich a&#123; top: 10px; left: 30px; &#125; .imagemap a:hover,.imagemap a:focus&#123; border: #d4d82d; /*鼠标悬停时边框从透明变成黄色*/ &#125; .imagemap a .note&#123; position: absolute; bottom: -3em; width: 7em; padding: 0.2em 0.5em; background-color: #ffc; text-align: center; left: -1000em; margin-left: -4em; /*使说明在热点下面水平居中*/ &#125; .imagemap a:hover .note,.imagemap a:focus .note&#123; left: 25px; &#125;&lt;/style&gt;&lt;div class="imagemap"&gt; &lt;img src="img.png" alt="image" height="161" width="159"&gt; &lt;ul&gt; &lt;li class="rich"&gt; &lt;a href="#"&gt; &lt;span class="outer"&gt; &lt;span class="inner"&gt; &lt;span class="note"&gt;aa&lt;/span&gt; &lt;/span&gt; &lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 对于定义列表的简短说明定义列表（&lt;dl&gt;）由两个核心组件组成：定义术语&lt;dt&gt;和一个或多个定义描述&lt;dd&gt;。 对表单和数据表格应用样式对数据表格应用样式表格特有的元素 summary和caption caption基本上用作表格的标题。 summary用于表格标签，用来描述表格的内容。与图像的alt文本相似，summary应该总结表格中的数据。 thead、tbody和tfoot 利用thead、tbody和tfoot可以将表格划分为几个逻辑部分。 thead表示列表标题。 如果选择使用tbody或tfoot，就必须至少使用一个tbody。 一个表格中只能使用一个tbody和tfoot元素，但是可以使用多个tbody元素将复杂的表格划分为更容易管理的几部分。 行标题和列标题应该使用th而不是td标记。但是某些内容既是内容又是数据，那么应该使用td标记。 th可以设置scope=&quot;col&quot;或scope=&quot;row&quot;的属性来定义是列标题还是行标题。 col和colgroup tr表示整行。 col表示整列，colgroup能够使用col元素对一个或多个列定义和分组。 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;table class="cal" summary="A calendar style date picker"&gt; &lt;caption&gt; &lt;a href="#" rel="prev"&gt;&amp;lt;&lt;/a&gt;January 2008&lt;a href="#" rel="next"&gt;&amp;gt;&lt;/a&gt; &lt;/caption&gt; &lt;colgroup&gt; &lt;col id="sun"&gt; &lt;col id="mon"&gt; &lt;col id="tue"&gt; &lt;col id="wed"&gt; &lt;col id="thur"&gt; &lt;col id="fri"&gt; &lt;col id="sat"&gt; &lt;/colgroup&gt; &lt;thead&gt; &lt;tr&gt; &lt;th scope="col"&gt;sun&lt;/th&gt; &lt;th scope="col"&gt;mon&lt;/th&gt; &lt;th scope="col"&gt;tue&lt;/th&gt; &lt;th scope="col"&gt;wed&lt;/th&gt; &lt;th scope="col"&gt;thur&lt;/th&gt; &lt;th scope="col"&gt;fri&lt;/th&gt; &lt;th scope="col"&gt;sat&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td class="null"&gt;30&lt;/td&gt; &lt;td class="null"&gt;31&lt;/td&gt; &lt;td&gt;&lt;a href="#"&gt;1&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href="#"&gt;2&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href="#"&gt;3&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href="#"&gt;4&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href="#"&gt;5&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;a href="#"&gt;6&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href="#"&gt;7&lt;/a&gt;&lt;/td&gt; &lt;td class="selected"&gt;&lt;a href="#"&gt;8&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href="#"&gt;9&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href="#"&gt;10&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href="#"&gt;11&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href="#"&gt;12&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 对表格应用样式CSS规范有两个表格边盒模型：单独的和叠加的。 在单独模型中，在各个单元格周围有边框，而在叠加模型中，单元格共享边框。 大多数浏览器默认采用单独模型。 border-collapse可以用来设置表格的边盒模型，其值seperate表示单独模型，collapse表示叠加模型 border-spacing属性设置相邻单元格的边框间的距离（仅用于单独模型中）。 123456table.cal&#123; border-collapse: separate; border-spacing: 0; text-align: center; color: #333333;&#125; 添加视觉样式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566.cal th, .cal td&#123; margin: 0; padding: 0;&#125;.cal caption&#123; /*设置表格标题样式*/ font-size: 1.25em; padding-top: 0.692em; padding-bottom: 0.692em; background-color: #d4dde6;&#125;.cal caption[rel="prev"]&#123; /*设置前一个链接样式*/ float: left; margin-left: 0.2em;&#125;.cal caption[rel="next"]&#123; /*设置后一个链接样式*/ float: right; margin-right: 0.2em;&#125;.cal caption a:link,.cal caption a:visited&#123; text-decoration: none; color: #333333; padding: 0 0.2em;&#125;.cal caption a:hover,.cal caption a:active,.cal caption a:focus&#123; background-color: #6d8ab7;&#125;.cal thead th&#123; /*设置表格第一行样式*/ background-color: #d4dde6; border-bottom: 1px solid #a9bacb; font-size: 0.875em;&#125;.cal tbody&#123; /*设置表格体样式*/ color: #a4a4a4; text-shadow: 1px 1px 1px white; background-color: #d0d9e2;&#125;.cal tbody td&#123; /*设置表格内单元格样式*/ border-top: 1px solid #e0e0e1; border-right: 1px solid #9f9fa1; border-bottom: 1px solid #acacad; border-left: 1px solid #dfdfe0;&#125;.cal tbody a&#123; /*设置表格内锚链接样式*/ display: block; text-decoration: none; color: #333333; background-color: #c0c8d2; font-weight: bold; padding: 0.385em 0.692em 0.308em 0.692em;&#125;.cal tbody a:hover,.cal tbody a:focus,.cal tbody a:active,.cal tbody .selected a:link,.cal tbody .selected a:visited,.cal tbody .selected a:hover,.cal tbody .selected a:focus,.cal tbody .selected a:active&#123; background-color: #6d8ab7; color: white; text-shadow: 1px 1px 2px #22456b;&#125;.cal tbody td:hover,.cal tbody td.selected&#123; border-top: 1px solid #2a3647; border-right: 1px solid #465977; border-bottom: 1px solid #576e92; border-left: 1px solid #466080;&#125; 简单的表单布局有用的表单元素fieldset用来对相关信息块进行分类。 为了识别每个fieldset元素的用途，可以使用legend元素，legend就像fieldset的标题，它常常在fieldset的顶部垂直居中，并且向右缩进一点。legend在不同浏览器有不同的默认样式。 表单标签label元素用来帮助添加结构和增加表单的可用性和可访问性。 标签和表单控件关联起来的方法有下面两种： 隐式方式： 1&lt;label&gt;email&lt;input name="email" type="text"/&gt;&lt;/label&gt; 显式方式： 12&lt;label for="email"&gt;email&lt;/label&gt;&lt;input name="email" id="email" type="text" /&gt; 在表单输入控件和标签之间创建关联需要id属性，将表单数据发送回服务器需要name属性。id和name不必相同，但为了保持一致，尽可能让它们相同。 基本布局12345678910111213141516171819202122232425262728293031323334&lt;style&gt; fieldset&#123; margin: 1em 0; padding: 1em; border: 1px solid #cccccc; background: #f8f8f8; &#125; legend&#123; font-weight: bold; &#125; label&#123; display: block; cursor: pointer; &#125; input&#123; width: 20em; &#125;&lt;/style&gt;&lt;fieldset&gt; &lt;legend&gt;You Contact Details&lt;/legend&gt; &lt;div&gt; &lt;label for="author"&gt;Name:&lt;/label&gt; &lt;input name="author" id="author" type="text"/&gt; &lt;/div&gt; &lt;div&gt; &lt;label for="email"&gt;Email:&lt;/label&gt; &lt;input name="email" id="email" type="text"&gt; &lt;/div&gt; &lt;div&gt; &lt;label for="url"&gt;Web Address&lt;/label&gt; &lt;input name="url" id="url" type="text"&gt; &lt;/div&gt;&lt;/fieldset&gt; 复杂的表单布局可访问的数据输入元素1234567891011121314151617181920212223242526272829303132333435&lt;style&gt; label &#123; float: left; width: 10em; cursor: pointer; &#125; #monthOfBirthLabel,#yearOfBirthLabel&#123; text-indent: -1000em; /*隐藏标签*/ width: 0; /*防止标签影响布局*/ &#125; input#dateOfBirth&#123; width: 3em; margin-right: 0.5em; &#125; select#monthOfBirth&#123; width: 10em; margin-right: 0.5em; &#125; input#yearOfBirth&#123; width: 5em; &#125;&lt;/style&gt;&lt;div&gt; &lt;label for="dateOfBirth"&gt;Date of Birth:&lt;/label&gt; &lt;input name="dateOfBirth" id="dateOfBirth" type="text"&gt; &lt;label for="monthOfBirth" id="monthOfBirthLabel"&gt;Month Of Birth&lt;/label&gt; &lt;select name="monthOfBirth" id="monthOfBirth"&gt; &lt;option value="1"&gt;1月&lt;/option&gt; &lt;option value="2"&gt;2月&lt;/option&gt; &lt;option value="3"&gt;3月&lt;/option&gt; &lt;/select&gt; &lt;label for="yearOfBirth" id="yearOfBirthLabel"&gt;Year Of Birth&lt;/label&gt; &lt;input name="yearOfBirth" id="yearOfBirth" type="text"&gt;&lt;/div&gt; 多列复选框12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;style&gt; fieldset#favoriteColor&#123; margin: 0; padding: 0; border: none; background: transparent; &#125; #favoriteColor h2&#123; /*为了避免浏览器处理legend定位的方式不一致，将标题用作标签*/ width: 10em; float: left; font-weight: normal; &#125; #favoriteColor .col&#123; width: 8em; float: left; &#125; #favoriteColor label&#123; float: none; /*复选框不浮动*/ &#125;&lt;/style&gt;&lt;fieldset id="favoriteColor"&gt; &lt;h2&gt;FavoriteColor:&lt;/h2&gt; &lt;div class="col"&gt; &lt;div&gt; &lt;label&gt;&lt;input type="checkbox" class="checkbox" id="red" name="red" value="red"&gt;red&lt;/label&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;&lt;input type="checkbox" class="checkbox" id="yellow" name="yellow" value="yellow"&gt;yellow&lt;/label&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;&lt;input type="checkbox" class="checkbox" id="blue" name="blue" value="blue"&gt;blue&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="col"&gt; &lt;div&gt; &lt;label&gt;&lt;input type="checkbox" class="checkbox" id="green" name="green" value="green"&gt;green&lt;/label&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;&lt;input type="checkbox" class="checkbox" id="orange" name="orange" value="orange"&gt;orange&lt;/label&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;&lt;input type="checkbox" class="checkbox" id="other" name="other" value="other"&gt;other&lt;/label&gt; &lt;/div&gt; &lt;/div&gt;&lt;/fieldset&gt; 提交按钮为了在整个操作系统中保持一致，在一些操作系统上禁止修改input按钮样式，但是button元素不受这些限制影响。button在IE6和IE7提交元素本身的内容，而不是value属性的内容（非IE6和IE7浏览器的行为）。 123456789101112131415161718&lt;style&gt; button&#123; width: 200px; height: 50px; border: 1px solid #989898; border-radius: 6px; background: linear-gradient(to bottom,yellow,greenyellow) #c5e063 bottom left repeat-x; box-shadow: 2px 2px 2px #ccc; color: #ffffff; font-size: 26px; font-weight: bold; text-shadow: 1px 1px 1px #666; &#125;&lt;/style&gt;&lt;p&gt; &lt;button type="submit"&gt;Book Now&lt;/button&gt;&lt;/p&gt; 布局所有CSS布局技术的根本都是3个基本概念：定位、浮动和外边距操纵。 计划布局 先把页面划分为大的结构性区域，比如容器、页眉、内容器和页脚。这些区域在整个站点中往往是一致的。 然后将注意力转移到内容区域本身，开始建立网格结构。设计有多少个不同的内容区域？它们有什么差异？从布局的角度来说，内容区域是确实不一样，还是可以被同等看待？大多数设计只有几个独特的内容区域，所以应该寻找共同的特征而不是视觉表现。 最后在各个内容区域中寻找不同的布局结构。是否需要把某些信息分为两列、三列或四列？与前面不同，这些布局结构往往非常灵活，在各个页面之间常常有变化。 结构设计完成之后，可以开始关注不同类型的内容。给每个内容块起一个有意义的名称，然后分析它们的关系。 查看每个内容块的结构，看看不同的类型中是否有共同的模式。应该尽量采用一般的类名，然后根据上下文应用样式。 找出模式并确定命名约定后，最好马上开始定义将使用的元素。 设置基本结构123456789101112131415161718&lt;style&gt; .wrapper &#123; width: 920px; margin: 0 auto; &#125;&lt;/style&gt;&lt;div class="wrapper"&gt; &lt;div class="header"&gt; headerheaderheaderheader &lt;/div&gt; &lt;div class="content"&gt; contentcontentcontent &lt;/div&gt; &lt;div class="footer"&gt; footerfooterfooterfooter &lt;/div&gt;&lt;/div&gt; 基于浮动的布局在基于浮动的布局中，只需要设置希望定位的元素的宽度，然后将它们向左或向右浮动。 因为浮动的元素不再占据文档流中的任何空间，它们就不再对包围它们的块框产生任何影响。为了解决这个问题，需要对布局中各个点上的浮动元素进行清理。非常常见的做法不是连续地浮动和清理元素，而是浮动几乎所有东西，然后在整个文档的“战略点”（比如页脚）上进行一次或两次清理。还可以使用overflow: hidden;清理某些元素的内容。 两列的浮动布局在创建基于浮动的布局时，一般将两列布局向左浮动，然后使用外边距或内边距在两列之间创建一个隔离带。在使用这种方法时，列在可用空间内包得很紧。在IE上会发生打乱紧密布局，迫使一列退到另一列的下面。 因为IE考虑元素的内容的尺寸，而不是元素本身的尺寸。在符合标准的浏览器中，如果元素的内容太大，它只会超出框之外。在IE上如果元素的内容太大，整个元素就会扩展。 为了防止这种情况发生，需要避免浮动布局在包含它们的元素中太挤。可以不用水平外边距或内边距来建立隔离带，而是让一个元素向左浮动，让另一个元素向右浮动。 1234567891011121314151617181920212223242526272829303132333435363738&lt;style&gt; .wrapper &#123; width: 920px; margin: 0 auto; overflow: hidden; &#125; .content .primary&#123; width: 650px; padding-right: 20px; float: right; display: inline; &#125; .content .secondary&#123; width: 230px; float: left; display: inline; &#125; .content&#123; overflow: hidden; &#125;&lt;/style&gt;&lt;div class="wrapper"&gt; &lt;div class="header"&gt; aaaaaaaaaaaaaaaaaaaaaaaaaaaa &lt;/div&gt; &lt;div class="content"&gt; &lt;div class="primary"&gt; bbbbbbbbbbbbbbb &lt;/div&gt; &lt;div class="secondary"&gt; bbbbbbbbbbbbbbb &lt;/div&gt; &lt;/div&gt; &lt;div class="footer"&gt; aaaaaaaaaaaaaaaaaaaaaaaaaaaa &lt;/div&gt;&lt;/div&gt; 三列的浮动布局1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;style&gt; .wrapper &#123; width: 920px; margin: 0 auto; overflow: hidden; &#125; .content .primary&#123; width: 670px; float: right; display: inline; &#125; .content .secondary&#123; width: 230px; float: left; display: inline; &#125; .content&#123; overflow: hidden; &#125; .content .primary .primary&#123; width: 400px; float: left; display: inline; &#125; .content .primary .secondary&#123; width: 230px; float: right; display: inline; padding-left: 20px; &#125;&lt;/style&gt;&lt;div class="wrapper"&gt; &lt;div class="header"&gt; aaaaaaaaaaaaaaaaaaaaaaaaaaaa &lt;/div&gt; &lt;div class="content"&gt; &lt;div class="primary"&gt; &lt;div class="primary"&gt; cccccccccc &lt;/div&gt; &lt;div class="secondary"&gt; cccccccccc &lt;/div&gt; &lt;/div&gt; &lt;div class="secondary"&gt; bbbbbbbbbbbbbbb &lt;/div&gt; &lt;/div&gt; &lt;div class="footer"&gt; aaaaaaaaaaaaaaaaaaaaaaaaaaaa &lt;/div&gt;&lt;/div&gt; 固定宽度、流式和弹性布局宽度以像素为单位的布局称为固定宽度布局，它使开发人员对布局和定位有更大的控制能力，但是随着屏幕尺寸越来越大，这种设计越来越不适应灵活的web开发，而且固定宽度的布局往往适合于浏览器默认文本字号，只要文本字号增加几级，边栏就会挤满空间并且行长太短，导致阅读性差。 为了解决这些问题，可以使用流式布局或弹性布局代替固定宽度布局。 流式布局使用流式布局时，尺寸是使用百分数而不是像素设置。这使得流式布局能够相对于浏览器窗口进行伸缩。但当窗口较小时，行变得非常窄，很难阅读。因此，有必要添加以像素或em为单位的min-width；从而防止布局变得太窄。但是，如果min-width设置得太大，流式布局也会遇到固定宽度布局相同的限制。 与之相反，如果设计横跨整个浏览器窗口，那么行就变得太长。可以采取几个措施来避免这个问题： 不要横跨浏览器而是让容器只跨越宽度的一部分，比如85% 可以考虑用百分数设置内边距和外边距。这样的话，内边距和外边距的宽度将随着窗口尺寸而变 对于非常严重的情况，可以选择为容器设置最大宽度，防止内容在大显示器上变得过宽 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;style&gt; .wrapper &#123; width: 76.8%; margin: 0 auto; text-align: left; min-width: 62em; max-width: 125em; &#125; .content .primary&#123; width: 72.82%; float: right; display: inline; &#125; .content .secondary&#123; width: 25%; float: left; display: inline; &#125; .content .primary .primary&#123; width: 59.7%; float: left; display: inline; &#125; .content .primary .secondary&#123; width: 34.33%; float: right; display: inline; padding-left: 2.63%; &#125;&lt;/style&gt;&lt;div class="wrapper"&gt; &lt;div class="header"&gt; aaaaaaaaaaaaaaaaaaaaaaaaaaaa &lt;/div&gt; &lt;div class="content"&gt; &lt;div class="primary"&gt; &lt;div class="primary"&gt; cccccccccc &lt;/div&gt; &lt;div class="secondary"&gt; cccccccccc &lt;/div&gt; &lt;/div&gt; &lt;div class="secondary"&gt; bbbbbbbbbbbbbbb &lt;/div&gt; &lt;/div&gt; &lt;div class="footer"&gt; aaaaaaaaaaaaaaaaaaaaaaaaaaaa &lt;/div&gt;&lt;/div&gt; 弹性布局虽然流式布局可以充分利用可用空间，但是在大分辨率显示器上，行仍然会过长。相反，在窄窗口中或在增加文本字号时，行会变得非常短，内容很零碎。这时候可以使用弹性布局。 弹性布局相对于字号来设置元素的宽度，以em为单位设置宽度，可以确保在字号增加时整个布局随之扩大，这可以将行长保持在可阅读的范围内。 但是弹性布局的一些问题与固定宽度布局一样，比如不能充分利用可用空间。另外，因为文本字号增加时整个布局会加大，所以弹性布局会变得比浏览器窗口宽，导致水平滚动条出现。为了防止这种情况，可能需要在容器div上添加100%的max-width。 将固定宽度布局转化为弹性布局要设置基字号，让1em大致相当于10像素。大多数浏览器上默认字号是16像素。 建议内部宽度仍然使用百分数，只以em为单位设置容器的宽度。这样的话，内部宽度仍然是相对于字号的，这样就可以方便地修改布局的总尺寸，不必修改每个元素的宽度，这种方案更灵活和易于维护。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;style&gt; body&#123; font-size: 62.5%; text-align: center; &#125; .wrapper &#123; width: 92em; margin: 0 auto; text-align: left; max-width: 95%; &#125; .content .primary&#123; width: 72.82%; float: right; display: inline; &#125; .content .secondary&#123; width: 25%; float: left; display: inline; &#125; .content .primary .primary&#123; width: 59.7%; float: left; display: inline; &#125; .content .primary .secondary&#123; width: 34.33%; float: right; display: inline; padding-left: 2.63%; &#125;&lt;/style&gt;&lt;div class="wrapper"&gt; &lt;div class="header"&gt; aaaaaaaaaaaaaaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaaaaaaaaaaaaaa &lt;/div&gt; &lt;div class="content"&gt; &lt;div class="primary"&gt; &lt;div class="primary"&gt; cccccccccc cccccccccc cccccccccc &lt;/div&gt; &lt;div class="secondary"&gt; cccccccccc cccccccccc cccccccccc &lt;/div&gt; &lt;/div&gt; &lt;div class="secondary"&gt; bbbbbbbbbbbbbbb bbbbbbbbbbbbbbb bbbbbbbbbbbbbbb &lt;/div&gt; &lt;/div&gt; &lt;div class="footer"&gt; aaaaaaaaaaaaaaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaaaaaaaaaaaaaa &lt;/div&gt;&lt;/div&gt; 流式和弹性图像对于需要跨大区域的图像，比如站点页眉或品牌区域中的图像，可以考虑使用背景图像，而不是图像元素。 如果图像需要用作页面上的图像元素，那么将容器元素的宽度设置为100%并且将overflow:hidden。这样的话，图像右边会被截短，使它适合容器元素。而不会随着布局伸缩。 对于常规内容图像，如果希望它们垂直和水平伸缩以避免被剪切，可以将图像元素添加到没有设置任何尺寸的页面上，然后设置图像的百分数宽度，并且添加与图像宽度相同的max-width以避免像素失真。 faux列为了创建列的效果，需要创建一个伪列。方法是在一个占据布局最大高度的元素上应用重复的背景图像。 对于固定宽度的布局，只需要在容器元素上应用一个垂直重复的背景图像，其宽度与导航区域相同。 为流式布局创建faux列需要按百分比对背景图像进行定位。按百分比定位背景图像可以创建水平比例与布局相同的背景图像。 background-position使用像素为单位设置背景图像的位置时，是图像左上角到元素左上角的距离为指定像素。而使用百分数为单位时，是图像上距离图像左上角的指定百分数的点到父元素上距离父元素左上角为指定百分数距离的位置。 高度相等的列123456789101112131415161718192021222324252627282930313233&lt;style&gt; .wrapper&#123; width: 100%; &#125; .box&#123; width: 250px; margin-left: 20px; float: left; display: inline; padding: 20px; background: yellowgreen; &#125;&lt;/style&gt;&lt;div class="wrapper"&gt; &lt;div class="box"&gt; &lt;h1&gt;tangcheng&lt;/h1&gt; &lt;p&gt;aaaaaaaaaaaaaaaaaaaaaaaa&lt;/p&gt; &lt;div class="bottom"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="box"&gt; &lt;h1&gt;tangcheng&lt;/h1&gt; &lt;p&gt;bbbbbbbbbbbbbbbbbbbbbbbbb&lt;/p&gt; &lt;div class="bottom"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="box"&gt; &lt;h1&gt;tangcheng&lt;/h1&gt; &lt;p&gt;ccccccccccccccccccccccccc&lt;/p&gt; &lt;div class="bottom"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 上面代码给每个框设置大的底内边距，然后用数值相似的负外边距消除这个高度。但这会导致每个列溢出容器元素。 为了把列的底边定位在正确的位置，需要让它们与容器元素的底部对齐： 1234567891011121314151617181920212223.wrapper&#123; width: 100%; overflow: hidden; position: relative;&#125;.box&#123; width: 250px; margin-left: 20px; margin-bottom: 500px; float: left; display: inline; padding: 20px; padding-bottom: 520px; background: yellowgreen;&#125;.bottom&#123; position: absolute; bottom: 0; height: 20px; width: 290px; background: yellowgreen; margin-left: -20px;&#125; CSS3列CSS3也可以创建等高文本列，需要用到colum-count、colum-width和colum-gap属性： 12345678910111213&lt;style&gt; .col&#123; column-count: 3; column-width: 14em; column-gap: 2em; column-rule: 1px solid #ccc; &#125;&lt;/style&gt;&lt;h1&gt;aaaa&lt;/h1&gt;&lt;div class="col"&gt; &lt;p&gt;bbbbbbbbb&lt;/p&gt;&lt;/div&gt; CSS列的有点之一是在可用空间小于已定义的宽度时的处理方式。列不会像使用浮动那样回绕，而是会减少列数。 bug和修复bug捕捉bug常见的CSS问题 特殊性和分类次序的问题 将一个规则应用于一个元素时，如果发现没有任何效果，这时往往存在特殊性问题。 不要随便添加更特殊的选择器，因为这可能会给代码的其他部分带来特殊性问题。更好的方法往往是删除额外的选择器，让它们尽可能一般化，只在需要细粒度的控制时添加更特殊的选择器。 外边距叠加的问题 如果元素没有垂直边框或内边距，那么它的高度就是它包含的子元素的顶部和底部边框边缘之间的距离。 因此，包含的子元素的顶部和底部外边距就突出到容器元素的外边，有一个简单的解决方案：通过添加一个垂直边框或内边距，外边距就不再叠加了，而且元素的高度就是它包含的子元素的顶部和底部外边距边缘的距离。 123456789101112131415161718192021222324&lt;style&gt; #box&#123; margin: 10px; background-color: #d5d5d5; &#125; p&#123; margin: 20px; background-color: #6699ff; &#125; /*************升级*****************/ #box&#123; margin: 10px; background-color: #d5d5d5; padding: 1px; &#125; p&#123; margin: 20px; background-color: #6699ff; &#125;&lt;/style&gt;&lt;div id="box"&gt; &lt;p&gt;mmmmmmmmmm&lt;/p&gt;&lt;/div&gt; 升级后： 捕捉bug的基本知识 尽量一开始就避免bug 应该尽可能使用简单的代码实现所需的结果，所以要避免使用过分花哨的技术，只在绝对必要的情况下才使用hack。 隔离问题 通过隔离问题和识别症状，有可能查明问题的原因并修复它。隔离问题的一种方法是在相关的元素上应用边框或轮廓。 创建基本测试案例 要创建基本测试案例，首先应该复制出问题文件，删除多余HTML，只留下最基本的内容，然后开始注释样式表，从而查明哪些样式导致了这个问题。 修复问题，而不是修复症状 请求帮助 拥有布局什么是布局IE使用布局概念来控制元素的尺寸和定位。那些“拥有布局”（have layout）的元素负责本身及其子元素的尺寸设置和定位。如果一个元素“没有拥有布局”，那么它的尺寸和位置由最近的拥有布局的祖先元素控制。 IE显示引擎利用布局概念减少它的处理开销。在理想情况下，所有元素都控制自己的尺寸和定位。但是，这会在IE中导致很大的性能问题。因此，IE开发团队只将布局应用于实际需要它的元素，这样可以减少性能开销。 在默认情况下拥有布局的元素包括： body html（标准模式中） table tr、td img hr input、select、textarea、button iframe、embed、object、applet marquee 布局的概念是Windows上的IE特有的，而且不是CSS属性。尽管设置某些CSS属性会使元素拥有布局，但是在CSS中无法显式地设置布局。可以使用JavaScript函数hasLayout来查看一个元素是否拥有布局，这个函数是一个只读属性，不能进行设置值。 设置以下CSS属性会自动使元素拥有布局： float: left或float: right display: inline-block width: 任何值 height: 任何值 zoom: 任何值 writing-node: tb-rl 在IE7中，以下属性也成了布局触发器： overflow: hidden、scroll或auto min-width: 任何值 max-width: 除none以外的任何值 解决办法 IE条件注释 条件注释是一种专有的（因此是非标准的）对常规HTML注释的Microsoft扩张。条件注释在其他所有浏览器看来是常规注释，因此本质上是无害的，所以条件注释通常被看做处理IE特有bug的最好方法。 12345678910111213141516171819指定IE5以上所以版本中的属性&lt;!-- [if IE] &lt;link rel="stylesheet" type="text/css" href="ie.css"&gt;--&gt;指定IE6中的属性&lt;!-- [if IE6] &lt;link rel="stylesheet" type="text/css" href="ie.css"&gt;--&gt;对IE所有版本隐藏样式&lt;!-- [if !IE]&gt;--&gt; &lt;link rel="stylesheet" type="text/css" href="ie.css"&gt;&lt;!--&lt;![endif]--&gt;对IE5.X隐藏样式&lt;!-- [if gte IE6]&gt;&lt;!--&gt; &lt;link rel="stylesheet" type="text/css" href="ie.css"&gt;&lt;!--&lt;![endif]--&gt; 关于hack和过滤器的一个警告 如果浏览器不理解某个选择器或者属性和值，它会忽略整个规则或声明。利用这点可以确保老式浏览器会平稳退化。 使用不被支持的CSS作为过滤机制是一种相对安全的方法，但是这些hack和过滤器常常会使你的代码失效。作为一般规则，应该使用依赖于不被支持的CSS过滤器，而不是依赖于某种浏览器bug的过滤器。最好完全避免使用过滤器。 明智地使用hack和过滤器 使用hack较多时，最好把它们放在自己独立的样式表中。 应用IE for Mac带通过滤器 应用星号HTML hack 应用子选择器hack 分级浏览器支持 首先确定一组浏览器，让站点在这些浏览器中的表现一致。对这些浏览器，希望站点的外观大体上相同，但允许一些细微差异 确定一组已经过时但仍然比较重要的浏览器，在这些浏览器中随机选择几个执行测试，尝试修复问题，但是即使显示效果不完美并且在浏览器之间有差异，也是可以接受的，只要不影响访问内容即可 最后确定一组完全不想正式支持的浏览器，可以确保内容和功能可用，表现方式无所谓。 实例研究：Roma Italia 对于各种标记（HTML元素、属性和值，CSS的选择器、属性和值），能简化就简化。 reset.css可以避免和缓解HTML元素默认样式不一致的问题。 RGBa不透明度和opacity不一样，RGBa不透明度可以应用于特定的属性（比如背景），它只影响这个属性。opacity会影响应用它的元素中的所有东西。 如果文本太长，在包含它的元素中放不下，text-overflow会截断它，使用ellipsis值在被截断的文本后面加上省略号。 对于Ctrl+/-和Command+/-命令，每种浏览器的最新版本现在默认采用页面缩放，而不是文本缩放。页面缩放直接缩放整个页面—布局、格式和文本大小。这意味着px是适合font-size的单位，因为用户分辨不出用绝对单位和用相对单位设置的文本之间的差异。 @font-face可以在设计中使用任何字体显示HTML文本，而不用考虑用户的机器上是否安装了这种字体。 AJAX通常至少包括3个部分： 异步的服务器通信，通常使用XMLHttpRequest实现 通过操作DOM进行动态显示和交互 使用JavaScript把所有部分组合在一起 实例研究：Climb the Mountains :first-child伪类只选择包含元素的第一个子元素 相邻同胞选择器可以包含多个选择器，由+分隔 1div ul li + li + li + li&#123;....&#125;/*会选择第四个li元素*/ 可以通过组合类（不同样式的类组合成一个你想要的效果）为元素提供更大的灵活性]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在Angular中快速定位DOM元素]]></title>
    <url>%2F2017%2F05%2F16%2F%E5%A6%82%E4%BD%95%E5%9C%A8Angular%E4%B8%AD%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8DDOM%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[在使用Angular2+中，经常会想快速的去选择DOM上的某个元素，如果是刚上手Angular，有可能直接就使用原生DOM操作或者导入jQuery再进行DOM操作，既然都使用了Angular了，有没有更好的方法呢？答案是肯定的。 通过ElementRef先上代码： 12345678910111213141516171819202122import &#123;Component, ElementRef, OnInit&#125; from '@angular/core';@Component(&#123; selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.css']&#125;)export class AppComponent implements OnInit&#123; color:string; title = 'button !'; constructor(private el:ElementRef)&#123;&#125; setHeight()&#123; this.el.nativeElement.querySelector('.btn1').style.height = '300px'; &#125; ngOnInit()&#123; this.setHeight(); &#125;&#125; 12345678&lt;h1&gt; &#123;&#123;title&#125;&#125;&lt;/h1&gt;&lt;div&gt;&lt;button myHighlight class="btn btn1"&gt;按钮一&lt;/button&gt;&lt;button myHighlight class="btn"&gt;按钮二&lt;/button&gt;&lt;button myHighlight class="btn"&gt;按钮三&lt;/button&gt;&lt;/div&gt; 效果是这样： 上述代码中的nativeElement其实包含的是组件中所有的DOM元素，如下图所示： 通过调用querySelectorAPI就能获取页面元素，需要注意的是querySelector只返回第一个元素，当你需要选择多个元素的时候可以使用querySelectorAll。 通过@viewChild12345678&lt;h1&gt; &#123;&#123;title&#125;&#125;&lt;/h1&gt;&lt;div&gt;&lt;button myHighlight class="btn btn1"&gt;按钮一&lt;/button&gt;&lt;button myHighlight class="btn" #btn&gt;按钮二&lt;/button&gt; &lt;!--增加一个变量--&gt;&lt;button myHighlight class="btn"&gt;按钮三&lt;/button&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829import &#123;Component, ElementRef, OnInit, ViewChild&#125; from '@angular/core';@Component(&#123; selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.css']&#125;)export class AppComponent implements OnInit&#123; @ViewChild('btn') btn:ElementRef;//通过@ViewChild获取元素 color:string; title = 'button !'; constructor(private el:ElementRef)&#123;&#125; setHeight()&#123; this.el.nativeElement.querySelector('.btn1').style.height = '300px'; &#125; setWidth()&#123; this.btn.nativeElement.style.width = '200px';//定义宽度 &#125; ngOnInit()&#123; this.setHeight(); this.setWidth(); &#125;&#125; 效果如下： 如果多个HTML元素都定义了相同的变量，使用@viewChild时只能选择到第一个元素。 更好的方法是配合renderer2对象提供的API去实现同样的效果，这样减少应用层与渲染层之间强耦合关系： 123456789101112131415161718192021222324252627282930313233import &#123;Component, ElementRef, OnInit, Renderer2, ViewChild&#125; from '@angular/core';@Component(&#123; selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.css']&#125;)export class AppComponent implements OnInit&#123; @ViewChild('btn') btn:ElementRef; color:string; title = 'button !'; //初始化renderer2 constructor(private el:ElementRef,private renderer2: Renderer2)&#123;&#125; setHeight()&#123; this.el.nativeElement.querySelector('.btn1').style.height = '300px'; &#125; setWidth()&#123; // this.btn.nativeElement.style.width = '200px'; //使用renderer2的setStyle方法设置宽度 this.renderer2.setStyle(this.btn.nativeElement,'width','200px') &#125; ngOnInit()&#123; this.setHeight(); this.setWidth(); &#125;&#125; 参考文章中都提到了@viewChild配合renderer选择元素，但是在Angular4中renderer已经废弃掉了，变成了renderer2。 renderer2API中还有其他的一些方法可以用来进行一些DOM操作： 1234567891011121314151617181920212223class Renderer2 &#123; data : &#123;[key: string]: any&#125; destroy() : void createElement(name: string, namespace?: string) : any createComment(value: string) : any createText(value: string) : any destroyNode : (node: any) =&gt; void | appendChild(parent: any, newChild: any) : void insertBefore(parent: any, newChild: any, refChild: any) : void removeChild(parent: any, oldChild: any) : void selectRootElement(selectorOrNode: string|any) : any parentNode(node: any) : any nextSibling(node: any) : any setAttribute(el: any, name: string, value: string, namespace?: string) : void removeAttribute(el: any, name: string, namespace?: string) : void addClass(el: any, name: string) : void removeClass(el: any, name: string) : void setStyle(el: any, style: string, value: any, flags?: RendererStyleFlags2) : void removeStyle(el: any, style: string, flags?: RendererStyleFlags2) : void setProperty(el: any, name: string, value: any) : void setValue(node: any, value: string) : void listen(target: 'window'|'document'|'body'|any, eventName: string, callback: (event: any) =&gt; boolean | void) : () =&gt; void&#125; 参考文章 [译]Angular2新人常犯的5个错误； Angular 2 ElementRef Angular Renderer2]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[参加中兴通讯前端技术大会一些总结]]></title>
    <url>%2F2017%2F05%2F05%2F%E5%8F%82%E5%8A%A0%E4%B8%AD%E5%85%B4%E9%80%9A%E8%AE%AF%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E5%A4%A7%E4%BC%9A%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[今天公司层面举办了一次前端大会，请了公司内部重量级的前端大咖和UX大咖以及大漠穷秋（章小飞）老师。忘了以后还有幸和大漠穷秋老师一起吃了一顿饭，感觉还是很开心的。 大漠穷秋老师以前是中兴软创的，现在是Google Angular项目组在中国的开发者PM，出版过《Ext江湖》、《ActionScript3.0游戏设计基础（第二 版）》、《用AngularJS开发下一代WEB应用》等书籍，录制过《AngularJS实战》和《Angular2.0视频教程》等视频教程。 此处应该有大漠穷秋老师和我的合影一张（不要脸状o(////▽////)q） 公司内部的前端大咖和UX大咖们主要讲了内部的一些组件库的介绍以及一些web缓存、web安全之类的介绍，因为涉及到公司的一些东西，这里就不多说了。 大漠穷秋老师主要介绍了前端发展史、Angular-CLI、angular（angularJS指的是angular1，而angular指的是2及其以上版本）中核心的三个概念（component、module、route），Angular核心架构思想（组件化、依赖注入、数据绑定），其实内容主要基于Angular2.0视频教程来了！这篇博客，大家也可以自己上去看。 其实我对Angular-CLI这个东西还是很有好感的，大漠老师也是在这个章节介绍了前端的发展历史和历史上用过的工具后引出了Angular-CLI这个东西，用ppt上的话就是Angular-CLI is more than a tool,it is a PLATFORM!。其实他底层集成webpack、karma等一些东西，包括像Angular中AOT和摇树优化仅仅只需要在ng命令后添加一句话就行，而不是像官网一样做一大堆配置，并且使用这个工具可以得到一个更清晰的项目结构。所以可以把Angular-CLI理解成一个为Angular服务的平台，更加快速方便的进行开发。 在提问环节中，因为我们团队有前端测试的需求，大漠穷秋老师给出的回答是这样的，前端的测试建议在产品发布之前进行测试，不然需要维护很多测试用例，特别是前端界面一改，测试用例就需要变，维护成本太高。 对于有的团队有ng1升级到ng2的想法，大漠穷秋老师给出的答案是直接用ng2重写，因为ng1升级到ng2是破坏性的升级，升级耗费的时间还不如重写。而对于ng2到ng4的升级则是比较平滑的，没有break change，所以可以放心升级。我已经把我们项目从ng2升级到了ng4，暂时没有什么毛病，升级教程可以参考Angular4.0.0正式发布，附新特性及升级指南。 最后，感谢王博腾出一天时间让我们去参加这次大会，收货还是蛮大的，最后还带我去和大漠穷秋老师吃了一次饭，第一次和大咖们一起吃饭，好激动，以至于啥都没问，就顾着听大咖们讲了，哈哈哈。]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>会议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Anglar-cli的种子工程]]></title>
    <url>%2F2017%2F04%2F25%2F%E5%9F%BA%E4%BA%8EAnglar-cli%E7%9A%84%E7%A7%8D%E5%AD%90%E5%B7%A5%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[为公司项目做了一个种子工程，方便以后做Demo或者其他工程。 项目地址：Angular-cli-starter 说明node版本 7.9.0 npm版本 4.2.0 Angular版本 4.0.2 AngularCLI版本 1.0.0 已经引入了Angular Material、ngx-bootstrap、bootstrap、karma-firefox-launcher、fontawesome、echarts、jQuery、moment.js。 使用 在node_modules的文件夹下找到/node_modules/@angular/cli/bin/ 然后在终端中pwd输出路径 在root目录下找到~/bash_profile文件，用vim打开，把下面路径两个字换成刚刚得到的路径，然后写入文件中 alias ng=&quot;路径/ng&quot; 在终端执行’. ~/.bash_profile’(如果遇到command not found: ng，重新运行一下这个命令) 项目中使用了sass做css预编译,因此需要安装sass,安装方法见下文 在项目根目录执行npm install ng serve --open 注： 1-4步可以用npm i @angular/cli@latest -g代替，而且不会经常需要执行第四步; 如果项目在虚机中，需要在外部浏览器访问，可以查询到虚机ip地址后，用ng serve --host ip地址来起服务，在外部用虚机地址+端口号访问。 安装Sasssass基于Ruby语言开发而成，因此安装sass前需要安装Ruby，下面以linux系统安装为例子（mac自带ruby,windows下安装参考Sass官网） 去Ruby官网下载Ruby 2.4.1版本到本地 分别运行以下命令安装： 1234cd ruby-2.4.1./configuremakesudo make install 安装完后输入ruby -v，若出现ruby版本号表示安装成功 ruby安装完成后就可以安装sass和Compass了,在ruby目录下打开终端，输入：12gem install sassgem install compass 每个安装过程都会看到如下输出：123456Fetching: sass-3.x.x.gem (100%)Successfully installed sass-3.x.xParsing documentation for sass-3.x.xInstalling ri documentation for sass-3.x.xDone installing documentation for sass after 6 secon1 gem installed 安装完成后，在终端输入sass -v和compass -v，若出现版本号表示安装成功。 若遇到gem下载不稳定，可以参考官网更换gem源 关于AOT和摇树优化打开命令行，进入App根目录，执行以下命令：ng build --prod --aot 加上–prod参数之后，angular-cli会自动启用TreeShaking（摇树）特性，简而言之，就是把用不到的包全部剔除掉，就像从树上把枯叶子摇下来一样，加上–aot参数是让angular-cli启动预编译特性。 【请注意】最新版本的angular-cli已经内置了对AOT和TreeShaking的支持，只要像上面这样在build的时候加上–prod和–aot参数就可以了，不需要再做任何其它任何配置工作，官方网站上的那一篇指南有点过时了。 引入外部组件 引入ngx-bootstrap 在所要引入的模块的module文件中import就行：1234567import &#123; AlertModule &#125; from 'ngx-bootstrap';@NgModule(&#123; imports: [ AlertModule.forRoot(), ]&#125;)export class XXXModule &#123; &#125; 组件列表及使用参考官网：ngx-bootstrap组件 引入Angular Material 1234567import &#123; MdAutocompleteModule &#125; from '@angular/material';@NgModule(&#123; imports: [ MdAutocompleteModule, ]&#125;)export class XXXModule &#123; &#125; 组件列表及使用参考官网：Angular Material 引入echarts、jQuery、moment.js 在所需组件中import就行：123import echarts from 'echarts';import $ from 'jquery/dist/jquery';import * as moment from 'moment'; 注意事项目录结构可以参考如dir-desc.txt文件。 项目中新建css文件时，后缀名统一为.scss。scss完全兼容css(可以在scss文件中直接写css)。scss的使用可以看参考文章7。 参考文章 command not found: ng的解决办法 Angular 2 升级 Angular 4 如何利用angular-cli组织项目结构 预(AOT)编译器 【重要】启用AOT+TreeShaking+Gzip大幅度压缩Angular2应用的体积 大漠穷秋Angular4完整案例 anuglar-2-animate.css-example Angular 2 Animate.css Tutorial – How to use Animate.CSS in NG2 Application? Sass官网 Sass入门]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sass入门]]></title>
    <url>%2F2017%2F04%2F08%2FSass%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[本文是Sass中文网、慕课网Sass入门篇 和 Sass进阶篇、阮一峰SASS用法指南的学习笔记。 Sass简介什么是SassSass 官网上是这样描述 Sass 的： Sass 是一门高于 CSS 的元语言，它能用来清晰地、结构化地描述文件样式，有着比普通 CSS 更加强大的功能。Sass 能够提供更简洁、更优雅的语法，同时提供多种功能来创建可维护和管理的样式表。 Sass 是采用 Ruby 语言编写的一款 CSS 预处理语言，它诞生于2007年，是最大的成熟的 CSS 预处理语言。最初它是为了配合 HAML（一种缩进式 HTML 预编译器）而设计的，因此有着和 HTML 一样的缩进式风格。 Sass和SCSS的区别Sass 和 SCSS 其实是同一种东西，我们平时都称之为 Sass，两者之间不同之处有以下两点： 文件扩展名不同，Sass 是以.sass后缀为扩展名，而 SCSS 是以.scss后缀为扩展名 语法书写方式不同，Sass 是以严格的缩进式语法规则来书写，不带大括号{}和分号;，而 SCSS 的语法书写和我们的 CSS 语法书写方式非常类似。 例如： Sass： 123456$font-stack: Helvetica, sans-serif //定义变量$primary-color: #333 //定义变量body font: 100% $font-stack color: $primary-color SCSS: 1234567$font-stack: Helvetica, sans-serif;$primary-color: #333;body &#123; font: 100% $font-stack; color: $primary-color;&#125; Sass/SCSS和纯CSS写法的区别Sass 和 CSS 写法的确存在一定的差异，由于 Sass 是基于 Ruby 写出来，所以其延续了 Ruby 的书写规范。在书写 Sass 时不带有大括号和分号，其主要是依靠严格的缩进方式来控制的。 SCSS 和 CSS 写法无差别，这也是 Sass 后来越来越受大众喜欢原因之一。简单点说，把你现有的.css文件直接修改成.scss即可使用。 Sass安装sass基于Ruby语言开发而成，因此安装sass前需要安装Ruby。 mac下自带Ruby无需在安装Ruby。 window下先从官网下载Ruby并安装。安装过程中请注意勾选Add Ruby executables to your PATH添加到系统环境变量。 安装完成后需测试安装有没有成功,运行以下命令，下图表示已经安装成功： 然后安装Sass和Compass，安装需要通过gem源，国内可以更换成淘宝源，更换过程参考Sass官网，要安装最新版本的Sass和Compass，需要输入下面的命令： 12sudo gem install sasssudo gem install compass 安装成功后运行下面命令来确认应用已经正确地安装到了电脑中： 123456789sass -vSass 3.4.23 (Selective Steve)compass -vCompass 1.0.3 (Polaris)Copyright (c) 2008-2017 Chris EppsteinReleased under the MIT License.Compass is charityware.Please make a tax deductable donation for a worthy cause: http://umdf.org/compass 如下sass常用更新、查看版本、sass命令帮助等命令： 1234567891011//更新sassgem update sass//查看sass版本sass -v//查看sass帮助sass -h//删除sassgem uninstall sass Sass编译Sass 的编译有多种方法： 命令编译 GUI工具编译 自动化编译 命令编译单文件编译12345//单文件转换命令sass input.scss output.css//单文件监听命令sass --watch input.scss:output.css 多文件编译12//如果你有很多的sass文件的目录，你也可以告诉sass监听整个目录：sass --watch app/sass:public/stylesheets 命令编译配置选项123456789101112//编译格式,--style表示解析后的css是什么排版格式; sass内置有四种编译格式:nested,expanded,compact,compressedsass --watch input.scss:output.css --style compact//编译添加调试map,--sourcemap表示开启sourcemap调试。开启sourcemap调试后，会生成一个后缀名为.css.map文件。sass --watch input.scss:output.css --sourcemap//选择编译格式并添加调试mapsass --watch input.scss:output.css --style expanded --sourcemap//开启debug信息sass --watch input.scss:output.css --debug-info 四种编译排版格式nested(嵌套)编译排版格式1234567891011121314151617181920//未编译样式.box &#123; width: 300px; height: 400px; &amp;-title &#123; height: 30px; line-height: 30px; &#125;&#125;/*命令行内容*/sass style.scss:style.css --style nested/*编译过后样式*/.box &#123; width: 300px; height: 400px; &#125; .box-title &#123; height: 30px; line-height: 30px; &#125; expanded(展开)编译排版格式12345678910111213141516171819202122//未编译样式.box &#123; width: 300px; height: 400px; &amp;-title &#123; height: 30px; line-height: 30px; &#125;&#125;/*命令行内容*/sass style.scss:style.css --style expanded/*编译过后样式*/.box &#123; width: 300px; height: 400px;&#125;.box-title &#123; height: 30px; line-height: 30px;&#125; compact(紧凑)编译排版格式12345678910111213141516//未编译样式.box &#123; width: 300px; height: 400px; &amp;-title &#123; height: 30px; line-height: 30px; &#125;&#125;/*命令行内容*/sass style.scss:style.css --style compact/*编译过后样式*/.box &#123; width: 300px; height: 400px; &#125;.box-title &#123; height: 30px; line-height: 30px; &#125; compressed(压缩)编译排版格式123456789101112131415//未编译样式.box &#123; width: 300px; height: 400px; &amp;-title &#123; height: 30px; line-height: 30px; &#125;&#125;/*命令行内容*/sass style.scss:style.css --style compressed/*编译过后样式*/.box&#123;width:300px;height:400px&#125;.box-title&#123;height:30px;line-height:30px&#125; GUI工具编译对于 GUI 界面编译工具，目前较为流行的主要有： Koala Compass.app Scout CodeKit Prepros 这里推荐koala&amp;codekit,其中koala是免费编译器，简单操作如下图: 自动化编译通过Grunt和Gulp来配置Sass编译，具体请看[Sass]自动化编译，这里我只写一下在webstorm下的自动化编译。 在webstorm的设置中搜索File Watcher，然后在mac中webstorm自动会添加ruby中的scss文件，其他配置默认，然后点击ok就可以。 项目所在的路径中请不要出现中文，不然sass在编译是会出现编码错误。并且在Sass的编译的过程中，是不是支持GBK编码的。所以在创建 Sass 文件时，就需要将文件编码设置为utf-8。 Sass调试CSS调试首先，先讲一下css的调试，在chrome中打开开发者工具，在sources中右击选择add folder to workspace，选择所要调试的项目文件夹，浏览器弹出提示框，选择允许，这时候就可以看到浏览器sources中有项目的文件夹： 这时候需要把localhost中的项目文件夹和导入的文件夹关联起来： 这时候会弹出一个选择框，选择chrome自动匹配到的文件： 这时候就匹配上了，chrome还会提示你其他文件匹配，选择enable就行： 这时候在导入的项目文件夹中修改css样式，浏览器会立刻生效，按command+s或者ctrl+s后，webstorm中源代码也会修改： Sass调试和css调试一样，直接修改Sass或者SCSS文件，保存后webstorm和浏览器同步更新。 Sass的基本特性使用变量sass使用$符号来标识变量，Sass 的变量包括三个部分： 声明变量的符号“$” 变量名称 赋予变量的值 1$highlight-color: #F90; 任何可以用作css属性值的赋值都 可以用作sass的变量值，甚至是以空格分割的多个属性值或以逗号分割的多个属性值: 12$basic-border: 1px solid black;$plain-font: "Myriad Pro"、Myriad、"Helvetica Neue"、Helvetica、"Liberation Sans"、Arial和sans-serif; sans-serif; 当变量定义在css规则块内，那么该变量只能在此规则块内使用，将局部变量转换为全局变量可以添加 !global 声明： 12345678910111213141516171819202122232425$nav-color: #F90;nav &#123; $width: 100px; width: $width; color: $nav-color;&#125;#main &#123; $width: 5em !global; width: $width;&#125;#sidebar &#123; width: $width;&#125;//编译后nav &#123; width: 100px; color: #F90;&#125;#main &#123; width: 5em; &#125;#sidebar &#123; width: 5em; &#125; 如果值后面加上!default则表示默认值: 1$btn-primary-border : darken($btn-primary-bg, 5%) !default; sass 的默认变量一般是用来设置默认值，然后根据需求来覆盖的，覆盖的方式也很简单，只需要在默认变量之前重新声明下变量即可： 12345678910$baseLineHeight: 2;$baseLineHeight: 1.5 !default;body&#123; line-height: $baseLineHeight; &#125;//编译后body&#123; line-height:2;&#125; 凡是css属性的标准值可存在的地方，变量就可以使用。 在声明变量时，变量值也可以引用其他变量。 12345678910$highlight-color: #F90;$highlight-border: 1px solid $highlight-color;.selected &#123; border: $highlight-border;&#125;//编译后.selected &#123; border: 1px solid #F90;&#125; sass的变量名可以与css中的属性名和选择器名称相同，包括中划线和下划线，并且这两种用法相互兼容： 123456789$link-color: blue;a &#123; color: $link_color;&#125;//编译后a &#123; color: blue;&#125; 嵌套Sass 的嵌套分为三种： 选择器嵌套 属性嵌套 伪类嵌套 选择器嵌套Sass 允许将一套 CSS 样式嵌套进另一套样式中，内层的样式将它外层的选择器作为父选择器，例如： 12345678910111213141516#main p &#123; color: #00ff00; width: 97%; .redbox &#123; background-color: #ff0000; color: #000000; &#125;&#125;//编译后#main p &#123; color: #00ff00; width: 97%; &#125; #main p .redbox &#123; background-color: #ff0000; color: #000000; &#125; 属性嵌套有些 CSS 属性遵循相同的命名空间 (namespace)，比如 font-family, font-size, font-weight 都以 font 作为属性的命名空间。为了便于管理这样的属性，同时也为了避免了重复输入，Sass 允许将属性嵌套在命名空间中，例如： 12345678910111213.funky &#123; font: &#123; family: fantasy; size: 30em; weight: bold; &#125;&#125;//编译后.funky &#123; font-family: fantasy; font-size: 30em; font-weight: bold; &#125; 命名空间也可以包含自己的属性值，例如： 123456789101112.funky &#123; font: 20px/24px &#123; family: fantasy; weight: bold; &#125;&#125;//编译后.funky &#123; font: 20px/24px; font-family: fantasy; font-weight: bold; &#125; 伪类嵌套其实伪类嵌套和属性嵌套非常类似，只不过他需要借助&amp;符号一起配合使用。例如： 12345678910111213141516171819.clearfix&#123;&amp;:before,&amp;:after &#123; content:""; display: table; &#125;&amp;:after &#123; clear:both; overflow: hidden; &#125;&#125;//编译后.clearfix:before, .clearfix:after &#123; content: ""; display: table; &#125;.clearfix:after &#123; clear: both; overflow: hidden; &#125; 父级选择器&amp;&amp; 代表嵌套规则外层的父选择器，编译后的 CSS 文件中 &amp; 将被替换成嵌套外层的父选择器，如果含有多层嵌套，最外层的父选择器会一层一层向下传递： 123456789101112131415#main &#123; color: black; a &#123; font-weight: bold; &amp;:hover &#123; color: red; &#125; &#125;&#125;//编译后#main &#123; color: black; &#125; #main a &#123; font-weight: bold; &#125; #main a:hover &#123; color: red; &#125; &amp; 必须作为选择器的第一个字符，其后可以跟随后缀生成复合的选择器，例如: 12345678910#main &#123; color: black; &amp;-sidebar &#123; border: 1px solid; &#125;&#125;//编译后#main &#123; color: black; &#125; #main-sidebar &#123; border: 1px solid; &#125; 当父选择器含有不合适的后缀时，Sass 将会报错。 避免选择器嵌套：- 选择器嵌套最大的问题是将使最终的代码难以阅读。开发者需要花费巨大精力计算不同缩进级别下的选择器具体的表现效果。- 选择器越具体则声明语句越冗长，而且对最近选择器的引用(&amp;)也越频繁。在某些时候，出现混淆选择器路径和探索下一级选择器的错误率很高，这非常不值得。 混合指令混合指令（Mixin）用于定义可重复使用的样式，避免了使用无语意的 class。混合指令可以包含所有的 CSS 规则，绝大部分 Sass 规则，甚至通过参数功能引入变量，输出多样化的样式。 定义混合指令混合指令的用法是在 @mixin 后添加名称与样式，比如名为 large-text 的混合通过下面的代码定义： 12345678@mixin large-text &#123; font: &#123; family: Arial; size: 20px; weight: bold; &#125; color: #ff0000;&#125; 可以在定义混合指令时带有参数，如： 1234@mixin border-radius($radius:5px)&#123; -webkit-border-radius: $radius; border-radius: $radius;&#125; 混合也需要包含选择器和属性，甚至可以用 &amp; 引用父选择器： 1234567891011@mixin clearfix &#123; display: inline-block; &amp;:after &#123; content: "."; display: block; height: 0; clear: both; visibility: hidden; &#125; * html &amp; &#123; height: 1px &#125;&#125; 当然， Sass 中的混合宏还提供更为复杂的，你可以在大括号里面写上带有逻辑关系，帮助更好的做你想做的事情,如： 12345678@mixin box-shadow($shadow...) &#123; @if length($shadow) &gt;= 1 &#123; @include prefixer(box-shadow, $shadow); &#125; @else&#123; $shadow:0 0 4px rgba(0,0,0,.3); @include prefixer(box-shadow, $shadow); &#125;&#125; 引用混合样式使用 @include 指令引用混合样式，格式是在其后添加混合名称，以及需要的参数（可选）： 1234567891011121314151617181920212223@mixin large-text &#123; font: &#123; family: Arial; size: 20px; weight: bold; &#125; color: #ff0000;&#125;.page-title &#123; @include large-text; padding: 4px; margin-top: 10px;&#125;//编译后.page-title &#123; font-family: Arial; font-size: 20px; font-weight: bold; color: #ff0000; padding: 4px; margin-top: 10px; &#125; 也可以在最外层引用混合样式，不会直接定义属性，也不可以使用父选择器: 123456789101112@mixin silly-links &#123; a &#123; color: blue; background-color: red; &#125;&#125;@include silly-links;//编译后a &#123; color: blue; background-color: red; &#125; 混合样式中也可以包含其他混合样式，比如: 123456@mixin compound &#123; @include highlighted-background; @include header-text;&#125;@mixin highlighted-background &#123; background-color: #fc0; &#125;@mixin header-text &#123; font-size: 20px; &#125; 混合样式中应该只定义后代选择器，这样可以安全的导入到文件的任何位置。 参数参数用于给混合指令中的样式设定变量，并且赋值使用。在定义混合指令的时候，按照变量的格式，通过逗号分隔，将参数写进圆括号里。引用指令时，按照参数的顺序，再将所赋的值对应写进括号： 1234567891011121314@mixin sexy-border($color, $width) &#123; border: &#123; color: $color; width: $width; style: dashed; &#125;&#125;p &#123; @include sexy-border(blue, 1in); &#125;//编译后p &#123; border-color: blue; border-width: 1in; border-style: dashed; &#125; 混合指令也可以使用给变量赋值的方法给参数设定默认值，然后，当这个指令被引用的时候，如果没有给参数赋值，则自动使用默认值： 1234567891011121314151617181920@mixin sexy-border($color, $width: 1in) &#123; border: &#123; color: $color; width: $width; style: dashed; &#125;&#125;p &#123; @include sexy-border(blue); &#125;h1 &#123; @include sexy-border(blue, 2in); &#125;//编译后p &#123; border-color: blue; border-width: 1in; border-style: dashed; &#125;h1 &#123; border-color: blue; border-width: 2in; border-style: dashed; &#125; 混合指令也可以使用关键词参数，关键词参数可以打乱顺序使用，如果使用默认值也可以省缺，另外，参数名被视为变量名，下划线、短横线可以互换使用，上面的例子也可以写成： 123456789101112131415161718192021@mixin sexy-border($color, $width: 1in) &#123; border: &#123; color: $color; width: $width; style: dashed; &#125;&#125;p &#123; @include sexy-border($color: blue); &#125;h1 &#123; @include sexy-border($color: blue, $width: 2in); &#125;//编译后p &#123; border-color: blue; border-width: 1in; border-style: dashed; &#125;h1 &#123; border-color: blue; border-width: 2in; border-style: dashed; &#125; 有时，不能确定混合指令需要使用多少个参数，比如一个关于 box-shadow 的混合指令不能确定有多少个 ‘shadow’ 会被用到。这时，可以使用参数变量 … 声明（写在参数的最后方）告诉 Sass 将这些参数视为值列表处理： 1234567891011121314@mixin box-shadow($shadows...) &#123; -moz-box-shadow: $shadows; -webkit-box-shadow: $shadows; box-shadow: $shadows;&#125;.shadows &#123; @include box-shadow(0px 4px 5px #666, 2px 6px 10px #999);&#125;//编译后.shadows &#123; -moz-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999; -webkit-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999; box-shadow: 0px 4px 5px #666, 2px 6px 10px #999; &#125; 参数变量也可以用在引用混合指令的时候 (@include)，将一串值列表中的值逐条作为参数引用： 123456789101112131415@mixin colors($text, $background, $border) &#123; color: $text; background-color: $background; border-color: $border;&#125;$values: #ff0000, #00ff00, #0000ff;.primary &#123; @include colors($values...);&#125;//编译后.primary &#123; color: #ff0000; background-color: #00ff00; border-color: #0000ff; &#125; 扩展/继承在 Sass 中是通过关键词 “@extend”来继承已存在的类样式块，从而实现代码的继承。如下所示： 1234567891011121314151617181920212223242526272829303132.btn &#123; border: 1px solid #ccc; padding: 6px 10px; font-size: 14px;&#125;.btn-primary &#123; background-color: #f36; color: #fff; @extend .btn;&#125;.btn-second &#123; background-color: orange; color: #fff; @extend .btn;&#125;//编译后//编译出来的 CSS 会将选择器合并在一起，形成组合选择器.btn, .btn-primary, .btn-second &#123; border: 1px solid #ccc; padding: 6px 10px; font-size: 14px; &#125;.btn-primary &#123; background-color: #f36; color: #fff; &#125;.btn-second &#123; background-color: orange; color: #fff; &#125; Class 选择器并不是唯一可以被继承的，Sass 允许延伸任何定义给单个元素的选择器，比如 .special.cool，a:hover 或者 a.user[href^=&quot;http://&quot;] 等，例如： 12345678910.hoverlink &#123; @extend a:hover;&#125;a:hover &#123; text-decoration: underline;&#125;//编译后a:hover, .hoverlink &#123; text-decoration: underline; &#125; 所有 a:hover 的样式将继承给 .hoverlink，包括其他使用到 a:hover的样式，例如： 1234567891011.hoverlink &#123; @extend a:hover;&#125;.comment a.user:hover &#123; font-weight: bold;&#125;//编译后//.comment a.user:hover的样式也继承给了.hoverlink.comment a.user:hover, .comment .user.hoverlink &#123; font-weight: bold; &#125; 同一个选择器可以继承给多个选择器，它所包含的属性将继承给所有被继承的选择器，且后定义的样式享有优先权。多重继承可以使用逗号分隔选择器名，比如 @extend .error, .attention; 与 @extend .error; `@extend.attention` 有相同的效果。 当一个选择器继承给第二个后，可以继续将第二个选择器继承给第三个，第三个选择器既包含第二个选择器的样式，又包含第一个选择器样式。 暂时不可以将选择器列 (Selector Sequences)，比如 .foo .bar 或 .foo + .bar，延伸给其他元素。 当两个列 (sequence) 合并时，如果没有包含相同的选择器，将生成两个新选择器，第一列出现在第二列之前，或者第二列出现在第一列之前： 123456789101112#admin .tabbar a &#123; font-weight: bold;&#125;#demo .overview .fakelink &#123; @extend a;&#125;//编译后#admin .tabbar a,#admin .tabbar #demo .overview .fakelink, //第一列在第二列之前#demo .overview #admin .tabbar .fakelink &#123; //第二列在第一列之前 font-weight: bold; &#125; 如果两个列 (sequence) 包含了相同的选择器，相同部分将会合并在一起，其他部分交替输出： 123456789101112#admin .tabbar a &#123; font-weight: bold;&#125;#admin .overview .fakelink &#123; @extend a;&#125;//编译后#admin .tabbar a, //相同部分#admin .tabbar .overview .fakelink, #admin .overview .tabbar .fakelink &#123; font-weight: bold; &#125; 在指令中使用 @extend 时（比如在 @media 中）有一些限制：Sass 不可以将 @media 层外的 CSS 规则延伸给指令层内的 CSS，如果在 @media （或者其他 CSS 指令）中使用 @extend，必须延伸给相同指令层中的选择器（@media中的继承，只能在其内部使用）。 占位符与常用的 id 与 class 选择器写法相似，只是 # 或 . 替换成了 %。必须通过@extend指令调用，当占位符选择器单独使用时（未通过 @extend 调用），不会编译到 CSS 文件中： 123456789101112131415%mt5 &#123; margin-top: 5px;&#125;%pt5&#123; padding-top: 5px;&#125;.btn &#123; @extend %mt5;&#125;//编译后.btn &#123; margin-top: 5px; &#125; 通过 @extend 调用的占位符，编译出来的代码会将相同的代码合并在一起。 何时使用混合指令、继承、占位符混合指令用混合指令编译出来的 CSS 不会自动合并相同的样式代码，如果在样式文件中调用同一个混合指令，会产生多个对应的样式代码，造成代码的冗余。 混合指令可以用来传参数，如果你的代码块中涉及到变量，建议使用混合指令来创建相同的代码块。 继承通过继承编译出来的 CSS 会将使用继承的代码块合并到一起，通过组合选择器的方式向大家展现，相对于混合指令来说要干净的多。但是他不能传变量参数。 如果你的代码块不需要传任何变量参数，而且有一个基类已在文件中存在，那么建议使用 Sass 的继承。 占位符占位符和继承编译出来的CSS代码基本相同。占位符是独立定义，不调用的时候是不会在 CSS 中产生任何代码；继承是首先有一个基类存在，不管调用与不调用，基类的样式都将会出现在编译出来的 CSS 代码中。 插值通过 #{} 插值语句可以在选择器或属性名中使用变量： 123456789$name: foo;$attr: border;p.#&#123;$name&#125; &#123; #&#123;$attr&#125;-color: blue;&#125;//编译后p.foo &#123; border-color: blue; &#125; #{} 插值语句也可以在属性值中插入 SassScript，大多数情况下，这样可能还不如使用变量方便，但是使用 #{} 可以避免 Sass 运行运算表达式，直接编译 CSS。 123456789p &#123; $font-size: 12px; $line-height: 30px; font: #&#123;$font-size&#125;/#&#123;$line-height&#125;;&#125;//编译后p &#123; font: 12px/30px; &#125; 使用插值语句可以构建一个选择器： 12345678910111213141516@mixin generate-sizes($class, $small, $medium, $big) &#123; .#&#123;$class&#125;-small &#123; font-size: $small; &#125; .#&#123;$class&#125;-medium &#123; font-size: $medium; &#125; .#&#123;$class&#125;-big &#123; font-size: $big; &#125;&#125;@include generate-sizes("header-text", 12px, 20px, 40px);//编译后.header-text-small &#123; font-size: 12px; &#125;.header-text-medium &#123; font-size: 20px; &#125;.header-text-big &#123; font-size: 40px; &#125; 但是不能在mixin中作为参数调用： 123456789@mixin updated-status &#123; margin-top: 20px; background: #F00;&#125;$flag: "status";.navigation &#123; @include updated-#&#123;$flag&#125;;&#125;//以上代码会报错 可以在@extend中使用插值。例如： 1234567891011121314151617181920%updated-status &#123; margin-top: 20px; background: #F00;&#125;.selected-status &#123; font-weight: bold;&#125;$flag: "status";.navigation &#123; @extend %updated-#&#123;$flag&#125;; @extend .selected-#&#123;$flag&#125;;&#125;//编译后.navigation &#123; margin-top: 20px; background: #F00; &#125;.selected-status, .navigation &#123; font-weight: bold; &#125; 注释Sass 支持标准的 CSS 多行注释 /* */，以及单行注释 //，前者会 被完整输出到编译后的 CSS 文件中，而后者则不会，例如： 123456789101112131415161718192021/* This comment is * several lines long. * since it uses the CSS comment syntax, * it will appear in the CSS output. */body &#123; color: black; &#125;// These comments are only one line long each.// They won't appear in the CSS output,// since they use the single-line comment syntax.a &#123; color: green; &#125;//编译后/* This comment is * several lines long. * since it uses the CSS comment syntax, * it will appear in the CSS output. */body &#123; color: black; &#125;a &#123; color: green; &#125; 将 ! 作为多行注释的第一个字符表示在压缩输出模式下保留这条注释并输出到 CSS 文件中，通常用于添加版权信息。 插值语句也可写进多行注释中输出变量值： 12345$version: "1.2.3";/* This CSS is generated by My Snazzy Framework version #&#123;$version&#125;. *///编译后/* This CSS is generated by My Snazzy Framework version 1.2.3. */ 数据类型SassScript 支持 6 种主要的数据类型： 数字，1, 2, 13, 10px 字符串，有引号字符串与无引号字符串，&quot;foo&quot;, &#39;bar&#39;, baz 颜色，blue, #04a3f9, rgba(255,0,0,0.5) 布尔型，true, false 空值，null 数组 (list)，用空格或逗号作分隔符，1.5em 1em 0 2em, Helvetica, Arial, sans-serif maps, 相当于 JavaScript 的 object，(key1: value1, key2: value2) SassScript 也支持其他 CSS 属性值，比如 Unicode 范围，或 !important 声明。然而，Sass 不会特殊对待这些属性值，一律视为无引号字符串 。 字符串SassScript 支持 CSS 的两种字符串类型： 有引号字符串 (quoted strings)，如 “Lucida Grande” 、’http://sass-lang.com&#39;； 无引号字符串 (unquoted strings)，如 sans-serifbold，在编译 CSS 文件时不会改变其类型。只有一种情况例外，使用 #{} (interpolation) 时，有引号字符串将被编译为无引号字符串，这样便于在 mixin 中引用选择器名： 1234567891011@mixin firefox-message($selector) &#123; body.firefox #&#123;$selector&#125;:before &#123; content: "Hi"; &#125;&#125;@include firefox-message(".header");//编译后body.firefox .header:before &#123; content: "Hi"; &#125; 数组数组 (lists) 指 Sass 如何处理 CSS 中 margin: 10px 15px 0 0 或者 font-face: Helvetica, Arial, sans-serif 这样通过空格或者逗号分隔的一系列的值。事实上，独立的值也被视为数组。 Sass数组函数（Sass list functions）赋予了数组更多功能： nth函数可以直接访问数组中的某一项； join函数可以将多个数组连结在一起； append函数可以在数组中添加值； @each指令能够遍历数组中的每一项。 数组中可以包含子数组，可以用两种方式书写 使用逗号分割子数组，比如1px 2px, 5px 6px 使用空格分割子数组，比如(1px 2px) (5px 6px) 当数组被编译为 CSS 时，Sass 不会添加任何圆括号（CSS 中没有这种写法），所以 (1px 2px) (5px 6px) 与 1px 2px, 5px 6px 在编译后的 CSS 文件中是完全一样的，但是它们在 Sass 文件中却有不同的意义，前者是包含两个数组的数组，而后者是包含四个值的数组。 用 () 表示不包含任何值的空数组（在 Sass 3.3 版之后也视为空的 map）。空数组不可以直接编译成 CSS，比如编译 font-family: () Sass 将会报错。如果数组中包含空数组或空值，编译时将被清除，比如 1px 2px () 3px 或 1px 2px null 3px。 基于逗号分隔的数组允许保留结尾的逗号，这样做的意义是强调数组的结构关系，尤其是需要声明只包含单个值的数组时。例如 (1,) 表示只包含 1 的数组，而 (1 2 3,) 表示包含 1 2 3 这个以空格分隔的数组的数组。 MapsMap表示key和value之间的关联，其中key用于查找value。Map可以轻松地将value收集到命名组中，并动态访问这些组。语法类似于媒体查询表达式：$ map：（key1：value1，key2：value2，key3：value3）; 与数组不同，Map必须始终用括号括起来，并且必须始终以逗号分隔。 Map中的key和value都可以是任何SassScript对象。Map可能只有一个与给定key相关联的value（尽管该值可能是一个数组）。但是，给定的值可能与许多键相关联。 像数组一样，Map大都使用SassScript函数进行操作。map-get函数在地图中查找值，map-merge函数将值添加到地图。@each指令可用于为Map中的每个键/值对添加样式。 （key1：value1，key2：value2）将被视为嵌套key1 value1，key2 value2的数组。除了空数组之外，数组不能被视为Map。 请注意，Map的key可以是任何Sass数据类型（甚至另一个Map），声明Map的语法同时也允许任意正确的SassScript表达式作为key。 Map无法转换为纯CSS。使用一个作为CSS函数的变量或参数的值将导致错误。 使用inspect（$ value）函数来生成一个对调试Map有用的输出字符串。 颜色任何CSS颜色表达式返回SassScript颜色值，SassScript颜色值包括大量命名的颜色，与无引号的字符串不可区分。 在压缩输出模式下，Sass将输出颜色的颜色的16进制形式。 例如，＃FF0000将以压缩模式输出为红色，但blanchedalmond将输出为#FFEBCD。 用户常遇到的命名颜色问题是，当压缩时插入到选择器中的颜色将变为无效语法。 为了避免这种情况，如果它们是用于构建选择器的话，总是引用命名的颜色。 Sass运算所有数据类型均支持相等运算 == 或 !=。 关系运算 &lt;, &gt;, &lt;=, &gt;= 也可用于数字运算。 SassScript 支持数字的加减乘除、取整等运算 (+, -, *, /, %)，如果必要会在相同类型的不同单位间转换值。 运算时碰到不同类型的单位时，编译也会报错，如：em和px。 运算符两边有空格。 加法1234567.box &#123; width: 20px + 8in;&#125;//编译后.box &#123; width: 788px; &#125; 减法12345678910$full-width: 960px;$sidebar-width: 200px;.content &#123; width: $full-width - $sidebar-width;&#125;//编译后.content &#123; width: 760px; &#125; 乘法乘法中一个单位同时只能声明一个值。 1234567.box &#123; width: 10px * 2; //等于10px * 2px&#125;//编译后.box &#123; width: 20px; &#125; 除法/ 在 CSS 中通常起到分隔数字的用途，SassScript 作为 CSS 语言的拓展当然也支持这个功能，同时也赋予了 / 除法运算的功能。也就是说，如果 / 在 SassScript 中把两个数字分隔，编译后的 CSS 文件中也是同样的作用。 以下三种情况 / 将被视为除法运算符号： 如果值，或值的一部分，是变量或者函数的返回值 如果值被圆括号包裹 如果值是算数表达式的一部分 12345678910111213141516p &#123; font: 10px/8px; // “/”起分隔作用 $width: 1000px; width: $width/2; // “/”起除法运算 width: round(1.5)/2; // “/”起除法运算 height: (500px/2); // “/”起除法运算 margin-left: 5px + 8px/2px; // “/”起除法运算&#125;//编译后p &#123; font: 10px/8px; width: 500px; width: 1; height: 250px; margin-left: 9px; &#125; 如果需要使用变量，同时又要确保 / 不做除法运算而是完整地编译到 CSS 文件中，只需要用 #{} 插值语句将变量包裹。 123456789p &#123; $font-size: 12px; $line-height: 30px; font: #&#123;$font-size&#125;/#&#123;$line-height&#125;;&#125;//编译后p &#123; font: 12px/30px; &#125; 在除法运算时，如果两个值带有相同的单位值时，除法运算之后会得到一个不带单位的数值： 1234567.box &#123; width: (1000px / 100px);&#125;//编译后.box &#123; width: 10; &#125; 颜色运算颜色值的运算是分段计算进行的，也就是分别计算红色，绿色，以及蓝色的值： 1234567p &#123; color: #010203 + #040506;&#125;//编译后p &#123; color: #050709; &#125;//计算过程：01 + 04 = 05 02 + 05 = 07 03 + 06 = 09 数字与颜色值之间也可以进行算数运算，同样也是分段计算的，比如： 1234567p &#123; color: #010203 * 2;&#125;//编译后p &#123; color: #020406; &#125;//计算过程： 01 * 2 = 02 02 * 2 = 04 03 * 2 = 06 需要注意的是，如果颜色值包含 alpha channel（rgba 或 hsla 两种颜色值），必须拥有相等的 alpha 值才能进行运算，因为算术运算不会作用于 alpha 值。 1234567p &#123; color: rgba(255, 0, 0, 0.75) + rgba(0, 255, 0, 0.75);&#125;//编译后p &#123; color: rgba(255, 255, 0, 0.75); &#125; 颜色值的 alpha channel 可以通过 opacify 或 transparentize 两个函数进行调整。 12345678910$translucent-red: rgba(255, 0, 0, 0.5);p &#123; color: opacify($translucent-red, 0.3); //透明度相加 background-color: transparentize($translucent-red, 0.25);//透明度替换&#125;//编译后p &#123; color: rgba(255, 0, 0, 0.8); background-color: rgba(255, 0, 0, 0.25); &#125; IE 滤镜要求所有的颜色值包含 alpha 层，而且格式必须固定 #AABBCCDD，使用 ie_hex_str 函数可以很容易地将颜色转化为 IE 滤镜要求的格式。 12345678910$translucent-red: rgba(255, 0, 0, 0.5);$green: #00ff00;div &#123; filter: progid:DXImageTransform.Microsoft.gradient(enabled='false', startColorstr='#&#123;ie-hex-str($green)&#125;', endColorstr='#&#123;ie-hex-str($translucent-red)&#125;');&#125;//编译后div &#123; filter: progid:DXImageTransform.Microsoft.gradient(enabled='false', startColorstr=#FF00FF00, endColorstr=#80FF0000);&#125; 字符串运算+ 可用于连接字符串: 1234567p &#123; cursor: e + -resize;&#125;//编译后p &#123; cursor: e-resize; &#125; 如果有引号字符串（位于 + 左侧）连接无引号字符串，运算结果是有引号的，相反，无引号字符串（位于 +左侧）连接有引号字符串，运算结果则没有引号。 运算表达式与其他值连用时，用空格做连接符： 1234567p &#123; margin: 3px + 4px auto;&#125;//编译后p &#123; margin: 7px auto; &#125; 在有引号的文本字符串中使用 #{} 插值语句可以添加动态的值： 1234567p:before &#123; content: "I ate #&#123;5 + 10&#125; pies!";&#125;//编译后p:before &#123; content: "I ate 15 pies!"; &#125; 空的值被视作插入了空字符串： 12345678$value: null;p:before &#123; content: "I ate #&#123;$value&#125; pies!";&#125;//编译后p:before &#123; content: "I ate pies!"; &#125; 布尔运算SassScript 支持布尔型的 and or 以及 not 运算。 数组运算数组不支持任何运算方式，只能使用 list functions 控制。 Sass控制指令@if当 @if 的表达式返回值不是 false 或者 null 时，条件成立，输出 {} 内的代码： 123456789p &#123; @if 1 + 1 == 2 &#123; border: 1px solid; &#125; @if 5 &lt; 3 &#123; border: 2px dotted; &#125; @if null &#123; border: 3px double; &#125;&#125;//编译后p &#123; border: 1px solid; &#125; @if 声明后面可以跟多个 @else if 声明，或者一个 @else 声明。如果 @if 声明失败，Sass 将逐条执行 @else if 声明，如果全部失败，最后执行 @else 声明，例如： 123456789101112$type: monster;p &#123; @if $type == ocean &#123; color: blue; &#125; @else if $type == matador &#123; color: red; &#125; @else if $type == monster &#123; color: green; &#125; @else &#123; color: black; &#125;&#125; @for@for 指令可以在限制的范围内重复输出格式，每次按要求（变量的值）对输出结果做出变动。 这个指令包含两种格式：@for $var from &lt;start&gt; through &lt;end&gt;，或者 @for $var from &lt;start&gt; to &lt;end&gt;，区别在于 through 与 to 的含义：当使用through时，条件范围包含&lt;start&gt;与 &lt;end&gt;的值，而使用to时条件范围只包含&lt;start&gt;的值不包含&lt;end&gt;的值。另外，$var 可以是任何变量，比如 $i；&lt;start&gt; 和 &lt;end&gt; 必须是整数值。 1234567891011@for $i from 1 through 3 &#123; .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125;&#125;//编译后.item-1 &#123; width: 2em; &#125;.item-2 &#123; width: 4em; &#125;.item-3 &#123; width: 6em; &#125; @each@each 指令的格式是 $var in &lt;list&gt;，$var 可以是任何变量名，比如 $length 或者 $name，而 &lt;list&gt; 是一连串的值，也就是值列表。 @each 将变量 $var 作用于值列表中的每一个项目，然后输出结果，例如： 12345678910111213141516171819202122232425$list: adam john wynn mason kuroir;//$list 就是一个列表@mixin author-images &#123; @each $author in $list &#123; .photo-#&#123;$author&#125; &#123; background: url("/images/avatars/#&#123;$author&#125;.png") no-repeat; &#125; &#125;&#125;.author-bio &#123; @include author-images;&#125;//编译后.author-bio .photo-adam &#123; background: url("/images/avatars/adam.png") no-repeat; &#125;.author-bio .photo-john &#123; background: url("/images/avatars/john.png") no-repeat; &#125;.author-bio .photo-wynn &#123; background: url("/images/avatars/wynn.png") no-repeat; &#125;.author-bio .photo-mason &#123; background: url("/images/avatars/mason.png") no-repeat; &#125;.author-bio .photo-kuroir &#123; background: url("/images/avatars/kuroir.png") no-repeat; &#125; @each指令中也可以使用多个变量： 12345678910111213141516171819202122232425@each $animal, $color, $cursor in (puma, black, default), (sea-slug, blue, pointer), (egret, white, move) &#123; .#&#123;$animal&#125;-icon &#123; background-image: url('/images/#&#123;$animal&#125;.png'); border: 2px solid $color; cursor: $cursor; &#125;&#125;//编译后.puma-icon &#123; background-image: url("/images/puma.png"); border: 2px solid black; cursor: default; &#125;.sea-slug-icon &#123; background-image: url("/images/sea-slug.png"); border: 2px solid blue; cursor: pointer; &#125;.egret-icon &#123; background-image: url("/images/egret.png"); border: 2px solid white; cursor: move; &#125; 因为maps可以看做是有键值对的数组，所以用@each遍历多个变量也能用： 12345678910111213@each $header, $size in (h1: 2em, h2: 1.5em, h3: 1.2em) &#123; #&#123;$header&#125; &#123; font-size: $size; &#125;&#125;//编译后h1 &#123; font-size: 2em; &#125;h2 &#123; font-size: 1.5em; &#125;h3 &#123; font-size: 1.2em; &#125; @while@while 指令重复输出格式直到表达式返回结果为 false。这样可以实现比 @for 更复杂的循环，只是很少会用到。例如： 12345678910111213$i: 6;@while $i &gt; 0 &#123; .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125; $i: $i - 2;&#125;//编译后.item-6 &#123; width: 12em; &#125;.item-4 &#123; width: 8em; &#125;.item-2 &#123; width: 4em; &#125; Sass的函数字符串函数unquote(\$string)和quote(\$string) unquote(\$string)：删除字符串中的引号 quote(\$string)：给字符串添加引号，如果字符串自身带有引号会统一换成双引号 123456789101112131415161718192021222324.test1 &#123; content: unquote('Hello Sass!') ;&#125;.test2 &#123; content: unquote("'Hello Sass!");&#125;.test3 &#123; content: quote('Hello Sass!');&#125;.test4 &#123; content: quote(ImWebDesigner);&#125;//编译后.test1 &#123; content: Hello Sass!; &#125;.test2 &#123; content: 'Hello Sass!; &#125;.test3 &#123; content: "Hello Sass!"; &#125;.test4 &#123; content: "ImWebDesigner"; &#125; To-upper-case()和To-lower-case() To-upper-case()：将字符串转换成大写字母 To-lower-case()：将字符串转换成小写字母 123456789.test &#123; text: to-upper-case(aaaaa); text: to-lower-case(AA);&#125;//编译后.test &#123; text: AAAAA; text: aa; &#125; 数字函数percentage()percentage()函数主要是将一个不带单位的数字转换成百分比形式： 1234567.footer&#123; width : percentage(.2)&#125;//编译后.footer &#123; width: 20%; &#125; round()round() 函数可以将一个数四舍五入为一个最接近的整数: 1234567.footer &#123; width:round(12.3px)&#125;//编译后.footer &#123; width: 12px; &#125; ceil()和floor() ceil() 函数将一个数转换成最接近于自己的整数，会将一个大于自身的任何小数转换成大于本身 1 的整数。也就是只做入，不做舍的计算 floor() 函数刚好与 ceil() 函数功能相反，其主要将一个数去除其小数部分，并且不做任何的进位。也就是只做舍，不做入的计算 12345678910111213.footer &#123; width:ceil(12.3px);&#125;.footer1 &#123; width:floor(12.3px);&#125;//编译后.footer &#123; width: 13px; &#125;.footer1 &#123; width: 12px; &#125; abs()abs( ) 函数会返回一个数的绝对值 1234567.footer &#123; width:abs(-12.3px);&#125;//编译后.footer &#123; width: 12.3px; &#125; min()和max() min() 函数功能主要是在多个数之中找到最小的一个，这个函数可以设置任意多个参数，不过参数类型不同会报错 max() 函数和 min() 函数一样，不同的是，max() 函数用来获取一系列数中的最大那个值 12345678910111213.footer &#123; width: max(13px,5px); &#125;.footer1 &#123; width: min(13px,5px); &#125;//编译后.footer &#123; width: 13px; &#125;.footer1 &#123; width: 5px; &#125; random()random() 函数是用来获取一个随机数： 1234567.footer &#123;3 width: random(); &#125;//编译后.footer &#123; width: 0.18589; &#125; 数组函数length()length() 函数主要用来返回一个数组中有几个值： 1234567.footer &#123; width: length(10px 20px (border 1px solid) 2em);&#125;//编译后.footer &#123; width: 4; &#125; length() 函数中的列表参数之间使用空格隔开，不能使用逗号，否则函数将会出错。 nth()nth() 函数用来指定列表中某个位置的值，语法为nth($list,$n)，$n 必须是大于 0 的整数： 1234567.footer &#123; width: nth(10px 20px 30px,1);&#125;//编译后.footer &#123; width: 10px; &#125; join()join() 函数是将两个列表（只能是两个列表）连接合并成一个列表，碰到两个以上列表合并时，需要用多个join() 函数合并： 1234567.footer &#123; color: join((blue red), join((#abc #def),(#dee #eff)));&#125;//编译后.footer &#123; color: blue red #abc #def #dee #eff; 在join()函数中还有一个很特别的参数$separator，这个参数主要是用来给数组函数连接数组值，默认值为auto。 join()函数中$separator除了默认值auto之外，还有comma和space两个值，其中 comma值指定数组中的数组值之间使用逗号分隔，space值指定列表中的数组项值之间使用空格分隔。 在join()函数中除非明确指定了$separator值，否则将会有多种情形发生，建议大家使用join()函数合并列表项的时候就明确指定$separator参数： 1234567891011.footer &#123; color: join(blue,red,comma) (#0000ff, #ff0000);&#125;.footer1 &#123; color: join(blue,red,space) (#0000ff #ff0000);&#125;//编译后.footer &#123; color: blue, red #0000ff, #ff0000; &#125;.footer1 &#123; color: blue red #0000ff #ff0000; &#125; append()append()函数是用来将某个值插入到数组中，并且处于最末位。 append()函数中也有\$separator参数。 123456789101112.footer &#123; color: append((blue green),red,comma) (#0000ff, #008000, #ff0000);&#125;.footer1 &#123; color: append((blue green),red,space) (#0000ff #008000 #ff0000);&#125;//编译后.footer &#123; color: blue, green, red #0000ff, #008000, #ff0000; &#125;.footer1 &#123; color: blue green red #0000ff #008000 #ff0000; &#125; zip()zip()函数将多个数组值转成一个多维的数组，在使用zip()函数时，每个单一的数组个数值必须是相同的。 1234567.footer &#123; border: zip(1px 2px 3px,solid dashed dotted,green blue red);&#125;//编译后.footer &#123; border: 1px solid green, 2px dashed blue, 3px dotted red &#125; index()index() 函数类似于索引一样，主要让你找到某个值在列表中所处的位置。在 Sass 中，第一个值就是1，第二个值就是 2，依此类推，如果指定的值不在列表中（没有找到相应的值），那么返回的值将是 false。 Introspection函数Introspection 函数包括了几个判断型函数： type-of(\$value)：返回一个值的类型，number 为数值型、string 为字符串型、bool 为布尔型、color 为颜色型。 unit(\$number)：返回一个值的单位 unitless(\$number)：判断一个值是否带有单位，不带单位返回的值为 true，带单位返回的值为 false comparable(\$number-1, \$number-2)：判断两个值是否可以做加、减和合并，如果可以返回的值为 true，如果不可以返回的值是 false Miscellaneous函数Miscellaneous函数和 JavaScript 中的三元判断非常的相似：if($condition,$if-true,$if-false)。他有两个值，当条件成立返回一种值，当条件不成立时返回另一种值： 12345678910@mixin containue($bool)&#123; p&#123; width:if($bool,8em,20em); &#125;&#125;@include containue(false);//编译后p &#123; width: 20em; &#125; Map Sass 的 map 长得与 JSON 极其相似： 12345$map: ( $key1: value1, $key2: value2, $key3: value3) 首先有一个类似于 Sass 的变量一样，用个 $ 加上命名空间来声明 map。后面紧接是一个小括号 ()，将数据以 key:value 的形式赋予，其中 key 和 value 是成对出现，并且每对之间使用逗号分隔，其中最后一组后面没有逗号。 对于 Sass 的 map，还可以让 map 嵌套 map。其实就是 map 的某一个 key 当成 map，里面可以继续放一对或者多对 key:value： 12345678$map: ( key1: value1, key2: ( key-1: value-1, key-2: value-2, ), key3: value3); map 的嵌套实用性也非常的强，大家可能有碰到过换皮肤的项目，可能每一套皮肤对应的颜色蛮多的，那么使用此功能来管理颜色的变量就非常的有条理性，便于维护与管理。你可以这样使用： 1234567891011121314151617$theme-color: ( default: ( bgcolor: #fff, text-color: #444, link-color: #39f ), primary:( bgcolor: #000, text-color:#fff, link-color: #93f ), negative: ( bgcolor: #f36, text-color: #fefefe, link-color: #d4e )); map-get(\$map,\$key)map-get(\$map,\$key) 函数的作用是根据 \$key 参数，返回 \$key 在 \$map 中对应的 value 值。如果 \$key 不存在 $map中，将返回 null 值。此函数包括两个参数： $map：定义好的 map。 $key：需要遍历的 key。 1234567891011121314$social-colors: ( dribble: #ea4c89, facebook: #3b5998, github: #171515, google: #db4437, twitter: #55acee);.btn-dribble&#123; color: map-get($social-colors,facebook);&#125;//编译后.btn-dribble &#123; color: #3b5998; &#125; 如果 $key 不在 $map 中，不会编译出 CSS，其实在 Sass 中，map-get($social- colors,weibo) 返回了一个 null 值。但在编译出来的 CSS 中，你只知道他没有编译出样式，而且在命令终端编译时，也没有任何错误或者警告信息。说实话，你并不知道他为什么编译不出来样式，或者说他已返回了值为 null。 map-has-key(\$map,\$key)map-has-key(\$map,\$key) 函数将返回一个布尔值。当 \$map 中有这个 \$key，则函数返回 true，否则返回 false。 123456789101112131415161718$social-colors: ( dribble: #ea4c89, facebook: #3b5998, github: #171515, google: #db4437, twitter: #55acee);@if map-has-key($social-colors,facebook)&#123; .btn-facebook &#123; color: map-get($social-colors,facebook); &#125;&#125; @else &#123; @warn "No color found for faceboo in $social-colors map. Property ommitted."&#125;//编译后.btn-facebook &#123; color: #3b5998; &#125; 这样可以解决map-get(\$social- colors,weibo) 返回了一个 null 值后没有提示的状态。其实可以自定义一个函数来实现： 1234567891011121314151617181920212223242526272829303132333435363738394041@function colors($color)&#123; @if not map-has-key($social-colors,$color)&#123; @warn "No color found for `#&#123;$color&#125;` in $social-colors map. Property omitted."; &#125; @return map-get($social-colors,$color);&#125;.btn-dribble &#123; color: colors(dribble);&#125;.btn-facebook &#123; color: colors(facebook);&#125;.btn-github &#123; color: colors(github);&#125;.btn-google &#123; color: colors(google);&#125;.btn-twitter &#123; color: colors(twitter);&#125;.btn-weibo &#123; color: colors(weibo);&#125;//编译后.btn-dribble &#123; color: #ea4c89; &#125;.btn-facebook &#123; color: #3b5998; &#125;.btn-github &#123; color: #171515; &#125;.btn-google &#123; color: #db4437; &#125;.btn-twitter &#123; color: #55acee; &#125; map-keys(\$map)map-keys(\$map) 函数将会返回 \$map 中的所有 key。这些值赋予给一个变量，那他就是一个列表。如： 12345678$list: map-keys($social-colors);.test&#123; content:$list&#125;//编译后.test &#123; content: dribble, facebook, github, google, twitter; &#125; 上面的`@function colors函数可以做通过 map-keys(\$map) 来做一个修改： 1234567891011121314151617181920212223242526272829@function colors($color)&#123; $names: map-keys($social-colors); @if not index($names,$color)&#123; @warn "Waring: `#&#123;$color&#125; is not a valid color name.`"; &#125; @return map-get($social-colors,$color);&#125;@each $name in map-keys($social-colors)&#123; .btn-#&#123;$name&#125;&#123; color: colors($name); &#125;&#125;//编译后.btn-dribble &#123; color: #ea4c89; &#125;.btn-facebook &#123; color: #3b5998; &#125;.btn-github &#123; color: #171515; &#125;.btn-google &#123; color: #db4437; &#125;.btn-twitter &#123; color: #55acee; &#125; map-values(\$map)和map-merge(\$map1,\$map2)map-values(\$map) 函数类似于 map-keys(\$map) 功能，不同的是 map-values(\$map )获取的是 \$map 的所有 value 值，可以说也将是一个数组。而且，map-values(\$map) 中如果有相同的 value 也将会全部获取出来。 12345678$list: map-values($social-colors);.test&#123; content:$list&#125;//编译后.test &#123; content: #ea4c89, #3b5998, #171515, #db4437, #55acee; &#125; map-merge(\$map1,\$map2) 函数是将 \$map1 和 \$map2 合并，然后得到一个新的 \$map。如果你要快速将新的值插入到 \$map 中的话，这种方法是最佳方法。 123456789101112131415161718192021$color: ( text: #f36, link: #f63, border: #ddd, backround: #fff);$typo:( font-size: 12px, line-height: 1.6);$newmap: map-merge($color,$typo);//得到新的map$newmap:( text: #f36, link: #f63, font-size: 12px, line-height: 1.6, border: #ccc, background: #000); map-remove(\$map,\$key)和keywords(\$args)map-remove(\$map,\$key) 函数是用来删除当前 \$map 中的某一个 \$key，从而得到一个新的 map。其返回的值还是一个 map。他并不能直接从一个 map 中删除另一个 map，仅能通过删除 map 中的某个 key 得到新 map。如： 12345678910111213141516$social-colors: ( dribble: #ea4c89, facebook: #3b5998, github: #171515, google: #db4437, twitter: #55acee);$map:map-remove($social-colors,dribble);//返回新的map$map:( facebook: #3b5998, github: #171515, google: #db4437, twitter: #55acee); keywords(\$args) 函数可以说是一个动态创建 map 的函数。可以通过混合宏或函数的参数变创建 map。参数也是成对出现，其中 \$args 变成 key(会自动去掉\$符号)，而 \$args 对应的值就是value。 1234567891011121314@mixin map($args...)&#123; @debug keywords($args);&#125;@include map( $dribble: #ea4c89, $facebook: #3b5998, $github: #171515, $google: #db4437, $twitter: #55acee);//在命令终端可以看到一个输入的 @debug 信息DEBUG: (dribble: #ea4c89, facebook: #3b5998, github: #171515, google: #db4437, twitter: #55acee) 颜色函数RGB()颜色函数在 Sass 中为 RGB 颜色提供六种函数： rgb(\$red,\$green,\$blue)：根据红、绿、蓝三个值创建一个颜色； rgba(\$red,\$green,\$blue,\$alpha)：根据红、绿、蓝和透明度值创建一个颜色； red(\$color)：从一个颜色中获取其中红色值； green(\$color)：从一个颜色中获取其中绿色值； blue(\$color)：从一个颜色中获取其中蓝色值； mix(\$color-1,\$color-2,[\$weight])：把两种颜色混合在一起。 12345678910111213$ sass -i //相当于开启 Sass 的函数计算&gt;&gt; rgb(200,40,88) //根据r:200,g:40,b:88计算出一个十六进制颜色值#c82858&gt;&gt; rgba(#c82858,.65) //根据#c82858的65%透明度计算出一个rgba颜色值rgba(200, 40, 88, 0.65)&gt;&gt; red(#c82858) //从#c82858颜色值中得到红色值 200200&gt;&gt; green(#c82858) //从#c82858颜色值中得到绿色值 4040&gt;&gt; blue(#c82858) //从#c82858颜色值中得到蓝色值 8888&gt;&gt; mix(#c82858,rgba(200,40,80,.65),.3) //把#c82858和rgba(200,40,88,.65) 两颜色按比例混合得到一个新颜色rgba(200, 40, 80, 0.65105) RGBA()颜色函数rgba() 函数主要用来将一个颜色根据透明度转换成 rgba 颜色。 其语法有两种格式： 12rgba($red,$green,$blue,$alpha) //将一个rgba颜色转译出来，和未转译的值一样rgba($color,$alpha) //将一个Hex颜色转换成rgba颜色 其中 rgba(\$color,\$alpha) 函数作用更大，主要运用在这样的情形之中：假设在实际中知道的颜色值是#f36或者red，但在使用中，需要给他们配上一个透明度，这时可以用上rgba(\$color,\$alpha) 函数： 1234567891011121314$color: #f36;$bgColor: orange;$borderColor:green;.rgba &#123; color: rgba(#f36,.5); background: rgba(orange,.5); border-color: rgba(green,.5);&#125;//编译后.rgba &#123; color: rgba(255, 51, 102, 0.5); background: rgba(255, 165, 0, 0.5); border-color: rgba(0, 128, 0, 0.5); &#125; Mix()函数Mix 函数是将两种颜色根据一定的比例混合在一起，生成另一种颜色。其使用语法如下： 1mix($color-1,$color-2,$weight); $color-1和$color-2指的是你需要合并的颜色，颜色可以是任何表达式，也可以是颜色变量。 $weight为合并的比例（选择权重），默认值为 50%，其取值范围是 0~1 之间。它是每个 RGB 的百分比来衡量，当然透明度也会有一定的权重。默认的比例是 50%，这意味着两个颜色各占一半，如果指定的比例是 25%，这意味着第一个颜色所占比例为 25%，第二个颜色所占比例为75%。 123456789101112131415161718$color1: #a63;$color2: #fff;$bgColor1: #f36;$bgColor2: #e36;$borderColor1:#c36;$borderColor2:#b36;.mix &#123; background: mix($bgColor1,$bgColor2,.75); color: mix($color1,$color2,.25); border-color: mix($borderColor1,$bgColor2,.05);&#125;//编译后.mix &#123; background: #ee3366; color: #fffffe; border-color: #ee3366; &#125; HSL函数在 Sass 中提供了一系列有关于 HSL 的颜色函数： hsl(\$hue,\$saturation,\$lightness)：通过色相（hue）、饱和度(saturation)和亮度（lightness）的值创建一个颜色 hsla(\$hue,\$saturation,\$lightness,\$alpha)：通过色相（hue）、饱和度(saturation)、亮度（lightness）和透明（alpha）的值创建一个颜色 hue(\$color)：从一个颜色中获取色相（hue）值 saturation(\$color)：从一个颜色中获取饱和度（saturation）值 lightness(\$color)：从一个颜色中获取亮度（lightness）值 adjust-hue(\$color,\$degrees)：通过改变一个颜色的色相值，创建一个新的颜色 lighten(\$color,\$amount)：通过改变颜色的亮度值，让颜色变亮，创建一个新的颜色 darken(\$color,\$amount)：通过改变颜色的亮度值，让颜色变暗，创建一个新的颜色 saturate(\$color,\$amount)：通过改变颜色的饱和度值，让颜色更饱和，从而创建一个新的颜色 desaturate(\$color,\$amount)：通过改变颜色的饱和度值，让颜色更少的饱和，从而创建出一个新的颜色 grayscale(\$color)：将一个颜色变成灰色，相当于desaturate(\$color,100%) complement(\$color)：返回一个补充色，相当于adjust-hue(\$color,180deg) invert(\$color)：返回一个反相色，红、绿、蓝色值倒过来，而透明度不变 lighten()lighten() 和 darken() 两个函数都是围绕颜色的亮度值做调整的，其中 lighten() 函数会让颜色变得更亮，与之相反的 darken() 函数会让颜色变得更暗。这个亮度值可以是0~1之间，不过常用的一般都在3%~20%之间。 1234567891011121314$baseColor: #ad141e;.lighten &#123; background: lighten($baseColor,10%);&#125;.darken&#123; background: darken($baseColor,10%);&#125;//编译后.lighten &#123; background: #db1926; &#125;.darken &#123; background: #7f0f16; &#125; saturate()saturate()、desaturate()这两个函数是通过改变颜色的饱和度来得到一个新的颜色，他们和前面介绍的修改亮度得到新颜色的方法非常相似。 1234567891011121314$baseColor: #ad141e;.saturate &#123; background: saturate($baseColor,30%); //在原色饱和度基础上增加饱和度&#125;.desaturate &#123; background: desaturate($baseColor,30%);//在原色饱和度基础上减少饱和度&#125;//编译后.saturate &#123; background: #c1000d; &#125;.desaturate &#123; background: #903137; &#125; adjust-hue()函数这个是通过调整颜色的色相换算一个新颜色。他需要一个颜色和色相度数值。通常这个度数值是在-360deg至360deg之间，当然了可以是百分数： 1234567891011121314$baseColor: #ad141e;.adjust-hue-deg &#123; background: adjust-hue($baseColor,30deg);&#125;.adjust-hue-per &#123; background: adjust-hue($baseColor,30%);&#125;//编译后.adjust-hue-deg &#123; background: #ad5714; &#125;.adjust-hue-per &#123; background: #ad5714; &#125; grayscale()函数这个函数会颜色的饱和度值直接调至0%，所以此函数与desaturate($color,100%)所起的功能是一样的。一般这个函数能将彩色颜色转换成不同程度的灰色。例如： 1234567891011121314$baseColor: #ad141e;.grayscale &#123; background: grayscale($baseColor);&#125;.desaturate &#123; background: desaturate($baseColor,100%);&#125;//编译后.grayscale &#123; background: #616161; &#125;.desaturate &#123; background: #616161; &#125; Opacity函数alpha()、opacity()函数alphpa() 和 opacity() 函数很简单，与前面介绍的 red(),green() 等函数很类似。这个函数的主要功能是用来获取一个颜色的透明度值。如果颜色没有特别指定透明度，那么这两个函数得到的值都会是 1。 opacify()、fade-in()函数这两个函数是用来对已有颜色的透明度做一个加法运算，会让颜色更加不透明。其接受两个参数，第一个参数是原始颜色，第二个参数是你需要增加的透明度值，其取值范围主要是在 0~1 之间。当透明度值增加到大于 1 时，会以 1 计算，表示颜色不具有任何透明度。 transparentize()、 fade-out()函数transparentize() 和 fade-out() 函数所起作用刚好与 opacify() 和 fade-in() 函数相反，让颜色更加的透明。这两个函数会让透明值做减法运算，当计算出来的结果小于 0 时会以 0 计算，表示全透明。 Sass的@规则@importSass 拓展了 @import 的功能，允许其导入 SCSS 或 Sass 文件。被导入的文件将合并编译到同一个 CSS 文件中，另外，被导入的文件中所包含的变量或者混合指令 (mixin) 都可以在导入的文件中使用。 Sass 在当前地址，或 Rack, Rails, Merb 的 Sass 文件地址寻找 Sass 文件，如果需要设定其他地址，可以用 :load_paths 选项，或者在命令行中输入 --load-path 命令。 通常，@import 寻找 Sass 文件并将其导入，但在以下情况下，@import 仅作为普通的 CSS 语句，不会导入任何 Sass 文件。 文件拓展名是 .css； 文件名以 http:// 开头； 文件名是 url()； @import 包含 media queries。 如果不在上述情况内，文件的拓展名是 .scss 或 .sass，则导入成功。没有指定拓展名，Sass 将会试着寻找文件名相同，拓展名为 .scss 或 .sass 的文件并将其导入。 Sass 允许同时导入多个文件，例如同时导入 rounded-corners 与 text-shadow 两个文件： 1@import "rounded-corners", "text-shadow"; 导入文件也可以使用 #{ } 插值语句，但不是通过变量动态导入 Sass 文件，只能作用于 CSS 的 url() 导入方式： 12$family: unquote("Droid+Sans");@import url("http://fonts.googleapis.com/css?family=\#&#123;$family&#125;"); 如果需要导入 SCSS 或者 Sass 文件，但又不希望将其编译为 CSS，只需要在文件名前添加下划线，这样会告诉 Sass 不要编译这些文件，但导入语句中却不需要添加下划线。注意，不可以同时存在添加下划线与未添加下划线的同名文件，添加下划线的文件将会被忽略。 大多数情况下，一般在文件的最外层（不在嵌套规则内）使用 @import，其实，也可以将 @import 嵌套进 CSS 样式或者 @media 中，与平时的用法效果相同，只是这样导入的样式只能出现在嵌套的层中。但是不可以在混合指令 (mixin) 或控制指令 (control directives) 中嵌套 @import。 假设 example.scss 文件包含以下样式： 123.example &#123; color: red;&#125; 然后导入到 #main 样式内 123#main &#123; @import "example";&#125; 将会被编译为 123#main .example &#123; color: red;&#125; @mediaSass 中 @media 指令与 CSS 中用法一样，只是增加了一点额外的功能：允许其在 CSS 规则中嵌套。如果 @media嵌套在 CSS 规则内，编译时，@media 将被编译到文件的最外层，包含嵌套的父选择器。这个功能让 @media 用起来更方便，不需要重复使用选择器，也不会打乱 CSS 的书写流程。 12345678910111213.sidebar &#123; width: 300px; @media screen and (orientation: landscape) &#123; width: 500px; &#125;&#125;//编译后.sidebar &#123; width: 300px; &#125; @media screen and (orientation: landscape) &#123; .sidebar &#123; width: 500px; &#125; &#125; @media 的 queries 允许互相嵌套使用，编译时，Sass 自动添加 and 123456789101112@media screen &#123; .sidebar &#123; @media (orientation: landscape) &#123; width: 500px; &#125; &#125;&#125;//编译后@media screen and (orientation: landscape) &#123; .sidebar &#123; width: 500px; &#125; &#125; @media 甚至可以使用 SassScript（比如变量，函数，以及运算符）代替条件的名称或者值： 1234567891011121314$media: screen;$feature: -webkit-min-device-pixel-ratio;$value: 1.5;@media #&#123;$media&#125; and ($feature: $value) &#123; .sidebar &#123; width: 500px; &#125;&#125;//编译后@media screen and (-webkit-min-device-pixel-ratio: 1.5) &#123; .sidebar &#123; width: 500px; &#125; &#125; @at-root@at-root 从字面上解释就是跳出根元素。当你选择器嵌套多层之后，想让某个选择器跳出，此时就可以使用 @at-root。来看一个简单的示例： 12345678910111213141516171819202122232425.a &#123; color: red; .b &#123; color: orange; .c &#123; color: yellow; @at-root .d &#123; color: green; &#125; &#125; &#125; &#125;//编译后.a &#123; color: red; &#125;.a .b &#123; color: orange; &#125;.a .b .c &#123; color: yellow; &#125;.d &#123; color: green; &#125; @debug@debug 在 Sass 中是用来调试的，当你的在 Sass 的源码中使用了 @debug 指令之后，Sass 代码在编译出错时，在命令终端会输出你设置的提示 Bug: 1234@debug 10em + 12em;//输出Line 1 DEBUG: 22em @warn@warn 和 @debug 功能类似，用来帮助我们更好的调试 Sass。如： 1234567891011121314151617181920@mixin adjust-location($x, $y) &#123; @if unitless($x) &#123; @warn "Assuming #&#123;$x&#125; to be in pixels"; $x: 1px * $x; &#125; @if unitless($y) &#123; @warn "Assuming #&#123;$y&#125; to be in pixels"; $y: 1px * $y; &#125; position: relative; left: $x; top: $y;&#125;.button&#123; @include adjust-location(20px,30)&#125;//编译后.button &#123; position: relative; left: 20px; top: 30px; &#125; @error@error 和 @warn、@debug 功能是如出一辙。 1234567891011121314151617@mixin error($x)&#123; @if $x &lt; 10 &#123; width: $x * 10px; &#125; @else if $x == 10 &#123; width: $x; &#125; @else &#123; @error "你需要将#&#123;$x&#125;值设置在10以内的数"; &#125;&#125;.test &#123; @include error(15);&#125;//编译后你需要将15值设置在10以内的数 on line 7 at column 5]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>Sass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《CSS揭秘》学习笔记]]></title>
    <url>%2F2017%2F04%2F01%2F%E3%80%8ACSS%E6%8F%AD%E7%A7%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[这本书给我打开了css新的大门，看之前最好对css基础比较熟练，然后对css3的新特性有一定的了解。书中大部份代码都在github上，大部分手敲，有问题可以提交pr 关于本书$$()函数可以更容易地获取和遍历所有匹配特定CSS选择符的DOM元素： 12345function $$(selector,context)&#123; context = context || document; var elements = context.querySelectorAll(selector); return Array.prototype.slice.call(elements);&#125; 应该把标准语法排在最后，这样可以通过层叠机制来确保标准语法能够最终生效。 可以使用modernizr来针对支持或者不支持某些特性的浏览器分别编写样式。 自定义特性检测函数： 123456789function testProperty(property)&#123; var root = document.documentElement; if (property in root.style)&#123; root.classList.add(property.toLowerCase()); return true; &#125; root.classList.add('no-' + property.toLowerCase()); return false;&#125; 自定义检测某个具体值是否支持的函数： 12345678910function testValue(id,value,property)()&#123; var dummy = document.createElement("p"); dummy.style[property] = value; if (dummy.style[property])&#123; root.classList.add(id); return true; &#125; root.classList.add('no-' + id); return false;&#125; 引言Web标准：是敌还是友冰与火之歌：浏览器前缀常见浏览器前缀：Firefox的-moz-、IE的-ms-、Opera的-o-、Safari和Chrome的-webkit-。 自动添加浏览器前缀的工具： css3,please，允许把无前缀的css代码粘贴进去，它们会自动帮你把必要的前缀都加好。 css3generator，可视化的css3代码生成器（我补充的）。 autoprefixer，它是在本地完成编译的，类似于预处理器。 prefixfree，会在浏览器中进行特性检测，来决定哪些前缀是需要的，几乎不需要更新。 CSS编码技巧尽量减少代码重复字号和行高之间有关系，如果都写成绝对值，改变字号的时候好需要计算行高。当某些值相互依赖时，应该把他们的相互关系用代码表达出来。 12345678font-size: 20px;line-height: 30px;--------升级-----------font-size: 20px;line-height: 1.5;--------升级-----------font-size: 125%;/*假设父级字号是16px*/line-height: 1.5; 把下面一些长度单位单位改成em，这样这些效果就可以根据字号进行缩放，em可能会导致复杂的运算，因为它只能跟父级元素建立联系，这种情况下可以使用rem，rem是指相对于根元素的字体大小的单位，简单的说它就是一个相对单位。 把半透明的黑色或者白色叠加在主色调上，即可产生主色调的亮色和暗色变体，只要覆盖background-color属性，就可以得到不同颜色版本的按钮。 123456789101112131415161718192021222324252627282930313233343536padding: 6px 16px;border: 1px solid #446d88;background: #58a line-gradient(#77a0bb,#58a);border-radius: 4px;box-shadow: 0 1px 5px gray;color: white;text-shadow: 0 -1px 1px #335166;font-size: 20px;line-height: 30px;--------升级-----------padding: .3em .8em;border: 1px solid #446d88;background: #58a line-gradient(#77a0bb,#58a);border-radius: .2em;box-shadow: 0 .05em .25em gray;color: white;text-shadow: 0 -.05em .05em #335166;font-size: 125%;line-height: 1.5;--------升级-----------padding: .3em .8em;border: 1px solid rgba(0,0,0,.1);background: #58a line-gradient(hsla(0,0%,100%,.2),transparent);border-radius: .2em;box-shadow: 0 .05em .25em rgba(0,0,0,.5);color: white;text-shadow: 0 -.05em .05em rgba(0,0,0,.5);font-size: 125%;line-height: 1.5;button.cancel&#123; background-color: #c00;&#125;button.ok&#123; background-color: #6b0;&#125; currentColorcurrentColor是CSS有史以来的第一个变量。假设让所有水平分割线自动与文本颜色保持一致： 1234hr&#123; height: .5em; background: currentColor;&#125; 继承inherit总是绑定到父元素的计算值。 1input,button&#123;font: inherit;&#125; 相信你的眼睛，而不是数字有时候精准的尺度看起来并不精准，这种视觉上的错觉在任何形式的视觉设计中都普遍存在，我们的设计要顺应这种偏差。 关于响应式网页设计每个媒体查询都会增加成本。 不妨在媒体查询中使用em单位，这能让文本缩放在必要时触发布局的变化。 使用百分比长度来取代固定长度。如果实在做不到这点，也应该尝试使用与视口相关的单位（vm、vh、vmin和vmax），它们的值解析为视口的宽度或者高度的百分比。 当需要在较大分辨率下得到固定宽度时，使用max-width而不是width，因为它可以适应较小分辨率，而无需使用媒体查询。 不要忘记为替换元素（比如img、object、video、iframe等）设置一个max-width，值为100% 假如背景图片需要完整的铺满一个容器，不管容器的尺寸如何变化，background-size: cover这个属性都可做到。但是带宽并不是无限的，因此在移动设备中通过css把大图缩小显示往往是不明智的。 当图片（或其他元素）以行列式进行布局时，让视口的宽度来决定列的数量。弹性盒布局（即flexbox）或者display: inline-block加上常规的文本折行行为，都可以实现这一点。 在使用多列文本时，指定column-width（列宽）而不是指定column-count（列数），这样它就可以在较小的屏幕上自动显示为单列布局。 实现弹性可伸缩的布局，并在媒体查询的各个断点区间内指定相应的尺寸。 合理使用简写12background: rebeccapurole;background-color: rebeccapurole; 上面两行代码并不等价，前者是简写，它可以确保你得到rebeccapurole纯色背景；使用后者有可能背景颜色会受到background-image影响，从而背景最终显示为其他的图案。 我应该使用预处理器吗123ul&#123; --accent-color: purple;&#125;ol&#123; --accent-color: rebeccapurole;&#125;li&#123; background: var(--accent-color);&#125; 这段原生css代码使用变量玩法，在有序列表中，li的背景颜色是rebeccapurole；在无序列表中，li的背景颜色是purple。 背景与边框半透明边框 RGBA(R,G,B,A)，R：红色值，正整数 | 百分数；G：绿色值，正整数 | 百分数；B：蓝色值，正整数 | 百分数；A：Alpha透明度，取值0~1之间。此色彩模式与RGB相同，只是在RGB模式上新增了Alpha透明度。IE6.0-8.0不支持使用 rgba 模式实现透明度，可使用 IE 滤镜处理。 HSLA(H,S,L,A)，H：Hue(色调)，0(或360)表示红色，120表示绿色，240表示蓝色，也可取其他数值来指定颜色，取值为：0 - 360；S：Saturation(饱和度)，取值为：0.0% - 100.0%；L：Lightness(亮度)，取值为：0.0% - 100.0%；A：Alpha透明度，取值0~1之间。 默认情况下，背景会延伸到边框所在的区域下层。 在背景与边框第三版中可以通过background-clip属性来调整上面的默认行为带来的不便。 123border: 10px solid hsla(0,0%,100%,0.5);background: white;background-clip: padding-box; background-clip属性初始值是border-box，意味着背景会被元素的border box（边框的外沿边框）剪裁掉。padding-box意味着浏览器会用内边距的外沿来把背景剪裁掉。 多重边框box-shadow方案box-shadow第四个参数（称作扩张半径）通过指定正值或者负值，可以让投影面积加大或者减小。 一个正值的扩张半径加上两个为零的偏移量以及为零的模糊值，得到的投影其实像一道实线边框： 12background: yellowgreen;box-shadow: 0 0 0 10px #655, 用box-shadow的好处在于，它支持逗号分隔语法，可以用来创建任意数量的投影： 123box-shadow: 0 0 0 10px #655, 0 0 0 15px deeppink, 0 2px 5px 15px rgba(0,0,0,.6); 唯一需要注意的是，box-shadow是层层叠加的，第一层投影位于最顶层，假设为10px，如果外圈再加一道5px的外框，需要指定的扩张半径为：15px（10px+5px）。 需要注意的是： 投影不会影响布局，而且不会受到box-size属性的影响。不过可以通过内边距或者外边距来额外模拟出边框所需要占据的空间。 投影的边框出现在元素的外圈，不会影响鼠标事件。 outline方案如果只需要两层边框，可以先设置一层常规边框，再设置一层outline属性来产生外层的边框。这种方法有点在于边框样式比较灵活，可以模拟虚线边框的效果，还可以通过outline-offset属性来控制它跟元素边缘之间的间距，这个属性可以接受负值。但是这个方案中outline产生的边框不会贴合圆角边框。 12345678910111213141516171819202122232425262728293031323334353637#div1&#123; display: inline-block; color: white; text-align: center; width: 100px; height: 60px; margin: 25px 25px; background: yellowgreen; border: 10px solid #655; outline: 5px dashed deeppink;&#125;#div2&#123; display: inline-block; color: white; text-align: center; width: 100px; height: 60px; margin: 25px 25px; background: black; border: 10px solid black; outline: 1px dashed white; outline-offset: -5px;&#125;#div3&#123; display: inline-block; color: white; text-align: center; width: 100px; height: 60px; margin: 25px 25px; background: yellowgreen; border: 10px solid #655; border-radius: 15px; outline: 5px solid deeppink;&#125; 灵活的背景定位background-position的扩展语法方案在CSS背景与边框（第三版）中，background-position属性允许指定背景图片距离任意角的偏移量，只要在偏移量前面指定关键字。 123background: url(http://csssecrets.io/images/code-pirate.svg) no-repeat #58a;background-position: right 20px bottom 10px; 对不支持background-position扩展语法的浏览器中，回退方案是把bottom right写到background简写属性中： 123background: url(http://csssecrets.io/images/code-pirate.svg) no-repeat bottom right #58a;background-position: right 20px bottom 10px; background-origin方案当偏移量与容器内边距一致的时候，可以用background-origin，让偏移量自动跟着内边距走。 默认情况下，background-position的偏移量是以padding box为准，这样边框才不会遮住背景图片。在背景与边框（第三版）中的background-origin属性可以改变这种行为，其默认值是padding box，改成content-box后background-position的偏移量以content-box为准。 calc()方案请不要忘记在calc()函数内部的-和+运算符的两侧各加一个空白符，否则会产生解析错误。 123background: url(http://csssecrets.io/images/code-pirate.svg) no-repeat bottom right #58a;background-position: calc(100% - 20px) calc(100% - 10px); 边框内圆角12345outline: .6em solid #655;box-shadow: 0 0 0 .4em #655; /* todo calculate max of this */border-radius: .8em;padding: 1em;background: tan; 描边并不会跟着元素的圆角走，但是box-shadow会，两者叠加到一起，box-shadow刚好填补描边和容器圆角之间的空隙，达到下图的效果。扩张值等于描边宽度可能会浏览器渲染异常，所以扩张半径取圆角半径的一半，并且描边的宽度要比圆角半径的一半要小。 条纹背景如果多个色标具有相同的位置，它们会产生一个无限小的过度区域，过度的起止色分别是第一个和最后一个指定值。从效果上看，颜色会在那个位置突然变化，而不是一个平滑的渐变过程：background: linear-gradient(#fb3 50%, #58a 50%);。 关于linear-gradient()，MDN是这样说明的（颜色参数后面的长度参数是渐变的起始位置或者终止位置）： 如果第二个色标的位置值设为0，那它的位置就总会被浏览器调整为前一个色标的位置值。background: linear-gradient(#fb3 50%, #58a 0); 垂直条纹1234background: linear-gradient(to right, #fb3 50%, #58a 0);/*或者这样写*//*background: linear-gradient(90deg, #fb3 50%, #58a 0);*/background-size: 30px 100%; 斜向条纹单个贴片中包含四条条纹，才有可能无缝拼接成斜向条纹。 条纹宽度要和垂直条纹宽度一样时，条纹宽度需要通过勾股定理计算。 12background: linear-gradient(45deg, #fb3 25%, #58a 0, #58a 50%, #fb3 0, #fb3 75%, #58a 0); background-size: 42px 42px; 更好的斜向条纹可以通过linear-gradient()（radial-gradient()）的循环加强版repeating-linear-gradient()（repeating-radial-gradient()）来实现斜向条纹，和前者相比，后者的色标是无限循环的。 使用repeating-radial-gradient()可以随意改变斜纹的角度，而且代码中的长度直接表示条纹自身宽度。 1background: repeating-linear-gradient(45deg, #fb3 0, #fb3 15px, #58a 0, #58a 30px); 灵活的同色系条纹如果条纹图案属于同色系，只是在明暗方面有着轻微的差别，可以这样写： 1234 background: #58a; background-image: repeating-linear-gradient(30deg, hsla(0,0%,100%,.1) 0, hsla(0,0%,100%,.1) 15px, transparent 0, transparent 30px);---------等同于---------background: repeating-linear-gradient(30deg, #79b 0, #79b 15px, #58a 0, #58a 30px); 这样写只需要修改一处就可以改变所有颜色，而且对不支持css渐变的浏览器来说起到了回退作用。 复杂的背景图案网格1234567 background: white; background-image: linear-gradient(90deg, rgba(200,0,0,.5) 50%, transparent 0),linear-gradient(rgba(200,0,0,.5) 50%, transparent 0); background-size: 30px 30px;----------改进版，可方便的改变网格尺寸、线宽、颜色---------- background: #5588aa; background-image: linear-gradient( white 1px, transparent 0),linear-gradient(90deg,white 1px, transparent 0); background-size: 30px 30px; 波点12345background: #655; background-image: radial-gradient(tan 30%, transparent 0), radial-gradient(tan 30%, transparent 0); background-size: 30px 30px; background-position: 0 0,15px 15px; 为了达到波点的效果，第二层背景的偏移定位必须是贴片宽高的一半。为了方便维护，可以使用scss的mixin： 1234567@mixin polka($size,$dot,$base,$accent)&#123; background: $base; background-image: radial-gradient($accent $dot, transparent 0), radial-gradient($accent $dot, transparent 0); background-size: $size $size; background-position: 0 0,$size/2 $size/2;&#125; Bennett的图案库 伪随机背景12345678background: hsl(20,40%,90%);background-image: linear-gradient(90deg, #fb3 10px, transparent 0), linear-gradient(90deg, #ab4 20px, transparent 0), linear-gradient(90deg, #655 20px, transparent 0); background-size: 41px 100%,61px 100%,83px 100%; width: 300px; height: 100px; margin: 2em 2em; 贴片尺寸是background-size的最小公倍数，也就是每隔41px*61px*83px后贴片会重复，所以background-size尽量选择质数，使得最小公倍数尽可能大，减小重复。 连续的图像边框border-image工作原理是把图片分成9块，然后把他们应用到元素边框的边和角。 使用border-image生成边框，需要额外的html元素： 12345678910111213141516.div3&#123; background: url(http://csssecrets.io/images/stone-art.jpg); background-size: cover; /* Styling &amp; enable resize */ width: 21em; padding: 1em; overflow: hidden; resize: both; font: 100%/1.6 Baskerville, Palatino, serif; margin: 5em 5em;&#125;.div3 &gt; div&#123; background: white; padding: 1em;&#125; 1&lt;div class="div3"&gt;&lt;div&gt;i am a man&lt;/div&gt;&lt;/div&gt; 还可以在背景图片之上，再叠加一层纯白实色背景，这两层背景分别设置不同的background-clip值，并且background-origin设置为border-box，这样使得背景图片在border-box范围内平铺： 1234567 padding: 1em;border: 1em solid transparent; background: linear-gradient(white , white), url(http://csssecrets.io/images/stone-art.jpg); background-size: cover; background-clip: padding-box,border-box; background-origin: border-box 这个技巧可以用来做蚂蚁行军框： 123456789101112131415161718@keyframes div5 &#123; to &#123;background-position: 100%&#125;&#125;.div5&#123; border: 1px solid transparent; background: linear-gradient(white , white) padding-box, repeating-linear-gradient(-45deg , black 0,black 25%, white 0,white 50%) 0 / .6em .6em; animation: div5 12s linear infinite; /* Styling &amp; enable resize */ width: 21em; padding: 1em; font: 100%/1.6 Baskerville, Palatino, serif; margin: 5em 5em;&#125; border-image配合渐变图案生成顶部边框被剪裁的效果： 123border-top : .2em solid transparent; border-image : 100% 0 0 linear-gradient(90deg, currentColor 4em, transparent 0); padding-top : 1em; 形状自适应椭圆给任何足够大的正方形元素设置一个足够大的border-radius就可以把它变成一个圆形。 当任意两个相邻圆角的半径之和超过border box的尺寸时，用户代理必须按比例减小各个边框半径所使用的值，直到它们不会相互重叠为止。 border-radius可以单独指定水平和垂直半径，只要用/分隔两个值即可。 border-radius不仅可以接受长度值，还可以接受百分比。 border-radius: 50%;可以实现自适应椭圆。 border-radius是简写，对应的展开式属性为：border-top-left-radius、border-top-right-radius、border-bottom-right-radius、border-bottom-left-radius。可以向border-radius一次性提供空格分隔的多个值。如果传了4个值，这4个值分别从左上角开始以顺时针顺序应用到元素的各个拐角；如果传了3个值，意味着第四个值与第二个值相同；如果传了2个值，意味着第三个值与第一个相同。 可以为所有四角提供完全不同的水平半径和垂直半径：斜杠前指定1~4个值，斜杠后指定1~4个值：border-radius: 10px/5px 20px; 自适应的半椭圆：border-radius: 50%/100% 100% 0 0; 自适应四分之一椭圆：border-radius: 100% 0 0 0; 平行四边形嵌套元素方案用skew()变形属性对矩形进行斜向拉伸：transform: skewX(-45deg);。 直接用skew()拉伸内容也会拉伸，此时可以对内容再用一次反向skew()变形，缺点是需要额外的HTML元素包裹内容。 伪元素方案另一种方法是把所有样式（背景、边框等）应用到伪元素上，然后再对伪元素进行变形，因为内容不包含在伪元素中，所以内容不会受到影响： 12345678910111213141516171819202122.button2 &#123; position: relative; color: white; font: bold 200%/1 sans-serif; padding: .5em 1em; border: 0;&#125;.button2::before &#123; content: ""; /*用伪元素生成一个矩形*/ /*偏移量设置为0，以便让伪元素在水平和垂直方向上都被拉伸至宿主元素的尺寸*/ position: absolute; top: 0; right: 0; bottom: 0; left: 0; z-index: -1;/*伪元素生成的方块位于内容之上，设置z-index后会推到宿主元素之后*/ background: #5588aa; transform: skew(45deg);&#125; 当想变形一个元素而不想变形它的内容时都可以用到上面的代码。 菱形图片基于变形的方案1234567891011121314.div1 &#123; width: 250px; height: 250px; transform: rotate(45deg); overflow: hidden; margin: 100px;&#125;.div1 img&#123; max-width: 100%; transform: rotate(-45deg) scale(1.42); z-index: -1; position: relative;&#125; 123&lt;div class="div1"&gt; &lt;img src="http://csssecrets.io/images/adamcatlace.jpg" /&gt;&lt;/div&gt; max-width: 100%会被解析为容器的边长。要显示为菱形，图片的宽度要与容器的对角线相等。 通过scale()变形样式缩放图片时，是以它的中心点进行缩放的。通过width属性来放大图片时，只会以它的左上角为原点进行缩放。 裁切路径方案clip-path属性可以把元素剪裁成任何形状。polygon()是多边形函数，可以用一系列坐标点来指定任意的多边形，使用百分比时会解析为元素自身的尺寸。 1clip-path: polygon(50% 0, 100% 50%, 50% 100%, 0 50%); 只要使用同一种形状函数并且点的数量相同，clip-path属性可以参与动画： 12345678.img2&#123; clip-path: polygon(50% 0, 100% 50%, 50% 100%, 0 50%); transition: 1s clip-path;&#125;.img2:hover&#123; clip-path: polygon(0 0, 100% 0, 100% 100%, 0 100%);&#125; 切角效果linear-gradient可以接受一个角度作为方向，色标的位置信息也可以是绝对的长度值。 12background: #5588aa;background: linear-gradient(45deg, white 15px,#5588aa 0); 四角切角效果需要把background-repeat关掉，防止四层渐变背景相互覆盖。 1234567background: #5588aa;background: linear-gradient(135deg, white 15px,#5588aa 0) top left, linear-gradient(-135deg, white 15px,#5588aa 0) top right, linear-gradient(-45deg, white 15px,#5588aa 0) bottom right, linear-gradient(45deg, white 15px,#5588aa 0) bottom left;background-size: 50% 50%;background-repeat: no-repeat; 弧形切角123456background: radial-gradient(circle at top left, transparent 15px, #58a 0) top left, radial-gradient(circle at top right, transparent 15px, #58a 0) top right, radial-gradient(circle at bottom right, transparent 15px, #58a 0) bottom right, radial-gradient(circle at bottom left, transparent 15px, #58a 0) bottom left;background-size: 50% 50%;background-repeat: no-repeat; 内联SVG与border-image方案SVG可以实现与尺寸完全无关的缩放，此处使用的切片尺寸是1，它所对应的是SVG文件的坐标系统，因此不需要单位。background-clip属性避免背景色蔓延到边框区域。 border-width支持动画效果。 1234567border: 21px solid transparent;border-image: 1 url('data:image/svg+xml,\ &lt;svg xmlns="http://www.w3.org/2000/svg" width="3" height="3" fill="%2358a"&gt;\ &lt;polygon points="0,1 1,0 2,0 3,1 3,2 2,3 1,3 0,2" /&gt;\ &lt;/svg&gt;'); background: #58a; background-clip: padding-box; 裁切路径方案clip-path属性中可以同时使用百分比数值和绝对长度。 12345background: #58a;clip-path: polygon(20px 0, calc(100% - 20px) 0, 100% 20px, 100% calc(100% - 20px), calc(100% - 20px) 100%, 20px 100%, 0 calc(100% - 20px), 0 20px); 这个方法不仅可以对任意类型的背景进行裁剪，甚至对替换元素（比如图片）进行裁剪，而且还支持动画效果。 由于它只能对元素做统一的裁剪，当内边距不够宽时，这个方案会裁剪掉文本。渐变方案允许文字溢出并超出切角区域，而border-image方案则会起到普通边框的作用，令文字折行。 梯形标签页对元素使用3d变形后，其内部的变形效应是不可逆的。 当没有设置transform-origin属性时，应用变形效果会让这个元素以它自身的中心线为轴进行空间上的旋转，因此元素投射到2D屏幕上的尺寸会发生变化。指定transform-origin: bottom;，当元素在3D空间中旋转时，可以把它的底边固定住。 12345678910111213141516171819.div1&#123; height: 50px; width: 100px; color: white; position: relative; line-height: 50px; margin: 5em 5em; text-align: center;&#125;.div1::before&#123; content: ""; position: absolute; top: 0;right: 0;left: 0;bottom: 0; z-index: -1; background: #5588aa; transform: perspective(.5em) rotateX(5deg) scaleY(1.3); transform-origin: bottom;&#125; 这个方法可以给梯形标签页添加背景、边框。圆角。投影等一系列样式，并且只需要把transform-origin改成bottom left或者buttom right就可以立刻得到左侧倾斜或者右侧倾斜的标签页。但是这个方法的斜边角度依赖于元素的宽度。 简单的饼图基于transform的解决方案用伪元素覆盖上去，通过旋转决定露出多大扇形区。 12345678910.pie::before &#123; content: ''; display: block; margin-left: 50%; height: 100%; border-radius: 0 100% 100% 0 / 50%; background-color: inherit; /*背景元素与宿主元素保持一致,比率超过50%时改成棕色*/ transform-origin: left; /*伪元素圆形的圆形旋转，还可以写成transform-origin: 0 50%*/ animation: spin 3s linear infinite, bg 6s step-end infinite;&#125; 一个负的延时值是合法的。与0s的延时类似，它意味着动画会立即开始播放，但会自动前进到延时值的绝对值处，就好像动画在过去已经播放了指定的时间一样。因此实际效果就是动画跳过指定时间而从中间开始播放了。 可以用负的动画延时来直接跳至动画中的任意时间点，并且定格在那里，以此来实现按照比率来显示饼图。这里的动画永远处于暂停状态，指定的持续时间并不会产生任何副作用。 SVG解决方案stroke-dasharray: 20 10;是为虚线描边而准备的，20是虚线线段长度，10是间隙长度。 SVG描边时总会把一半绘制在元素外部，另一半绘制在元素内部： 视觉效果单侧投影单侧投影投影box-shadow: 2px 3px 4px rgba(0,0,0,5);的绘制过程： 在该元素相同尺寸和位置绘制颜色为rgba(0,0,0,5)的矩形； 把它向右移2px，向下移3px； 使用高斯模糊算法进行4px的模糊处理，本质上表示在阴影边缘发生阴影色和纯透明色之间的颜色过度长度近似于模糊半径的两倍（在这里就是8px）； 模糊后的矩形与原始元素交集部分会被切除掉。 所以box-shadow中，没有任何投影绘制在元素的下层。 text-shadow中，文字下层的投影不会被剪裁。 使用4px的模糊半径意味着投影的尺寸会比元素本身的尺寸大8px；因此投影的最外圈会从元素的四面向外显露出来。 box-shadow还有第四个长度参数—扩张半径，这个参数会根据指定的值去扩大或者缩小投影尺寸。比如，一个-5px的扩张半径会把投影的宽度和高度各减少10px（每边5px）。 1box-shadow: 0 5px 4px -4px rgba(0,0,0,5); 邻边投影扩张半径设为模糊半径相反值的一半，并且偏移量的值需要大于或者等于模糊半径的一半，比如，把6px模糊半径的投影设置到右侧和底部： 1box-shadow: 3px 3px 6px -3px rgba(0,0,0,5); 双侧投影设置两块投影（运用两次单侧投影）以实现双侧投影的效果： 12box-shadow: 5px 0 5px -5px rgba(0,0,0,5), -5px 0 5px -5px rgba(0,0,0,5); 不规则投影使用filter滤镜属性，该属性只需要一些函数，就可以指定滤镜效果，比如blur()、grayscale()、drop-shadow()等。 1filter: blur() grayscale() drop-shadow(); drop-shadow()带有的参数和box-shadow属性一样，但是不包括扩张半径，不包括insert关键字，也不支持逗号分隔的多层投影语法： 1filter: drop-shadow(2px 2px 10px rgba(0,0,0,.5)); 任何非透明的部分都会被打上投影，如果文字被搭上投影，不能用text-shadow: none去除。 染色效果基于滤镜的方案sepia()滤镜会给图片增加一种降饱和度的橙黄色染色效果，几乎所有像素的色相值都会被收敛到35~40： 1filter: sepia(); saturate()滤镜可以给每个像素提升饱和度；hue-rotate()滤镜把每个像素的相色以指定的度数进行偏移。 1filter: sepia(1) saturate(4) hue-rotate(295deg); 基于混合模式的方案luminosity混合模式会保留上层元素的HSL亮度信息，并从下层吸取色相的饱和度信息。 background-blend-mode: luminosity;可以为每层背景单独指定混合模式，不用&lt;img&gt;元素，而是用&lt;div&gt;元素，把这个元素的第一层背景设置为要染色的图片，并把第二层颜色设置成想要的主色调； mix-blend-mode: luminosity;可以为整个元素设置混合模式，需要把图片包裹在一个容器中，并把容器的背景色设置成想要的主色调。 混合模式不可以加动画。把属性设置为luminosity混合模式，图片总会跟某些东西进行混合，如果要加上过度动画，可以通过修改背景颜色的方式实现，比如，可以把背景图片和一个透明背景混合，此时不会出现任何混合效果： 毛玻璃效果blur()会使整个元素都会模糊。所以不能对元素本身进行模糊处理，这样文字也会变模糊。 可以对一个伪元素进行处理，然后将其定位到元素下层，它的背景将会无缝匹配&lt;body&gt;的背景。 12345678910111213141516171819202122232425262728main &#123; position: relative; margin: 0 auto; padding: 1em; max-width: 23em; background: hsla(0,0%,100%,.25) border-box; overflow: hidden; border-radius: .3em; box-shadow: 0 0 0 1px hsla(0,0%,100%,.3) inset, 0 .5em 1em rgba(0, 0, 0, 0.6); text-shadow: 0 1px 1px hsla(0,0%,100%,.3);&#125;main::before &#123; content: ''; position: absolute; top: 0; right: 0; bottom: 0; left: 0; margin: -30px; /*为了让边缘不出现逐渐消退的效果，需要让伪元素 相对其宿主元素的尺寸再向 外扩大 至少 20px （即它的模糊半径）。由于不同浏览器的模糊算法可能存在差异， 用一个更大的绝对值（比 如 -30px ）会更保险一些。*/ z-index: -1;/*把伪元素移动到宿主元素后面*/ -webkit-filter: blur(20px);/*设置伪元素模糊效果*/ filter: blur(20px);&#125;body, main::before &#123; /*第二张图是去掉body的效果*/ background: url("http://csssecrets.io/images/tiger.jpg") 0 / cover fixed; /*把伪元素和body背景设置为相同的图片，因为main元素有overflow: hidden;所以超出main元素大小的部分会被剪裁掉*/&#125; 折角效果45°折角的解决方案切角效果的矩形和渐变生成的小三角形重合。要注意，第二层渐变中的1.5em是沿着渐变轴测量的，第一层渐变中background-size中的2em长度是背景贴片的宽度和高度。为了两者尺寸一致，需要把原来切角渐变的角标位置2em除以√2变成1.5em。 1234background: #58a; /* Fallback */ background: linear-gradient(to left bottom, transparent 50%, rgba(0,0,0,.4) 0) no-repeat 100% 0 / 2em 2em, linear-gradient(-135deg, transparent 1.5em, #58a 0); 其他角度的解决方案123456789101112131415161718192021222324252627282930.div5 &#123; position: relative; background: #5588aa; background: linear-gradient(-150deg,transparent 1.5em,#5588aa 0); border-radius: .5em; margin-top: 2em; width: 12em; font: 100%/1.6 Baskerville, Palatino, serif; padding: 2em; color: white;&#125;.div5::before&#123; content: ''; position: absolute; top: 0;right: 0; background: linear-gradient(to left bottom,transparent 50%,rgba(0,0,0,.2) 0,rgba(0,0,0,.4)) 100% 0 no-repeat; width: 1.73em; height: 3em; /*移动并旋转伪元素与切角对齐*/ transform: translateY(-1.3em) rotate(-30deg); /*让三角形的右下角成为旋转中心，方便计算便宜距离*/ transform-origin: bottom right; border-bottom-left-radius: inherit; box-shadow: -.2em .2em .3em -.1em rgba(0,0,0,.15);&#125; 字体排印连字符断行hyphens属性有三个值：none、manual、auto。manual为默认值，它允许任何时候手工插入软连字符（&amp;shy;），来实现断词折行的效果。hyphens属性会优先处理软连字符，再去计算其他可以断词的地方。 hyphens属性的auto值可以比较好的实现连字符断行，不过需要在在HTML标签的lang属性中指定合适的语言。 1hyphens: auto; 插入换行\A在Unicode中代表换行，可以用它来作为 ::after伪元素的内容，并将其添加到每个 &lt;dd&gt;元素的尾部。 设置white-space: pre; 保留源代码中 的空白符和换行。 如果你的结构代码在多个连续的 &lt;dd&gt;之间包含了（未加 注释的）空白符，那么逗号前面会有一个空格。可以利用负外边距修复这个问 题，但如果你的内容是以不一样的字体和尺寸来 显示的， 这个空隙的宽度就 不一定刚好 是 0.25em 。 1234567891011121314151617181920212223dt, dd &#123; display: inline; margin: 0;&#125;dd &#123; font-weight: 600;&#125;dd + dt::before &#123; content: "\A"; white-space: pre;&#125;dd + dd::before &#123; content: ', '; font-weight: normal; margin-left: -.25em;&#125;body &#123; font: 150%/1.6 Baskerville, Palatino, serif;&#125; 1234567891011&lt;dl&gt; &lt;dt&gt;Name:&lt;/dt&gt; &lt;dd&gt;Lea Verou&lt;/dd&gt; &lt;dt&gt;Email:&lt;/dt&gt; &lt;dd&gt;lea@verou.me&lt;/dd&gt; &lt;dd&gt;leaverou@mit.edu&lt;/dd&gt; &lt;dt&gt;Location:&lt;/dt&gt; &lt;dd&gt;Earth&lt;/dd&gt;&lt;/dl&gt; 文本行的斑马条纹可以在 CSS 中用渐变直接生成背景图像，用 em 单位来设定背景尺寸，这样背景就可以自动适应 font-size 的变化了。 12345678910111213141516pre &#123; padding: .5em; /*创建出水平条纹背景。它的background-size需要设置为line-height的两倍，因为每个背景贴片需要覆盖两行代码。*/ line-height: 1.5em; background: hsl(20, 50%, 95%); background-image: linear-gradient( rgba(120,0,0,.1) 50%, transparent 0); background-size: auto 3em; /*让背景自动跟着内边距的宽度走*/ background-origin: content-box; font-family: Consolas, Monaco, monospace;&#125; 调整tab的宽度tab-size属性接受一个数字（表示字符数）或者一个长度值（这个不那么实用）来调整tab缩进尺寸。 连字font-variant-ligatures专门用来控制连字效果的开启和关闭。如果要启用所有可能的连字，需要同时指定这三个标识符： 1font-variant-ligatures: common-ligatures discretionary-ligatures historical-ligatures; 可以显式地把两种连字关闭： 1font-variant-ligatures: common-ligatures no-discretionary-ligatures no-historical-ligatures; 如果要把font- variant-ligatures属性复位为初始值，应该使用normal而不是none，none会把所有连字效果都关掉。 华丽的&amp;符号在 font-family 声明中同时指定多个字体（即字体队列 ）这样，即使我们指定的最优先字体不可用，浏览器还可以回退到其他符合整 体设计风格的字体。但是，很多开发者都忽略了一点：这个机制对单个字符 来说也是有效的。如果某款字体可用，但仅包括某几个字符，那它就只会用 来显示这几个字符；而在显示其他字符时，浏览器就会回退到其他字体。这 个规则对本地字体和通过 @font-face 规则引入的嵌入字体都是有效的。 @font-face 规则中的 src 描述符还可以接受 local() 函数，用于指定本地字体的名称。 1234567@font-face &#123; font-family: Ampersand; src: local ('Baskerville'), local ('Goudy Old Style'), local ('Garamond'), local ('Palatino'); &#125; unicode-range描述符只在@font-face规则内部生效（因此这里用了描述符这个术语；它并不是一个 CSS 属性），它可以把字体作用的字符范围限制在一个子集内。它对本地字体和远程字体都是有效的。 1unicode-range : U+26; 可以在控制台用下面语句查询字符的16进制Unicode码位： 1"&amp;".charCodeAt(0).toString(16); // 返回26 如果你想指定一个字符区间，还是要加上U+前缀， 比如U+400-4FF。 实际上对于这个区间来说， 你还可以使用通配符， 以这样的方式来写：U+4??。同时指定多个字符或多个区间也是允许的，把它们用逗号隔开即可， 比如U+26,U+4??, U+2665-2670 。 123456789@font-face &#123; font-family: Ampersand; src: local('Baskerville-Italic'), local('GoudyOldStyleT-Italic'), local('Garamond-Italic'), local('Palatino-Italic'); unicode-range: U+26;&#125;h1 &#123; font-family: Ampersand, Helvetica, sans-serif;&#125; 自定义下划线使用background-image及其相关属性生成下划线。可以设置两层与背景色相同的text-shadow来模拟下划线在遇到字母时会自动断开避让的效果： 123456a &#123; background: linear-gradient(gray, gray) no-repeat; background-size: 100% 1px; background-position: 0 1.02em; text-shadow: .05em 0 white, -.05em 0 white;&#125; 使用渐变来实现下划线的高明之处在于， 这些线条 极为灵活。比如生成虚线下划线： 12background: linear-gradient(90deg, gray 66%, transparent 0) repeat-x; background-size: .2em 2px;background-position: 0 1em; 现实中的文字效果凸版印刷效果出现在底部的浅色投影（或者出现在顶部的暗色投影）会让人 产生物体是凹进平面内的错觉。同理，出现在底部的暗色投影（或者出现在 顶部的浅色投影）会让人产生物体从平面上凸起的错觉。 空心字效果 使用多个 text-shadow ，分别为这些投影加上不同方向的少量偏移： 1234background: deeppink;color: white;text-shadow: 1px 1px black, -1px -1px black, 1px -1px black,-1px 1px black; 重叠多层轻微模糊的投影来模拟描边。这种方法不需要设置偏移量，但是性能较差，因为使用了模糊算法： 12345background: deeppink;color: white;text-shadow: 0 0 1px black, 0 0 1px black, 0 0 1px black, 0 0 1px black, 0 0 1px black, 0 0 1px black; SVG方案： 12345678910111213141516171819h1&#123; font: 500%/1 Rockwell, serif; background: deeppink; color: white;&#125;h1 text&#123; fill: currentcolor;&#125;h1 svg&#123; overflow: visible;&#125;h1 use&#123; stroke: black; stroke-width: 6; stroke-linejoin: round;&#125; 123456&lt;h1&gt; &lt;svg width="2em" height="1.2em"&gt; &lt;use xlink:href="#css"/&gt; &lt;text id="css" y="1em"&gt;css&lt;/text&gt; &lt;/svg&gt;&lt;/h1&gt; 文字外发光效果 通过几层重叠的 text-shadow，但是依赖 text-shadow 来实现文字显示的做法无法实 现平稳退化： 12345678910.p1 &#123; font: 250%/1.6 Baskerville, Palatino, serif; background: #203; color: white; transition: 1s;&#125;.p1:hover&#123; text-shadow: 0 0 .1em, 0 0 .3em;&#125; 使用 CSS 滤镜来实现文字的模糊效果： 12345678910.span3 &#123; font: 250%/1.6 Baskerville, Palatino, serif; background: #203; color: white; transition: 1s;&#125;.span3:hover&#123; filter: blur(.1em);&#125; 文字凸起效果使用一长串累加的投影， 不设模糊并以 1px 的跨度逐渐错开，使颜色逐渐变暗，然后在底部加一层强 烈模糊的暗投影，从而模拟完整的立体效果。 1234567891011.p1 &#123; font: 250%/1.6 Baskerville, Palatino, serif; background: #58a; color: white; text-shadow: 0 1px hsl(0,0%,85%), 0 2px hsl(0,0%,80%), 0 3px hsl(0,0%,75%), 0 4px hsl(0,0%,70%), 0 5px hsl(0,0%,65%), 0 5px black;&#125; 环形文字12345678910&lt;div class="circular"&gt; &lt;svg viewBox="0 0 100 100"&gt; &lt;path d="M 0,50 a 50,50 0 1,1 0,1 z" id="circle"/&gt; &lt;text&gt; &lt;textPath xlink:href="#circle"&gt; circular reasoning works because &lt;/textPath&gt; &lt;/text&gt; &lt;/svg&gt;&lt;/div&gt; M 0,50 ：移动到点 (0,50) 。 a 50,50 0 1,1 0,1 ：以当前所在的这个点为起点，以当前点右侧 0单位、下方 1 单位的那个点为终点， 画一段圆弧。这段圆弧的水平 半径和垂直半径都必须是 50。如果存在两种可能的圆弧度数，选择 度数较大的那一种；同时，如果存在两种可能的圆弧方向， 选择画 在这两个点右侧的那一种，而不是左侧的。 z ：用一条直线线段闭合这条路径。 通过 &lt;text&gt; 和 &lt;textPath&gt;元素来添加文本，并通过xlink:href属性来把它链接到这个圆上： 123456789101112131415161718.circular path &#123; fill: none;&#125;.circular &#123; width: 30em; height: 30em; /*把 SVG 元素自身往下推*/ margin: 3em auto 0;&#125;.circular svg &#123; display: block; /*取消把溢出内容裁切效果*/ overflow: visible;&#125; 用脚本遍历所有设置了 circular 类的元素，将其文本内容删除并保存在变量中，然后为其填入必要的 SVG 元素： 123&lt;div class="circular" &gt; circular reasoning works because &lt;/div&gt; 12345678910111213141516171819202122$$('.circular').forEach(function (el) &#123; var NS = "http://www.w3.org/2000/svg"; var xlinkNS = "http://www.w3.org/1999/xlink"; var svg = document.createElementNS(NS, "svg"); var circle = document.createElementNS(NS, "path"); var text = document.createElementNS(NS, "text"); var textPath = document.createElementNS(NS, "textPath"); svg.setAttribute("viewBox", "0 0 100 100"); circle.setAttribute("d", "M0,50 a50,50 0 1,1 0,1z"); circle.setAttribute("id", "circle"); textPath.textContent = el.textContent; textPath.setAttributeNS(xlinkNS, "xlink:href", "#circle"); text.appendChild(textPath); svg.appendChild(circle); svg.appendChild(text); el.textContent = ''; el.appendChild(svg);&#125;); 用户体验选择合适的鼠标光标提示禁用状态123:disabled , [ disabled ], [ aria - disabled ="true"] &#123; cursor : not-allowed; &#125; 隐藏鼠标光标在css2.1中需要用到一张 1×1 的透明 GIF 图片，然后cursor:url(&#39;transparent.gif&#39;); 在css3中只要：cursor: none;。 扩大可点击区域 Fitts 法则认为，人类移动到某个 目标区域所需的最短时间是由目标距离与目标宽度之比所构成的对数函数。 为按钮设置一圈透明边框： 123456789 border: 10px solid transparent; /*把背景限制在原本的区域内*/ background: #58a; background-clip: padding-box;/*用box-shadow模拟边框*/ box-shadow: 0 0 0 1px rgba(0,0,0,.3) inset; 通过伪元素代表其宿主元素来响应鼠标交互： 1234567891011121314151617181920.button1 &#123; position: relative; padding: .3em .5em; background: #58a; border-radius: 50%; border: 1px solid rgba(0,0,0,.3); box-shadow: 0 .1em .2em -.05em rgba(0,0,0,.5); color: white; font: bold 150%/1 sans-serif; cursor: pointer;&#125;.button1:before &#123; content: ''; position: absolute; /*伪元素在四个方向上都比宿主元素大出10px*/ top: -10px; right: -10px; bottom: -10px; left: -10px;&#125; 自定义复选框伪类选择符:checked和属性选择符[checked]的区别是：后者不会根据用户的交互行为进行更新，因为用户的交互不会影响到HTML标签上的属性。 可以基于复选框的勾选状态借助组合选择符来给其他元素设置样式。 123456789101112131415161718192021222324252627282930313233343536input[type="checkbox"] &#123; /*隐藏原始的复选框，不能使用display: none，这样会把它从tab键切换焦点的队列完全删除*/ position: absolute; clip: rect(0,0,0,0);&#125;/*设置紧邻input的label伪元素样式*/input[type="checkbox"] + label::before &#123; content: '\a0'; display: inline-block; vertical-align: .2em; width: .8em; height: .8em; margin-right: .2em; border-radius: .2em; background: silver; text-indent: .15em; line-height: .65;&#125;/*设置紧邻已经勾选的input的label伪元素的样式*/input[type="checkbox"]:checked + label::before &#123; content: '\2713'; background: yellowgreen;&#125;input[type="checkbox"]:focus + label::before &#123; box-shadow: 0 0 .1em .1em #58a;&#125;input[type="checkbox"]:disabled + label::before &#123; background: gray; box-shadow: none; color: #555; cursor: not-allowed;&#125; 12&lt;input type="checkbox" id="awesome" autofocus /&gt;&lt;label for="awesome"&gt;Awesome!&lt;/label&gt; 把&lt;label&gt;元素与复选框关联，让它起到触发开关的作用，为它添加生成性内 容（伪元素），并基于复选框的状态来为其设置样式。把真正 的复选框隐藏起来，再 把生成性内容美化一番，用来顶替原来的复选框。 开关式按钮用同样的思路可以实现开关式按钮： 123456789101112131415161718192021222324input[type="checkbox"] &#123; position: absolute; clip: rect(0,0,0,0);&#125;input[type="checkbox"] + label &#123; display: inline-block; padding: .35em .5em .2em; background: #ccc; background-image: linear-gradient(#ddd, #bbb); border: 1px solid rgba(0,0,0,.2); border-radius: .3em; box-shadow: 0 1px white inset; text-align: center; text-shadow: 0 1px 1px white; cursor: pointer;&#125;input[type="checkbox"]:checked + label,input[type="checkbox"]:active + label &#123; box-shadow: .04em .1em .2em rgba(0,0,0,.6) inset; border-color: rgba(0,0,0,.3); background: #bbb;&#125; 12&lt;input type="checkbox" id="awesome" autofocus /&gt;&lt;label for="awesome"&gt;Awesome!&lt;/label&gt; 在绝大多数场景下，开关式按钮 对可用性有负面作用，因为它们很容易与普通按钮混淆，让人误以为按下它 会触发某个动作。 通过阴影来弱化背景配合HTML实现1234567891011121314151617/*用于遮挡背景*/.overlay&#123; position: fixed; top: 0; right: 0; bottom: 0; left: 0; background: rgba(0,0,0,.8);&#125;/*需要吸引用户注意的元素*/.lightbox &#123; position: absolute; z-index: 1; top: 50%; left: 50%; margin: -200px;&#125; 这个方案需要增加额外的HTML，.overlay负责把这个关键元素背后的所有东西调暗。 伪元素方案123456789101112131415.lightbox::before &#123; position: fixed; top: 0; right: 0; bottom: 0; left: 0; z-index: -1; background: rgba(0, 0, 0, .8);&#125;.lightbox &#123; position: absolute; z-index: 1; top: 50%; left: 50%; margin: -200px;&#125; 这个方案没有成功~~~ box-shadow方案box-shadow的扩张参数可以把元素的投影向各个方 向延伸放大。具体做法就是生成一个巨大的投影，不偏移也不模糊，简单而 拙劣地模拟出遮罩层的效果： 1234567.lightbox &#123; position: fixed; top: 50%; left: 50%; margin: -200px; box-shadow: 0 0 0 50vmax rgba(0, 0, 0, .8);&#125; vmax是视口单位，1vmax相当于1vw和1vh两者中的较大值。100vw等于整 个视口的宽度，100vh就是视口的高度。因此，满足我们需求的最小值就是50vmax。 由于投影是同时向四个方向扩展的， 这个遮罩层的最终尺寸将是100vmax加上元素本身的尺寸。 这个方案的缺点是： 由于遮罩层的尺寸是与视口相关，而不是与页面相关的，当我们 滚动页面时，遮罩层的边缘就露出来了，除非给它加上position: fixed; 当使用一个独立的元素（或伪元素）来实现遮罩层时，这个遮罩 层不仅可以从视觉上把用户的注意力引导到关键元素上，还可以防止用户的 鼠标与页面的其他部分发生交互， 因为遮罩层会捕获所有指针事件。box- shadow并没有这种能力， 因此它只能在视觉上起到引导注意力的作用， 却 无法阻止鼠标交互。 backdrop方案&lt;dialog&gt;元素可以由它的showModal()方法显示出来。根据浏览器 的默认样式，它会自带一个遮罩层。借助::backdrop伪元素，这个原生的 遮罩层也是可以设置样式的，比如可以把它变得更暗一些： 123dialog::backdrop &#123; background: rgba(0,0,0,.8)&#125; 12345&lt;button onclick="document.querySelector('#modal').showModal()"&gt;Click me&lt;/button&gt;&lt;dialog id="modal"&gt; O HAI! &lt;button onclick="this.parentNode.close()"&gt;Close&lt;/button&gt;&lt;/dialog&gt; 浏览器对它的支持还极为有限。 通过模糊来弱化背景&lt;main&gt;元素它可以把页面中的主要内容标记出来（对话框通常都不是主要内 容），同时还给了我们添加样式的钩子。 12&lt;main&gt;.....&lt;/main&gt;&lt;dialog&gt;o hai&lt;/dialog&gt; 12345678main.de-emphasized &#123; -webkit-filter: blur(3px); filter: blur(3px);&#125;main &#123; transition: .6s; background: white;&#125; 可以通过contrast()和brightness()滤镜同时实现模糊效果和阴影效果来弱化背景： 1filter: blur(3px) contrast(.8) brightness(.8); 但是这个方法没有任何回退方案。 滚动提示background-attachment属性有三个值：scroll、fixed、local。scroll是默认值，背景图像会随着页面其余部分的滚动而移动。fixed表示页面的其余部分滚动背景图像不会移动。local表示背景相对于元素的内容固定。如果一个元素拥有滚动机制，背景将会随着元素的内容滚动， 并且背景的绘制区域和定位区域是相对于可滚动的区域而不是包含他们的边框。 达到上面动图的效果，需要用两层背景，一层用来生成那条阴影，另一层基本 上就是一个用来遮挡阴影的白色矩形，其作用类似于遮罩层。生成阴影的那 层背景将具有默认的 background-attachment值（scroll），因为我们希望 它总是保持在原位。 我们把遮罩背景的background-attachment属性设置 为local，这样它就会在我们滚动到最顶部时盖住阴影，在向下滚动时跟着 滚动，从而露出阴影。 123456789101112ul &#123; /*基本样式，让ul的高度小于内容的高度*/ display: inline-block; overflow: auto; width: 7.2em; height: 7em; border: 1px solid silver; padding: .3em .5em; list-style: none; margin-top: 2em; font: 100 200%/1.6 'Frutiger LT Std', sans-serif;&#125; 1234567891011121314151617181920212223242526.ul1 &#123; /*通过径向渐变生成顶部的阴影，但是生成的阴影出现的时机和我们期望的相反*/ background: radial-gradient(at top,rgba(0,0,0,.2), transparent 70%) no-repeat; background-size: 100% 15px; background-attachment: local;&#125;----------进化----------.ul2 &#123; /*通过线性渐变生成白色矩形来遮挡阴影*/ background: linear-gradient(white,white), radial-gradient(at top,rgba(0,0,0,.2), transparent 70%); background-repeat: no-repeat; background-size: 100% 15px; background-attachment: local,scroll;&#125;----------进化----------.ul3 &#123; /*生成底部的阴影和遮挡矩形，并且把白色矩形的渐变颜色改成linear-gradient(white,hsla(0,0%,100%,0))，这样可以让阴影的显现变得平滑*/ background: linear-gradient(white 15px, hsla(0,0%,100%,0)) 0 0 / 100% 50px, radial-gradient(at top, rgba(0,0,0,.2), transparent 70%) 0 0 / 100% 15px, linear-gradient(to top, white 15px, hsla(0,0%,100%,0)) bottom / 100% 50px, radial-gradient(at bottom, rgba(0,0,0,.2), transparent 70%) bottom / 100% 15px; background-repeat: no-repeat; background-attachment: local, scroll, local, scroll;&#125; 交互式的图片对比控件CSS resize方案resize属性控制元素是否能被用户缩放，有none、both、horizontal、vertical、block、inline这几个属性。其中：none表示元素不能被用户缩放。both表示允许用户在水平和垂直方向上调整元素的大小。horizontal表示允许用户在水平方向上调整元素的大小。vertical表示允许用户在垂直方向上调整元素的大小。如果一个block元素的 overflow 属性被设置成了visible，那么resize属性对该元素无效。 12345&lt;body&gt;&lt;div class="image-slider"&gt; &lt;div&gt;&lt;img src="http://csssecrets.io/images/adamcatlace-before.jpg" alt="Before" /&gt;&lt;/div&gt; &lt;img src="http://csssecrets.io/images/adamcatlace.jpg" /&gt;&lt;/div&gt; 12345678910111213141516.image-slider1 &#123; position:relative; display: inline-block;&#125;.image-slider1 &gt; div &#123; position: absolute; top: 0; bottom: 0; left: 0; width: 50%;/*设置初识宽度*/ overflow: hidden;/*剪裁图片*/ resize: horizontal;/*动态改变宽度*/&#125;.image-slider1 img &#123; display: block;&#125; 可以看到已经可以随心所欲的改变图片的宽度了，但是调节手柄不容易辨认，而且&lt;div&gt;的宽度拉伸超过了图片宽度的（可以注意动图最后右下角调节手柄的位置）。 超出图片宽度只要这样设置max-width: 100%。 调节手柄可以通过伪元素覆盖在调节手柄之上： 123456789101112.image-slider2 &gt; div:before &#123; content: ''; position: absolute; right: 0; bottom: 0; width: 12px; height: 12px; padding: 5px; background: linear-gradient(-45deg, white 50%, transparent 0); background-clip: content-box; cursor: ew-resize; -webkit-filter: drop-shadow(0 0 2px black); filter: drop-shadow(0 0 2px black);&#125; cursor: ew-resize;表示鼠标变成 这个方案对键盘来说是不可访问的。 范围输入控件方案将原生的滑块控件覆盖在图片上，通过js脚本将滑块移动和&lt;div&gt;的宽度联系起来，实现用控件控制的效果。 1234&lt;div class="image-slider3"&gt; &lt;img src="http://csssecrets.io/images/adamcatlace-before.jpg" alt="Before" /&gt; &lt;img src="http://csssecrets.io/images/adamcatlace.jpg" alt="After" /&gt;&lt;/div&gt; 12345678910111213141516171819202122$$('.image-slider3').forEach(function (slider) &#123; //创建附加的div元素，并用它包裹住第一个图片元素 var div = document.createElement("div"); var img = slider.querySelector("img"); slider.insertBefore(div,img); div.appendChild(img); //创建滑块 var range = document.createElement("input"); range.type = 'range'; //滑块和div宽度绑定 range.oninput = function () &#123; div.style.width = this.value + "%"; &#125;; slider.appendChild(range);&#125;);function $$(selector, context) &#123; context = context || document; var elements = context.querySelectorAll(selector); return Array.prototype.slice.call(elements);&#125; 1234567891011121314151617181920212223.image-slider3 &#123; position:relative; display: inline-block;&#125;.image-slider3 &gt; div &#123; position: absolute; top: 0; bottom: 0; left: 0; width: 50%;/*设置初识宽度*/ overflow: hidden;/*剪裁图片*/&#125;.image-slider3 img &#123; display: block; user-select: none;&#125;.image-slider3 input&#123; position: absolute; left: 0; bottom: 10px; width: 100%; margin: 0;&#125; 可以通过混合模式、滤镜和变形来优化控件： 12345678910111213.image-slider3 input&#123; position: absolute; left: 0; bottom: 10px; /*width: 100%;*/ margin: 0; width: 50%; filter: contrast(.5); mix-blend-mode: luminosity; transform: scale(2); transform-origin: left bottom;&#125; 结构与布局自适应内部元素width和height属性有一个新的关键字： min-content，这个关键字将解析为这个容器内部最大的不可断行元素的宽度（即最宽的单词、图片或者具有固定宽度的盒元素）： 12345678&lt;p&gt;Let’s assume we have some text here. Bacon ipsum dolor sit amet turkey veniam shankle, culpa short ribs kevin t-bone occaecat.&lt;/p&gt;&lt;figure&gt; &lt;img src="http://csssecrets.io/images/adamcatlace.jpg" /&gt; &lt;figcaption&gt; The great Sir Adam Catlace was named after Countess Ada Lovelace, the first programmer ever. &lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;We also have some more text here. Et laborum venison nostrud, ut veniam sint kielbasa ullamco pancetta.&lt;/p&gt; 1234567891011121314figure &#123; max-width: 300px;/*为了向下兼容*/ max-width: min-content; margin: auto;&#125;figure &gt; img &#123; max-width: inherit &#125;/* Basic styling */figure &#123; padding: 10px; border: 1px solid silver;&#125; width和height属性其他的值还有max-content，它的行为类似于display: inline-block；fit-content的行为与浮动元素是相同的（和min-content效果通常一致，但也有例外） 精确控制表格列宽table-layout属性有auto和fixed两个值： auto的行为模式被称为自动表格布局算法，会根据内容自动调整表格宽度。 fixed表示表和列宽度由表和元素的宽度或第一行单元格的宽度来设置。后续行中的单元格不会影响列宽度。 table-layout: fixed这种固定表格布局算法不仅更容易预测、便于使用，同时也明显更快。 因为表格的内容并不会影响单元格的宽度，所以在页面的下载过程中，表格 不需要频繁重绘。 在使用时，我们只需要对 &lt;table&gt;元素或其他具有display: table样 式的元素应用这个属性即可。 请注意， 为了确保这个技巧奏效， 需要为这 些表格元素指定一个宽度（哪怕是 100% ）。 同样， 为了让text-overflow: ellipsis发挥作用， 我们还需要为那一列指定宽度。 1234table&#123; table-layout: fixed; width: 100%;&#125; 根据兄弟元素的数量来设置样式:only-child可以用来定义只有一个子元素时的样式。等效于:first-child:last-child。:last-child相当于:nth-last-child(1)。 li:first-child:nth-last-child(4)表示一个正好有四个列表项的列表中的第一个列表项。如下图所示： 通过:first-child:nth-last-child()找到特定数量列表中的第一项，然后可以使用兄弟选择器~来命中它之后的所有兄弟元素，这样就达到了选定特定数量列表项中每个元素的目的： 1li:first-child:nth-last-child ( 4 ), li:first-child:nth-last-child ( 4 ) ~ li &#123; /* 当列表正好包含四项时，命中所有列表项 */ &#125; 根据兄弟元素的数量范围来匹配元素:nth-child()中的参数不仅可以是数字还可以是an+b这样的表达式。如果参数是n+b这样的表达式，不论n取何值，这个表达式无法产生小于b的值，因此n+b这个表达式可以选择从第b个元素开始的所有子元素。 同样n+b这个表达式也可以用在:nth-last-child ()上，这样可以在列表总数是b或者更多时选中所有列表项： 1li:first-child:nth-last-child ( n + 4 ), li:first-child:nth-last-child ( n + 4 ) ~ li &#123; /* 当列表至少包含四项时，命中所有列表项 */ &#125; -n+b表达式可以选中开头的b个元素。这样可以在列表总数是b或者更少时选中所有列表项： 1li:first-child:nth-last-child ( -n + 4 ), li:first-child:nth-last-child ( -n + 4 ) ~ li &#123; /* 当列表最多包含四项时，命中所有列表项 */ &#125; 这两个技巧还可以组合起来使用，比如在列表包含2~4个列表项时命中所有的列表项： 1li:first-child:nth-last-child ( n + 2 ) :nth-last-child ( -n + 4 ), li:first-child:nth-last-child ( n + 2 ) :nth-last-child ( -n + 4 ) ~ li &#123; /* 当列表包含2～4项时，命中所有列表项 */ &#125; 满幅的背景，定宽的内容calc()函数允许在css中直接进行简单的算式来指定属性的值。 别忘了在calc()函数中用 空白符把-和+隔起来，否则会 产生解析错误！这个看似怪异的规则是为了向前兼容，因为在未来，calc()可能会允许使用标识符， 而这些标识符本身可能会包含连字符，容易与减号混淆。 如果内容居中，左右外边距实际上都等于视口宽度的一半减去内容宽度的一半，而且使用calc()函数计算出的值可以用在任何一个接受长度值的属性上，所以可以这样写： 12345678910111213141516171819202122232425262728293031323334&lt;footer&gt; &lt;div class="wrapper"&gt; &lt;!--内容--&gt; &lt;/div&gt;&lt;/footer&gt; footer &#123; background: #333;&#125;.wrapper &#123; max-width:900px; margin:1em auto;&#125;-------升级-------&lt;footer&gt; &lt;!--内容--&gt;&lt;/footer&gt;footer &#123; max-width: 900px;/*这一行声明注释掉没影响，因为当内边距是 50% - 450px 时，只可能给内容留出 900px （2× 450px ）的可用空 间。 只有把 width 显式地设置为 900px 之外（或大或小）的其他值， 我们 才有可能看出区别。由于我们想要得到的内容宽度本来就是 900px ，这一行 声明其实就是冗余的，我们可以把它去掉*/ padding: 1em calc(50% - 450px); background: #333;&#125;-------升级-------&lt;footer&gt; &lt;!--内容--&gt;&lt;/footer&gt;footer &#123; padding: 1em; /*向后兼容，避免浏览器不支持calc()函数*/ padding: 1em calc(50% - 450px); background: #333;&#125; 垂直居中基于绝对定位的解决方案先把这个元素的左上角放置在视 口（或最近的、具有定位属性的祖先元素）的正中心，然后再利用负外边距 把它向左、向上移动（移动距离相当于它自身宽高的一半），从而把元素的 正中心放置在视口的正中心。借助calc()函数可以简化代码： 1234567891011121314151617.main1 &#123; position: absolute; top: 50%; left: 50%; margin-top: -5em; /*6/2=3*/ margin-left: -9em; /*18/2=9*/ width: 18em; height: 10em;&#125;-------升级-------.main1 &#123; position: absolute; left: calc(50% - 9em); top: calc(50% - 5em); width: 18em; height: 10em;&#125; 当我们在 translate() 变形函数中使用百分比值时，是以这个元素自身的宽度和高度 为基准进行换算和移动的，而这正是我们所需要的。接下来，只要换用基于 百分比的 CSS 变形来对元素进行偏移， 就不需要在偏移量中把元素的尺寸 写死了。 123456.main1 &#123; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);&#125; translate()用来移动元素在平面上的位置。这种变换的特点是一个向量，其坐标定义多少，它在每个方向移动多少。 这个方案有以下缺点： 需要绝对定位，对整个布局的影响太过强烈 如果需要居中的元素已经在高度上超过了视口，那它的顶部会被视 口裁切掉 在某些浏览器中，这个方法可能会导致元素的显示有一些模糊，因 为元素可能被放置在半个像素上。 这个问题可以用 transform- style: preserve-3d 来修复，不过很难保证它在未来不会出问题。 基于视口单位的解决方案原理和上面的方案一样，不过通过margin属性的百分比值来控制元素左上角位于容器的中心，然后再用translate()技巧来把元素以其自身高度宽高的一半为距离进行移动。 margin的百分比是以父元素的宽度作为解析基准的。 css3定义了一套与视口相关的长度单位： vw是与视口宽度相关的。1vw实际上表示视口宽度的1%，而不是100%。 1vh表示视口高度的1%。 当视口宽度小于高度时，1vmin等于1vw，否则等于1vh。 当视口宽度大于高度时，1vmax等于1vw，否则等于1vh。 123456.main2 &#123; width: 18em; padding: 1em 1.5em; margin: 50vh auto 0; transform: translate(-50%,-50%);&#125; 这个方案只适合在视口中居中的场景。 基于Flexbox的解决方案先给这个待居中元素的父元素设置display: flex（在这个例子中是&lt;body&gt;元素），再给这个元素自身设置margin: auto（在这个例子中是&lt;main&gt;元素）： 123456789body&#123; display: flex; min-height: 100vh; margin: 0;&#125;main &#123; margin: auto;&#125; 当我们使用 Flexbox 时，margin: auto不仅在水平方向上将元 素居中，垂直方向上也是如此。我们甚至不需要指定任何宽度（如果需要的话，也是可以指定的）：这个居中元素分配到的宽度等于max- content。 Flexbox 的另一个好处在于，它还可以将匿名容器（即没有被标签包裹 的文本节点）垂直居中。比如： 1&lt;main&gt;Center me,please!&lt;/main&gt; 1234567main &#123; display : flex; align-items : center; justify-content : center; width : 18em; height : 10em; &#125; justify-content用于设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式。align-items属性属性定义flex子项在flex容器的当前行的侧轴（纵轴）方向上的对齐方式。这意味着它像justify-content一样，但是在垂直方向。 align-self属性规定弹性盒子元素内被选中项目的对齐方式。直接用align-self: center就可以实现垂直居中。 紧贴底部的页脚固定高度的解决方案1234567891011&lt;header&gt; &lt;h1&gt;Site name&lt;/h1&gt;&lt;/header&gt;&lt;main&gt; &lt;input type="checkbox" id="contents" /&gt;&lt;label for="contents"&gt;Toggle contents&lt;/label&gt; &lt;p&gt;Bacon ipsum dolor ....&lt;/p&gt;&lt;/main&gt;&lt;footer&gt; &lt;p&gt;© 2015 No rights reserved.&lt;/p&gt; &lt;p&gt;Made with ♥ by an anonymous pastafarian.&lt;/p&gt;&lt;/footer&gt; 计算出页脚所占高度和大标题与最顶部的距离，然后让内容的最小高度为（视口高度-页脚所占高度-大标题与最顶部的距离）。 12345main &#123; min-height : calc(100vh - 2.5em - 7em); /* 避免内边距或边框搞乱高度的计算： */ box-sizing : border-box; &#125; 或者直接把&lt;header&gt;和&lt;main&gt;元素包在一个容器里面，这样只要计算页脚高度： 123#wrapper &#123; min-height: calc(100vh - 7em); &#125; 这套方案不仅要求我们确保页脚内的文本永远不会折行， 而且每当我们改变页脚的尺寸时，都需要跟着调整min-height值。 更灵活的解决方案对父元素设置display: ﬂex，当父元素获得这个属性之后，就可以对其 子元素触发“伸缩盒布局模型”。 我们还需要把ﬂex-ﬂow设置为column， 否则子元素会被水平排放在一行上。 要把父元素的min-height属性指 定为100vh，这样它就至少会占据整个视口的高度。不过此时各个子元素的高度仍然是以各自的内容为准的（按照 CSS 规 范的说法，它们的高度仍然由内部因素来决定）。只要给&lt;main&gt;这个容器的ﬂex属性指定一个大于 0 的值（比如 1 即可），内容区块的高度应该可以自动伸展并占满所有的可用空间。 12345678body &#123; display: flex; flex-direction: column; min-height: 100vh;&#125;main &#123; flex: 1;&#125; flex属 性 实 际 上 是flex-grow、flex-shrink和flex-basis的 简 写 语 法。 任 何 元素只要设置了一个大于 0 的flex值， 就将获得可伸缩的特 性；flex的值负责控制多个可伸 缩元素之间的尺寸分配比例。 举例来说，在上面的这个例子中， 如 果&lt;main&gt;是flex: 2而 &lt;footer&gt;是flex: 1，那么内容 区块的高度将是页脚高度的两倍。如果把它们的值从 2 和 1 改为 4和 2 ， 结果也是一样的， 因为真 正起作用的是它们的数值比例。 过渡与动画缓动效果弹跳动画所有过渡和动画都是跟一条曲线（缓动曲线）有关的，这条曲线指定了动画过程在整段时间中是如何推进的。如果不指定调速函数， 它就会得到一个默认值。这个默认的缓动效果并不是我们想像中的匀速效果，而是如下图所示的效果： 不 论 是在animation / transition简 写 属 性 中，还 是在animation- timing-function / transition-timing-function展开式属性中，ease都是是 默认值缓动曲线如上图。除此以外，还有四种内置的缓动曲线，你可以用它们来改变动画的推进方式： ease-out是ease-in是反向版本。 这一对组合正好是实现回弹效果所需要的：每当小球的运动方向相反时，我们希望调速函数也是相反的。 因此，我们可以在animation属性中指定一个通用的调速函数， 然后在关键帧中按需覆盖它。我们希望下落方向上的调速函数是加速的（ease- out），而弹起方向上是减速的（ease-in）： 12345678910111213141516@keyframes bounce &#123; 60%, 80%, to &#123; transform: translateY(400px); animation-timing-function: ease-out; &#125; 70% &#123; transform: translateY(300px); &#125; 90% &#123; transform: translateY(360px); &#125;&#125;.ball &#123; width: 0; height: 0; padding: 1.5em; border-radius: 50%; margin: auto; background: red radial-gradient(at 30% 30%, #fdd, red); animation: bounce 2s ease-in ;&#125; 所有这五种曲线都是通过（三次）贝塞尔曲线来指定的。这种曲线 由一定数量的路径片断所组成，各个片断的每一端都可以由一个手柄来控制曲率（这些手柄通常也被称作控制锚点）。一条复杂的曲线可能包含很多个 片断，这些片断的端点彼此相连构成了整条曲线。 作为对上述五种预定义曲线的补充，CSS 提供了cubic-bezier()函数，允许我们指定自定义的调速函数。它接受四个参数，分别代表两个控 制锚点的坐标值， 我们通过这两个控制锚点来指定想要的贝塞尔曲线。 语法形式是这样的：cubic-bezier(x1, y1, x2, y2)，其中( x 1 , y 1 )表示第一 个控制锚点的坐标， 而( x 2 , y 2 )是第二个。 曲线片断的两个端点分别固定在(0,0)和(1,1)，前者是整个过渡的起点（时间进度为零，动画进度为零）， 后者是终点（时间进度为 100%，动画进度为 100%）。两个控制锚点 的 x 值都被限制在 [0, 1] 区间内（即我们无法把手柄在水平方向上移出这个图形范围）。只要把控制锚点的水平坐标和垂直坐标互换， 就可以得到任何调速函数的反向版本。 下面的ease 等 同 于cubic-bezier(.25,.1,.25,1)，它的反向版本就是cubic- bezier(.1,.25,1,.25)： 12345678910111213141516@keyframes bounce &#123; 60%, 80%, to &#123; transform: translateY(400px); animation-timing-function: ease; &#125; 70% &#123; transform: translateY(300px); &#125; 90% &#123; transform: translateY(360px); &#125;&#125;.ball &#123; width: 0; height: 0; padding: 1.5em; border-radius: 50%; margin: auto; background: red radial-gradient(at 30% 30%, #fdd, red); animation: bounce 2s cubic-bezier(.1,.25,1,.25) forwards;&#125; 借助一款cubic-bezier.com的图形化工具，可以反复调整贝塞尔曲线，从而优化动画效果。 弹性过渡1234567&lt;label&gt; Your username: &lt;input value="leaverou"&gt;&lt;/input&gt; &lt;span class="callout"&gt; Only letters, numbers, underscores (_) and hyphens (-) allowed! &lt;/span&gt;&lt;/label&gt; 123456789101112131415161718192021222324input:not(:focus) + .callout &#123; transform: scale(0);&#125;.callout &#123; transition: .5s transform; transform-origin: 1.4em -.4em;&#125;---------升级到弹性过渡---------@keyframes elastic-grow &#123; from &#123;transform: scale(0)&#125; 70% &#123; transform: scale(1.1); animation-timing-function: cubic-bezier(.1,.25,1,.25); &#125;&#125;input:not(:focus) + .callout:not(:hover) &#123; transform: scale(0);&#125;input:focus + .callout &#123; animation: elastic-grow .5s;&#125; 上面的弹性过渡特效使用了动画，但是有点大材小用，还可以只用cubic-bezier()函数来实现。 曲线的控制锚点可以在垂直方向上突破 0~1 区间，从而让过渡达到低于0或高于100%的程度。它表示如果我们要从 scale(0) 的变形程度过渡到 scale(1) ，就还将经历一个比最终值更大的状 态，比如 scale(1.1) （或者更甚，这取决于调速函数有多陡）。 从上图可以看出，现在这个过渡会在总时长 50% 的时间点达到100%的变形程度。 不过， 过渡过程并不会停在那里；它会在超越最终值之后继 续推进， 在 70% 的时间点达到 110% 的变形程度峰值， 然后在最后可用的 30% 时间里过渡回它的最终值。 可见， 整个过渡的推进过程非常接近前面 的动画方案，但它只需要一行代码就可以实现整个效果： 1234567input:not(:focus) + .callout &#123; transform: scale(0);&#125;.callout &#123; transition: .5s cubic-bezier(.25,.1,.3,1.5); transform-origin: 1.4em -.4em;&#125; 当我们把焦点从输入框中切出去的时候，所触发 的过渡会以scale(1)作为起始值， 并以scale(0)作为最终值。 由于此时 是相同的调速函数在起作用，这个过渡仍然会在 350ms 后到达110%的变形 程度。只不过在这里，110% 变形程度的解析结果并不是 scale(1.1)，而是scale(-0.1)，这样就会出现下面的效果： 修复这个问题不过是多加一行代码而已。假设我们 只想给提示框的关闭过程指定普通的 ease 调速函数，那么可以在定义关闭 状态的 CSS 规则中把当前的调速函数覆盖掉： 12345678input:not(:focus) + .callout &#123; transform: scale(0); transition-timing-function: ease;&#125;.callout &#123; transition: .5s cubic-bezier(.25,.1,.3,1.5); transform-origin: 1.4em -.4em;&#125; 但是此时提示框的关闭动作明显要迟钝一 些。这是因为在提示框的展开过程中，当时间 进行到 50% 时（即 250ms 之后）， 它就已经达到 100% 的完整尺寸了。 但 在收缩的过程中，从 0 到 100% 的变化会花费我们为过渡所指定的所有时间 （500ms），因此感觉上会慢一半。要修复这个问题，只需同时覆盖过渡的持续时间即可，我们既可以单独 覆盖transition-duration这一个属性，也可以用transition这个简写属 性来覆盖所有的值。如果选择后者的话，就不需要显式指定 ease 了： 12345678input:not(:focus) + .callout &#123; transform: scale(0); transition: .25s;&#125;.callout &#123; transition: .5s cubic-bezier(.25,.1,.3,1.5); transform-origin: 1.4em -.4em;&#125; 在对颜色属性的弹性过渡中，由于RGB三个通道的值是独立进行插值运算的， 因此这个过渡过程中可能会产生其他颜色，为避免不小心对颜色设置了弹性过渡， 可以尝试 把过渡的作用范围 限制在某几种特定的属性上。当我们在transition简写属性中不指定任何属性时，transition-property就会得 到它的初始值：all。这意味着只要是可以过渡的属性，都会参与过渡。因 此，如果我们以后在提示框打开状态的样式规则中增加一行 background声明，那么弹性过渡也会作用在这个属性上。 12345678input:not(:focus) + .callout &#123; transform: scale(0); transition: .25s transform;&#125;.callout &#123; transition: .5s cubic-bezier(.25,.1,.3,1.5) transform; transform-origin: 1.4em -.4em;&#125; 可以通过transition-delay属 性把各个属性的过渡过程排成列队， 这个 属性的值实际上就是transition简写属性中的第二个时间值。 举例 来 说， 如 果width和height都需要过渡效果， 而且你希望高 度先变化然后宽度再变化， 就可以这样 写：transition: .5s height, .8s .5s width;（ 也 就 是 说， 让 width过渡的延时正好等于height过渡的持续时间）。 逐帧动画1&lt;div class="loader"&gt;Loading…&lt;/div&gt; 12345678910@keyframes loader &#123; to &#123; background-position: -800px 0; &#125;&#125;.loader &#123; width: 100px; height: 100px; animation: loader 1s infinite linear; text-indent: 999px; overflow: hidden; /* Hide text */ background: url(http://dabblet.com/img/loader.png) 0 0;&#125; 这种通过应用各种不同的background-position值的方法会显示帧与帧之间的动画： 这时候可以采用steps()调速函数，而不是基于贝塞尔曲线的调速函数。 所有基于贝塞尔曲线的调速函数都会在关键帧之间进行插值运算，从而产生平滑的过渡效果。在通常情况下，平滑的过渡是我们使用 CSS 过渡和动画的原因。 但在眼前的场景下， 这种平滑特性恰恰毁 掉了我们想实现的逐帧动画效果。 与贝塞尔曲线调速函数迥然不同的是，steps()会根据你指定的步进数量（在这个例子中就是动画的帧数），把整个动画切分为多帧，而且整个动画会在帧与帧之间硬切，不会做任何插值处理。 123456.loader &#123; width: 100px; height: 100px; text-indent: 999px; overflow: hidden; /* Hide text */ background: url(http://dabblet.com/img/loader.png) 0 0; animation: loader 1s infinite steps(8);&#125; steps()还接受可选的第二个参数， 其值可以是start或end（默认值）。这个参数用于指定动画在每个循环周期的什么位置发生帧的切换动作，但实际上这个参数用得并不 多。 如果我们只需要一个单步切换效果， 还可以使用step-start和step- end这样的简写属性，它们分别等同于steps(1, start)和steps(1, end)。 对steps(1, start)和steps(1, end)的理解可以参照闪烁效果中的例子 闪烁效果1234567891011@keyframes blink-1 &#123; to &#123; color: transparent &#125; &#125;.blink-smooth-1 &#123; animation: 1s blink-1 3;&#125;----------升级----------@keyframes blink-2 &#123; 50% &#123; color: transparent &#125; &#125;.blink-smooth-2 &#123; animation: 1s blink-1 3;&#125; 下图中，.blink-smooth-1对应第二个闪烁图，.blink-smooth-2对应第一个闪烁图。 通过修改关键帧，让状态切换发生在每个循环周期的中间。 animation-direction的唯一作用就是反转每一个循环周期（reverse），或第偶数个循环周期（alternate），或第奇数个循环周期（alternate-reverse）。它的伟大之处在于，它会同时反转调整函数 ，从而产生更加逼真的动画效果。 12345@keyframes blink-2 &#123; to &#123; color: transparent &#125; &#125;.blink-smooth-2 &#123; animation: .5s blink-1 6 alternate;&#125; 必须把动画循环的次数翻倍（而不是像前面的方法那样把循环周期的时间长度翻倍），因为现在一次淡入淡出的过程是由两个循环周 期组成的。基于同样的原因，我们也要把animation-duration减半。 如果用steps()函数来实现: 12345@keyframes blink &#123; to &#123; color: transparent &#125; .blink &#123; animation: 1s blink 3 steps(1);&#125; 此时文字不会闪烁，因为steps(1)本质上等同于steps(1, end)， 它表示当前颜色与transparent之间的过渡会在一次步进中完成，于是颜色值的切换只会发生在动画周期的末尾。因此，我们会看到起始值贯穿于整个动画周期，而终止值只在 动画结尾的无限短的时间点处出现。如果我们改用steps(1, start)，结果 就完全相反了：颜色值的切换会发生在动画周期最开始，于是我们始终只能 看到纯透明的文字，没有任何动画或闪烁效果。 我们接下来可以换用steps(2)来碰碰运气，两种步进方式（start或end）都可以试一下。现在我们终于可以看到闪烁效果了， 但这个闪烁效果要么是由半透明切到纯透明，要么是由半透明切到实色，原因同上。由于我们无法通过配置steps()来让这个切换动作发生在动画周期 的中间点（只能发生在起点或终点），唯一的解决方案是调整动画的关键帧， 让切换动作发生在 50% 处，就像我们在本节刚开始所做的那样： 1234567891011@keyframes blink-1 &#123; to &#123; color: transparent &#125; .blink1 &#123; animation: 1s blink-1 3 steps(2);&#125;----------升级----------@keyframes blink-2 &#123; 50% &#123; color: transparent &#125; .blink2 &#123; animation: 1s blink-2 3 steps(1);&#125; 上图第一个对应的是blink-1的效果，第二个对应的是blink-2的效果。 打字动画核心思路就是让容器的宽度成为动画的主体：把所有文本包裹在这个容 器中，然后让它的宽度从 0 开始以步进动画的方式、一个字一个字地扩张到 它应有的宽度。这个方法并不适用于多行文本。 动画的持续时间越长，动画效果越差：持续时间较短的动画会让界面显得更加精致。反之，动画的持续时间越长，越容易让用户感到厌烦。因此，即使这个 技巧可以用在大段文本身上，也不一定是个好主意。 需要用white-space: nowrap;来阻止文本折行，否则文本的行数会随着宽度的扩张不断变化。 用overﬂow: hidden;， 裁切超出宽度的文本。 用steps()来达到动画逐字呈现的效果，而不是平滑连贯的。 1&lt;h1&gt;CSS is awesome!&lt;/h1&gt; 1234567891011@keyframes typing &#123; from &#123; width: 0 &#125;&#125;h1 &#123; font: bold 200% Consolas, Monaco, monospace; width: 7.7em; white-space: nowrap; overﬂow: hidden; animation: typing 8s steps(15),&#125; 此时的效果如下： 用em指定宽度显然效果不好，可以用ch来解决这个问题。 ch表示“0” 字形的宽度，是CSS值与单位（第三版）规范引入的一个新单位。在绝大多数场景下， 我们并不关心0这个字符显示出来到底有多宽。但对等宽字体来说，这是个 例外。在等宽字体中，“0”字形的宽度和其他所有字形的宽度是一样的。因 此，如果我们用 ch 单位来表达这个标题的宽度，那取值实际上就是字符的数量。 1234567891011@keyframes typing &#123; from &#123; width: 0 &#125;&#125;h1 &#123; font: bold 200% Consolas, Monaco, monospace; width: 15ch; white-space: nowrap; overﬂow: hidden; animation: typing 8s steps(15),&#125; 在这个例子中，可以用一个伪元素来生成光标，并通过opacity属性来实现闪烁效果；我们也可以用右边框来模拟 光标效果，这样就可以把有限的伪元素资源节省下来留作他用。光标的闪烁动画是需要无限循环的（即使所有的文字都显示完整之后仍然如此）， 因此需要用到 inﬁnite 关键字。 1234567891011121314151617@keyframes typing &#123; from &#123; width: 0 &#125;&#125;@keyframes caret &#123; 50% &#123; border-right-color: transparent; &#125;&#125;h1 &#123; font: bold 200% Consolas, Monaco, monospace; width: 15ch; white-space: nowrap; overflow: hidden; border-right: .05em solid; animation: typing 8s steps(15), caret 1s steps(1) infinite;&#125; 由于需要根据每 个标题的字数来给它们分别指定不同的宽度样式， 而且还需要在每次改变标题内容时同步更新这些宽度样式，所有可以用一段JavaScript代码来实现： 123456789function $$(expr, con) &#123; return [].slice.call((con || document).querySelectorAll(expr));&#125;$$('h1').forEach(function (h1) &#123; var len = h1.textContent.length, s = h1.style; s.width = len + 'ch'; s.animationTimingFunction = "steps(" + len + "),steps(1)";&#125;); 状态平滑的动画让背景的background-position属性值从原本的0 0一直变化到100% 0时，我们就会看到这张图片从左侧一直滚动到右侧的完整过程。 12345678910@keyframes panoramic &#123; to &#123; background-position: 100% 0; &#125;&#125;.panoramic &#123; width: 150px; height: 150px; background: url('http://c3.staticflickr.com/3/2671/3904743709_74bc76d5ac_b.jpg'); background-size: auto 100%; animation: panoramic 10s linear infinite alternate;&#125; 接下来实现当用户鼠标悬停时才开始播放的效果： 12345678910111213@keyframes panoramic &#123; to &#123; background-position: 100% 0; &#125;&#125;.panoramic &#123; width: 150px; height: 150px; background: url('http://c3.staticflickr.com/3/2671/3904743709_74bc76d5ac_b.jpg'); background-size: auto 100%;&#125;.panoramic:hover, .panoramic:focus &#123; animation: panoramic 10s linear infinite alternate;&#125; 这时候当我们把鼠标移出图片时，它就会生硬地跳回最左侧。为了修复这个问题，我们需要换个角度来思考：我们在这里到底想要实 现什么样的结果。我们需要的并不是在:hover时应用一个动画，因为这意 味着动画被中断时的状态是无处保存的。我们需要的是当失去 :hover 状态 时暂停动画。有一个属性正好是为暂停动画的需求专门设计的：animation-play-state。 123456789101112131415@keyframes panoramic &#123; to &#123; background-position: 100% 0; &#125;&#125;.panoramic &#123; width: 150px; height: 150px; background: url('http://c3.staticflickr.com/3/2671/3904743709_74bc76d5ac_b.jpg'); background-size: auto 100%; animation: panoramic 10s linear infinite alternate; animation-play-state: paused;&#125;.panoramic:hover, .panoramic:focus &#123; animation-play-state: running;&#125; 沿环形路径平移的动画123&lt;div class="path"&gt; &lt;img src="http://lea.verou.me/book/adamcatlace.jpg" /&gt;&lt;/div&gt; 1234567@keyframes spin &#123; to &#123; transform: rotate(1turn); &#125;&#125;.avatar &#123; animation: spin 3s infinite linear; transform-origin: 50% 150px; /*150px = 路径的半径*/&#125; 这段代码不仅让头像沿着环形路径转动，同时还会让头像自身旋转。如果有文字的话，那文字也会是颠倒的，这在可读性方面可是一个严重的问题。因此我们希望它只是沿着环形进行移动，同时保持自己本来的朝向。 需要两个元素的解决方案最主要的思路 与“平行四边形” 或者“菱形图片” 中提到的“嵌套的两层变形会相互抵 消”如出一辙：用内层的变形来抵消外层的变形效果。这时需要给图片套上额外的div： 12345&lt;div class="path"&gt; &lt;div class="avatar"&gt; &lt;img class="avatar" src="http://lea.verou.me/book/adamcatlace.jpg" /&gt; &lt;/div&gt;&lt;/div&gt; 然后只需把头像的动画设置为相反的角度范围（ 360-0deg ） 即可： 123456789101112131415@keyframes spin &#123; to &#123; transform : rotate(1turn); &#125; &#125; @keyframes spin-reverse &#123; from &#123; transform : rotate(1turn); &#125; &#125;.avatar &#123; animation : spin 3s infinite linear; transform-origin : 50% 150px; /* 150px = 路径的半径 */ &#125;.avatar &gt; img &#123; animation : spin-reverse 3s infinite linear;&#125; 上面代码中animation的参数重复了两次，可以让内层动画从父元素那里继承所有的动画属性，然后把动画名覆盖掉。 如果只是为了反转第一套动画，就又建了一套新动画， 有点浪费。可以用在“闪烁效果”中所提到的animation-direction属性的reverse值得到原始动画的反向版本。 12345678910111213@keyframes spin &#123; to &#123; transform : rotate(1turn); &#125; &#125;.avatar &#123; animation : spin 3s infinite linear; transform-origin : 50% 150px; /* 150px = 路径的半径 */ &#125;.avatar &gt; img &#123; animation : inherit; animation-direction: reverse;&#125; 单个元素的解决方案transform-origin只是一个语法糖而已。实际上你总是可以用translate()来代替它 每 个transform-origin都是可以被两个translate()模拟出来的。比如，下面两段代码实际上是等效的： 1234567transform : rotate(30deg); transform-origin : 200px 300px;transform : translate(200px, 300px) rotate(30deg) translate(-200px, -300px); transform-origin : 0 0; 这是因为，变形函数并不是彼此独立的。每个变形函数并不是只对这个元素进行变形， 而且会把整个元素的坐标系统进行变形， 从而影响所有后续的变形操作。这也说明了为什么变形函数的顺序是很重要的，变形属性中不同函数的顺序如果被打乱， 可能会产生完全不同的结果。 借助这个思路，基于同一个transform-origin来实现前面用到的两个旋转动画： 1234567891011121314151617181920212223242526272829303132333435@keyframes spin &#123; from &#123; transform : translate(50%, 150px) rotate(0turn) translate(-50%, -150px); &#125; to &#123; transform : translate(50%, 150px) rotate(1turn) translate(-50%, -150px); &#125;&#125;@keyframes spin-reverse &#123; from &#123; transform : translate(50%, 50%) rotate(1turn) translate(-50%, -50%); &#125; to &#123; transform : translate(50%, 50%) rotate(0turn) translate(-50%, -50%); &#125;&#125;.avatar &#123; animation: spin 3s infinite linear;&#125;.avatar &gt; img &#123; animation: inherit; animation-name: spin-reverse;&#125; 因为现在所有变形函数都是使用一个起点，可以把两套动画合成一套，这时候就不需要两层div来实现了： 12345678910111213141516171819202122@keyframes spin &#123; from &#123; transform : translate(50%, 150px) rotate(0turn) translate(-50%, -150px) translate(50%, 50%) rotate(1turn) translate(-50%, -50%); &#125; to &#123; transform : translate(50%, 150px) rotate(1turn) translate(-50%, -150px) translate(50%, 50%) rotate(0turn) translate(-50%, -50%);; &#125;&#125;.avatar &#123; animation: spin 3s infinite linear;&#125; 上面代码还可以把连续的translate()变形操作合并起来， translate(-50%, -150px)和 translate(50%, 50%)在水平方向上的位移可以抵消，相当于我们只在 Y 轴上做了两次位移操作translateY(-150px) translateY(50%)： 12345678910111213141516171819202122@keyframes spin &#123; from &#123; transform : translateY(150px) translateY(-50%) rotate(0turn) translateY(-150px) translateY(50%) rotate(1turn) &#125; to &#123; transform : translateY(150px) translateY(-50%);; rotate(1turn) translateY(-150px) translateY(50%) rotate(0turn) &#125;&#125;.avatar &#123; animation: spin 3s infinite linear;&#125; 如果把头像放在圆心并以此作为起点，就可以消除最开始的那两个位移操作了，而实际上这两个位移在本质上所做的就是把它放在圆心。 123456789101112131415161718@keyframes spin &#123; from &#123; transform : rotate(0turn) translateY(-150px) translateY(50%) rotate(1turn) &#125; to &#123; transform : rotate(1turn) translateY(-150px) translateY(50%) rotate(0turn) &#125;&#125;.avatar &#123; animation: spin 3s infinite linear;&#125;]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端基础知识]]></title>
    <url>%2F2017%2F03%2F24%2F%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[HTML初级 介绍一下你对浏览器内核的理解？ 简述一下你对HTML语义化的理解？ html5有哪些新特性、移除了那些元素？ 中级 页面导入样式时，使用link和@import有什么区别？ 为什么通常推荐将 CSS &lt;link&gt; 放置在 &lt;head&gt;&lt;/head&gt; 之间，而将 JS &lt;script&gt; 放置在 &lt;/body&gt; 之前？你知道有哪些例外吗？ 高级 如何实现浏览器内多个标签页之间的通信? 请描述一下 cookies，sessionStorage 和 localStorage 的区别？ CSS初级 css的position属性有哪些取值，它们的行为是什么？ css哪些属性可以继承，哪些属性不可继承？ 清除浮动的几种方法？ css居中常用的方法（垂直、水平和同时水平垂直居中）。 请解释你对盒模型的理解，以及如何在 CSS 中告诉浏览器使用不同的盒模型来渲染你的布局。 中级 px、em、rem的区别。 什么是CSS 预处理器 / 后处理器？ li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？ ::after 和:after中双冒号和单冒号有什么区别，在css3中这两个属性有什么区别？ 什么叫优雅降级和渐进增强？ 响应式设计 (responsive design) 和自适应设计 (adaptive design)有什么 不同？ 解释下 CSS sprites，以及你要如何在页面或网站中使用它。 高级 用css实现多重边框，如下图所示： 用css实现自定义复选框，如下图所示: ​ JavaScript初级 DOM元素的property与attribute都可以翻译成属性，那两者有什么的区别？ 123456var a = false;var b = "";if (a == b)&#123; alert("a = b");&#125;输出结果是什么？为什么？ Javascript如何实现继承？ 谈谈This对象的理解。 什么是事件冒泡?事件冒泡有什么作用? 请解释事件委托（或者事件代理） 解释一下捕获型事件和冒泡型事件。 什么是闭包（closure），为什么要用它？ javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？ 请解释什么是单页应用 (single page app), 以及如何使其对搜索引擎友好 (SEO-friendly)。 中级 Javascript作用链域? JavaScript原型，原型链 ? 有什么特点？ 123456789function add(a,b)&#123; alert(a+b); &#125;function sub(a,b) &#123; alert(a-b); &#125;add.call(sub,3,1);这个函数最后输出结果是什么？为什么？ 123456var v = "hello";(function()&#123; console.log(v); var v = "world";&#125;)();上面两段代码分别输出什么？为什么？ js延迟加载的方式有哪些？ 你知道有哪些性能优化的方法？ HTTP状态码有哪些，都是什么含义？ Ajax 是什么? 如何创建一个Ajax？ 使用 Ajax 都有哪些优劣？ AJAX注意点及适用和不适用场景 高级 关于Http 2.0 你知道多少？ 网站重构的理解？ AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？ Object.is() 与原来的比较操作符“ ===”、“ ==”的区别？ 什么是指内存泄露，哪些操作会造成内存泄漏？ js如何操作获取和设置cookie 听说过PWA（Progressive Web App）吗？有哪些优点？ 答案HTML初级 主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。 JS引擎则：解析和执行javascript来实现网页的动态效果。 最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。 用正确的标签做正确的事情。html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。 HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。 1234567绘画 canvas;用于媒介回放的 video 和 audio 元素;本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;sessionStorage 的数据在浏览器关闭后自动删除;语意化更好的内容元素，比如 article、footer、header、nav、section;表单控件，calendar、date、time、email、url、search;新的技术webworker, websocket, Geolocation; 移除的元素： 12纯表现的元素：basefont，big，center，font, s，strike，tt，u;对可用性产生负面影响的元素：frame，frameset，noframes； 中级 link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS;页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题。 浏览器从上到下依次解析html文档。将 css 文件放到头部， css 文件可以先加载。避免先加载 body 内容，导致页面一开始样式错乱，然后闪烁。将 javascript 文件放到底部是因为：若将 javascript 文件放到 head 里面，就意味着必须等到所有的 javascript 代码都被 下载、解析和执行完成 之后才开始呈现页面内容。这样就会造成呈现页面时出现明显的延迟，窗口一片空白。为避免这样的问题一般将全部 javascript 文件放到 body 元素中页面内容的后面。 一般希望DOM还没加载必须需要先加载的js会放置在&lt;head&gt;中,有些加了defer、async的&lt;script&gt;也会放在&lt;head&gt;中。 高级 WebSocket、SharedWorker；也可以调用localstorge、cookies等本地存储方式； localstorge另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，我们通过监听事件，控制它的值来进行页面信息通信。 cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。 存储大小： 12cookie数据大小不能超过4k。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。 有期时间： 123localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage 数据在当前浏览器窗口关闭后自动删除。cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭 CSS初级 (这个问题的答案很基础，但是这个问题可以问的很深入，可以筛选从初级到高级前端工程师，参考：https://github.com/wintercn/blog/issues/4) postision：static；始终处于文档流给予的位置。看起来好像没有用，但它可以快速取消定位，让top，right，bottom，left的值失效。 position：relative和absolute都可以用于定位，区别在于前者的div还属于正常的文档流，后者已经是脱离了正常文档流，不占据空间位置，不会将父类撑开。定位原点relative是相对于它在正常流中的默认位置偏移，它原本占据的空间任然保留；absolute相对于第一个position属性值不为static的父类。所以设置了position：absolute，其父类的该属性值要注意，而且overflow：hidden也不能乱设置，因为不属于正常文档流，不会占据父类的高度，也就不会有滚动条。 fixed旧版本IE不支持，却是很有用，定位原点相对于浏览器窗口，而且不能变。常用于header，footer，或者一些固定的悬浮div，随滚动条滚动又稳定又流畅，比JS好多了。fixed可以有很多创造性的布局和作用，兼容性是问题。 可继承的样式：font-size font-family color, text-indent; 不可继承的样式：border padding margin width height ; 12345678910111，额外标签，&lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt;（缺点：不过这个办法会增加额外的标签使HTML结构看起来不够简洁。）2，使用after伪类#parent:after&#123; content:&quot;.&quot;; height:0; visibility:hidden; display:block; clear:both; &#125;3,浮动外部元素4,设置overflow为hidden或者auto 水平居中： 12内联元素水平居中：text-align: center;块级元素水平居中：margin: 0 auto;同时还要设置width 垂直居中： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849内联元素:设置相等的上下padding，或者单行文本可以利用line-height和height相等来实现;块级元素： 1、若元素有固定高度 .parent &#123; position: relative; &#125; .child &#123; position: absolute; top: 50%; height: 100px; margin-top: -50px; /* 如果没有使用: border-box; 的盒子模型则需要设置这个 */ &#125; 2、如果不知道元素高度 .parent &#123; position: relative; &#125; .child &#123; position: absolute; top: 50%; transform: translateY(-50%); &#125; 3、用flexbox &lt;main&gt; &lt;div&gt; I'm ok. &lt;/div&gt; &lt;/main&gt; body &#123; background: #f06d06; font-size: 80%; &#125; main &#123; background: white; height: 300px; width: 200px; padding: 20px; margin: 20px; display: flex; flex-direction: column; justify-content: center; resize: vertical; overflow: auto; &#125; main div &#123; background: black; color: white; padding: 20px; resize: vertical; overflow: auto; &#125; 同时水平和垂直居中： 1234567891011121314151617181920212223元素有固定高度和宽度：先绝对居中，然后上移和左移50%的宽度即可: .parent &#123; position: relative; &#125; .child &#123; width: 300px; height: 100px; padding: 20px; position: absolute; top: 50%; left: 50%; margin: -70px 0 0 -170px; &#125;元素的高度和宽度未知或可变的：使用transofrm属性在两个方向都平移负50%: .parent &#123; position: relative; &#125; .child &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); &#125; ​ 盒模型包括margin、border、padding和content，W3C的标准是width和height就是content的宽和高，而IE默认盒模型的width和height是包含了border、padding和content的。 box-sizing：content-box（w3c标准盒模型），border-box（IE类盒模型）。 中级 Px是一个绝对字体大小，em则是基于基数（比如：1.5em）来计算出来的相对字体大小。这个基数是需要乘以当前对象从其父级遗传字体大小。rem是基于根节点（比如html）的字体大小进行计算的。 预处理器例如：LESS、Sass、Stylus，用来预编译Sass或less，增强了css代码的复用性，还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。 后处理器例如：PostCSS，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的是给CSS属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。 行框的排列会受到中间空白（回车\空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了。 单冒号:用于伪类，双冒号::用于伪元素。 伪类是为了通过选择器找到那些不存在与DOM树中的信息以及不能被常规CSS选择器获取到的信息，伪类本质上是为了弥补常规CSS选择器的不足，以便获取到更多信息。 伪元素在DOM树中创建了一些抽象元素，这些抽象元素是不存在于文档语言里的，伪元素本质上是创建了一个有内容的虚拟容器。 可以同时使用多个伪类，但是一个选择器只能使用一个伪元素，并且伪元素必须处于选择器语句的最后。 优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了,为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效. 渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。 Responsive design (响应式设计)：建立一个网页，通过CSS Media Queries，Content－Based Breakpoint（基于内容的断点）等技术来改变网页的大小以适应不同分辨率的屏幕。 Adaptive design (自适应设计)：为不同类别的设备建立不同的网页，检测到设备分辨率大小后调用相应的网页。目前AWD网页主要针对这几种分辨率（320，480，760，960，1200，1600） CSS Sprites其实就是把网页中一些背景图片整合到一张图片文件中，再利用CSS的background-image，background- repeat，background-position的组合进行背景定位，background-position可以用数字能精确的定位出背景图片的位置。这样可以减少很多图片请求的开销，因为请求耗时比较长；请求虽然可以并发，但是也有限制，一般浏览器都是6个。对于未来而言，就不需要这样做了，因为有了http2。 高级 123456789#div1 &#123; width: 100px; height: 60px; margin: 25px; background: yellowgreen; box-shadow: 0 0 0 10px #655, 0 0 0 15px deeppink, 0 2px 5px 15px rgba(0,0,0,.6);&#125; 把&lt;label&gt;元素与复选框关联，让它起到触发开关的作用，为它添加生成性内 容（伪元素），并基于复选框的状态来为其设置样式。把真正 的复选框隐藏起来，再 把生成性内容美化一番，用来顶替原来的复选框。 123456789101112131415161718192021222324252627282930313233343536input[type="checkbox"] &#123; /*隐藏原始的复选框，不能使用display: none，这样会把它从tab键切换焦点的队列完全删除*/ position: absolute; clip: rect(0,0,0,0);&#125;/*设置紧邻input的label伪元素样式*/input[type="checkbox"] + label::before &#123; content: '\a0'; display: inline-block; vertical-align: .2em; width: .8em; height: .8em; margin-right: .2em; border-radius: .2em; background: silver; text-indent: .15em; line-height: .65;&#125;/*设置紧邻已经勾选的input的label伪元素的样式*/input[type="checkbox"]:checked + label::before &#123; content: '\2713'; background: yellowgreen;&#125;input[type="checkbox"]:focus + label::before &#123; box-shadow: 0 0 .1em .1em #58a;&#125;input[type="checkbox"]:disabled + label::before &#123; background: gray; box-shadow: none; color: #555; cursor: not-allowed;&#125; 12&lt;input type="checkbox" id="awesome" autofocus /&gt;&lt;label for="awesome"&gt;Awesome!&lt;/label&gt; JavaScript初级 property是DOM中的属性，是JavaScript里的对象；attribute是HTML标签上的特性，它的值只能够是字符串。attributes是属于property的一个子集，它保存了HTML标签上定义property。 输出true，JavaScript中，==并不表示严格相等，因为==认为空字符串与false的含义相同。要进行严格比较，就要使用另一种等号：===。这个全等操作符会执行严格的比较，不仅比较值，而且会比较变量的类型。 JavaScript无法实现接口继承，支持实现继承，而且继承主要是依靠原型链来实现的。主要继承方式有：原型式继承、寄生式继承、寄生组合式继承。 this总是指向函数的直接调用者（而非间接调用者）；如果有new关键字，this指向new出来的那个对象；在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window。 在一个对象上触发某类事件（比如单击onclick事件），如果此对象定义了此事件的处理程序，那么此事件就会调用这个处理程序，如果没有定义此事件处理程序或者事件返回true，那么这个事件会向这个对象的父级对象传播，从里到外，直至它被处理（父级对象所有同类事件都将被激活），或者它到达了对象层次的最顶层，即document对象（有些浏览器是window）。 事件冒泡允许多个操作被集中处理（把事件处理器添加到一个父级元素上，避免把事件处理器添加到多个子级元素上），它还可以让你在对象层的不同级别捕获事件。 让不同的对象同时捕获同一事件，并调用自己的专属处理程序做自己的事情，就像老板一下命令，各自员工做自己岗位上的工作去了。 事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。 捕获型事件(event capturing)：事件从最不精确的对象(document 对象)开始触发，然后到最精确(也可以在窗口级别捕获事件，不过必须由开发人员特别指定)。 冒泡型事件：事件按照从最特定的事件目标到最不特定的事件目标(document对象)的顺序触发。 IE是事件冒泡、firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件。 12345678910111213141516171819202122232425闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部。闭包的特性：1.函数内再嵌套函数2.内部函数可以引用外层的参数和变量3.参数和变量不会被垃圾回收机制回收//li节点的onclick事件都能正确的弹出当前被点击的li索引 &lt;ul id="testUL"&gt; &lt;li&gt; index = 0&lt;/li&gt; &lt;li&gt; index = 1&lt;/li&gt; &lt;li&gt; index = 2&lt;/li&gt; &lt;li&gt; index = 3&lt;/li&gt;&lt;/ul&gt;&lt;script type="text/javascript"&gt; var nodes = document.getElementsByTagName("li"); for(i = 0;i&lt;nodes.length;i+= 1)&#123; nodes[i].onclick = (function(i)&#123; return function() &#123; console.log(i); &#125; //不用闭包的话，值每次都是4 &#125;)(i); &#125;&lt;/script&gt; use strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行, 使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为。默认支持的糟糕特性都会被禁用，比如不能用with，也不能在意外的情况下给全局变量赋值;全局变量的显示声明,函数必须声明在顶层，不允许在非函数代码块内声明函数,arguments.callee也不允许使用；消除代码运行的一些不安全之处，保证代码运行的安全,限制函数中的arguments修改，严格模式下的eval函数的行为和非严格模式的也不相同; 提高编译器效率，增加运行速度；为未来新版本的Javascript标准化做铺垫。 单页应用是指在浏览器中运行的应用，它们在使用期间不会重新加载页面。像所有的应用一样，它旨在帮助用户完成任务，比如“编写文档”或者“管理Web服务器”。可以认为单页应用是一种从Web服务器加载的富客户端。 搜索引擎优化： 1234567891011121314151617181、注重TDK的写法既然页面单一，那么就更需要注重网站标题、关键词和描述的写法。标题上来说，要简单明确，包含主要关键词，一句话能概括全文;描述上来讲，一句话活一小段文字提炼出文章的精髓，内容比标题更加详细;关键词，用绝对的与内容相关的词语，多个关键词用逗号分开。2、外链锚文本的多样化在外链建设上，切忌内容单一，这样很容易造成网站的过度优化，而我们都知道，网站的过度优化对SEO而言是不利的。3、网站标签的运用合理的运用网站标签可以让搜索引擎更好的理解网站的层次内容，比如h标签，strong标签等等。4、符合国际标准这里所说的符合国际标准指的是告诉搜索引擎我的网站符合W3C标准，对任何浏览器都是兼容的。5、代码优化CSS和JS的优化，尽可能的使用外部导入，从而让网页代码更加简洁，能用CSS就尽量不用JS，毕竟JS对于搜索引擎而言并不友好。6、图片的优化这个属于老生常谈了，这里就不多说了。7、合理设置锚点有一些单页面为了展示很多产品特点，页面会拉的很长，不利于用户查看，用户体验并不好，如果在单页面网站上设置合理的锚点，用户只需要点击一下快速达到想要看到的内容区域。8、避免全是图片展示如果单页面网站为了提升视觉效果从而更多的使用图片，那么就会造成网站文字内容过少，不利于搜索引擎对网站的抓取和索引。9、内容为王之前我们就举过百度百科的例子，而作为单页面网站来讲，将用户所有的需求点尽可能完整的展现出来，从而解决用户的烦恼才是单页面网站立足的关键。 中级 全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节。当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找，直至全局函数，这种组织形式就是作用域链。 每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念。 特点：JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。 call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。 这个程序中的add 来替换 sub，add.call(sub,3,1) == add(3,1)，所以运行结果为：alert(4); 输出undefined。 javascript的变量声明具有变量声明提升机制，JavaScript引擎在执行的时候，会把所有变量的声明都提升到当前作用域的最前面。并且function作用域里的变量v遮盖了上层作用域变量v。这段代码相当于下面这段： 123456var v = "hello";(function()&#123; var v; //declaration hoisting console.log(v); v = "world";&#125;)(); defer和async、动态创建DOM方式（创建script，插入到DOM中，加载完毕后callBack）、按需异步载入js 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数 当需要设置的样式很多时设置className而不是直接操作style。 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。 12345678910111213141516100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息200 OK 正常返回信息201 Created 请求成功并且服务器创建了新的资源202 Accepted 服务器已接受请求，但尚未处理301 Moved Permanently 请求的网页已永久移动到新位置。302 Found 临时性重定向。303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。304 Not Modified 自从上次请求后，请求的网页未修改过。400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。401 Unauthorized 请求未授权。403 Forbidden 禁止访问。404 Not Found 找不到如何与 URI 相匹配的资源。500 Internal Server Error 最常见的服务器端错误。503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。 ajax的全称：Asynchronous Javascript And XML。异步传输+js+xml。所谓异步，在这里简单地解释就是：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验。 创建一个Ajax： 创建XMLHttpRequest对象,也就是创建一个异步调用对象 创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息 设置响应HTTP请求状态变化的函数 发送HTTP请求 获取异步调用返回的数据 使用JavaScript和DOM实现局部刷新 优点： 无刷新更新数据。 异步与服务器通信。 前端和后端负载平衡。 基于标准被广泛支持。 界面与应用分离。 缺点： AJAX干掉了Back和History功能，即对浏览器机制的破坏。 安全问题 AJAX暴露了与服务器交互的细节。 对搜索引擎支持较弱。 破坏程序的异常处理机制。 违背URL和资源定位的初衷。 AJAX不能很好支持移动设备。 客户端过肥，太多客户端代码造成开发上的成本。 不容易调试。 注意点：Ajax开发时，网络延迟——即用户发出请求到服务器发出响应之间的间隔——需要慎重考虑。不给予用户明确的回应，没有恰当的预读数据，或者对XMLHttpRequest的不恰当处理，都会使用户感到延迟，这是用户不希望看到的，也是他们无法理解的。通常的解决方案是，使用一个可视化的组件来告诉用户系统正在进行后台操作并且正在读取数据和内容。 Ajax适用场景： 表单驱动的交互 深层次的树的导航 快速的用户与用户间的交流响应 类似投票、yes/no等无关痛痒的场景 对数据进行过滤和操纵相关数据的场景 普通的文本输入提示和自动完成的场景 Ajax不适用场景： 部分简单的表单 搜索 基本的导航 替换大量的文本 对呈现的操纵 高级 HTTP/2引入了“服务端推（serverpush）”的概念，它允许服务端在客户端需要数据之前就主动地将数据发送到客户端缓存中，从而提高性能。 HTTP/2提供更多的加密支持 HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。 它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的header都只会占用很小比例的带宽。 网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI。 对于传统的网站来说重构通常是： 表格(table)布局改为DIV+CSS使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的)对于移动平台的优化针对于SEO进行优化深层次的网站重构应该考虑的方面 减少代码间的耦合让代码保持弹性严格按规范编写代码设计可扩展的API代替旧有的框架、语言(如VB)增强用户体验通常来说对于速度的优化也包含在重构中 压缩JS、CSS、image等前端资源(通常是由服务器来解决)程序的性能优化(如数据读写)采用CDN来加速资源加载对于JS DOM的优化HTTP服务器的文件缓存 12345678910111213141516171819202122232425Asynchronous Module Definition，异步模块定义，所有的模块将被异步加载，模块加载不影响后面语句运行。所有依赖某些模块的语句均放置在回调函数中。 区别：1. 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.2. CMD 推崇依赖就近，AMD 推崇依赖前置。看代码： // CMD define(function(require, exports, module) &#123; var a = require('./a') a.doSomething() // 此处略去 100 行 var b = require('./b') // 依赖可以就近书写 b.doSomething() // ... &#125;) // AMD 默认推荐 define(['./a', './b'], function(a, b) &#123; // 依赖必须一开始就写好 a.doSomething() // 此处略去 100 行 b.doSomething() // ... &#125;) 两等号判等，会在比较时进行类型转换；三等号判等(判断严格)，比较时不进行隐式类型转换,（类型不同则会返回false）； Object.is在三等号判等的基础上特别处理了NaN、-0和+0 ，保证 -0和+0不再相同，但Object.is(NaN, NaN)会返回 true. Object.is应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。 内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。 垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。 setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环） ​ 12345678910111213141516171819202122232425262728293031323334353637//创建cookie function setCookie(name, value, expires, path, domain, secure) &#123; var cookieText = encodeURIComponent(name) + &apos;=&apos; + encodeURIComponent(value); if (expires instanceof Date) &#123; cookieText += &apos;; expires=&apos; + expires; &#125; if (path) &#123; cookieText += &apos;; expires=&apos; + expires; &#125; if (domain) &#123; cookieText += &apos;; domain=&apos; + domain; &#125; if (secure) &#123; cookieText += &apos;; secure&apos;; &#125; document.cookie = cookieText; &#125; //获取cookie function getCookie(name) &#123; var cookieName = encodeURIComponent(name) + &apos;=&apos;; var cookieStart = document.cookie.indexOf(cookieName); var cookieValue = null; if (cookieStart &gt; -1) &#123; var cookieEnd = document.cookie.indexOf(&apos;;&apos;, cookieStart); if (cookieEnd == -1) &#123; cookieEnd = document.cookie.length; &#125; cookieValue = decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd)); &#125; return cookieValue; &#125; //删除cookie function unsetCookie(name) &#123; document.cookie = name + &quot;= ; expires=&quot; + new Date(0); &#125; Progressive Web App是一个利用现代浏览器的能力来达到类似APP的用户体验的技术，由Google开发，让浏览器打开的网址像APP一样运行在手机上。让Web App和Native App之间的差距更小。 优点： Installability （可安装性） App Shell：第一次渲染渲个壳、等异步数据来了再填充 Offline （离线能力） Re-engageable：推送通知的能力 缺点： 门槛不低（要求 HTTPS；Service Worker也需要学习）； 浏览器支持（主要是Safari不愿意支持，只是在5年计划里提了一下）； 用户习惯（让用户习惯于网页可以离线工作真不是短期可以达到的）。]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chrome扩展程序推荐]]></title>
    <url>%2F2017%2F03%2F16%2Fchrome%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F%E6%8E%A8%E8%8D%90%2F</url>
    <content type="text"><![CDATA[Google Chrome，是一个由Google公司开发的一款设计简单、高效的网页浏览器。其最大的魅力就在于可以安装各种扩展插件，让Chrome浏览器自身的功能更加丰富。Chrome网上应用店，用户可以下载和安装应用程序、扩展程序以及主题背景。 作为用了7年的chrome的老用户，下面推荐一下我常用的chrome扩展程序。 因为某些原因，如果不能去chrome网上应用商店下载，可以去chrome插件和插件网下载，然后自行安装，安装教程参考:怎么在谷歌浏览器中安装.crx扩展名的离线Chrome插件？。 uBlock Origin一款去除页面广告的插件，之所以不推荐大名鼎鼎的Adblock Plus是因为uBlock Origin占用极低的内存和 CPU。而且uBlock Origin支持的Adblock Plus过滤语法拦截广告。 开启拦截前： 开启拦截后： 前端开发的时候记得把拦截取消。 国内下载地址：uBlock Origin 官方下载地址：uBlock Origin Tampermonkey俗称“油猴”，号称“Chrome第二应用商店”，是一款最为流行的用户脚本管理器。它可以加入更多的 Chrome 本身不支持的用户脚本功能。 安装完Tampermonkey，就可以去Greasy Fork安装各种脚本了，无数强大的脚本都可以通过这个扩展运行，代替应用商店里繁复的apps&amp;extensions，极大地减少了chrome应用、扩展造成的不必要的系统资源占用。不必担心这些脚本会导致浏览器卡顿，它们只在特定页面运行，资源占用极低。 下面是我安装的一些脚本： 国内下载地址：Tampermonkey 官方下载地址：Tampermonkey Speed dial 2Speed dial 2可以完美替代默认的新标签页。它可以记录书签、浏览历史，主题易于定制，对快速拨号页面进行分组，可以云同步所有配置（需要付费，不过很便宜）。 国内下载地址：Speed dial 2 官方下载地址：Speed dial 2 FireShotFireShot是网页截图插件，它可以对网页中整个屏幕或者是网页的部分视图进行截图操作，在截图之后用户还可以对当前截图的图片进行编辑，包括添加注释，批注，添加线条，上传，分享等操作。 国内下载地址：FireShot 官方下载地址：FireShot OneTabchrome浏览器每打开一个标签就相当于多独立运行了一个程序，所以每个网页标签都是占用内存的。标签页数量较多时消耗的内存相当可观。对内存不是那么大的人来说，用一段时间之后整个系统被拖得很慢着实非常痛苦。OneTab chrome扩展插件是为了解决 Chrome 浏览器内存占用过多的问题的，安装后，点击一下扩展图标，扩展的功能会将当前打开的标签关闭，显示在扩展页的标签列表中，相当于只打开一个标签，内存占用就一下子从几个 G 骤减为 100M 左右了；同时将标签页展示为一个竖排的列表样式，查看全部标签也更轻松了。你可以点击恢复某个标签页，也可以全部恢复打开。 国内下载地址：OneTab 官方下载地址：OneTab Scroll To TopScroll To Top可以在浏览页面时帮助你快速滚动到顶部或者底部。 国内下载地址：Scroll To Top 官方下载地址：Scroll To Top crxMouse Chrome GesturesCrxMouse是一款鼠标手势Chrome插件，使用它可以充分、方便、快捷地发挥鼠标在Chrome浏览器中的操作方式。其中包括鼠标手势，超级拖拽，滚动手势，摇杆手势，平滑滚动，标签页列表等功能，比如在Chrome浏览器中画上一个向左的转折线就可以快速地把当前的标签页关闭。 鼠标手势的设置： 鼠标手势效果演示： 超级拖拽的设置（可以方便的进行各种搜索）： 国内下载地址：crxMouse Chrome Gestures 官方下载地址：crxMouse Chrome Gestures 划词翻译一个简便但强大的翻译扩展。支持谷歌、百度、有道、必应四大翻译和朗读引擎，可以方便的查看、复制和朗读不同引擎的翻译结果。 国内下载地址：划词翻译 官方下载地址：划词翻译 Fatkun图片批量下载Fatkun图片批量下载是一个简单好用的下载图片扩展，它可以找出当前页面的所有图片，并提供按分辨率、链接等筛选图片的功能。 国内下载地址：Fatkun图片批量下载 官方下载地址：Fatkun图片批量下载 OctotreeOctotree是一个用来显示 Github 项目的目录结构的插件， Github上的项目可以显示为类似 IDE 的代码目录树结构。缺点是需要初始化的时间，像nodejs这种稍微大一点的代码库要花大概1分钟多有去爬吧。 国内下载地址：Octotree 官方下载地址：Octotree Isometric Contributions这个插件可以把github上的contributions 显示为3d柱状图，并且给出一些更加详细的信息。 国内下载地址：Isometric Contributions 官方下载地址：Isometric Contributions WEB前端助手(FeHelper)功能包括字符串编解码、代码压缩、美化、JSON格式化、正则表达式、时间转换工具、二维码生成器、编码规范检测、页面性能检测、页面取色、Ajax接口调试。 国内下载地址：WEB前端助手(FeHelper) 官方下载地址：WEB前端助手(FeHelper) WhatFontWhatFont是一款可以帮助用户查看识别网页字体的浏览器插件。 国内下载地址：WhatFont 官方下载地址：WhatFont Page RulerPage Ruler是一款页面尺寸测量工具，非常适合前端工程师。PageRuler插件可以与当前网页的屏幕无缝地集成到一起，使用户非常精确地测量出当前页面某个元素或者是整个页面的大小尺寸。 国内下载地址：Page Ruler 官方下载地址：Page Ruler CSSViewerCSSViewer是一款快速查看css样式的插件，不需点开开发者工具，直接可以显示元素的css样式信息。 国内下载地址：CSSViewer 官方下载地址：CSSViewer Code ColaCode Cola是一个可视化编辑在线页面css样式的chrome插件。比chrome自带的开发者工具要方便一点。 国内下载地址：Code Cola 官方下载地址：Code Cola PerfectPixel by WellDoneCodePerfectPixel是一种叠加插件。它处理的是图层，这样你可以在同一页面多次叠加。 在PixelPerfect中简单地加载任意JPG或PNG格式的网站原型，然后在你的工作代码上手工定位，锁定它的位置，并将它的不透明度降低到大约20％。 当你开发HTML页面时，你可以不断地将HTML和CSS呈现的效果与原始设计稿比较。 国内下载地址：PerfectPixel by WellDoneCode 官方下载地址：PerfectPixel by WellDoneCode Web Developer Checklist这个插件可以分析任何网页是否违反最佳实践，对于Web开发谁想要确保他们遵循最佳实践，这个扩展可以让你很容易发现你的网站的问题领域。 国内下载地址：Web Developer Checklist 官方下载地址：Web Developer Checklist PageSpeed Insights (with PNaCl)这个插件是Google官方的PageSpeed Tools的chrome扩展版本，通过分析网页的内容来提供网站加载速度优化建议。 安装完后，进入开发者页面，此时顶部会多出一个PageSpeed按钮，点击Start Analyzing就可以开始分析。 国内下载地址：PageSpeed Insights (with PNaCl) 官方下载地址：PageSpeed Insights (with PNaCl) User-Agent Switcher for ChromeUser-Agent Switcher插件是一款可以使用Chrome浏览器访问网站的时候来制造一种其他浏览器正在访问该网站的一种“假象”。 国内下载地址：User-Agent Switcher for Chrome 官方下载地址：User-Agent Switcher for Chrome Responsive Web Design TesterResponsive Web Design Tester是一个能模拟网站在不同浏览器和设备上的行为，适合前端响应式网站开发。 国内下载地址：Responsive Web Design Tester 官方下载地址：Responsive Web Design Tester]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我心红蓝]]></title>
    <url>%2F2017%2F03%2F09%2F%E6%88%91%E5%BF%83%E7%BA%A2%E8%93%9D%2F</url>
    <content type="text"><![CDATA[今天凌晨看完球到现在久久不能平静，虽然加午休只睡了5个小时，但是到现在仍然竟然一点都不困，仍然处于亢奋状态，我想这就是足球的魅力吧。 看比赛前我觉得已巴萨这几场比赛的状态，我觉得打巴黎个4比0是不成问题的，毕竟大巴黎没了大奉先后，实力根本和巴萨不是一个档次的。 恩里克也排出了3-3-4阵型，我也是第一次在欧冠上看到一上来就是4前锋的阵型，巴萨全队看来是众志成城。 上半场理所当然的压着大巴黎，运气也在巴萨这边，小白造的乌龙球球真的是当时久攻不下的强心剂。当时我就想似乎按照这样下去巴萨有可能踢个4比0打加时，或者5比0直接晋级，当然这场被称为欧冠有史以来最伟大的逆转（没有之一）不可能这么简单就称为伟大。 下半场卡瓦尼的进球似乎想钉子一样把巴萨钉在了出局名单上，我承认当时我是绝望的。就好比巴黎的4比0捅了巴萨一刀，但是巴萨没死，挣扎着站起来的时候，大巴黎又捅了巴萨一刀。这放在哪个队都是直接放弃比赛，缴枪投降的。但是这是巴萨，苏亚雷斯没有放弃，他一次次冲击禁区，哪怕球出了底线也奋力追；梅西没有放弃，他一次次回撤组织进攻、不停跑位；内马尔也没有放弃，一次次不停突破、传中… 然而奇迹真的出现了，先是内马尔的任意球，划过美丽的弧线直奔死角；然后苏亚雷斯突破造点。此时已经是91分钟了，留给巴萨的时间真的不多了，要么被淘汰、要么再进一个逆转。 还是内马尔，一个轻盈的挑传，罗伯托像鬼魅般冒了出来，出现在正确的时间、正确的地点，用正确的方式把球捅进去。若不是怕影响舍友睡觉，此时我应该已经疯了吧，我狠狠地拍了拍枕头，“真TM牛逼！” 这样的球队你怎么能不爱，大巴黎连捅两刀，巴萨只要没死，就继续战斗，直到打败对手，这种逆转把足球乃至竞技体育的精神体现得淋漓尽致。 就像标题图片中球迷打出的标语：“Yes！We Can！”，是的，我们真的做到了，赛前连欧足联官方给出的比赛预测，巴萨晋级概率都是0，就这样，我萨还是做到了。 感谢巴萨，感谢这场世纪逆转， 让我们领略足球世界中的非凡魅力和无限可能性， 让我们重拾对生活的热爱，与对梦想的渴望追寻。 人生真是充满了阳光啊！ 最后以煤老板的霸气庆祝图结尾，我心红蓝！]]></content>
      <categories>
        <category>生活杂谈</category>
      </categories>
      <tags>
        <tag>感悟</tag>
        <tag>足球</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJS2中一种button切换效果的实现（三）]]></title>
    <url>%2F2017%2F03%2F03%2FAngularJS2%E4%B8%AD%E4%B8%80%E7%A7%8Dbutton%E5%88%87%E6%8D%A2%E6%95%88%E6%9E%9C%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[之前在AngularJS2中一种button切换效果的实现（一）和AngularJS2中一种button切换效果的实现（二）中实现了按钮的切换效果，但是方法比较low，这次我们使用Angular2的指令来实现。 指令实现hover效果123456789101112131415161718192021import &#123; Directive, ElementRef, HostListener, Input &#125; from '@angular/core';@Directive(&#123; selector: '[myHighlight]'&#125;)export class HighlightDirective &#123; constructor(private el: ElementRef) &#123; &#125; @HostListener('mouseenter') onMouseEnter() &#123; this.highlight('red'); &#125; @HostListener('mouseleave') onMouseLeave() &#123; this.highlight(null); &#125; private highlight(color: string) &#123; this.el.nativeElement.style.backgroundColor = color; &#125;&#125; 123&lt;button myHighlight class="btn"&gt;按钮一&lt;/button&gt;&lt;button myHighlight class="btn"&gt;按钮二&lt;/button&gt;&lt;button myHighlight class="btn"&gt;按钮三&lt;/button&gt; 123456789.btn&#123; height: 50px; width: 100px; background-color: #3399ff; color: white; border: 0; outline: 0; cursor: hand;&#125; hover的效果直接参考Angular官网的代码。 指令实现click效果12345678910111213141516171819202122232425import &#123; Directive, ElementRef, HostListener, Input &#125; from '@angular/core';@Directive(&#123; selector: '[myHighlight]'&#125;)export class HighlightDirective &#123; constructor(private el: ElementRef) &#123; &#125; @HostListener('click') onMouseClick() &#123; this.clickhighlight("black"); &#125; private clickhighlight(color: string) &#123; let obj = this.el.nativeElement; let btns = obj.parentNode.children; //背景色全部重置 for(let i=0; i&lt;btns.length; i++)&#123; btns[i].style.backgroundColor = "#3399ff"; &#125; //设置当前点击对象的背景色 obj.style.backgroundColor = color; &#125;&#125; 12345&lt;div&gt;&lt;button myHighlight class="btn"&gt;按钮一&lt;/button&gt;&lt;button myHighlight class="btn"&gt;按钮二&lt;/button&gt;&lt;button myHighlight class="btn"&gt;按钮三&lt;/button&gt;&lt;/div&gt; 123456789.btn&#123; height: 50px; width: 100px; background-color: #3399ff; color: white; border: 0; outline: 0; cursor: hand;&#125; click效果仍然用@HostListener装饰器引用属性型指令的宿主元素，首先把所有button的背景颜色重置，然后再设置当前点击对象的背景颜色，这样就达到了点击后背景颜色变化的效果。 指令实现click加hover效果12345678910111213141516171819202122232425import &#123; Directive, ElementRef, HostListener, Input &#125; from '@angular/core';@Directive(&#123; selector: '[myHighlight]'&#125;)export class HighlightDirective &#123; constructor(private el: ElementRef) &#123; &#125; @HostListener('click') onMouseClick() &#123; this.clickhighlight("black"); &#125; private clickhighlight(color: string) &#123; let obj = this.el.nativeElement; let btns = obj.parentNode.children; //背景色全部重置 for(let i=0; i&lt;btns.length; i++)&#123; btns[i].style.backgroundColor = "#3399ff"; &#125; //设置当前点击对象的背景色 obj.style.backgroundColor = color; &#125;&#125; 12345&lt;div&gt;&lt;button myHighlight class="btn"&gt;按钮一&lt;/button&gt;&lt;button myHighlight class="btn"&gt;按钮二&lt;/button&gt;&lt;button myHighlight class="btn"&gt;按钮三&lt;/button&gt;&lt;/div&gt; 12345678910111213.btn&#123; height: 50px; width: 100px; background-color: #3399ff; color: white; border: 0; outline: 0; cursor: hand;&#125;.btn:hover&#123; background: black !important;&#125; 配合上文click效果，只要加上一行css代码就可以实现click和hover的组合效果，此处务必使用hover伪类，并用!important来提升样式的优先级，如果用@HostListener装饰器，mouseenter、mouseleave、click三者会打架：]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《JavaScript DOM编程艺术》学习笔记]]></title>
    <url>%2F2017%2F02%2F25%2F%E3%80%8AJavaScript%20DOM%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[本书大部分demo参见DOM Scripting Demo，本人手敲，如有错误欢迎提交pr JavaScript语法准备工作12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Test&lt;/title&gt; &lt;meta charset="UTF-8"&gt;&lt;/head&gt;&lt;body&gt;&lt;script src="example.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 把&lt;script&gt;标签放在HTML文档最后，&lt;/body&gt;标签之前，这样即使加载脚本时，Windows对象的load事件依然可以执行对文档进行的各种操作。 因为位于&lt;head&gt;中的脚本会导致浏览器不能并行加载其他文件。一般来说，根据HTTP规范，浏览器每次从同一个域名中最多只能同时下载两个文件。 操作算术操作符字符串和数值拼接在一起结果是更长的字符串。 1alert("10"+20)； //输出1020 比较操作符JavaScript中，==并不表示严格相等，例如： 12345var a = false;var b = "";if (a == b)&#123; //true alert("a = b");&#125; 这个语句求值结果是ture，因为==认为空字符串与false的含义相同。要进行严格比较，就要使用另一种等号：===。这个全等操作符会执行严格的比较，不仅比较值，而且会比较变量的类型： 12345var a = false;var b = "";if (a === b)&#123; //flase alert("a = b");&#125; 函数如果在某个函数中使用var，那个变量就被看做局部变量，它只存在这个函数上下文中；如果没有使用var，这个变量就被看做是全局变量，如果脚本里面出现一个与之同名的全局变量，这个函数就会改变这个全局变量的值。 1234567891011121314151617function square(num)&#123; total = num * num; return total&#125;var total = 50;var number = square(20);alert(total); //输出400-------------我是分割线-------------function square(num)&#123; var total = num * num; return total&#125;var total = 50;var number = square(20);alert(total); //输出50 对象假设有个Person的对象，为了使用Person来描述人，需要创建一个Person对象的实例。实例是对象的具体个体。例如，你和我都是人，都可以用person对象来描述；但你和我是两个不同的个体，和可能有着不同的属性。因此对应着不同的Person对象–虽然都是Person对象，但是它们是两个不同的实例。 new关键字为对象创建一个新的实例： 1var tangcheng = new Person; 内建对象Array对象、Math对象、Date对象都是内建对象。 宿主对象有些已经预定义的对象是由运行环境提供，具体到web就是浏览器提供的，这些对象被称为宿主对象。不仅包括Form、Image、Element等，还包括document对象。 DOMwindow对象对应浏览器窗口本身，这个对象的属性和方法通常称为BOM（浏览器对象模型）。 DOM的节点树和家谱类似。 节点节点分为元素节点、文本节点、属性节点。 获取元素getElementByIdgetElementById返回的是一个对象。 getElementsByTagNamegetElementsByTagName返回的是一个对象数组，即使整个文档只有一个元素，getElementsByTagName返回的也是数组，数组长度为1。 getElementsByTagName允许把一个通配符作为参数，返回文档中所有元素，*必须放在引号中（为了与乘法操作符区别）。 1document.getElementsByTagName("*"); getElementsByTagName可以和getElementById结合起来使用： 123var shopping = document.getElementById("purchase");var items = shopping.getElementsByTagName("*");//返回shopping下面所有的标签 getElementsByClassNamegetElementsByClassName返回的是一个具有同类名元素的数组。 可以指定多个类名，只要在字符串参数中用空格分隔类名，匹配时类名顺序不重要，就算类名还带有其他类名也可以匹配： 1document.getElementsByClassName("tc zj"); getElementsByClassName兼容性可以使用下面的脚本实现： 123456789101112131415function getElementsByClassName(node, classname)&#123; if (node.getElementsByClassName)&#123; //使用现有方法 return node.getElementsByClassName(classname); &#125;else&#123; var results = new Array(); var elems = node.getElementsByTagName("*"); for (var i = 0; i&lt;elems.length; i++)&#123; if (elems[i].className.indexOf(classname)!=-1)&#123; results[results.length] = elems[i]; &#125; &#125; return results; &#125;&#125; 获取和设置属性getAttributegetAttribute方法不属于document对象，只能通过元素节点对象调用。属性不存在时返回null。 如果something是null，if (something)和if (something != null)等价。 setAttributesetAttribute方法也只能通过元素节点对象调用。 1object.setAttribute(attribute,value); 通过setAttribute对文档做出的修改后，再通过浏览器的view source（查看源码）选项去查看文档的源码时看到的仍将是改变前的值，也就是说setAttribute做出的修改不会反映在文档本身的源码中。这是因为： DOM的工作模式是：先加载文档的静态内容，再动态刷新，动态刷新不影响文档的静态内容。这正是DOM的真正威力：对页面进行刷新不需要再浏览器里刷新页面。 案例研究：JavaScript图片库JavaScriptDOM是一种适用于多种环境和多种程序设计语言的通用型API。如果想把从本书学到的DOM技巧运用在web浏览器以外的应用环境里，严格遵守”第1级DOM“能够让你避免与兼容性有关的任何问题。 应用这个JavaScript函数事件处理函数事件处理函数的工作机制：在给某个元素添加事件处理函数后，一旦事件发生，相应的JavaScript代码就会得到执行。被调用的JavaScript代码可以返回一个值，这个值将被传递给那个事件处理函数。 例如：给某个链接添加一个onclick事件处理函数，onclick事件处理函数所触发的JavaScript代码会返回false或者true。当这个链接被点击时，如果那段JavaScript代码返回的是true，onclick事件处理函数就认为”这个链接被点击了“；反之，如果返回值是false,onclick事件处理函数就认为”这个链接没有被点击“。 12&lt;!--当点击时，返回的是false，链接的默认行为没有被触发--&gt;&lt;a href="http://tc9011.com" onclick="return false"&gt;&lt;/a&gt; 对这个函数进行扩展childNodes属性在一颗节点树上，childNodes属性可以获取任何一个元素的所有子元素，它是一个包含这个元素全部子元素的数组。 nodeType属性每个节点都有nodeType属性，nodeType的值是一个数字： 元素节点的nodeType属性值是1 属性节点的nodeType属性值是2 文本节点的nodeType属性值是3 nodeValue属性nodeValue属性用来获取或者设置一个节点的值。 &lt;p&gt;元素里的文本是另一种节点，&lt;p&gt;元素本身的nodeValue是一个空值： 1&lt;p id="description"&gt;Choose an image&lt;/p&gt; 1234var description = document.getElementById("description");alert(description.nodeValue);//输出nullalert(description.childNodes[0].nodeValue);//输出"Choose an image"alert(description.firstChild.nodeValue);//输出"Choose an image" 最佳实践平稳退化JavaScript使用window对象的open()方法来创建新的浏览器窗口。这个方法有三个参数： 1window.open(url,name,feature) 这三个参数都是可选的： 第一个参数是想在新窗口打开的URL地址。省略则弹出空白窗口。 第二个参数是新窗口的名字。可以在代码中通过这个名字与新窗口进行通信。 第三个参数是一个以逗号分隔的字符串，其内容是新窗口的各种属性。 ”javascript:“伪协议”javascript:“伪协议让我们通过一个链接来调用JavaScript函数。 1&lt;a href="javascript:popUp("http://tc9011.com");"&gt;tc9011.com&lt;/a&gt; 在HTML文档中通过”javascript:“伪协议调用JavaScript代码的做法非常不好。 分离JavaScript1&lt;a href="http://tc9011.com" onclick="popUp(this.href);return false"&gt;&lt;/a&gt; JavaScript语言不要求事件必须在HTML文档里处理（如上面的onclick事件可以分离到外部JavaScript文件中。），可以在外部的JavaScript文件里面把一个事件添加到HTML文档中某个元素上。 1getElementById(id).event = active 如果涉及多个元素，可以用getElementsByTagName和getAttribute把事件添加到有着特定属性的一组元素上： 123456789var links = document.getElementsByTagName("a");for (var i=0; i&lt;links.length; i++)&#123; if (links[i].getAttribute("class") == "popup")&#123; links[i].onclick = function()&#123; popUp(this.getAttribute("href")); return false; &#125; &#125;&#125; 以上代码把click操作从HTML文档中分离出来。 当HTML文档全部加载完毕将触发window.onload事件，这个事件触发时document对象已经存在，这样可以避免HTML没有加载完全时，JavaScript代码获取不到相应的id或者class。 性能考虑尽量减少访问DOM和尽量减少标记访问DOM对脚本性能会产生非常大的影响。多次访问相同的DOM，可以先把第一次搜索的结果保存在一个变量中。 12345678910111213if (document.getElementsByTagName("a").length &gt; 0)&#123; var links = document.getElementsByTagName("a"); for (var i=0; i&lt;links.length; i++)&#123; //对每个链接节点做处理 &#125;&#125;------------优化后------------var links = document.getElementsByTagName("a");if (links.length &gt; 0)&#123; for (var i=0; i&lt;links.length; i++)&#123; //对每个链接节点做处理 &#125;&#125; 案例研究：图片库改进版它支持平稳退化吗href设置为真实值，在JavaScript被禁用的情况下，链接也能跳转。 1&lt;a href="images/1.jpg" title="A" onclick="showPic(this);return false"&gt;&lt;/a&gt; 它的JavaScript与HTML标记是分离的吗出现多个window.onload时，只会执行最后一个。可以使用自定义的addLoadEvent函数完成多个函数绑定到window.onload。 1234567891011121314function addLoadEvent(func) &#123; var oldonload = window.onload; if (typeof window.onload != "function")&#123; window.onload = func; &#125;else &#123; window.onload = function () &#123; oldonload(); func(); &#125; &#125;&#125;------------使用------------addLoadEvent(firstFunction);addLoadEvent(secondFunction); 优化nodeName属性总是返回一个大写字母的值，即使元素在HTML文档里面是小写字母。 键盘访问用Tab键移动到某个链接然后按下回车键的动作也会出发onclick事件。 DOM Core和HTML-DOM getElementById getElementsByTagName getAttribute setAttribute 这些方法都是DOM Core的组成部分。它们并不专属于JavaScript，支持DOM和任何一种程序设计语言都可以使用它们。 onclick属性属于HTML-DOM，HTML-DOM只能用来处理web文档。HTML-DOM书写更简短： 1234567891011document.getElementsByTagName("form") --&gt;document.forms--------分割线--------element.getAttribute("src") --&gt;element.src--------分割线--------var source = whichpic.getAttribute("href") --&gt;var source = whichpic.href--------分割线--------placeholder.setAttribute("src",source) --&gt;placeholder.src = source 动态创建标记一些传统的方法document.writedocument.write最大的缺点是违背了“行为应该和表现分离”的原则，应该避免使用。 innerHTML属性innerHTML无法区分“插入一段HTML内容”和“替换一段HTML内容”，一旦使用这个属性，里面全部内容都将被替换。 DOM方法浏览器实际显示的是DOM节点树，不是物理文档的内容。 createElement方法createElement方法只能创建元素节点。 1document.createElement(nodeName); appendChild方法1parent.appendChild(child); createTextNode方法createTextNode方法用来创建文本节点。 重返图片库 如果元素存在只是为让DOM方法处理，用DOM方法来创建它们才是最合适的。 这样是不是太极端了，增加了对DOM的操作，会不会影响性能？ 在已有元素前插入一个新元素insertBefore()方法把一个新元素插入到现有元素的前面。 12parentElement.insertBefore(newElement,targetElement);parentElement 等于 targetElement.parentNode 在现有元素后插入一个新元素编写insertAfter函数DOM本身没有提供insertAfter函数，可以利用已有DOM方法和属性编写一个： 12345678function insertAfter(newElement,targetElement) &#123; var parent = targetElement.parentNode; if (parent.lastChild == targetElement)&#123; parent.appendChild(newElement); &#125;else &#123; parent.insertBefore(newElement,targetElement.nextSibling); &#125;&#125; AjaxXMLHttpRequest对象XMLHttpRequest对象充当浏览器中的脚本（客户端）与服务器之间的中间人的角色。 onreadystatechange是一个事件处理函数，它会在服务器给XMLHttpRequest对象送回响应的时候被触发执行。在这个处理函数中，可以根据服务器的具体响应做相应的处理。 服务器在向XMLHttpRequest对象发回响应时，浏览器会在不同阶段更新readyState属性的值： 0表示未初始化 1表示正在加载 2表示加载完毕 3表示正在交互 4表示完成 访问服务器发送回来的数据要通过两个属性完成。一个是responseText属性，这个属性用于保存文本字符串形式的数据。另一个属性是responseXML属性，用于保存content-Type头部中指定为text/xml的数据，其实是一个DocumentFragment对象。 充实文档的内容不应该做什么遵循下面两个原则：1、渐进增强。应该在最开始根据内容使用标记实现良好的结构，然后再逐步加强这些内容。这些增强工作可以是通过css改进呈现效果，也可以通过DOM添加各种行为。2、平稳退化。渐进增强的实现必然支持平稳退化。缺乏必要css和DOM支持的访问者仍然可以访问到核心内容。 CSS-DOM三位一体的网页结构层结构层由HTML或XHTML之类的标记语言负责创建。 表示层表示层由css负责完成。css描述页面内容应该如何呈现。 行为层行为层负责内容应该如何响应事件这一问题。这是JavaScript和DOM主宰的领域。 style属性每个元素的style属性是都是一个对象。 引用中间带减号的css属性时，DOM要求用驼峰命名法。例如：font-family变成element.style.fontFamily。 何时该用DOM脚本设置样式为有类似属性的多个元素声明样式： 123input[type*="text"] &#123; font-size: 1em;&#125; 根据元素位置声明样式： 123p:first-of-type &#123; font-of-size: 1em;&#125; 需要决定是采用纯粹的CSS来解决，还是利用DOM来设置样式，需要考虑以下因素： 这个问题最简单的解决方案是什么； 哪种解决方案会得到更多浏览器的支持。 className属性通过className属性直接赋值来设置某个元素的class属性将替换该元素的原有class属性。如要追加class属性，可以这样写： 1elem.className += " intro"; 用JavaScript实现动画效果动画基础知识位置position属性的合法值有static、fixed、relative和absolute四种。static是position属性的默认值，意思是有关元素将按照它们在标记里出现的先后顺序出现在浏览器窗口里。relative含义和static相似，区别在于position属性等于relative的元素还可以（通过应用float属性）从文档的正常显示顺序里脱离出来。 如果把某个元素的position属性设置为absolute，我们就可以把它摆放到容纳它的”容器“的任何位置。这个容器要么是文档本身，要么是一个有着fixed或者absolute属性的父元素。这个元素原始标记里出现的位置与它的显示位置无关，因为它的显示位置由top、left、right和bottom等属性决定。 时间递增量JavaScript函数parseInt可以把字符串里的数值信息提取出来。例如： 1parseInt("18 forbidden");//返回数值18 实用的动画W3C在web内容可访问性指南（Web Content Accessibility Guidelines）7.2节里给出这样的建议： 除非浏览器允许用户”冻结“移动着的内容，否则就应该避免让内容在页面中移动。（优先级2）。如果页面上有移动着的内容，就应该用脚本或插件的机制允许用户”冻结“这种移动或动态更新行为。 CSSCSS的overflow属性用来处理一个元素的尺寸超出其容器尺寸的情况。overflow属性有四个可取值： visible：不剪裁溢出的内容。浏览器将把溢出的内容呈现在其容器元素的显示区域以外，全部内容都可见。 hidden：隐藏溢出的内容。内容只显示在其容器元素的显示区域里，这意味着只有一部分内容可见。 scroll：类似于hidden，浏览器将对溢出的内容进行隐藏，但是显示一个滚动条以便让用户能够滚动看到内容的其他的地方。 auto：类似于scroll，但浏览器只在确实发生溢出时才显示滚动条。如果内容没有溢出，就不显示滚动条。 父元素的position设置为relative，子元素的（0，0）坐标将固定在父元素的左上角。 变量作用域问题属性是只与某个特定元素有关的变量。JavaScript允许我们为元素创建属性： 1element.property = value; 这和创建变量很像，但是区别在于这是属于某个特定元素的变量。 下面是我自己改写的时候碰到的for循环中的闭包问题，按照错误的改写，for循环中i的值始终为2，要使得for循环每次正常输出，需要先把i的值赋给每个links的i属性，调用时候用this表示当前links来调用i属性。参考资料浅谈JavaScript for循环 闭包 12345678910111213141516171819202122232425 //把下面改写成for循环。 links[0].onmousemove = function () &#123; moveElement("preview",-110,0,10); &#125;; links[1].onmousemove = function () &#123; moveElement("preview",-220,0,10); &#125;; links[2].onmousemove = function () &#123; moveElement("preview",-330,0,10); &#125;;--------------错误改写-------------- for (var i=0; i&lt;links.length; i++)&#123; links[i].onmousemove = function () &#123; var x = (i+1)*-110; moveElement("preview",x,0,10); &#125;; &#125;--------------正确改写-------------- for (var i=0; i&lt;links.length; i++)&#123; links[i].i = i; links[i].onmousemove = function () &#123; var x = (this.i+1)*-110; moveElement("preview",x,0,10); &#125;; &#125; HTML5XHTML语法比HTML严格，如：标签一定要闭合、标签一定要是小写、所有属性都要赋值等。 几个示例音频和视频为了保证HTML5的最大兼容性，至少要包含下列三个版本： 基于H.264和AAC的MP4 WebM（VP8+Vorbis） 基于Theora视频和Vorbis音频的Ogg文件 为了最大程度兼容不支持HTML5的浏览器，一般还要准备一个flash或者QuickTime插件版的视频。 不同视频格式排序的时候应该把MP4放在第一位，因为IOS4之前版本中的Mobile Safari只能解析一个&lt;video&gt;元素，故把针对IOS格式的放在最前面 自定义控件&lt;video&gt;元素自定义控件可以通过一些DOM属性来实现，主要包括： currentTime，返回当前播放的位置，以秒表示； duration，返回媒体的总时长，以秒表示，对流媒体返回无穷大； pause，表示媒体是否处于暂停状态； 此外，还有一些与特定媒体相关的事件，可以用来触发你的脚本。主要事件有： play，在媒体播放开始时发生； pause，在媒体暂停时发生； loadeddata，在媒体可以从当前播放位置开始播放时发生； ended，在媒体已播放完成而停止时发生。 不管创建什么控件，都不要忘了在&lt;video&gt;元素中添加control属性： 1&lt;video src="movie.ogv" controls&gt;&lt;/video&gt; 表单新的输入控件类型包括： email url date number range，用于生成滑动条 search tel color，用于选择颜色 新的属性： autocomplete，用于文本输入框添加一组建议的输入项； autofocus，用于让表单元素自动获得焦点； form，用于对&lt;form&gt;标签外部的表单元素分组； min、max和step，用在范围（range）和数值（number）输入框中； pattern，用于定义一个正则表达式，以便验证输入的值； placeholder required，表示必填 综合示例css把css可以拆成几个模块，然后用@import导入到一个基本的样式表basic.css中，如果要添加或者删除一个样式，只要编辑basic.css就可以。在html中也只要引入basic.css就行。 颜色不管哪个元素应用什么颜色，都要同时给它一个背景颜色。 JavaScript取到当前页面的URL可以使用window.location.href。 表单每一个form对象都有一个elements.length属性，这个属性返回表单中包含的表单元素的个数： 1form.elements.length 这个返回值与childNodes.length不一样，后者返回的是元素中包含的所有节点的个数。而form对象的elements.length属性只关注那些属于表单元素的元素，如：input、textarea等。 form.elements是包含了所有表单元素的数组。 elements数组中的每个表单元素都有自己的一组属性。 elements.value保存了表单元素的当前值。 onfocus事件会在用户通过按Tab键或者单击表单字段时被触发。 onblur事件会在用户把焦点移除表单字段时触发。 encodeURIComponent函数把有歧义的字符串转换成对应的ASCⅡ编码。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[听说你的placeholder想换行？]]></title>
    <url>%2F2017%2F02%2F18%2F%E5%90%AC%E8%AF%B4%E4%BD%A0%E7%9A%84placeholder%E6%83%B3%E6%8D%A2%E8%A1%8C%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[这是同事遇到的一个问题，在&lt;textarea&gt;标签里面不仅要加上placeholder属性，还要换行。在stackoverflow上有相关的讨论，主要有下面几种做法： 官方说明官方说明： The placeholder attribute represents a short hint (a word or short phrase) intended to aid the user with data entry when the control has no value. A hint could be a sample value or a brief description of the expected format. The attribute, if specified, must have a value that contains no U+000A LINE FEED (LF) or U+000D CARRIAGE RETURN (CR) characters. The placeholder attribute should not be used as a replacement for a label. For a longer hint or other advisory text, place the text next to the control. 翻译过来就是： placeholder属性是用来帮助用户输入的简短提示（一个字或者一个短语），这个提示应该是简单的数值或者简短的描述。placeholder属性不应该作为label的替代者。对于较长或者复杂的提示，将文本置于控件旁边。 解决办法使用&amp;#10;1&lt;textarea name="foo" placeholder"hello you&amp;#10;Second line&amp;#10;Third line"&gt;&lt;/textarea&gt; 这个不能跨浏览器，在ie、chrome下是可以的，但是在firefox和safari中不行。 css解决办法1234567891011::-webkit-input-placeholder::before &#123; content: "FIRST\000ASECOND\000ATHIRD";&#125;::-moz-placeholder::before &#123; content: "FIRST\000ASECOND\000ATHIRD";&#125;:-ms-input-placeholder::before &#123; content: "FIRST\000ASECOND\000ATHIRD";&#125; 只适用于webkit内核的浏览器（chrome、safari），对firefox和ie没有效果。 使用jQuery的watermark控件通过watermark可以全平台兼容。下载控件后，引入到项目，然后在&lt;textarea&gt;中定义jq_watermark的class。 1234&lt;script type="text/javascript" src="jquery.watermark.js"&gt;&lt;/script&gt;&lt;label for="comments"&gt;Comments:&lt;/label&gt;&lt;br /&gt;&lt;textarea id="comments" placeholder="Tell Us&lt;br/&gt;What do you think...&lt;br/&gt;We are here" class="jq_watermark" rows="3" cols="80"&gt;&lt;/textarea&gt;]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】angular2-webpack-starter]]></title>
    <url>%2F2017%2F02%2F16%2F%E3%80%90%E8%AF%91%E3%80%91-angular2-webpack-starter%2F</url>
    <content type="text"><![CDATA[在github上看到了这个项目，感觉挺好的，就拿过来翻译一下，顺便提高一下看英文文档的水平 Angular2 Webpack Starter本仓库作为Angular2初始化工具为所有寻找更快启动和运行Angular2和TypeScript的人提供帮助。这个项目使用webpack2来构建我们的文件和协助模块化。同时使用Protractor进行e2e测试、Karma进行单元测试。 这是Angular2在文件和应用架构方面最好的练习； 准备用webpack构建基于TypeScript的应用； 当尝试使用Angular2时，Angular2的案例已经准备好了； 对于想启动自己项目的人来说，这是一个极好的Angular2种子库； 为你产品构建的页面快速加载提供AoT编译； Tree shaking会自动删除包中没有用的代码； Webpack DLLs可以大大加快开发构建； 用Jasmine和Karma来测试Angular2的代码； 用Istanbul和Karma来进行测试覆盖； 用Protractor来进行Angular2代码的e2e测试； 用@type进行类型管理； 用webpack、@angularclass/hmr和@angularclass/hmr-loader来做模块热替换(HMR)； 用angular/material2来做Material Design； 通过修改package.json实现对Angular4以及未来Angular任何版本的支持。 Quick start确保你的node版本大于5.0，npm版本大于3.0。 克隆或者下载这个仓库后，编辑在/src/app/app.component.ts里的app.component.ts。 123456789101112131415161718# 克隆仓库# --depth 1 表示克隆最近一次commit.git clone --depth 1 https://github.com/angularclass/angular2-webpack-starter.git# 切换目录cd angular2-webpack-starter# 用npm安装库npm install# 起一个服务npm start# 使用模块热替换npm run server:dev:hmr# 如果在中国，请使用cnpm# https://github.com/cnpm/cnpm 在浏览器中打开 http://0.0.0.0:3000 或者 http://localhost:3000 。 Table of Contents文件结构我们在项目中使用组件化的方法，这是开发Angular app的新标准，是一种通过封装行为逻辑来确保代码可维护性的极好的方法。一个组件基本上是一个完整的app，它通常在一个文件或者文件夹里面包含style, template, specs, e2e, and component class。下面是文件结构的样子： 1234567891011121314151617181920212223242526272829303132333435angular2-webpack-starter/ ├──config/ * 配置 | ├──helpers.js * 配置文件的helper functions | ├──spec-bundle.js * 忽略这个设置Angular2测试环境的魔法 | ├──karma.conf.js * 单元测试的karma配置 | ├──protractor.conf.js * e2e测试的protractor配置 │ ├──webpack.dev.js * webpack开发环境配置 │ ├──webpack.prod.js * webpack产品环境配置 │ └──webpack.test.js * webpack测试环境配置 │ ├──src/ * 将被编译成js的源代码 | ├──main.browser.ts * 浏览器的入口文件 │ │ | ├──index.html * Index.html: 用来生成index页面 │ │ | ├──polyfills.ts * polyfills文件 │ │ │ ├──app/ * WebApp: 文件夹 │ │ ├──app.component.spec.ts * 在app.component.ts中的一个简单测试 │ │ ├──app.e2e.ts * 一个简单e2e测试 │ │ └──app.component.ts * 一个简单的App component │ │ │ └──assets/ * 静态资源存放在这边 │ ├──icon/ * www.favicon-generator.org图标列表 │ ├──service-worker.js * 忽略这个.service worker还没完成 │ ├──robots.txt * 让搜索引擎爬取你的网站 │ └──humans.txt * 让别人知道谁是开发者 │ │ ├──tslint.json * typescript lint配置 ├──typedoc.json * typescript文件生成 ├──tsconfig.json * typescript使用外部webpack的配置 ├──tsconfig.webpack.json * webpack对typescript使用的配置 ├──package.json * npm管理的项目依赖 └──webpack.config.js * webpack主要的配置文件 开始依赖运行这个app你需要： node和npm（通过brew安装node） 确保你运行最新版本的Nodev4.X.X(或者v5.X.X)和NPM3.X.X+ 如果你已经安装nvm—特别推荐（可以通过brew安装nvm）—你可以通过nvm install --lts &amp;&amp; nvm use来运行最新版本的Node。你也可以用zsh来帮你自动完成。 一旦你完成这些，你应该用npm insatll --global安装这些全局包。 webpack (npm install --global webpack) webpack-dev-server (npm install --global webpack-dev-server) karma (npm install --global karma-cli) protractor (npm install --global protractor) typescript (npm install --global typescript) 安装 fork 这个仓库 clone 你fork的仓库 npm install webpack-dev-server rimraf webpack -g 安装需要的全局依赖 npm install 安装所有的依赖或者yarn npm run server 在另一个标签启动一个服务 运行app安装完所有的依赖以后，现在可以运行这个app。运行npm run server来启动一个本地服务，这个服务利用webpack-dev-server 来监听、构件（在内存中）和重新加载。通过这个端口http://0.0.0.0:3000可以访问页面（如果你是IPv6或者使用express服务，通过http://[::1]:3000/访问）。 服务12345# developmentnpm run server# productionnpm run build:prodnpm run server:prod 其他命令构件文件123456# developmentnpm run build:dev# production (jit)npm run build:prod# AoTnpm run build:aot 模块热替换1npm run server:dev:hmr 监听和构件文件1npm run watch 运行单元测试1npm run test 监听和运行测试1npm run watch:test 运行e2e测试1234# 升级Webdriver (可选, 通过postinstall script自动完成)npm run webdriver:update# 启动服务并且启用Protractornpm run e2e 集成测试（一起运行单元测试和e2e测试）12# 测试JIT和AoT buildsnpm run ci 运行Protractor的elementExplorer (为e2e测试)1npm run e2e:live 构件Docker1npm run build:docker 配置 配置文件在config/目录下，一般用 webpack, karma, and protractor 作为项目的脚手架。 AoT禁忌下面是一些会使AoT编译失败的做法： 不需要为模板和样式声明，使用styleUrls and templateUrls，angular2-template-loader插件会在构建时声明； 不要使用默认的exports； 不要用 form.controls.controlName, 使用 form.get(‘controlName’)； 不要用 control.errors?.someError, 使用 control.hasError(‘someError’)； 不要在providers, routes 或者declarations中使用函数, 应该暴露一个函数，然后引用这个函数的名字； @Inputs, @Outputs, View , Content Child(ren), Hostbindings或者任何从模板、注释中使用的字段对Angular都应该是public。 外部样式任何导入到项目中的样式或者在src/styles文件夹下的样式 (Sass 或者 CSS) 都将被编译成外部的 .css 并嵌入你的产品构建。 例如用Bootstrap作为外部样式: 1) 在src/styles文件夹下创建一个 styles.scss 文件 (名字不重要) ； 2) 用 npm install 安装你想要的Boostrap版本； 3) 在 styles.scss 加上 @import &#39;bootstrap/scss/bootstrap.scss&#39;; 4) 在 src/app/app.module.ts 其他声明下面加上: import &#39;../styles/styles.scss&#39;; 贡献你可以用组件的形式引进更多的案例，但是它们必须引入一些新的概念，比如 Home component (独立文件夹)和Todo (服务)。我将会很乐意接受，所以尽情Pull-Request。 TypeScript 全局安装TypeScript，并使用带有TypeScript插件的编辑器，利用自动补全来充分使用TypeScript。 使用最新的TypeScriptTypeScript 2.1.x 包含所有你需要的东西。 请确保升级到这个版本，即使你之前已经安装了TypeScript。 1npm install --global typescript 使用支持TypeScript的编辑器推荐使用下面的编辑器: Visual Studio Code Webstorm 10 带 TypeScript plugin的Atom 带 Typescript-Sublime-Plugin的Sublime Text Visual Studio Code + Debugger for Chrome 安装 Debugger for Chrome ，然后去看操作指南 项目中的 .vscode 会自动连接到webpack development server 的 3000端口。 Types 当你引入一个没有定义类型的模块，你可以用@types引入外部类型定义。 比如，为了让YouTube api运行，在终端中输入下面的命令： 1npm i @types/youtube @types/gapi @types/gapi.youtube 在一些案例中，你的代码编辑器不支持Typescript 2或者这些类型不在tsconfig.json列表内，这时候把这些类型增加到“src/custom-typings.d.ts” 中来帮助编译时检查： 123import '@types/gapi.youtube';import '@types/gapi';import '@types/youtube'; 类型定义习惯如果需要用到第三方模块，当它没有提供类型定义时，同样需要为模块引入类型定义。你可以试着用@types来完成： 12npm install @types/nodenpm install @types/lodash 如果你不能在库中找到对应的类型定义，可以暂时在文件中使用ambient definition ： 123declare module "my-module" &#123; export function doesSomething(value: string): string;&#125; 如果导入的模块是使用Node.js，你需要这样引入： 1import * as _ from 'lodash'; 常见问题 如何知道当前浏览器时候支持Angular2？ 答：请查看这个更新列表：browser support for Angular 2。 为什么服务没有正确注入参数？ 答：请使用 @Injectable() ，以便让TypeScript的服务正确的依附上元数据（这是TypeScript的问题）。 怎么才能用node 0.12.X运行protractor？ 答：请切换到这个仓库以便使用老版本的protractor，参见 #146 在哪里写测试？ 答：可以在组件文件下写你的测试。 例如 /src/app/home/home.component.spec.ts 当报 EACCES 和 EADDRINUSE 错误时，如何启动app？ 答： EADDRINUSE 错误是 3000 端口已经被使用了， EACCES 错误是webpack在./dist/目录下没有权限来构建文件。 如何在css中使用 sass ？ 答：使用loaders: [&#39;raw-loader&#39;,&#39;sass-loader&#39;] 和 @Component({ styleUrls: [&#39;./filename.scss&#39;] }) ，参见 Wiki How to include SCSS in components, 或者 #136 问题。 如何测试服务？ 答：参见 #130 如何增加 vscode-chrome-debug 支持？ 答：VS Code chrome debug 插件的支持可以通过 launch.json 来实现，参见 #144。 如何让这个仓库在虚拟机上运行？ 答：host使用 0.0.0.0 ，参见 #205。 Angular 2的命名约定是什么？ 答：参见 #185 和 196。 如何引入bootstrap或者jQuery？ 答：参见 #215 和#214。 组件如何异步加载？ 答：参见 How-do-I-async-load-a-component-with-AsyncRoute。 Error: Cannot find module ‘tapable’ 答：移除 node_modules/ ，然后运行 npm cache clean ，最后 npm install。 如何开启模块热替换？ 答：运行 npm run server:dev:hmr。 RangeError: Maximum call stack size exceeded 答：这是压缩Angular2和JIT模板时的错误，可以把mangle 设置为false。 为什么app比development大？ 答：因为使用了inline source-maps和模块热替换，这回导致包的大小增加。 如果你在中国，请使用https://github.com/cnpm/cnpm。 如果希望增加Angular 2 Material Design，切换到material2分支。 node-pre-gyp ERR in npm install (Windows) 答：安装Python x86，Windows版本在2.5 和 3.0之间 参见： #626。 Error:Error: Parse tsconfig error [{&quot;messageText&quot;:&quot;Unknown compiler option &#39;lib&#39;.&quot;,&quot;category&quot;:1,&quot;code&quot;:5023},{&quot;messageText&quot;:&quot;Unknown compiler option &#39;strictNullChecks&#39;.&quot;,&quot;category&quot;:1,&quot;code&quot;:5023},{&quot;messageText&quot;:&quot;Unknown compiler option &#39;baseUrl&#39;.&quot;,&quot;category&quot;:1,&quot;code&quot;:5023},{&quot;messageText&quot;:&quot;Unknown compiler option &#39;paths&#39;.&quot;,&quot;category&quot;:1,&quot;code&quot;:5023},{&quot;messageText&quot;:&quot;Unknown compiler option &#39;types&#39;.&quot;,&quot;category&quot;:1,&quot;code&quot;:5023}] 答：移除 node_modules/typescript ，然后运行 npm install typescript@beta。当前仓库使用的是ts 2.0。 “There are multiple modules with names that only differ in casing” 答：修改 c:\[path to angular2-webpack-starter] 为 C:\[path to angular2-webpack-starter] （c变为大写）参见： 926#issuecomment-245223547。 支持、问题和反馈 对这个项目或者Angular2有任何问题欢迎随时联系我们 Chat: AngularClass.slack Twitter: @AngularClass Gitter: AngularClass/angular2-webpack-starter]]></content>
      <categories>
        <category>技术类</category>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>Angular</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[块级元素和行内元素]]></title>
    <url>%2F2017%2F02%2F07%2F%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E5%92%8C%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[知识点虽然小，但是有的时候突然会忘记，记录一下，好记性不如烂笔头，文章参考块级元素。 块级元素 address - 地址 blockquote - 块引用 center - 举中对齐块 dir - 目录列表 div - 常用块级容易，也是css layout的主要标签 dl - 定义列表 fieldset - form控制组 form - 交互表单 h1 - 大标题 h2 - 副标题 h3 - 3级标题 h4 - 4级标题 h5 - 5级标题 h6 - 6级标题 hr - 水平分隔线 isindex - input prompt menu - 菜单列表 noframes - frames可选内容，（对于不支持frame的浏览器显示此区块内容 noscript - ）可选脚本内容（对于不支持script的浏览器显示此内容） ol - 排序表单 p - 段落 pre - 格式化文本 table - 表格 ul - 非排序列表 行内元素 a - 锚点 abbr - 缩写 acronym - 首字 b - 粗体(不推荐) bdo - bidi override big - 大字体 br - 换行 cite - 引用 code - 计算机代码(在引用源码的时候需要) dfn - 定义字段 em - 强调 font - 字体设定(不推荐) i - 斜体 img - 图片 input - 输入框 kbd - 定义键盘文本 label - 表格标签 q - 短引用 s - 中划线(不推荐) samp - 定义范例计算机代码 select - 项目选择 small - 小字体文本 span - 常用内联容器，定义文本内区块 strike - 中划线 strong - 粗体强调 sub - 下标 sup - 上标 textarea - 多行文本输入框 tt - 电传文本 u - 下划线 var - 定义变量 可变元素可变元素为根据上下文语境决定该元素为块元素或者内联元素。 applet - java applet button - 按钮 del - 删除文本 iframe - inline frame ins - 插入的文本 map - 图片区块(map) object - object对象 script - 客户端脚本 区别1. 块级元素会独占一行，其宽度自动填满其父元素宽度；行内元素不会独占一行，相邻的行内元素会排列在同一行里，知道一行排不下，才会换行，其宽度随元素的内容而变化2. 块级元素可以设置 width, height属性，行内元素设置width, height无效 （注意：块级元素即使设置了宽度，仍然是独占一行的）3. 块级元素可以设置margin 和 padding. 行内元素的水平方向的padding-left,padding-right,margin-left,margin-right 都产生边距效果，但是竖直方向的padding-top,padding-bottom,margin-top,margin-bottom都不会产生边距效果。（水平方向有效，竖直方向无效）4. 块级元素可以容纳内联元素和其他块元素，内联元素只能容纳文本或者其他内联元素(内联元素中嵌套块级元素时，块级元素无法继承内联元素的属性。) 网上还看到一个知识点，display:inline-block时元素之间默认有一定的间隙，如下图：]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo本地搜索无法使用解决办法]]></title>
    <url>%2F2017%2F02%2F05%2Fhexo%E6%9C%AC%E5%9C%B0%E6%90%9C%E7%B4%A2%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[突然发现博客的本地搜索不能用了，这样就不能搜索学习笔记里面的内容了，这可是大事，得解决。 查找了github上的issues，发现local search这个issue下面有人提到博客搜索无法使用，显示链接是javascript:;，这不就是我的问题吗，但是这个问题有点蛋疼，需要在文章里面一个个找。 最后在hexo文章添加版权声明及一些特效中第二节中找到了这句话，删除后，搜索就可以用啦。]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebStorm中的AngularJS2模板插件使用]]></title>
    <url>%2F2017%2F02%2F03%2FWebstorm%E4%B8%AD%E7%9A%84AngularJS2%E6%A8%A1%E6%9D%BF%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Angular官方文档的风格指南提到使用IDE的模板来实现统一的风格，里面的IDE没有提到WebStorm，于是网上搜了一下相关资料。 安装插件参照WebStorm 最新 2016 AngularJs 2 代码提示插件安装。 在webstorm的setting或者performance（macos）中选择左侧Plugin选项，然后点击Browse repositories。 在搜索框中搜索Angular 2 TypeScript Live Templates，然后点击Install，会提示重启webstorm，重启后就安装好了。 如果电脑上设置了代理，点击左下角的HTTP proxy settings，选择auto-detect proxy settings，然后再进行下载。 使用插件Angular 2 TypeScript Live Templates (Snippets) for WebStorm的github上有使用说明，我按照这个说明演示一下。 TypeScript Snippets插件对于TypeScript有以下指令： 12345678ng2-component-root // Angular 2 root App componentng2-bootstrap // Angular 2 bootstraping, for main.tsng2-component // Angular 2 componentng2-pipe // Angular 2 pipeng2-routes // Angular 2 @Routesng2-route-path // Angular 2 routing pathng2-service // Angular 2 serviceng2-subscribe // Angular 2 observable subscription 指令会有提示，选择相应的指令会生成预设的模板。 HTML Snippets插件对Angular中的以下指令也有提示： 1234567ng2-ngClassng2-ngForng2-ngIfng2-ngModelng2-routerLinkng2-ngStyleng2-ngSwitch]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Angular</tag>
        <tag>WebStorm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo文章添加版权声明及一些特效]]></title>
    <url>%2F2017%2F02%2F02%2Fhexo%E6%96%87%E7%AB%A0%E6%B7%BB%E5%8A%A0%E7%89%88%E6%9D%83%E5%A3%B0%E6%98%8E%E5%8F%8A%E4%B8%80%E4%BA%9B%E7%89%B9%E6%95%88%2F</url>
    <content type="text"><![CDATA[看到有的博客上有版权声明的标记，感觉有点逼格，就想自己弄一下。 添加版权声明在Github上，Next主题的issues上有设置 Creative Commons 协议，这个就是设置版权声明，但是配置了以后图标比较小，没有文字说明（就是没逼格），而且还会出现在它不该出现的地方。 在网上找到一篇为Hexo博客的每一篇文章自动追加版权信息，可惜我木有成功。有兴趣的可以试一下。 这时候我想起了Hexo+nexT主题搭建个人博客的5.3中有在文章末尾添加“本文结束”标记的介绍。于是我就仿照写了一个版权声明。 新建 passage-end-tag.swig 文件 在路径\themes\next\layout\_macro中添加passage-end-tag.swig文件，其内容为： 123456789101112131415&#123;% if theme.passage_end_tag.enabled %&#125;&lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;------ 本文结束 ------&lt;/div&gt;&lt;br/&gt;&lt;div style="border: 1px solid black"&gt;&lt;div style="margin-left:10px"&gt;&lt;span style="font-weight:blod"&gt;版权声明&lt;/span&gt;&lt;img src="此处填自己版权声明图片地址" &gt;&lt;br/&gt;&lt;p style="font-size: 10px;line-height: 30px"&gt;&lt;a href="http://tc9011.com" style="color:#258FC6"&gt;tc9011's Notes&lt;/a&gt; by &lt;a href="http://tc9011.com" style="color:#258FC6"&gt;Cheng Tang&lt;/a&gt; is licensed under a &lt;a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" style="color:#258FC6"&gt;Creative Commons BY-NC-ND 4.0 International License&lt;/a&gt;.&lt;br/&gt;由&lt;a href="http://tc9011.com" style="color:#258FC6"&gt;汤诚&lt;/a&gt;创作并维护的&lt;a href="http://tc9011.com" style="color:#258FC6"&gt;tc9011's Notes&lt;/a&gt;博客采用&lt;a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" style="color:#258FC6"&gt;创作共用保留署名-非商业-禁止演绎4.0国际许可证&lt;/a&gt;。&lt;br/&gt;本文首发于&lt;a href="http://tc9011.com" style="color:#258FC6"&gt;tc9011's Notes&lt;/a&gt; 博客（ &lt;a href="http://tc9011.com" style="color:#258FC6"&gt;http://tc9011.com&lt;/a&gt; ），版权所有，侵权必究。&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&#123;% endif %&#125; 修改 post.swig 文件 在\themes\next\layout\_macro\post.swig中，post-body之后，post-footer之前添加如下代码： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'passage-end-tag.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 在主题配置文件中添加字段 在主题配置文件 _config.yml中添加以下字段开启此功能： 123# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 完成以上设置之后，在每篇文章之后都会添加“版权声明”标记。 添加背景动画背景动画基于canvas，添加到博客上也比较简单，在\themes\next\layout\_layout.swig的&lt;/body&gt;上面添加 123&#123;% if theme.canvas_nest %&#125; &lt;script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"&gt;&lt;/script&gt;&#123;% endif %&#125; 在\themes\next\_config.yml中添加以下字段开启此功能： 1234# background settings# add canvas-nest effect# see detail from https://github.com/hustcc/canvas-nest.jscanvas_nest: true 添加完了，发现博客背景是白色，会遮住动画，只留下两边一点点的位置看到动画效果，这时候可以去设置一下背景颜色，在\themes\next\source\css\_schemes\Pisces\_layout.styl中，把.content-wrap中的background修改为none。 这时候如果用手机打开，也能看到动画效果，但是带来的体验不好，显得页面比较乱，这是可以把.content-wrap的+mobile()中的background修改为white，这样手机端的体验就好很多，却又不影响电脑端的炫酷动画。 附上我的.content-wrap配置： 1234567891011121314151617181920212223.content-wrap &#123; float: right; box-sizing: border-box; padding: $content-desktop-padding; width: $content-desktop; background: none; min-height: 700px; box-shadow: $box-shadow-inner; border-radius: $border-radius-inner; +tablet() &#123; width: 100%; padding: 20px; border-radius: initial; &#125; +mobile() &#123; width: 100%; padding: 20px; min-height: auto; border-radius: initial; background: white; &#125;&#125; 修改一些样式never_yu‘Blog中的文章添加许多样式，看了一下github上的源码，在 themes\next\source\css\_custom\custom.styl 中，添加如下css： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359//修改文章内链接文本样式.post-body p a &#123; color: #0593d3; border-bottom: none; &amp;:hover &#123; color: #0477ab; text-decoration: underline; &#125;&#125;//修改不在文章内的链接文本样式.link-blue&#123; color: #f36; &amp;:hover &#123; color: #f00; &#125;&#125;//修改文章内code样式code &#123;color:#fff;background:#333;&#125;//修改文章中图片样式，改为居中.posts-expand .post-body img &#123; margin: 0 auto;&#125;// 下载样式a#download &#123; display: inline-block; padding: 0 10px; color: #000; background: transparent; border: 2px solid #000; border-radius: 2px; transition: all .5s ease; font-weight: bold; &amp;:hover &#123; background: #000; color: #fff; &#125;&#125;//阅读全文样式.post-more-link .btn &#123; position:relative; border: 2px solid #000; border-radius: 2px; padding: 0 10px; font-weight: bold; background: transparent; transition: all .5s ease; &amp;:hover &#123; background: #000; color: #eee; &#125;&#125;//// 颜色块-黄span#inline-yellow &#123; display:inline; padding:.2em .6em .3em; font-size:80%; font-weight:bold; line-height:1; color:#fff; text-align:center; white-space:nowrap; vertical-align:baseline; border-radius:0; background-color: #f0ad4e;&#125;// 颜色块-黑span#inline-black &#123; display:inline; padding:.2em .6em .3em; font-size:80%; font-weight:bold; line-height:1; color:#fff; text-align:center; white-space:nowrap; vertical-align:baseline; border-radius:0; background-color: black;&#125;// 颜色块-绿span#inline-green &#123; display:inline; padding:.2em .6em .3em; font-size:80%; font-weight:bold; line-height:1; color:#fff; text-align:center; white-space:nowrap; vertical-align:baseline; border-radius:0; background-color: #5cb85c;&#125;// 颜色块-蓝span#inline-blue &#123; display:inline; padding:.2em .6em .3em; font-size:80%; font-weight:bold; line-height:1; color:#fff; text-align:center; white-space:nowrap; vertical-align:baseline; border-radius:0; background-color: #2780e3;&#125;// 颜色块-紫span#inline-purple &#123; display:inline; padding:.2em .6em .3em; font-size:80%; font-weight:bold; line-height:1; color:#fff; text-align:center; white-space:nowrap; vertical-align:baseline; border-radius:0; background-color: #9954bb;&#125;// 颜色块-红span#inline-red &#123; display:inline; padding:.2em .6em .3em; font-size:80%; font-weight:bold; line-height:1; color:#fff; text-align:center; white-space:nowrap; vertical-align:baseline; border-radius:0; background-color: #df3e3e;&#125;// 左侧边框红色块级p#div-border-left-red &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-left-width: 5px; border-radius: 3px; border-left-color: #df3e3e;&#125;// 左侧边框黄色块级p#div-border-left-yellow &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-left-width: 5px; border-radius: 3px; border-left-color: #f0ad4e;&#125;// 左侧边框绿色块级p#div-border-left-green &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-left-width: 5px; border-radius: 3px; border-left-color: #5cb85c;&#125;// 左侧边框蓝色块级p#div-border-left-blue &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-left-width: 5px; border-radius: 3px; border-left-color: #2780e3;&#125;// 左侧边框紫色块级p#div-border-left-purple &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-left-width: 5px; border-radius: 3px; border-left-color: #9954bb;&#125;// 右侧边框红色块级p#div-border-right-red &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-right-width: 5px; border-radius: 3px; border-right-color: #df3e3e;&#125;// 右侧边框黄色块级p#div-border-right-yellow &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-right-width: 5px; border-radius: 3px; border-right-color: #f0ad4e;&#125;// 右侧边框绿色块级p#div-border-right-green &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-right-width: 5px; border-radius: 3px; border-right-color: #5cb85c;&#125;// 右侧边框蓝色块级p#div-border-right-blue &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-right-width: 5px; border-radius: 3px; border-right-color: #2780e3;&#125;// 右侧边框紫色块级p#div-border-right-purple &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-right-width: 5px; border-radius: 3px; border-right-color: #9954bb;&#125;// 上侧边框红色p#div-border-top-red &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-top-width: 5px; border-radius: 3px; border-top-color: #df3e3e;&#125;// 上侧边框黄色p#div-border-top-yellow &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-top-width: 5px; border-radius: 3px; border-top-color: #f0ad4e;&#125;// 上侧边框绿色p#div-border-top-green &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-top-width: 5px; border-radius: 3px; border-top-color: #5cb85c;&#125;// 上侧边框蓝色p#div-border-top-blue &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-top-width: 5px; border-radius: 3px; border-top-color: #2780e3;&#125;// 上侧边框紫色p#div-border-top-purple &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-top-width: 5px; border-radius: 3px; border-top-color: #9954bb;&#125;//动画模块//第一篇博客中-精于心，简于形-的动画（https://neveryu.github.io/page/2/）span#yu-1 &#123; display:inline; position:relative; border-top:1px solid #222; border-bottom:1px solid #222; font-size:110%; cursor:pointer; &amp;:hover &#123; background-color: #000; color: #fff; animation: animate-yu-1 3s ease-in; &#125;&#125;@keyframes animate-yu-1 &#123; 0% &#123; left:-10px; top:0px; &#125; 10% &#123; left:10px; top:0px; &#125; 20% &#123; left:-8px; top:0px; &#125; 30% &#123; left:8px; top:0px; &#125; 40% &#123; left:-5px; top:0px; &#125; 50% &#123; left:5px; top:0px; &#125; 60% &#123; left:-3px; top:0px; &#125; 70% &#123; left:3px; top:0px; &#125; 80% &#123; left:-1px; top:0px; &#125; 90% &#123; left:1px; top:0px; &#125; 100% &#123; left:0px; top:0px; &#125;&#125;//留言页面-[最近访客]-的样式span#yu-2 &#123; display:inline; position:relative; border-top:1px solid #222; border-bottom:1px solid #222; font-size:130%;&#125;]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Echarts改造之动态显示]]></title>
    <url>%2F2017%2F01%2F23%2FEcharts%E6%94%B9%E9%80%A0%E4%B9%8B%E5%8A%A8%E6%80%81%E6%98%BE%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[官网动态数据实例中展示了数据动态变化的案例，这个如何移植到Angular2中去呢？首先要读懂官网的这个例子，不然会有坑。 官网案例分析首先，数据处理和图表生成最好放在一起，根据官网的例子，在设置定时器之前，对应的配置项中已经设定好10个数据，而定时器，只是向对应的配置项中不断删除第一个数据，然后push新的数据。官网原话如下： 设置图表实例的配置项以及数据，万能接口，所有参数和数据的修改都可以通过setOption完成，ECharts 会合并新的参数和数据，然后刷新图表。如果开启动画的话，ECharts 找到两组数据之间的差异然后通过合适的动画去表现数据的变化。 其次，myChart这个变量要设置为全局变量，不然每次echarts会重新复制图表，而不是像官网例子一样，呈现出向左推送的效果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144&lt;!DOCTYPE html&gt;&lt;html style="height: 100%"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;/head&gt; &lt;body style="height: 100%; margin: 0"&gt; &lt;div id="container" style="height: 100%"&gt;&lt;/div&gt; &lt;script type="text/javascript" src="http://echarts.baidu.com/gallery/vendors/echarts/echarts-all-3.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="http://echarts.baidu.com/gallery/vendors/echarts/extension/dataTool.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="http://echarts.baidu.com/gallery/vendors/echarts/map/js/china.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="http://echarts.baidu.com/gallery/vendors/echarts/map/js/world.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="http://api.map.baidu.com/api?v=2.0&amp;ak=ZUONbpqGBsYGXNIYHicvbAbM"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="http://echarts.baidu.com/gallery/vendors/echarts/extension/bmap.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt;var dom = document.getElementById("container");var myChart = echarts.init(dom);var app = &#123;&#125;;option = null;option = &#123; title: &#123; text: '动态数据', subtext: '纯属虚构' &#125;, tooltip: &#123; trigger: 'axis' &#125;, legend: &#123; data:['最新成交价', '预购队列'] &#125;, toolbox: &#123; show: true, feature: &#123; dataView: &#123;readOnly: false&#125;, restore: &#123;&#125;, saveAsImage: &#123;&#125; &#125; &#125;, dataZoom: &#123; show: false, start: 0, end: 100 &#125;, xAxis: [ &#123; type: 'category', boundaryGap: true, data: (function ()&#123; var now = new Date(); var res = []; //预先设置好初始值 var len = 10; //定义x轴数据个数 while (len--) &#123; res.unshift(now.toLocaleTimeString().replace(/^\D*/,'')); now = new Date(now - 2000); &#125; return res; &#125;)() &#125;, &#123; type: 'category', boundaryGap: true, data: (function ()&#123; var res = []; var len = 10; while (len--) &#123; res.push(len + 1); &#125; return res; &#125;)() &#125; ], yAxis: [ &#123; type: 'value', scale: true, name: '价格', max: 30, min: 0, boundaryGap: [0.2, 0.2] &#125;, &#123; type: 'value', scale: true, name: '预购量', max: 1200, min: 0, boundaryGap: [0.2, 0.2] &#125; ], series: [ &#123; name:'预购队列', type:'bar', xAxisIndex: 1, yAxisIndex: 1, data:(function ()&#123; var res = []; var len = 10; while (len--) &#123; res.push(Math.round(Math.random() * 1000)); &#125; return res; &#125;)() &#125;, &#123; name:'最新成交价', type:'line', data:(function ()&#123; var res = []; var len = 0; while (len &lt; 10) &#123; res.push((Math.random()*10 + 5).toFixed(1) - 0); len++; &#125; return res; &#125;)() &#125; ]&#125;;app.count = 11;setInterval(function ()&#123; axisData = (new Date()).toLocaleTimeString().replace(/^\D*/,''); var data0 = option.series[0].data; var data1 = option.series[1].data; data0.shift(); //数组去头 data0.push(Math.round(Math.random() * 1000));//推送新的数据 data1.shift(); data1.push((Math.random() * 10 + 5).toFixed(1) - 0); option.xAxis[0].data.shift(); option.xAxis[0].data.push(axisData); option.xAxis[1].data.shift(); option.xAxis[1].data.push(app.count++); myChart.setOption(option);&#125;, 2100);;if (option &amp;&amp; typeof option === "object") &#123; myChart.setOption(option, true);&#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 移植到ANgular2首先创建一个dynamic-line.component.ts文件，@Component装饰器和import按照自己需求配置好。在class中先定义一些全局变量，并配置好echarts的option： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950url:any;id:string;userdata:any;dom:any;myoption:any;myChart:any;option:any = &#123; tooltip: &#123; show: true, trigger: 'axis' &#125;, toolbox: &#123; show: true, feature: &#123; dataZoom: &#123;show: true&#125;, restore: &#123;show: true&#125;, saveAsImage: &#123;show: true&#125; &#125; &#125;, legend: &#123; selectedMode: true, selected: &#123;&#125;, right: '0px', top: '80px', orient: 'vertical', textStyle: &#123; fontSize: 12, &#125;, show: true, data: [] &#125;, xAxis: &#123; data: [], axisLabel: &#123; interval: 0, &#125; &#125;, grid: &#123; left: '9%', x2: 150, &#125;, yAxis: [ &#123; type: 'value', name: '', &#125; ], series: []&#125;; 然后从外部传入url，以供echarts读取数据和刷新： 1@Input() url:any; 设置从后端获取数据的函数（获取数据后，因为后端数据有点乱，为了方便，我把数据重新处理了一下，定义了一个setMyoption()的函数，把处理后的数据，用json对象的形式存放在myoption这个变量中）： 123456789101112 getUrlData() &#123; let that = this; //从接口获取数据(省略) that.userdata = ...... &#125; setMyoption() &#123; let that = this; that.myoption = &#123; "data": [] &#125;;//处理数据后，存放在data中(省略) &#125; 根据数据配置legend，因为legend不需要刷新，所以独立成单独的函数： 1234567setLegend() &#123; let legend = []; //把数据处理后push到legend数组中（省略）； that.option.legend.data = legend; &#125; 设置配置option中x轴数据和series数据： 123setDataToOption() &#123; //把数据处理后push到xaxis的data数组和series数组中（省略）&#125; 设置生成echarts的函数： 123456createCharts() &#123; let that = this; that.dom = document.getElementById(that.id); that.myChart = echarts.init(that.dom, 'macarons'); that.myChart.setOption(that.option); &#125; 接下来在ngAfterViewInit中调用相关函数，让页面加载完后显示echarts： 123456789101112131415161718192021222324252627ngAfterViewInit() &#123; let that = this; that.myUrl = that.url; //把导入的url赋值给myUrl that.getUrlData(); that.setMyoption(); //清空原始数组 that.option.legend.data = []; that.option.series.data = []; that.option.xAxis.data = []; that.option.series = []; //配置Legend that.setLegend(); //配置option that.setDataToOption(); //调用echarts画图 that.createCharts(); //走到这步就已经把echarts初始化好了，下面要对特定的数据进行动态推送 //动态推送 setInterval(function () &#123; that.setDynamicData(); &#125;, 6000) &#125; 下面就设置动态推送数据的函数： 123456789101112131415161718setDynamicData() &#123; let that = this; let xaxisData = that.option.xAxis.data; that.getUrlData(); //读取的数据中不包含之前的数据 that.setMyoption(); for (let i = 0; i &lt; that.userdata.length; i++) &#123; //多个数据一个个推送 let time = that.myoption.data[0].systime[i]; xaxisData.shift(); xaxisData.push(time); for (let n = 0; n &lt; that.option.series.length; n++) &#123; let pushData = that.myoption.data[n].value[i]; that.option.series[n].data.shift(); that.option.series[n].data.push(pushData); &#125; that.myChart.setOption(that.option); //mychart必须是全局变量 &#125; &#125;]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>Angular</tag>
        <tag>Echarts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown--你值得拥有]]></title>
    <url>%2F2017%2F01%2F18%2FMarkdown-%E4%BD%A0%E5%80%BC%E5%BE%97%E6%8B%A5%E6%9C%89%2F</url>
    <content type="text"><![CDATA[什么是Markdown Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的HTML 标记语言来说，Markdown 可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。 官方文档创始人 John Gruber 的 Markdown 语法说明 Markdown 中文版语法说明 Markdown工具一般写文章大家会用word，那写makdown用什么呢？ mac平台收费的有： Ulysses Ⅲ， Mou ，Bear 免费的有：Typora Windows平台免费的有：Typora，MarkdownPad，MarkPad 这里推荐使用Typora，通吃Windows、mac和Linux三大平台。Typora 在 Markdown 的基础上，保持了应有的简洁和优雅，又一定程度地改良了 Markdown 本身较为不合理和烦琐的地方，适度地引入一些高级的编辑功能，使得一切都觉得如此顺手。 Markdown语法标题在 Markdown 中，如果一段文字被定义为标题，只要在这段文字前加 # 号即可。 # 一级标题 ## 二级标题 ### 三级标题 以此类推，总共六级标题，建议在井号后加一个空格，这是最标准的 Markdown 语法。 列表在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加 1. 2. 3.符号要和文字之间加上一个字符的空格。 引用只需要在文本前加入 &gt; 这种尖括号（大于号）即可显示引用格式。 图片与连接插入链接与插入图片的语法很像，区别在一个 !号 插入图片的地址需要图床，这里推荐 u图床 （mac）和MPic （Windows）的服务，生成URL地址即可。 在Typora中支持把图片拖拽进去，自动生成Markdown格式。 粗体与斜体Markdown 的粗体和斜体也非常简单，用两个 * 包含一段文本就是粗体的语法，用一个 * 包含一段文本就是斜体的语法。 代码框用两个 ` 把中间的代码包裹起来。 代码块输入三个\`，选择语言，然后输入代码，你会发现代码块中的代码自动高亮。 分割线分割线的语法只需要另起一行，连续输入三个星号 *** 即可。 表格Markdown 写表格比较累人。 12345| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | 生成的表格如下： 但是Typora中提供了比较方便的写表格的方法。通过菜单栏或快捷键 Command+T 可以插入表格，Typora 会弹出一个表格插入设置，你可以预先设定好行数和列数，确定后表格就出现了。每一列上面还有三个按钮，可以控制本列的文字向左、居中、向右对齐。甚至，你可以点击左上角改变表格的行数和列数。 删除线用~~包围住文字： Markdown还支持直接写HTML，例如#标题等价于&lt;h1&gt;标题&lt;/h1&gt;。 格式转化在Typora的file—&gt;Export中可以把md格式文件转化成pdf、word、html等格式文件。转word需要安装插件： Download Page。 md格式： 转化成word格式：]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebStorm那些事儿]]></title>
    <url>%2F2017%2F01%2F16%2FWebStorm%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%2F</url>
    <content type="text"><![CDATA[关于webstorm WebStorm 是jetbrains公司旗下一款JavaScript 开发工具。被广大中国JS开发者誉为“Web前端开发神器”、“最强大的HTML5编辑器”、“最智能的JavaScript IDE”等。与IntelliJ IDEA同源，继承了IntelliJ IDEA强大的JS部分的功能。 快捷键代码注释注释一行代码：ctrl+/(windows) ​ command+/(mac) 注释大段代码： 1 ctrl+/(windows) command+/(mac) ​ 2 ctrl+shif+/(windows) shift+command+/(mac) 格式化代码格式化代码：ctrl+alt+L(windows) ​ option+command+L(mac) shift+F6shift+F6（windows） shift+fn+F6（mac） 1 替换局部变量 ​ 2 重构函数名 快速跳转​ 快速跳转：ctrl+单击(windows) ​ command+单击（mac） 删除代码删除代码:ctrl+Y(windows) ​ Command+delete(mac) 多行编辑多行编辑：1 鼠标选择时按住alt(windows) ​ 鼠标按住时按住option（mac） ​ 2 长按alt+J，自动选择相同的元素（windows） ​ 选中元素后，按ctrl+g（mac） zencoding按tab键自动展开为完整html标签 后代：&gt; 兄弟：+ 上级：^ 分组：() 乘法：* 自增符号：$想显示几位数就使用几个$,$@-倒序，$@3从3开始计数 ​ ID和类属性:#和. 自定义属性:[] 文本:{} zencoding更多资料参见：zen coding 教程zen coding使用方法，大量实例和Zen Coding: 一种快速编写HTML/CSS代码的方法 自定义模板在setting&gt;Editor&gt;Live Templates中可以自定义模板，方便自己调用。 使用效果： 代码对比不同文件代码对比先把需要对比的代码复制到剪切板，然后右击有个compare with Clipboard，就会有个对话框弹出，里面标记了两个代码不同的地方。 相同文件历史代码对比右击有个Local History，选择Show History]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>WebStorm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJS2中一种button切换效果的实现（二）]]></title>
    <url>%2F2017%2F01%2F11%2FAngularJS2%E4%B8%AD%E4%B8%80%E7%A7%8Dbutton%E5%88%87%E6%8D%A2%E6%95%88%E6%9E%9C%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[之前用三目表达式和ng-class实现了按钮切换效果，似乎达到了我的预期，但是我觉得还有改进空间，网上找了一些资料，大概还有以下几种实现方式： 路由12&lt;button class="btn1" routerLink="component1" routerLinkActive="active" type="submit"&gt;btn1&lt;/button&gt;&lt;button class="btn2" routerLink="component2" routerLinkActive="active" type="submit"&gt;btn2&lt;/button&gt; 123.active &#123; background-color: white;&#125; 将button切换的页面写成一个component，通过routerLink链接到对应的component并显示出来，routerLinkActive来控制路由链接激活后button的样式应用的class。 但是这个有局限性，适合button按下去后，整个页面会有大幅变化的应用场景，那么还有其他方法吗？答案是肯定的。 [class]与(click)还是通过ngclass和ngclick配合，不过方法和之前写的略有不同。 字符串数组形式12&lt;button [class]="&#123;true:'btn1',false:'btn2'&#125;[isChange]" (click)="isChange=true"&gt;btn1&lt;/button&gt;&lt;button [class]="&#123;false:'btn1',true:'btn2'&#125;[isChange]" (click)="isChange=false" &gt;btn2&lt;/button&gt; 123456789101112131415161718.btn1&#123; width: 120px; height: 43px; border: 1px solid #EEEEEE; background: white; border-bottom: none; text-align: center;&#125;.btn2&#123; border: 1px solid #EEEEEE; border-top: 2px solid #238FF9; width: 120px; height: 42px; background: white; border-bottom: none; text-align: center;&#125; 字符串数组形式是针对class简单变化，具有排斥性的变化，true是什么class，false是什么class。若要设置初识状态的class，可以在component中的构造函数中预先赋值。 对象key/value处理1234&lt;button [class]="&#123;'one':'btn1','two':'btn2','three':'btn3','four':'btn4'&#125;[isChange]" (click)="isChange='one'"&gt;btn1&lt;/button&gt; &lt;button [class]="&#123;'one':'btn1','two':'btn2','three':'btn3','four':'btn4'&#125;[isChange]" (click)="isChange='two'"&gt;btn2&lt;/button&gt; &lt;button [class]="&#123;'one':'btn1','two':'btn2','three':'btn3','four':'btn4'&#125;[isChange]" (click)="isChange='three'"&gt;btn3&lt;/button&gt; &lt;button [class]="&#123;'one':'btn1','two':'btn2','three':'btn3','four':'btn4'&#125;[isChange]" (click)="isChange='four'"&gt;btn4&lt;/button&gt; 这种方法可以对多个对象赋不同的class。或者可以实现多个button互斥性变化： 1234&lt;button [class]="&#123;'one':'btn1','two':'btn2','three':'btn2','four':'btn2'&#125;[isChange]" (click)="isChange='one'"&gt;btn1&lt;/button&gt; &lt;button [class]="&#123;'one':'btn2','two':'btn1','three':'btn2','four':'btn2'&#125;[isChange]" (click)="isChange='two'"&gt;btn2&lt;/button&gt; &lt;button [class]="&#123;'one':'btn2','two':'btn2','three':'btn1','four':'btn2'&#125;[isChange]" (click)="isChange='three'"&gt;btn3&lt;/button&gt; &lt;button [class]="&#123;'one':'btn2','two':'btn2','three':'btn2','four':'btn1'&#125;[isChange]" (click)="isChange='four'"&gt;btn4&lt;/button&gt; 参考资料： angularJs的ng-class切换class]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Echarts改造之数据分离]]></title>
    <url>%2F2017%2F01%2F08%2FEcharts%E6%94%B9%E9%80%A0%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%88%86%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[Echarts官网中的数据都是写死的，如何让Echarts根据后台传过来的数据进行变化呢？下面介绍一下Angular2中嵌入Echarts，并实现数据分离。 先创建一个line.component.ts文件，component装饰器中这样写： 123456@Component(&#123; moduleId: module.id, selector: 'line', templateUrl: 'line.html', styleUrls: ['line.component.css'],&#125;) class中实现AfterViewInit接口，用于初始化组件视图后调用： 12345export class LineComponent implements AfterViewInit &#123; ngAfterViewInit()&#123; &#125;&#125; 在class中首先定义一些变量： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546lineData:Line; id:string; option:any = &#123; tooltip: &#123; show: true, trigger: 'axis' &#125;, toolbox: &#123; show: true, feature: &#123; magicType: &#123;show: true, type: ['bar']&#125;, dataZoom: &#123;show: true&#125;, restore: &#123;show: true&#125;, saveAsImage: &#123;show: true&#125; &#125; &#125;, legend: &#123; selectedMode: true, selected: &#123;&#125;, right: '0px', top: '80px', orient: 'vertical', textStyle: &#123; fontSize: 12, &#125;, show: true, data: [] &#125;, xAxis: &#123; data: [], axisLabel: &#123; interval: 0, &#125; &#125;, grid: &#123; left: '9%', x2: 150, &#125;, yAxis: [ &#123; type: 'value', name: '', &#125; ], series: [] &#125;; 在需要调用line.component.ts的父组件html中添加下面代码，把父组件中的myOption中的数据传递给data属性： 1&lt;line [data]='myOption'&gt;&lt;/line&gt; 在父组件的ts文件中，从后端读取数据，并把数据写入myOption（这里其实对原始数据进行了一次处理，让传给line.component.ts的数据更加容易处理）： 12345678910111213141516171819myOption:any; constructor()&#123; this.myOption = &#123; "data": [] &#125;;&#125;setMyOption()&#123; let that = this; let obj = &#123; "name": fieldkey, "value": [], "systime": [] &#125;; that.myOption.data = []; //先往obj中写入数据，再往data数组中写入对象&#125;getUrlData()&#123; //从后端读取数据&#125; 再回到line.component.ts中，引入myOption中的数据： 1@Input() data:any; 实现AfterViewInit接口： 12345678910111213141516ngAfterViewInit() &#123; let that = this; that.lineData = that.data; //data赋值给linedata //清空原始数组 that.option.legend.data = []; that.option.series.data = []; that.option.xAxis.data = []; that.option.series = []; //配置option that.setDataToOption(); //调用echarts画图 that.createCharts(); &#125; 往echarts中写入从后端读取的数据： 1234567891011121314151617181920212223242526272829303132333435setDataToOption() &#123; let that = this; let dataLength = this.lineData.data.length; let xAxisData = that.option.xAxis.data; let legend = that.option.legend; for (let n = 0; n &lt; dataLength; n++) &#123; let item = that.lineData.data[n]; legend.selected[item.name] = false; //往legend的selected中推送数据 let seriesData = &#123; name: item.name, type: 'line', showAllSymbol: true, data: [] &#125;; let legendData = &#123; name: item.name, icon: 'square' &#125;; let arr = Object.keys(item.value); for (let t = 0; t &lt; arr.length; t++) &#123; seriesData.data.push(item.value[t]); if (n === 0) &#123; xAxisData.push(item.systime[t]); //往x轴推送数据 &#125; &#125; legend.data.push(legendData); //往legend的data中推送数据 that.option.series.push(seriesData); //往series中推送数据 &#125; //设置x轴间隔 if (xAxisData.length &gt; 10) &#123; that.option.xAxis.axisLabel.interval = Math.ceil(xAxisData.length/10); &#125;&#125; 创建echarts： 123456createCharts() &#123; let that = this; let dom:any = document.getElementById(that.id); let myChart:any = echarts.init(dom, 'macarons'); myChart.setOption(that.option); &#125; 这样就实现了从后端读取数据，然后echarts显示在界面上。]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>Angular</tag>
        <tag>Echarts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[愿17可期]]></title>
    <url>%2F2016%2F12%2F27%2F%E6%84%BF17%E5%8F%AF%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[即将过去的一年对我来说太重要，以至于像我这样害怕写总结的人也拿起键盘，敲下了这一段文字。 记得在15年11月吧，在深圳青旅认识的蔡浩凯大哥来上海出差，正好抽空一起吃了一顿饭，交流了一下工作心得，在诺基亚和IBM就职过的浩凯大哥给了我很多职业规划方面的意见，也给我种下一颗转行的种子。 大概是16年3月，我开始在网上看java，每天上班回来，看一小时一建和一小时java，到后来工作太忙，以至于我下决心彻底放弃一建，专心看java，期间汪汪和田野还给我寄了一大箱java的书，虽然我最后去做前端了，哈哈哈。IT上的版本管理工具、IDE、各种开源论坛、各种资料的分享让我看到了一种自己想要的工作模式。 于是16年8月底辞职，去了趟成都和九寨沟散散心，顺便找昭哥和玉玺小聚了一下。回来后便安心的开始看前端。 辞职后，遇到很多朋友都没有透露我转行的消息。其实，当时自己真的挺迷茫的，要填的坑太多，甚至都不确定自己是否会成功，只晓得沿着自己计划的方向走，至于失败还是成功就留给老天吧。 自学期间顺手搭了这个博客，作为程序猿，有自己搭的博客，赶脚逼格max，哈哈哈。11月，在汪汪童鞋的建议下，我开始投简历，可能运气比较好，第二个面试就被录用了。就这样，我也算跨入了程序猿的行列。 工作一个多月，发现自己的选择是正确的，这种Geek的工作模式让我感到充满动力，每次调完bug，那种如沐春风的感觉，真的很棒。 很庆幸，能做自己想做的事情，不管未来是怎么样，至少自己努力了。 感谢蔡浩凯大哥、汪汪、田野，把我领进了IT的大门。 感谢郑部、王博、超哥在面试后决定录用我，虽然我至今都觉得自己技术漏洞太多，被录用简直是奇迹。 感谢中兴通讯虚拟化上海一部DG2的所有同事，面对我的很多问题都能耐心解答，让我成功避开了很多坑。 感谢家人在这一年的支持，在我迷茫的时候给我继续前进的动力。 最后，愿17可期。]]></content>
      <categories>
        <category>生活杂谈</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo添加音乐、high一下及一些坑]]></title>
    <url>%2F2016%2F12%2F24%2Fhexo%E6%B7%BB%E5%8A%A0%E9%9F%B3%E4%B9%90%E3%80%81high%E4%B8%80%E4%B8%8B%E5%8F%8A%E4%B8%80%E4%BA%9B%E5%9D%91%2F</url>
    <content type="text"><![CDATA[hexo添加音乐需要几个步骤？添加音乐当然可以用其他网站的外链，但是一般外链是&lt;iframe&gt;，这个影响网站的SEO，逼格也不够高。 下面我就隆重介绍一款html5音乐播放器：Aplayer。把Aplayer加入hexo需要用到hexo-tag-aplayer插件。 切换到hexo目录，运行： 1npm install hexo-tag-aplayer@2.0.1 这里直接运行npm install hexo-tag-aplayer只会安装2.0.0，这个版本会出现以下错误： 12FATAL Cannot find module '/Users/hechao/Documents/TechBlog/CniceToUpp/node_modules/hexo-tag-aplayer'Error: Cannot find module '/Users/hechao/Documents/TechBlog/CniceToUpp/node_modules/hexo-tag-aplayer' 作者给出来解决方案是用2.0.1版本，FATAL Cannot find module解决办法。 安装完成后，在需要添加音乐的地方加上： 1&#123;% aplayer "平凡之路" "朴树" "https://xxx.com/%E5%B9%B3%E5%87%A1%E4%B9%8B%E8%B7%AF.mp3" "https://xxx.com/1.jpg" "autoplay" %&#125; 就会出现你想要的音乐啦，这里我把音乐和专辑封面添加到七牛上，加载速度嗖嗖的。 如果你想加入歌单，把上面的代码换成下面代码就行，参数的用法可以参照插件的使用说明。 1&#123;% aplayerlist %&#125;&#123;"narrow": false,"autoplay": true,"showlrc": 3,"mode": "random","music": [&#123;"title": "平凡之路","author": "朴树","url": "http://xxx.com/%E5%B9%B3%E5%87%A1%E4%B9%8B%E8%B7%AF.mp3","pic": "https://xxx.com/1.jpg","lrc": "http://og9ocpmwk.bkt.clouddn.com/%E5%B9%B3%E5%87%A1%E4%B9%8B%E8%B7%AF.txt"&#125;,&#123;"title": "野子","author": "苏运莹","url": "http://xxx.com/01%20%E9%87%8E%E5%AD%90.m4a","pic": "http://xxxx.com/%E9%87%8E%E5%AD%90.jpg","lrc":"https://xxx.com/%E9%87%8E%E5%AD%90.txt"&#125;]&#125;&#123;% endaplayerlist %&#125; 当然，Aplayer的作者还有一款html5的视频播放器，叫Dplayer，对应有一款hexo的插件，叫hexo-tag-dplayer，有需求的可以去看看，用法都差不多。 一起high一下这个功能是我在Hexo high一下小功能上看到的，觉得很有意思，于是就引进来，改造了一下。 首先是重新封装了一个high.js文件，代码中注释的地方可下载下来放到七牛，加快国内访问速度： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150function shake() &#123; function c() &#123; var e = document.createElement("link"); e.setAttribute("type", "text/css"); e.setAttribute("rel", "stylesheet"); e.setAttribute("href", f); e.setAttribute("class", l); document.body.appendChild(e) &#125; function h() &#123; var e = document.getElementsByClassName(l); for (var t = 0; t &lt; e.length; t++) &#123; document.body.removeChild(e[t]) &#125; &#125; function p() &#123; var e = document.createElement("div"); e.setAttribute("class", a); document.body.appendChild(e); setTimeout(function() &#123; document.body.removeChild(e) &#125;, 100) &#125; function d(e) &#123; return &#123; height : e.offsetHeight, width : e.offsetWidth &#125; &#125; function v(i) &#123; var s = d(i); return s.height &gt; e &amp;&amp; s.height &lt; n &amp;&amp; s.width &gt; t &amp;&amp; s.width &lt; r &#125; function m(e) &#123; var t = e; var n = 0; while (!!t) &#123; n += t.offsetTop; t = t.offsetParent &#125; return n &#125; function g() &#123; var e = document.documentElement; if (!!window.innerWidth) &#123; return window.innerHeight &#125; else if (e &amp;&amp; !isNaN(e.clientHeight)) &#123; return e.clientHeight &#125; return 0 &#125; function y() &#123; if (window.pageYOffset) &#123; return window.pageYOffset &#125; return Math.max(document.documentElement.scrollTop, document.body.scrollTop) &#125; function E(e) &#123; var t = m(e); return t &gt;= w &amp;&amp; t &lt;= b + w &#125; function S() &#123; var e = document.createElement("audio"); e.setAttribute("class", l); e.src = i; e.loop = false; e.addEventListener("canplay", function() &#123; setTimeout(function() &#123; x(k) &#125;, 500); setTimeout(function() &#123; N(); p(); for (var e = 0; e &lt; O.length; e++) &#123; T(O[e]) &#125; &#125;, 15500) &#125;, true); e.addEventListener("ended", function() &#123; N(); h() &#125;, true); e.innerHTML = " &lt;p&gt;If you are reading this, it is because your browser does not support the audio element. We recommend that you get a new browser.&lt;/p&gt; &lt;p&gt;"; document.body.appendChild(e); e.play() &#125; function x(e) &#123; e.className += " " + s + " " + o &#125; function T(e) &#123; e.className += " " + s + " " + u[Math.floor(Math.random() * u.length)] &#125; function N() &#123; var e = document.getElementsByClassName(s); var t = new RegExp("\\b" + s + "\\b"); for (var n = 0; n &lt; e.length; ) &#123; e[n].className = e[n].className.replace(t, "") &#125; &#125; var e = 30; var t = 30; var n = 350; var r = 350; var i = "http://o9w8f1xrl.bkt.clouddn.com/highqilai/harlem-shake.mp3"; //可下载下来放到七牛，加快国内访问速度 var s = "mw-harlem_shake_me"; var o = "im_first"; var u = ["im_drunk", "im_baked", "im_trippin", "im_blown"]; var a = "mw-strobe_light"; var f = "http://o9w8f1xrl.bkt.clouddn.com/highqilai/harlem-shake-style.css";//可下载下来放到七牛，加快国内访问速度 var l = "mw_added_css"; var b = g(); var w = y(); var C = document.getElementsByTagName("*"); var k = null; for (var L = 0; L &lt; C.length; L++) &#123; var A = C[L]; if (v(A)) &#123; if (E(A)) &#123; k = A; break &#125; &#125; &#125; if (A === null) &#123; console.warn("Could not find a node of the right size. Please try a different page."); return &#125; c(); S(); var O = []; for (var L = 0; L &lt; C.length; L++) &#123; var A = C[L]; if (v(A)) &#123; O.push(A) &#125; &#125;&#125; 把这个文件保存在七牛上，在themes—&gt;next—&gt;layout—&gt;_partials—&gt;head.swig中加入这样一段代码，引入high.js文件(src里的内容请替换成自己的外链)： 1&lt;script type="text/javascript" src="https://xxx.com/high.js"&gt;&lt;/script&gt; 然后在themes—&gt;next—&gt;layout—&gt;_macro—&gt;sidebar.swig中加入注释包围中的代码： 1234567891011121314151617&lt;div class="links-of-author motion-element"&gt; &#123;% if theme.social %&#125; &#123;% for name, link in theme.social %&#125; &lt;span class="links-of-author-item"&gt; &lt;a href="&#123;&#123; link &#125;&#125;" target="_blank" title="&#123;&#123; name &#125;&#125;"&gt; &#123;% if theme.social_icons.enable %&#125; &lt;i class="fa fa-fw fa-&#123;&#123; theme.social_icons[name] | default('globe') | lower &#125;&#125;"&gt;&lt;/i&gt; &#123;% endif %&#125; &#123;&#123; name &#125;&#125; &lt;/a&gt; &lt;/span&gt; &#123;% endfor %&#125; &lt;!--以下是加入关于high一下的代码--&gt; &lt;span class="links-of-author-item"&gt;&lt;a title="小high一下~" style="underline: none;color:red" rel="alternate" class="mw-harlem_shake_slow wobble shake" href="javascript:shake()"&gt;&lt;i class="fa fa-music"&gt;&lt;/i&gt; &amp;nbsp;&amp;nbsp;High&lt;/a&gt;&lt;/span&gt; &lt;!--以上是加入关于high一下的代码--&gt; &#123;% endif %&#125; &lt;/div&gt; style中我用了红色，这样显眼一点，不喜欢的话可以改掉。 接下来点击high这个按钮，会出现一下效果： 大坑当我吭哧吭哧的弄完后，突然发现我运行hexo g命令后，出现下面两行提示后就不动了~ 12INFO Start processingINFO Files loaded in 3.9 s 我用了各种方法，包括版本回退，好像都没用。于是我就尝试切换到hexo默认主题，结果又可以hexo g，估计是next主题出问题了，于是我重新下了next主题，把我的配置都重新弄了一遍，结果好了~~，不过页脚的地方与之前博客不同，少了”power by hexo”这几个字眼。 更新next后遇到的第一个问题是，不显示文章发表时间了，github上的解答是这样的,文章标题下的发表时间不见了,在主题配置文件里面加上下面的配置，然后就出来了。 12345# Post meta display settingspost_meta: created_at: true updated_at: false categories: true 第二个问题，我hexo s成功后，登陆localhost:4000，发现出现下面的提示： 原因是，我开了shadowsocks的全局模式，切换到自动代理模式，就可以显示网页了。]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSON那些事]]></title>
    <url>%2F2016%2F12%2F18%2FJSON%E9%82%A3%E4%BA%9B%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[最近用echarts时和json打交道比较多，在此记录一下关于json的一些事情。 什么是JSONw3school上给出的描述是： JSON 指的是 JavaScript 对象表示法（JavaScript Object Notation） JSON 是轻量级的文本数据交换格式 JSON 独立于语言 * JSON 具有自我描述性，更易理解 * JSON 使用 JavaScript 语法来描述数据对象，但是 JSON 仍然独立于语言和平台。JSON 解析器和 JSON 库支持许多不同的编程语言。 JSON数据书写格式是： 1name : value 其中value的值可以是 数字（整数或浮点数） 字符串（在双引号中） 逻辑值（true 或 false） 数组（在方括号中） 对象（在花括号中） null JSON对象与JSON数组JSON对象JSON对象在{}中书写，对象可以包含多个键值对； 1&#123;"firstName":"John" , "lastName":"Doe"&#125; 一般JSON对象中有多个键值对时，用,隔开，最后一个键值对结束时可以不写,。 JSON数组JSON数组在[]中书写，数组可以包含多个对象。 举个栗子： 1234567&#123; "employees": [ &#123; "firstName":"John" , "lastName":"Doe" &#125;, &#123; "firstName":"Anna" , "lastName":"Smith" &#125;, &#123; "firstName":"Peter" , "lastName":"Jones" &#125; ]&#125; &quot;employees&quot;这个json对象包含了三个json对象的数组。 JSON的操作获取value举个例子: 12345var employees = [&#123; "firstName":"Bill" , "lastName":"Gates" &#125;,&#123; "firstName":"George" , "lastName":"Bush" &#125;,&#123; "firstName":"Thomas" , "lastName": "Carter" &#125;]; 如果要得到Bill的firstName，可以这样写： 1employees[0].firstName; 因为employees是数组，首先通过employees[0]来获取第一个对象，然后用.加要访问的字段名称，就可以获取该字段对应的值。 添加和删除JSON对象1234567var json = &#123;&#125;; //空json对像 json['firstname'] = "cheng"; //添加二个元素 json['lastname'] = "tang"; console.log(json); delete json['lastname']; //删除json中的某个元素 console.log(json); JSON数组123456789var json1 = [&#123;"name":"tang","total":"1"&#125;,&#123;"name":"zhou","total":"2"&#125;,&#123;"name":"he","total":"3"&#125;]; var add = &#123;"name":"may"&#125;; json1.push(add); //添加一个元素 console.log(json1); delete json1[2]; //删除一个元素 console.log(json1); 遍历JSON对象假设有一个JSON对象： 1var data=&#123;'a':10,'b':20,'c':30,'d':40&#125;; 怎么遍历这个对象呢，可以用for-in: 1234567for(var n in data)&#123; console.log(n); //输出 a，b，c，d console.log(data[n]); //输出 10，20，30，40&#125; 在JavaScript中[]等同于. ，所以 data[n]可以理解为data.n，只不过n是变量，用.获取不到对应的值。 JSON数组假设有一个JSON数组： 1var data=[&#123;name:"a",age:1&#125;,&#123;name:"b",age:2&#125;,&#123;name:"c",age:3&#125;,&#123;name:"d",age:4&#125;]; 遍历这个数组： 12345678910for(var n in data)&#123; console.log(n); //输出：0，1，2，3 console.log(data[n]); //输出：&#123;name:"a",age:1&#125;,&#123;name:"b",age:2&#125;,&#123;name:"c",age:3&#125;,&#123;name:"d",age:4&#125; console.log("text:"+data[n].name+" value:"+data[n].age ); //输出：text:a value:1，text:b value:2，text:c value:3，text:d value:4&#125; 或者： 1234567for (var n = 0;n &lt; data.length; n++)&#123; console.log(data[n]); //输出：&#123;name:"a",age:1&#125;,&#123;name:"b",age:2&#125;,&#123;name:"c",age:3&#125;,&#123;name:"d",age:4&#125; console.log("text:"+data[n].name+" value:"+data[n].age ); //输出：text:a value:1，text:b value:2，text:c value:3，text:d value:4&#125; eval()与JSON.parse()eval()可以将字符串转换为 JavaScript 对象： 12345var key = 'tangcheng';var test = '&#123;"'+ key +'": ""&#125;'; //定义了一个叫test的字符串var json = eval('('+test+')'); //用eval()函数解析testconsole.log(json)//输出： Object &#123;tangcheng: ""&#125; 通过这个方法我们就可以动态设置key的值。但是使用这个方法会存在潜在的安全问题，所以可以用JSON.parse()，这个方法需要较高版本的浏览器支持。 12345var key = 'tangcheng';var test = '&#123;"'+ key +'": ""&#125;'; //定义了一个叫test的字符串var json = JSON.parse(test); //用eval()函数解析testconsole.log(json)//输出： Object &#123;tangcheng: ""&#125; 接下来就可以通过json[key] = value来设置key对应的value值。 Object.keys() Object.keys() 方法会返回一个由给定对象的所有可枚举自身属性的属性名组成的数组，数组中属性名的排列顺序和使用for-in循环遍历该对象时返回的顺序一致（两者的主要区别是 for-in 还会遍历出一个对象从其原型链上继承到的可枚举属性）。 123456789101112var bookAuthors = &#123; "Farmer Giles of Ham": "J.R.R. Tolkien", "Out of the Silent Planet": "C.S. Lewis", "The Place of the Lion": "Charles Williams", "Poetic Diction": "Owen Barfield"&#125;;var arr = Object.keys(bookAuthors);console.log(arr);//输出: Array [ "Farmer Giles of Ham", "Out of the Silent Planet", "The Place of the Lion", "Poetic Diction" ]console.log(arr.length);//输出: 4 用这个方法可以把json对象转换成数组，这样可以方便的对这个数组进行一些操作。 1234567var test = &#123; "name ": "tangcheng", "value": [1,2,3,4,5]&#125;var arr = Object.keys(test);console.log(arr.length); //输出： 2console.log(test.length) //输出：undefined Object.keys()方法，只能使用在高版本浏览器，IE8及以下是不支持的，如果想支持IE低版本，可以参考Javascript 计算Object的长度中提供的方法。 参考文章： JSON中让key作为参数传入的方法； Javascript 计算Object的长度]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJS2中一种button切换效果的实现（一）]]></title>
    <url>%2F2016%2F12%2F08%2FAngularJS2%E4%B8%AD%E4%B8%80%E7%A7%8Dbutton%E5%88%87%E6%8D%A2%E6%95%88%E6%9E%9C%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[最近在AngularJS2中要实现一个按钮切换的效果，我采用三目表达式和ng-class的方式来实现了这一效果，比较简单粗暴。 首先，我的项目的XX.Component.ts中的template有个button标签： 12&lt;button type="submit"&gt;列表&lt;/button&gt;&lt;button type="submit"&gt;折线图&lt;/button&gt; 创建XX.Component.css，为标签添加简单的样式（我只是举个例子，这个样式的定义还可以再优化一下）： 12345678910111213141516171819.active &#123; color: #fff; border: 1px solid transparent; border-radius: 4px; background-color: #0086FD; padding: 5px; outline: none; width: 55px;&#125;.btn-lt &#123; color: #fff; border: 1px solid transparent; border-radius: 4px; background-color: gray; padding: 5px; outline: none; width: 55px;&#125; 然后我需要实现的效果是：加载完页面后，两个按钮都是灰色的，当你点击其中一个按钮时，按钮变成蓝色。 为了实现这个效果，我引入了begin和blue两个变量，分别控制起始状态和点击时的状态。当blue为true且begin===1时按钮变蓝色；当blue为false时或者begin！= 1时按钮变灰色。代码如下： 12&lt;button [class]="begin === 1 &amp;&amp; blue?'active':'btn-lt'" type="submit" (click)="blue=true;begin=1"&gt;列表&lt;/button&gt;&lt;button [class]="begin === 1 &amp;&amp; !blue?'active':'btn-lt'" type="submit" (click)="blue=false;begin=1"&gt;折线图&lt;/button&gt; 完成后的效果如下： 这个方法还可以组合出其他不同的效果，比如说点击后当前按钮变灰： 12&lt;button [class]="begin === 1 &amp;&amp; blue?'active':'btn-lt'" type="submit" (click)="blue=false;begin=1"&gt;列表&lt;/button&gt;&lt;button [class]="begin === 1 &amp;&amp; !blue?'active':'btn-lt'" type="submit" (click)="blue=true;begin=1"&gt;折线图&lt;/button&gt; 完成后的效果如下： 比如把begin去掉，可以实现加载完成后有一个按钮处于激活状态，这里我就不做gif了，可以自己尝试一下。]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Echarts使用小结]]></title>
    <url>%2F2016%2F12%2F04%2FEcharts%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[这周项目上写了一个基于Angular2.0的Echarts3组件，踩了好几个坑，也算有一点使用心得了。 Echarts是什么鬼 ECharts 是指 Enterprise Charts（商业产品图表库），提供商业产品常用图表库，底层基于 ZRender，创建了坐标系，图例，提示，工具箱等基础组件，并在此上构建出折线图（区域图）、柱状图（条状图）、散点图（气泡图）、K线图、饼图（环形图）、地图、力导向布局图，同时支持任意维度的堆积和多图表混合展现。 Echarts提供了多种图表展示方式： Echarts提供了包括值域漫游、大规模散点图、数据动态添加、数据区域漫游、图例开关、动态类型切换等在内的多种数据操作方式。Echarts升级到3.0后，增加了对移动端的支持，而且体积更小，实乃数据分析必备良药。 Echarts正确打开方式首先来看官方案例： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;ECharts&lt;/title&gt; &lt;!-- 引入 echarts.js --&gt; &lt;script src="echarts.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 为ECharts准备一个具备大小（宽高）的Dom --&gt; &lt;div id="main" style="width: 600px;height:400px;"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById('main')); // 指定图表的配置项和数据 var option = &#123; title: &#123; text: 'ECharts 入门示例' &#125;, tooltip: &#123;&#125;, legend: &#123; data:['销量'] &#125;, xAxis: &#123; data: ["衬衫","羊毛衫","雪纺衫","裤子","高跟鞋","袜子"] &#125;, yAxis: &#123;&#125;, series: [&#123; name: '销量', type: 'bar', data: [5, 20, 36, 10, 10, 20] &#125;] &#125;; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 怎么样，是不是觉得很好玩，当然这只是最基本的数据展示功能，下面我们来玩一个进阶一点的Demo。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="gb2312"&gt; &lt;title&gt;echarts3&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;echarts3 demo&lt;/h1&gt; &lt;!--定义有大小的DOM容器--&gt; &lt;div id="barChart" style="width: 100%;height:600px;"&gt;&lt;/div&gt; &lt;div id="lineChart" style="width: 100%;height:600px;"&gt;&lt;/div&gt; &lt;div id="radarChart" style="width: 100%;height:600px;"&gt;&lt;/div&gt; &lt;div id="pieChart" style="width: 100%;height:600px;"&gt;&lt;/div&gt; &lt;div id="dotChart" style="width: 100%;height:600px;"&gt;&lt;/div&gt; &lt;!--导入js代码--&gt; &lt;script type="text/javascript" src='./jquery.js'&gt;&lt;/script&gt; &lt;script type="text/javascript" src='./echarts.js'&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; //界面最先运行这个代码块 $(document).ready(function() &#123; initBarEcharts(); initLineEcharts(); initRadarEcharts(); initPieEcharts(); initDotEcharts(); &#125;); //初始化柱状图 function initBarEcharts() &#123; var myChart = echarts.init(document.getElementById('barChart')); // 指定图表的配置项和数据 var option = &#123; title: &#123; text: 'ECharts 入门示例' &#125;, dataZoom: &#123; type: 'slider', show: true, start: 1, end: 35 &#125;, tooltip: &#123;&#125;, toolbox: &#123; show: true, feature: &#123; saveAsImage: &#123; show: true, type: 'jpeg', &#125;, restore: &#123; show: true, &#125;, dataView: &#123; show: true, &#125;, magicType: &#123; show: true, &#125; &#125;, &#125;, legend: &#123; data: ['销量'] &#125;, xAxis: &#123; //x轴数据，数组形式 data: ["衬衫", "羊毛衫", "雪纺衫", "裤子", "高跟鞋", "袜子"] &#125;, yAxis: &#123;&#125;, series: [&#123; name: '销量', type: 'bar', data: [5, 20, 36, 10, 10, 20] &#125;] &#125;; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); &#125; //初始化折线图图 function initLineEcharts() &#123; var myChart = echarts.init(document.getElementById('lineChart')); // 指定图表的配置项和数据 option = &#123; title: &#123; text: '堆叠区域图' &#125;, tooltip: &#123; trigger: 'axis' &#125;, legend: &#123; data: ['邮件营销', '联盟广告', '视频广告', '直接访问', '搜索引擎'] &#125;, toolbox: &#123; feature: &#123; saveAsImage: &#123;&#125; &#125; &#125;, grid: &#123; left: '3%', right: '4%', bottom: '3%', containLabel: true &#125;, xAxis: [&#123; type: 'category', boundaryGap: false, data: ['周一', '周二', '周三', '周四', '周五', '周六', '周日'] &#125;], yAxis: [&#123; type: 'value' &#125;], series: [&#123; name: '邮件营销', type: 'line', stack: '总量', areaStyle: &#123; normal: &#123;&#125; &#125;, data: [120, 132, 101, 134, 90, 230, 210] &#125;, &#123; name: '联盟广告', type: 'line', stack: '总量', areaStyle: &#123; normal: &#123;&#125; &#125;, data: [220, 182, 191, 234, 290, 330, 310] &#125;, &#123; name: '视频广告', type: 'line', stack: '总量', areaStyle: &#123; normal: &#123;&#125; &#125;, data: [150, 232, 201, 154, 190, 330, 410] &#125;, &#123; name: '直接访问', type: 'line', stack: '总量', areaStyle: &#123; normal: &#123;&#125; &#125;, data: [320, 332, 301, 334, 390, 330, 320] &#125;, &#123; name: '搜索引擎', type: 'line', stack: '总量', label: &#123; normal: &#123; show: true, position: 'top' &#125; &#125;, areaStyle: &#123; normal: &#123;&#125; &#125;, data: [820, 932, 901, 934, 1290, 1330, 1320] &#125;] &#125;; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); &#125; //初始化雷达图 function initRadarEcharts() &#123; var myChart = echarts.init(document.getElementById('radarChart')); // 指定图表的配置项和数据 option = &#123; title: &#123; text: '基础雷达图' &#125;, tooltip: &#123;&#125;, legend: &#123; data: ['预算分配（Allocated Budget）', '实际开销（Actual Spending）'] &#125;, radar: &#123; // shape: 'circle', indicator: [&#123; name: '销售（sales）', max: 6500 &#125;, &#123; name: '管理（Administration）', max: 16000 &#125;, &#123; name: '信息技术（Information Techology）', max: 30000 &#125;, &#123; name: '客服（Customer Support）', max: 38000 &#125;, &#123; name: '研发（Development）', max: 52000 &#125;, &#123; name: '市场（Marketing）', max: 25000 &#125;] &#125;, series: [&#123; name: '预算 vs 开销（Budget vs spending）', type: 'radar', // areaStyle: &#123;normal: &#123;&#125;&#125;, data: [&#123; value: [4300, 10000, 28000, 35000, 50000, 19000], name: '预算分配（Allocated Budget）' &#125;, &#123; value: [5000, 14000, 28000, 31000, 42000, 21000], name: '实际开销（Actual Spending）' &#125;] &#125;] &#125;; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); &#125; //初始化饼图 function initPieEcharts() &#123; var myChart = echarts.init(document.getElementById('pieChart')); // 指定图表的配置项和数据 option = &#123; backgroundColor: '#2c343c', title: &#123; text: 'Customized Pie', left: 'center', top: 20, textStyle: &#123; color: '#ccc' &#125; &#125;, tooltip: &#123; trigger: 'item', formatter: "&#123;a&#125; &lt;br/&gt;&#123;b&#125; : &#123;c&#125; (&#123;d&#125;%)" &#125;, visualMap: &#123; show: false, min: 80, max: 600, inRange: &#123; colorLightness: [0, 1] &#125; &#125;, series: [&#123; name: '访问来源', type: 'pie', radius: '55%', center: ['50%', '50%'], data: [&#123; value: 335, name: '直接访问' &#125;, &#123; value: 310, name: '邮件营销' &#125;, &#123; value: 274, name: '联盟广告' &#125;, &#123; value: 235, name: '视频广告' &#125;, &#123; value: 400, name: '搜索引擎' &#125;].sort(function(a, b) &#123; return a.value - b.value &#125;), roseType: 'angle', label: &#123; normal: &#123; textStyle: &#123; color: 'rgba(255, 255, 255, 0.3)' &#125; &#125; &#125;, labelLine: &#123; normal: &#123; lineStyle: &#123; color: 'rgba(255, 255, 255, 0.3)' &#125;, smooth: 0.2, length: 10, length2: 20 &#125; &#125;, itemStyle: &#123; normal: &#123; color: '#c23531', shadowBlur: 200, shadowColor: 'rgba(0, 0, 0, 0.5)' &#125; &#125; &#125;] &#125;; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); &#125; //初始化散点图 function initDotEcharts() &#123; var myChart = echarts.init(document.getElementById('dotChart')); // 指定图表的配置项和数据 var data = [ [ [28604, 77, 17096869, 'Australia', 1990], [31163, 77.4, 27662440, 'Canada', 1990], [1516, 68, 1154605773, 'China', 1990], [13670, 74.7, 10582082, 'Cuba', 1990], [28599, 75, 4986705, 'Finland', 1990], [29476, 77.1, 56943299, 'France', 1990], [31476, 75.4, 78958237, 'Germany', 1990], [28666, 78.1, 254830, 'Iceland', 1990], [1777, 57.7, 870601776, 'India', 1990], [29550, 79.1, 122249285, 'Japan', 1990], [2076, 67.9, 20194354, 'North Korea', 1990], [12087, 72, 42972254, 'South Korea', 1990], [24021, 75.4, 3397534, 'New Zealand', 1990], [43296, 76.8, 4240375, 'Norway', 1990], [10088, 70.8, 38195258, 'Poland', 1990], [19349, 69.6, 147568552, 'Russia', 1990], [10670, 67.3, 53994605, 'Turkey', 1990], [26424, 75.7, 57110117, 'United Kingdom', 1990], [37062, 75.4, 252847810, 'United States', 1990] ], [ [44056, 81.8, 23968973, 'Australia', 2015], [43294, 81.7, 35939927, 'Canada', 2015], [13334, 76.9, 1376048943, 'China', 2015], [21291, 78.5, 11389562, 'Cuba', 2015], [38923, 80.8, 5503457, 'Finland', 2015], [37599, 81.9, 64395345, 'France', 2015], [44053, 81.1, 80688545, 'Germany', 2015], [42182, 82.8, 329425, 'Iceland', 2015], [5903, 66.8, 1311050527, 'India', 2015], [36162, 83.5, 126573481, 'Japan', 2015], [1390, 71.4, 25155317, 'North Korea', 2015], [34644, 80.7, 50293439, 'South Korea', 2015], [34186, 80.6, 4528526, 'New Zealand', 2015], [64304, 81.6, 5210967, 'Norway', 2015], [24787, 77.3, 38611794, 'Poland', 2015], [23038, 73.13, 143456918, 'Russia', 2015], [19360, 76.5, 78665830, 'Turkey', 2015], [38225, 81.4, 64715810, 'United Kingdom', 2015], [53354, 79.1, 321773631, 'United States', 2015] ] ]; option = &#123; backgroundColor: new echarts.graphic.RadialGradient(0.3, 0.3, 0.8, [&#123; offset: 0, color: '#f7f8fa' &#125;, &#123; offset: 1, color: '#cdd0d5' &#125;]), title: &#123; text: '1990 与 2015 年各国家人均寿命与 GDP' &#125;, legend: &#123; right: 10, data: ['1990', '2015'] &#125;, xAxis: &#123; splitLine: &#123; lineStyle: &#123; type: 'dashed' &#125; &#125; &#125;, yAxis: &#123; splitLine: &#123; lineStyle: &#123; type: 'dashed' &#125; &#125;, scale: true &#125;, series: [&#123; name: '1990', data: data[0], type: 'scatter', symbolSize: function(data) &#123; return Math.sqrt(data[2]) / 5e2; &#125;, label: &#123; emphasis: &#123; show: true, formatter: function(param) &#123; return param.data[3]; &#125;, position: 'top' &#125; &#125;, itemStyle: &#123; normal: &#123; shadowBlur: 10, shadowColor: 'rgba(120, 36, 50, 0.5)', shadowOffsetY: 5, color: new echarts.graphic.RadialGradient(0.4, 0.3, 1, [&#123; offset: 0, color: 'rgb(251, 118, 123)' &#125;, &#123; offset: 1, color: 'rgb(204, 46, 72)' &#125;]) &#125; &#125; &#125;, &#123; name: '2015', data: data[1], type: 'scatter', symbolSize: function(data) &#123; return Math.sqrt(data[2]) / 5e2; &#125;, label: &#123; emphasis: &#123; show: true, formatter: function(param) &#123; return param.data[3]; &#125;, position: 'top' &#125; &#125;, itemStyle: &#123; normal: &#123; shadowBlur: 10, shadowColor: 'rgba(25, 100, 150, 0.5)', shadowOffsetY: 5, color: new echarts.graphic.RadialGradient(0.4, 0.3, 1, [&#123; offset: 0, color: 'rgb(129, 227, 238)' &#125;, &#123; offset: 1, color: 'rgb(25, 183, 207)' &#125;]) &#125; &#125; &#125;] &#125;; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Echarts与Angular2.0我做组件的时候定义了ky-line标签，通过&lt;ky-line [data]=&quot;myoption&quot;&gt;&lt;/ky-line&gt;里的data属性来传递option的数据，这样拿到后端的数据后，往myoption里面push数据，并通过ky-line标签，把数据传递给Echarts中的option，这样就可以实现给echarts动态写入数据。不过要注意的是，给echarts中动态增加数据的时候，首先要搞清楚json对象和json数组的概念，不然容易出错。]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>Echarts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oh_My_Zsh-终端改造]]></title>
    <url>%2F2016%2F11%2F28%2FOh-My-Zsh-%E7%BB%88%E7%AB%AF%E6%94%B9%E9%80%A0%2F</url>
    <content type="text"><![CDATA[周末的时候无意中看到一篇文章终极 Shell，介绍的就是今天讲的主角Oh My Zsh 。 什么是Oh My Zsh Oh My Zsh是一款社区驱动的命令行工具，正如它的主页上说的，Oh My Zsh 是一种生活方式。它基于zsh命令行，提供了主题配置，插件机制，已经内置的便捷操作。给我们一种全新的方式使用命令行。 Oh My Zsh这个名字听起来就很有意思，它是基于zsh命令行的一个扩展工具集，提供了丰富的扩展功能。 Oh My Zsh只是一个对zsh命令行环境的配置包装框架，但它不提供命令行窗口，更不是一个独立的APP。 更详细介绍可到官网了解，Oh My Zsh官网：http://ohmyz.sh 安装Oh My Zsh前提条件：必须已安装ZSH 我们可以在命令行中输入这个命令来查看我们的电脑上是否安装了zsh命令行 1$ zsh --version 如果安装了，这个命令就会输出zsh当前的版本号。确定 zsh 已经安装后，我们就可以继续安装Oh My Zsh了。 安装Oh My Zsh Oh My Zsh 的安装方式非常简单，可以通过curl或wget的方式，用一条命令即可安装。 curl 方式 1$ sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; wget 方式 1$ sh -c &quot;$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot; 安装过程中输出如下 12345678910111213141516171819202122Cloning Oh My Zsh...Cloning into &apos;/root/.oh-my-zsh&apos;...remote: Counting objects: 712, done.remote: Compressing objects: 100% (584/584), done.remote: Total 712 (delta 15), reused 522 (delta 4), pack-reused 0Receiving objects: 100% (712/712), 443.58 KiB | 27.00 KiB/s, done.Resolving deltas: 100% (15/15), done.Checking connectivity... done.Looking for an existing zsh config...Using the Oh My Zsh template file and adding it to ~/.zshrcCopying your current PATH and adding it to the end of ~/.zshrc for you.Time to change your default shell to zsh! __ __ ____ / /_ ____ ___ __ __ ____ _____/ /_/ __ \/ __ \ / __ `__ \/ / / / /_ / / ___/ __ \/ /_/ / / / / / / / / / / /_/ / / /_(__ ) / / /\____/_/ /_/ /_/ /_/ /_/\__, / /___/____/_/ /_/ /____/ ....is now installed!Please look over the ~/.zshrc file to select plugins, themes, and options.p.s. Follow us at https://twitter.com/ohmyzsh.p.p.s. Get stickers and t-shirts at http://shop.planetargon.com. 到这里，Oh My Zsh 就安装成功了。 设置主题安装完毕后，我们就可以使用了，咱们先来简单配置一下。Oh My Zsh 提供了很多主题风格，我们可以根据自己的喜好，设置主题风格，主题的配置在 ~/.zshrc 文件中可以看到，用一个自己熟悉的编辑器打开这个文件，可以找到这一项： 1ZSH_THEME=&quot;robbyrussel&quot; 可以看到，我们默认使用的主题叫做robbyrussel。 Oh My Zsh默认自带了一些默认主题，存放在~/.oh-my-zsh/themes目录中。我们可以查看这些主题 12345678910111213$ ls ~/.oh-my-zsh/themes3den.zsh-theme essembeh.zsh-theme junkfood.zsh-theme rgm.zsh-themeSoliah.zsh-theme evan.zsh-theme kafeitu.zsh-theme risto.zsh-themeadben.zsh-theme example.zsh-theme kardan.zsh-theme rixius.zsh-themeaf-magic.zsh-theme fino-time.zsh-theme kennethreitz.zsh-theme rkj-repos.zsh-themeafowler.zsh-theme fino.zsh-theme kiwi.zsh-theme rkj.zsh-themeagnoster.zsh-theme fishy.zsh-theme kolo.zsh-theme robbyrussell.zsh-themealanpeabody.zsh-theme flazz.zsh-theme kphoen.zsh-theme sammy.zsh-themeamuse.zsh-theme fletcherm.zsh-theme lambda.zsh-theme simonoff.zsh-themeapple.zsh-theme fox.zsh-theme linuxonly.zsh-theme simple.zsh-themearrow.zsh-theme frisk.zsh-theme lukerandall.zsh-theme skaro.zsh-theme.... 这么多的主题可以满足你的各种偏好了，我们只需在./zshrc文件中配置需要的主题即可，比如我们想用lambda.zsh-theme这个主题，我们只要这样配置 1ZSH_THEME=lambda 请注意好多教程上这边都有&quot;&quot;，但是请把双引号去掉，不然可能安装不成功，这也算是一个小坑。 然后保存这个文件文件，再打开一个新的命令行窗口即可看到效果了。那么这么多的主题如何快速找到哪些是我们喜欢的呢，我们还可以这样设置 1ZSH_THEME=&quot;random&quot; 我们将主题设置为随机，这样在我们每次打开命令行窗口的时候，都会随机在默认主题中选择一个。这样我们如果觉得当前的主题比较喜欢，可以直接使用 echo 命令输出当前主题的名称 1$ echo $ZSH_THEME 然后再将他设置到配置文件中即可。 我使用的ys这款主题，该有的信息都能展示出来，界面如下： 启用插件Oh My Zsh 默认自带了一些默认主题，存放在~/.oh-my-zsh/plugins目录中。我们可以查看这些插件 1plugins=(git) 如需启用更多插件，可加入需启用插件的名称。如下 1plugins=(git wd web-search history history-substring-search) 更新设置自动更新oh-my-zsh 默认情况下，当oh-my-zsh有更新时，都会给你提示。如果希望让oh-my-zsh自动更新，在~/.zshrc 中添加下面这句 1DISABLE_UPDATE_PROMPT=true 要手动更新，可以执行 1$ upgrade_oh_my_zsh 卸载直接在终端中，运行uninstall_oh_my_zsh既可以卸载。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Oh_My_Zsh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo在遇到“{{”符号时出现解析报错]]></title>
    <url>%2F2016%2F11%2F24%2Fhexo%20%E5%9C%A8%E9%81%87%E5%88%B0%20%E2%80%9C%7B%7B%E2%80%9D%20%E7%AC%A6%E5%8F%B7%E6%97%B6%E5%87%BA%E7%8E%B0%E8%A7%A3%E6%9E%90%E6%8A%A5%E9%94%99%2F</url>
    <content type="text"><![CDATA[刚刚生成了一篇文章， hexo g 时会报错， 错误信息大致如下： 123FATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlTemplate render error: (unknown path) [Line 128, Column 48]unexpected token: . 估计是文章的原因，试了一下，把文章移除后一切又正常了，但是就是不知道文章中哪里出错了。 网上搜了好久，发现了这篇文章：hexo 在遇到 “}}” 符号时出现解析报错。 查找资料发现有人遇到和我类似的问题，但报的是 `unexpected token: }}的错误。搜索一下我那篇文章，果然有好几处带有 }} 符号。尝试着把几处符号删除，果然正常了。看来问题真的出在 }}上面。 直接说解决方案吧，参考别人的解决方法是在 }}中间加一个空格，但因为我的是有部分教程含义的文章，所以并不想这样误导人。于是去 github 上找解决方案。 github 上给出的方法是在需要显示 }}符号的地方加上 12&gt; &#123;% raw %&#125;&#123;% endraw %&#125;&gt; 标签，标记这部分不需要解析。例如文章中可能会出现 { { something } } 的片段，写成 12&gt; &#123;% raw %&#125;&#123;&#123; something &#125;&#125;&#123;% endraw %&#125;&gt; 就可以了。 虽然有点麻烦，但也算临时解决了这个问题，这是个已知 bug ，希望后续的版本能修复吧，毕竟使用太多 hexo 专属的标签对博客以后的迁移、改版什么的来说还是很麻烦的。 但是 1&#123;% raw %&#125;&#123;% endraw %&#125; 标签在代码块中会显示出来，前一篇文章的代码块中的}}符号我就用空格隔开了。]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小记]]></title>
    <url>%2F2016%2F11%2F14%2F%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[工作终于有了着落，也算半只脚跨入了心仪已久的行业。 因为行业跨度太大，一路走来承受了很多压力，也很庆幸自己真的走过来了。 这几个月经常为了一个问题弄到凌晨三四点，每天一成不变的白米饭加老干妈。自己也迷茫过、质疑过、崩溃过，但是既然自己选择了这条路，那就要走到底。 感谢汪汪和田野的帮助，给了我那么一大箱的书，耐心解答我的问题，把我这个门外汉一步步领进门。 很庆幸，在年轻的时候能尝试去做自己想做的事情，尽管前路漫漫，充满更多的未知。 希望多年后，自己依然对技术保持一颗火热的心，依然充满激情。]]></content>
      <categories>
        <category>生活杂谈</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[终于有自己的域名啦]]></title>
    <url>%2F2016%2F11%2F12%2F%E7%BB%88%E4%BA%8E%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9F%9F%E5%90%8D%E5%95%A6%2F</url>
    <content type="text"><![CDATA[双十一大家都在买买买的时候，有一个小码农也不甘寂寞，默默地在Namecheap上买了一个域名，完成了双十一的剁手之旅。 剁手之旅参照了新版Namecheap注册域名详细教程，还是比较简单的。不过我的域名解析用的是DNSPOD，没有用Namecheap的域名解析，这样国内的用coding访问，国外用github访问，可以加快网站访问速度。 Github的设置比较简单，在/hexo/source中添加一个CNAME文件，注意不需要后缀名，里面内容就写tc9011.com，不要写www。然后去github page上绑定一下域名，DNS解析的话我是这样设置的： 下面说一下新版的coding绑定域名的问题，我发现这是一个大坑啊~~ 我直接访问tc9011.github.io地址会跳转到tc9011.com,我直接访问tc9011.coding.me发现不会跳转到tc9011.com这个域名，原因我搜了一下，答案如下： github只能绑定一个域名，所以访问tengj.github.io时，github的服务器知道要往tengj.top跳转。coding可以绑定多个域名，当绑定多个域名时，访问tengj.coding.me,coding的服务器不知道要往哪里跳转，所以干脆就不跳转了。但是当绑定一个时，为什么不跳转，可能是coding觉得麻烦，就不跳转了。这些都是coding定的，我们没办法改变。 你先想一个问题：那么多人都要在github上搞博客，还要自定义域名。github哪来这么多ip给你们用？所以办法就是仅仅提供一个ip，这样必然导致这个服务器上发着所有人的博客文件，那么如何区分特定的域名应该展示谁的博客呢？答案就是在仓库里面新建一个CNAME文件，里面写上你博客想用的域名，github的服务器会根据当前http请求的Host头部（即域名），查找对应的包含相同的CNAME内容的目录，从而显示其中的页面。这就是为什么要在仓库里面创建一个CNAME原因。 不过，事情还没完，一个ip的问题是世界各地不同地点的访问速度不同，有些地方可能很慢，所以需要一组ip来分担一下。最早github好像只有2个ip，后来ip变多了。再后来，github支持域名解析的时候，通过alias来。比如在域名商那边设置成www.tengj.com ---&gt; tengj.github.io，由于github无法控制你如何配置域名和ip的关系，但他可以控制tengj.github.io的最终ip解析，所以github推荐大家使用alias解析，可以为博主提供就近ip访问。这就是你在域名商那边配置CNAME或者alias的原理。这里的CNAME跟上面提到的CNAME作用不同，不是一个概念，不要混淆。 还有就是coding.me的现在是指向国外的，不像以前是指向国内的，我也是醉了~ 要把博客同步到coding，首先要在coding里面新建一个与你Global Key（也就是个性后缀）一样的项目，然后修改博客根目录下面的_config.yml文件中的deploy如下（注意缩进）： 和github一样配置ssh，过程就不详细说了，比较简单。比较重要的是，在source/需要创建一个空白文件，至于原因，是因为 coding.net需要这个文件来作为以静态文件部署的标志。就是说看到这个Staticfile就知道按照静态文件来发布。 12cd source/touch Staticfile #名字必须是Staticfile 接下来在coding pages服务中绑定域名，注意分支一定要写master。 最后去DNSPOD上设置一下域名解析： 然后检测一下域名解析是否正确，国内解析到coding，国外解析到github，后面国外的解析很多是解析到美国 Fastly公司CDN网络节点，这个就是github的解析，所以国内的解析估计就是coding了，虽然也是指向国外，ORZ。]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>域名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[近期对HEXO博客的一些优化]]></title>
    <url>%2F2016%2F11%2F08%2F%E8%BF%91%E6%9C%9F%E5%AF%B9HEXO%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[前几天参加了一场面试，面试时展示我的博客时，发生了一个比较尴尬的事情：博客打开页面空白，此时我内心是崩溃的，明明昨天晚上还好好的。。。 回来后我就开始着手对我的博客进行bug调试和优化。 CSS JS 404导致博客页面空白首先解决这个问题，，在上网简单搜索了一下，导致这个结果的原因应该是： GitHub Pages 过滤掉了 source/vendors 目录的访问，所以next主题下的source下的vendors目录不能够被访问到，所以就出现了本地hexo s能够正常访问，但是deploy到github就是一片空白，按f12，可以看到大量来自source/vendors的css和js提示404 参考回答 解决方案正如github里面说说的： 找到解决方案了。。 @BBBOND @monsterLin @SpadeRoy 根据作者的提示 @iissnan ，首先修改source/vendors为source/lib，然后修改_config.yml， 将 _internal: vendors修改为_internal:lib 然后修改next底下所有引用source/vendors路径为source/lib。这些地方可以通过文件查找找出来。主要集中在这几个文件中。1. Hexo\themes\next.bowerrc 2. Hexo\themes\next.gitignore 3. Hexo\themes\next.javascript_ignore 4. Hexo\themes\next\bower.json 。修改完毕后，刷新重新g一遍就ok啦。 然而我觉得这个太麻烦了，毕竟要改很多东西，既然新版本已经修复这个问题了，那我就重新安装吧。安装前先把文件先备份了一下，然后就按照Next官网的说明，使用git来clone最新版本（之前我是下载安装）。 在终端窗口下，用cd定位到Hexo站点目录，然后clone，具体代码如下： $ cd your-hexo-site$ git clone https://github.com/iissnan/hexo-theme-next themes/next cd后面的“your-hexo-site”改成你自己的hexo路径。 安装完了把主题目录下的_config.yml文件替换成更新前的文件，其中的_internal: vendors修改为_internal:lib （大概在347行的地方），然后这个bug就可以解决了。 使用google字体影响网页加载效率对网页加载进行分析后，发现有三个东西影响网页加载效率： 首先是Swiftype 搜索，这个是因为墙的原因，但是我又不想替换成localsearch，所以这个问题就先略过； 第二个是不蒜子统计，本来想替换成腾讯分析，但是貌似需要先给博客买个域名，然后腾讯分析才能识别，不然光是tc9011.github.io是识别不到的，这个涉及到购买域名，域名解析等问题，所以我暂时忍一下（其实是没钱了T^T）； 最后一个就是google字体，其实国内可以通过360cdn来访问。具体方法如下： 找到\themes\next\layout_partials\head\external-fonts.swig文件，把里面的fonts.googleapis.com 改成fonts.useso.com 实践证明，改过后速度更慢了，于是我又改回了fonts.googleapis.com，ORZ 添加留言本页面之前添加了多说评论，无意中看到别人家的博客中有留言本功能，于是我也想整一个。其实方法也是蛮简单的。 1、添加留言本page先cd到博客根目录，然后运行： hexo new page guestbook 2、在留言本页面中添加多说代码进入到博客的source目录，里面会多了一个gusetbook文件夹，里面有一个index.md文件，打开该文件添加以下代码： &lt;div class=&quot;ds-recent-visitors&quot; data-num-items=&quot;28&quot; data-avatar-size=&quot;42&quot; id=&quot;ds-recent-visitors&quot;&gt;&lt;/div&gt; 然后登陆自己多说站点，进入设置-&gt;自定义CSS，添加 123456789101112131415161718#ds-reset .ds-avatar img,#ds-recent-visitors .ds-avatar img &#123; width: 54px; height: 54px; /*设置头像长宽*/ border-radius: 27px; /*设置头像圆角效果*/ -webkit-border-radius: 27px; /*圆角效果：兼容webkit*/ -moz-border-radius: 27px; box-shadow: inset 0 -1px 0 #3333sf; /*设置头像阴影效果*/ -webkit-box-shadow: inset 0 -1px 0 #3333sf;&#125;#ds-recent-visitors .ds-avatar &#123; float: left&#125;/*隐藏多说版权*/#ds-thread #ds-reset .ds-powered-by &#123; display: none;&#125; 3、菜单中设置留言本找到NexT主题设置的_config.yml文件里面的menu项 1234567menu: home: / #about: /about archives: /archives tags: /tags categories: /categories guestbook: /guestbook 在menu_icons下为留言本设定图标： 1234567891011menu_icons: enable: true#KeyMapsToMenuItemKey: NameOfTheIconFromFontAwesome home: home about: user categories: th tags: tags archives: archive commonweal: heartbeat search: search guestbook: book 我用的是 book 这个图标，如果想要设定为其他图标，请访问：Font Awesome Icons，找到喜欢的图标，记录下图标后的关键字再填写到 menu_icons 下。 4、添加多语言文件的值因为这里使用的是中文，找到languages文件夹里面的zh-Hans.yml文件，menu子项中添加留言： 123456789menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 commonweal: 公益404 guestbook: 留言 SEO优化1、添加robots.txt可以参考我的robots.txt，代码如下 1234567891011121314# hexo robots.txtUser-agent: *Allow: /Allow: /archives/Disallow: /vendors/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendors/Disallow: /fancybox/Sitemap: https://tc9011.github.io/sitemap.xmlSitemap: https://tc9011.github.io/baidusitemap.xml 把robots.txt放在你的hexo站点的source文件下即可。 2、添加sitemap网站地图之前学了SEO，尝试也给自己网站做一下SEO，具体方法如下： 安装hexo的sitemap网站地图生成插件 12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 在你的hexo站点的_config.yml添加下面的代码 123# hexo sitemap网站地图sitemap:path: sitemap.xml 配置成功后，hexo编译时会在hexo站点根目录生成sitemap.xml和baidusitemap.xml其中sitemap.xml适合提交给谷歌搜素引擎，baidusitemap.xml适合提交百度搜索引擎。​ 3、给非友情链接的出站链接添加“nofollow”标签以hexo的NexT主题为例，需要修改两处 找到footer.swig,路径在your-hexo-site\themes\next\layout\_partials，将下面代码 1&#123;&#123; __('footer.powered', '&lt;a class="theme-link" href="http://hexo.io"&gt;Hexo&lt;/a&gt;') &#125;&#125; 改成 1&#123;&#123; __('footer.powered', '&lt;a class="theme-link" href="http://hexo.io" rel="external nofollow"&gt;Hexo&lt;/a&gt;') &#125;&#125; 将下面代码 1&lt;a class="theme-link" href="https://github.com/iissnan/hexo-theme-next"&gt; 改成 1&lt;a class="theme-link" href="https://github.com/iissnan/hexo-theme-next" rel="external nofollow"&gt; 修改sidebar.swig文件，路径在your-hexo-site\themes\next\layout\_macro，将下面代码 1&lt;a href="&#123;&#123; link &#125;&#125;" target="_blank"&gt;&#123;&#123; name &#125;&#125;&lt;/a&gt; 改成 1&lt;a href="&#123;&#123; link &#125;&#125;" target="_blank" rel="external nofollow"&gt;&#123;&#123; name &#125;&#125;&lt;/a&gt; 将下面代码 1&lt;a href="http://creativecommons.org/licenses/&#123;&#123; theme.creative_commons &#125;&#125;/4.0" class="cc-opacity" target="_blank"&gt; 改成 1&lt;a href="http://creativecommons.org/licenses/&#123;&#123; theme.creative_commons &#125;&#125;/4.0" class="cc-opacity" target="_blank" rel="external nofollow"&gt; 这是根据动动手指，不限于NexT主题的Hexo优化（SEO篇来进行优化的，优化过程中发现，还是需要有自己的域名，不然百度抓不到你的数据，哎~等工作了一定要买一个域名（奋斗脸）。 多说评论不稳定，加载速度慢优化加载多说的时候，因为对方服务器的原因，很不稳定，经常刷不出多说评论，所以决定优化一下，多说评论不稳定，加载速度慢优化方法，主要参考这篇文章进行了优化，具体方法： 在七牛镜像储存中，镜像源地址填写http://static.duoshuo.com，然后保存。 加速成功后，可以通过七牛提供的空间访问域名访问到多说镜像网站，例如我的默认域名是http://og9ocpmwk.bkt.clouddn.com/，直接可以链接到多说的镜像网站。 下载多说核心脚本embed.js，需要更改一处地方代码， 1function n(e)&#123;j.theme=e,"none"!=e&amp;&amp;o.injectStylesheet(j.STATIC_URL+"/styles/embed"+(e?"."+e+".css?"+R[e]:"."+short_name)+".css")&#125; 上面代码应该是调用多说样式embed.xxx.css，我们需要修改成我们七牛镜像的多说样式，只需把j.STATIC_URL更改成七牛空间访问域名，例如我修改成&quot;http://xxx.com&quot;。更改后另存为dsembed.js（重命名主要防止与七牛镜像中的embed.js冲突）。最后上传到七牛空间里。现在你可以通过地址/dsembed.js访问经过七牛CDN加速后的多说核心脚本。 把多说默认引入static.duoshuo.com域名下的embed.js更改成七牛空间更改后的dsembed.js即可。 这里以多说通用代码为例， 12345678910111213141516&lt;!-- 多说评论框 start --&gt; &lt;div class="ds-thread" data-thread-key="请将此处替换成文章在你的站点中的ID" data-title="请替换成文章的标题" data-url="请替换成文章的网址"&gt;&lt;/div&gt;&lt;!-- 多说评论框 end --&gt;&lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt;&lt;script type="text/javascript"&gt;var duoshuoQuery = &#123;short_name:"araolin"&#125;; (function() &#123; var ds = document.createElement('script'); ds.type = 'text/javascript';ds.async = true; ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js'; ds.charset = 'UTF-8'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds); &#125;)(); &lt;/script&gt;&lt;!-- 多说公共JS代码 end --&gt; embed.js引入的代码是 1ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js'; 这里需要更改成 1ds.src = '这里是你的七牛空间embed.js的地址'; 以我的为例，我更改成了 1ds.src = 'http://xxx.com/dsembed.js'; 如果你是hexo Next主题的话，需要更改的文件是duoshuo.swig，具体路径在your-hexo-site\themes\next\layout\_scripts\comments目录里。​ 最后值的注意的是，因为我的网站是https://tc9011.github.io，上面的链接若写成http的话，也会加载不了多说评论。所以下面是针对https的一些修改： 首先给七牛账户充值11块钱，不然这个功能木有办法用~ 进入存储资源列表，然后点击下图所示的https域名，七牛会自动生成一个域名； 在内容管理里面选择刚刚生成的域名作为默认外链域名，记得保存。 把内容管理里面的文件先全部删掉，把上面dsembed.js文件重命名一下，主要防止没有覆盖旧文件，比如我命名为dembed.js，再把文件中添加http://xxx.com的地方都改成新的外链地址，比如我的https://xxxx.com，然后保存，上传七牛。 把duoshuo.swig中的src替换成新的域名。 1ds.src = 'http://XXX.com/dembed.js'; ​ 最后其实博客还有优化空间，比如有几个js加载速度简直是慢的令人发指，尝试了压缩代码，还是不行，感觉还是要把他们托管到其他地方，这个以后慢慢优化，可能以后买个域名，把博客同时托管到coding和github，国内访问coding，国外访问github，具体怎么操作，请听下回分解。]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SEO与Yahoo军规]]></title>
    <url>%2F2016%2F11%2F01%2FSEO%E4%B8%8EYahoo%E5%86%9B%E8%A7%84%2F</url>
    <content type="text"><![CDATA[《SEO在网页制作中的应用》与《Yahoo军规》课程总结 SEO与搜索引擎首先SEO是什么： SEO是由英文Search Engine Optimization缩写而来， 中文意译为“搜索引擎优化”。SEO是指通过站内优化（比如网站结构调整、网站内容建设、网站代码优化等）以及站外优化（比如网站站外推广、网站品牌建设等），使网站满足搜索引擎收录排名需求，在搜索引擎中提高关键词排名，从而吸引精准用户进入网站，获得免费流量，产生直接销售或品牌推广。 根据课程内容我自己画了上面这张图，这里以百度搜索引擎为例子说明一下，百度搜索引擎数据库通过百度蜘蛛爬取互联网上数据，这些数据是搜索引擎数据库中没有的，且有用的数据，理想状态下，用户输入关键字搜索，百度通过搜素引擎数据库中与关键字最匹配的结果返回给用户。 百度蜘蛛怎么才能更好的爬取数据呢，这就要通过网站的SEO，让网站用百度蜘蛛听得懂的语言和它交流，让它能更了解你的网站。SEO分为白帽SEO和黑帽SEO。黑帽SEO通过伪装让搜索引擎以为网站和某个关键字有联系，但实际上并没有；白帽SEO则通过上图列出的方法，让网站用百度蜘蛛听得懂的语言更好的去与搜索引擎交流。 网站结构与代码优化 结构布局优化：用扁平化结构 网站结构层次越少越容易被蜘蛛获取，中小型网站，目录层次结构超过3层，蜘蛛就不愿意往下爬。 控制首页链接数量 首页链接数量不能太少也不能太多，中小型企业首页链接在100个以内，例如：页面导航、底部导航、锚文字链接等。 扁平化目录层次 网站的设计不要用纵线性的结构。 导航SEO优化 尽量用文字，如果是图片，alt和title必须要有，面包屑导航（一般页面左上角的XX&gt;&gt;XX&gt;&gt;XX就是，便于了解当前位置和返回）。 页码 页码尽量用 首页 1 2 3 下一页 或者 首页 1 2 3 4 下拉菜单 这样方便蜘蛛抓取内容。 页面布局 左边正文，右边放热门文章和相关文章。 网速 控制页面不要超过100k，不然加载太慢。 网页代码 &lt;title&gt;标题 &lt;meta keywords&gt;关键词 &lt;meta description&gt;网页描述 HTML标签语义化 &lt;a&gt;要有title，对于指向其他网站的链接要写rel=&quot;nofollow&quot; &lt;h1&gt;用于正文标题，副级标题用&lt;h2&gt; &lt;table&gt;标签要写&lt;caption&gt;表格标题&lt;/caption&gt; &lt;img&gt;标签应使用alt说明 &lt;strong&gt;的权重&gt;&lt;em&gt;的权重，如果只为加粗斜体效果建议用&lt;b&gt;和&lt;i&gt;标签 重要内容HTML代码放在最前面 重要内容不要用JS输出 尽少使用iframe框架 谨慎使用display:none，不想显示的内容可以用z-index或者显示在浏览器显示范围之外。蜘蛛会过滤掉display:none中的内容 Yahoo军规 尽量减少HTTP的请求数 可以将图片合并、JavaScript代码合并、css样式合并 使用CDN（内容分发网络） CDN:内容分发网络。意思是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。 用简单的话说就是，在离你最近的地方，放置一台性能好链接顺畅的副本服务器，让你能够以最近的距离，最快的速度获取内容。 添加Expire/Cache-Control头 expire头的内容是一个时间值，值就是资源在本地的过期时间、存在本地。在本地缓存阶段，找到一个对应的资源值，当前时间还没超过资源的过期时间，就直接使用这一个资源，不会发送http请求。 Cache-Control是http协议中常用的头部之一，顾名思义，他是负责控制页面的缓存机制，如果该头部指示缓存，缓存的内容也会存在本地，操作流程和expire相似，但也有不同的地方，Cache-Control有更多的选项，也有更多的处理方式 启用Gzip压缩 将HTML、JavaScript、CSS、PHP等文件进行Gzip压缩，可以显著减小文件的体积。 将CSS放在页面最上方 避免页面出现空白或者闪烁，提高浏览器的渲染性能。 将Script放在页面最下面 先将内容呈现出来，不会让用户等太久。 避免在CSS中使用Expressions 在CSS中用了JavaScript的计算式，在页面显示和缩放、页面滚动、移动鼠标时CSS Expressions都会重新计算一次，严重影响性能。 把JS和CSS都放到外部文件中 JS和CSS单独提取出来，提高了JS和CSS的复用性，减少页面体积，提高了JS和CSS的可维护性；JS和CSS内置可以减少页面请求，提高页面渲染，若JS和CSS很少、只应用于一个页面或者不经常被访问到时可以这样使用。两者各有优势，灵活取用。 减少DNS查询 当缓存时间长时，减少DNS的重复查找，节省时间；当缓存时间短时，及时的检测网站服务器的变化，保证准确性。 压缩JavaScript和CSS 可以去除不必要的空白符、格式符、注释符，简写方法名、参数名压缩JS脚本。 避免重定向 重定向：用户的原始请求被重新转向到了其他请求 重定向状态码：301 Moved Permanently，表示用户请求的页面被移动到了另一个位置，客户端收到这个后会重新发起一次请求，是永久重定向；302 Found，表示用户请求的页面被找到了，但不在原始位置，服务器会返回一个地址，客户端会重新发起一次请求，是临时重定向。 用301重定向可以使搜索引擎识别，更新新的地址；用302总是会先找到旧地址再跳到新地址。 移除重复的脚本 配置实体标签（ETag） ETag属于HTTP协议，是使用特殊的字符串来标识某个请求资源版本，如果客户端缓存中的版本和服务器中的版本一致，服务器就不需要再传递。 使用AJAX缓存 post请求每次都执行，不被缓存；get请求时同一地址不重复执行，可以被缓存。 看完这两课觉得以前自己码的东西还有很多要修改的，前端之路，任重而道远。]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>SEO</tag>
        <tag>Yahoo军规</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Github和Hexo的个人博客搭建]]></title>
    <url>%2F2016%2F10%2F31%2F%E5%9F%BA%E4%BA%8EGithub%E5%92%8CHexo%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[花了两天终于把基于Github和Hexo的个人博客搭建好了，期间踩了不少坑，在此作为第一篇正式博文记录一下。 Hexo这里还是要说一下Hexo，它是一款基于Node.js的静态博客框架，可以换不同主题，自定义各种样式，个人觉得还是蛮不错的（因为你只用过这一个，呵呵）。 Hexo特性： Hexo基于Node.js，支持多进程，几百篇文章也可以秒生成。 支持GitHub Flavored Markdown和所有Octopress的插件。 Hexo支持EJS、Swig和Stylus。通过插件支持Haml、Jade和Less。 Hexo官网 ，官网也是基于Github构件的网站。 配置环境及安装Git的安装就跳过了，比较简单。下面说一下Node.js安装。 可以去node.js Git和Node.js安装完了就可以用npm安装Hexo，在mac的终端内输入下面的命令： 1$ npm install -g hexo-cli 然后Hexo就安装完成啦。安装好后，需要对Hexo初始化，在终端中挨个执行下面的命令，其中用指定的文件夹路径代替，一定要cd，不要问我为什么，都是血的教训： 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 至此，所有的安装工作都完成，撒花~ 完成后，目录如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 建站及部署安装完成后就可以通过下面的命令生成静态页面 hexo g 然后启用本地服务 hexo s 进入浏览器输入http://localhost:4000 就可以看到网站的效果，当然刚开始是默认样式。 下面我们就把网站部署到Github（此处我当你已经弄好github的ssh了） 登陆Github后创建一个名字为your_name.github.io（your_name替换成你的用户名）的仓库； 然后打开hexo下面的_config.yml，翻到最后面， 将下面的信息补充完整（your_name都换成你自己的用户名），注意Hexo 5.0以后type应该写成git而不是github，这又是一处血的教训（姚明脸）。 123type: git repository: https://github.com/your_name/your_name.github.io branch: master 然后分别执行以下命令部署本地博客到github 12hexo ghexo d 然后在浏览器里面输入your_name.github.io就可以访问你自己的博客啦！ NexT主题安装Hexo有好多主题，经过筛选，我选择了NexT，点击链接可以去官网看看，安装教程写的蛮详细的，我就不多说了。这里说一下一些要注意的地方吧，毕竟我踩的坑还是蛮多的，呵呵。 swiftype按照教程生成key后，那个框是不能下拉的，但是你的key却在你看不见的最底下，用command+A，然后command+C复制出来就行，key就是那一串大写字母，不要单引号，swiftype_key:后面记得加空格。 用LeanCloud来统计文章阅读次数，我是参考了这篇文章——&gt;&gt;最简便的方法搭建Hexo+Github博客,基于Next主题，记的在修改主题配置文件_config.yml时候，一定要把下面enable设置为true。 1234leancloud_visitors: enable: true app_id: ytnok33cvEchgidigtb0WumC-gzGzoHsz #&lt;AppID&gt; app_key: SrcG8cy1VhONurWBoEBGGHML #&lt;AppKEY&gt; 设置网站图标Favicon，用比特虫把图制作好后，上传到云存储空间（我用的是七牛），获取图片的网址，然后打开主题配置文件_config.yml，找到favicon字段，将图片网址粘贴在后面，即可。 其他东西跟着教程做起来都还好。]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>个人博客搭建</tag>
      </tags>
  </entry>
</search>
